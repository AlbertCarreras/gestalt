(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('tty'), require('path'), require('url'), require('fs'), require('util'), require('os'), require('module'), require('crypto'), require('assert'), require('events'), require('stream'), require('worker_threads')) :
  typeof define === 'function' && define.amd ? define(['tty', 'path', 'url', 'fs', 'util', 'os', 'module', 'crypto', 'assert', 'events', 'stream', 'worker_threads'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.tty, global.path$1, global.url$1, global.fs$4, global.util$2, global.os, global.Module, global.crypto, global.assert$d, global.require$$0$7, global.stream_1, global.require$$2$1));
}(this, (function (tty, path$1, url$1, fs$4, util$2, os, Module, crypto, assert$d, require$$0$7, stream_1, require$$2$1) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var tty__default = /*#__PURE__*/_interopDefaultLegacy(tty);
  var path__default = /*#__PURE__*/_interopDefaultLegacy(path$1);
  var url__default = /*#__PURE__*/_interopDefaultLegacy(url$1);
  var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs$4);
  var util__default = /*#__PURE__*/_interopDefaultLegacy(util$2);
  var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
  var Module__default = /*#__PURE__*/_interopDefaultLegacy(Module);
  var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
  var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert$d);
  var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$7);
  var stream_1__default = /*#__PURE__*/_interopDefaultLegacy(stream_1);
  var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);

  class Warning {
    constructor(text, opts = {}) {
      this.type = 'warning';
      this.text = text;

      if (opts.node && opts.node.source) {
        let range = opts.node.rangeBy(opts);
        this.line = range.start.line;
        this.column = range.start.column;
        this.endLine = range.end.line;
        this.endColumn = range.end.column;
      }

      for (let opt in opts) this[opt] = opts[opt];
    }

    toString() {
      if (this.node) {
        return this.node.error(this.text, {
          index: this.index,
          plugin: this.plugin,
          word: this.word
        }).message;
      }

      if (this.plugin) {
        return this.plugin + ': ' + this.text;
      }

      return this.text;
    }

  }

  var warning = Warning;
  Warning.default = Warning;

  class Result$1 {
    constructor(processor, root, opts) {
      this.processor = processor;
      this.messages = [];
      this.root = root;
      this.opts = opts;
      this.css = undefined;
      this.map = undefined;
    }

    toString() {
      return this.css;
    }

    warn(text, opts = {}) {
      if (!opts.plugin) {
        if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
          opts.plugin = this.lastPlugin.postcssPlugin;
        }
      }

      let warning$1 = new warning(text, opts);
      this.messages.push(warning$1);
      return warning$1;
    }

    warnings() {
      return this.messages.filter(i => i.type === 'warning');
    }

    get content() {
      return this.css;
    }

  }

  var result = Result$1;
  Result$1.default = Result$1;

  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */

  function isObject$7(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }

  function isPlainObject$7(o) {
    var ctor, prot;
    if (isObject$7(o) === false) return false; // If has modified constructor

    ctor = o.constructor;
    if (ctor === undefined) return true; // If has modified prototype

    prot = ctor.prototype;
    if (isObject$7(prot) === false) return false; // If constructor does not have an Object-specific method

    if (prot.hasOwnProperty('isPrototypeOf') === false) {
      return false;
    } // Most likely a plain Object


    return true;
  }

  var isPlainObject_2 = isPlainObject$7;

  var isPlainObject_1 = /*#__PURE__*/Object.defineProperty({
  	isPlainObject: isPlainObject_2
  }, '__esModule', {value: true});

  const {
    isPlainObject: _isPlainObject
  } = isPlainObject_1;
  /**
   * Checks if the value is a boolean or a Boolean object.
   * @param {unknown} value
   * @returns {value is boolean}
   */


  function isBoolean$a(value) {
    return typeof value === 'boolean' || value instanceof Boolean;
  }
  /**
   * Checks if the value is a function or a Function object.
   * @param {unknown} value
   * @returns {value is Function}
   */


  function isFunction$1(value) {
    return typeof value === 'function' || value instanceof Function;
  }
  /**
   * Checks if the value is *nullish*.
   * @see https://developer.mozilla.org/en-US/docs/Glossary/Nullish
   * @param {unknown} value
   * @returns {value is null | undefined}
   */


  function isNullish$1(value) {
    return value == null;
  }
  /**
   * Checks if the value is a number or a Number object.
   * @param {unknown} value
   * @returns {value is number}
   */


  function isNumber$g(value) {
    return typeof value === 'number' || value instanceof Number;
  }
  /**
   * Checks if the value is an object.
   * @param {unknown} value
   * @returns {value is object}
   */


  function isObject$6(value) {
    return value !== null && typeof value === 'object';
  }
  /**
   * Checks if the value is a regular expression.
   * @param {unknown} value
   * @returns {value is RegExp}
   */


  function isRegExp$10(value) {
    return value instanceof RegExp;
  }
  /**
   * Checks if the value is a string or a String object.
   * @param {unknown} value
   * @returns {value is string}
   */


  function isString$1j(value) {
    return typeof value === 'string' || value instanceof String;
  }
  /**
   * Checks if the value is a plain object.
   * @param {unknown} value
   * @returns {value is Record<string, unknown>}
   */


  function isPlainObject$6(value) {
    return _isPlainObject(value);
  }
  /**
   * Assert that the value is truthy.
   * @param {unknown} value
   * @param {string} [message]
   * @returns {asserts value}
   */


  function assert$c(value, message = undefined) {
    if (message) {
      // eslint-disable-next-line no-console
      console.assert(value, message);
    } else {
      // eslint-disable-next-line no-console
      console.assert(value);
    }
  }
  /**
   * Assert that the value is a function or a Function object.
   * @param {unknown} value
   * @returns {asserts value is Function}
   */


  function assertFunction$1(value) {
    // eslint-disable-next-line no-console
    console.assert(isFunction$1(value), `"${value}" must be a function`);
  }
  /**
   * Assert that the value is a number or a Number object.
   * @param {unknown} value
   * @returns {asserts value is number}
   */


  function assertNumber$4(value) {
    // eslint-disable-next-line no-console
    console.assert(isNumber$g(value), `"${value}" must be a number`);
  }
  /**
   * Assert that the value is a string or a String object.
   * @param {unknown} value
   * @returns {asserts value is string}
   */


  function assertString$7(value) {
    // eslint-disable-next-line no-console
    console.assert(isString$1j(value), `"${value}" must be a string`);
  }

  var validateTypes = {
    isBoolean: isBoolean$a,
    isFunction: isFunction$1,
    isNullish: isNullish$1,
    isNumber: isNumber$g,
    isObject: isObject$6,
    isRegExp: isRegExp$10,
    isString: isString$1j,
    isPlainObject: isPlainObject$6,
    assert: assert$c,
    assertFunction: assertFunction$1,
    assertNumber: assertNumber$4,
    assertString: assertString$7
  };

  const {
    isPlainObject: isPlainObject$5
  } = validateTypes; // Rule settings can take a number of forms, e.g.
  // a. "rule-name": null
  // b. "rule-name": [null, ...]
  // c. "rule-name": primaryOption
  // d. "rule-name": [primaryOption]
  // e. "rule-name": [primaryOption, secondaryOption]
  // Where primaryOption can be anything: primitive, Object, or Array.

  /**
   * This function normalizes all the possibilities into the
   * standard form: [primaryOption, secondaryOption]
   * Except in the cases with null, a & b, in which case
   * null is returned
   * @template T
   * @template {Object} O
   * @param {import('stylelint').ConfigRuleSettings<T, O>} rawSettings
   * @param {import('stylelint').Rule<T, O>} [rule]
   * @return {[T] | [T, O] | null}
   */


  var normalizeRuleSettings = function normalizeRuleSettings(rawSettings, rule) {
    if (rawSettings === null || rawSettings === undefined) {
      return null;
    }

    if (!Array.isArray(rawSettings)) {
      return [rawSettings];
    } // Everything below is an array ...


    const [primary, secondary] = rawSettings;

    if (rawSettings.length > 0 && (primary === null || primary === undefined)) {
      return null;
    }

    if (rule && !rule.primaryOptionArray) {
      return rawSettings;
    } // Everything below is a rule that CAN have an array for a primary option ...
    // (they might also have something else, e.g. rule-properties-order can
    // have the string "alphabetical")


    if (rawSettings.length === 1 && Array.isArray(primary)) {
      return rawSettings;
    }

    if (rawSettings.length === 2 && !isPlainObject$5(primary) && isPlainObject$5(secondary)) {
      return rawSettings;
    } // `T` must be an array type, but TSC thinks it's probably invalid to
    // cast `[T]` to `T` so we cast through `any` first.


    return [
    /** @type {T} */

    /** @type {any} */
    rawSettings];
  };

  const lazy = (importedModule, importFn, moduleId) => importedModule === undefined ? importFn(moduleId) : importedModule;

  var importLazy = importFn => {
    return moduleId => {
      let importedModule;
      const handler = {
        get: (target, property) => {
          importedModule = lazy(importedModule, importFn, moduleId);
          return Reflect.get(importedModule, property);
        },
        apply: (target, thisArgument, argumentsList) => {
          importedModule = lazy(importedModule, importFn, moduleId);
          return Reflect.apply(importedModule, thisArgument, argumentsList);
        },
        construct: (target, argumentsList) => {
          importedModule = lazy(importedModule, importFn, moduleId);
          return Reflect.construct(importedModule, argumentsList);
        }
      }; // eslint-disable-next-line prefer-arrow-callback

      return new Proxy(function () {}, handler);
    };
  };

  var openParentheses = "(".charCodeAt(0);
  var closeParentheses = ")".charCodeAt(0);
  var singleQuote$1 = "'".charCodeAt(0);
  var doubleQuote$1 = '"'.charCodeAt(0);
  var backslash$1 = "\\".charCodeAt(0);
  var slash$2 = "/".charCodeAt(0);
  var comma = ",".charCodeAt(0);
  var colon = ":".charCodeAt(0);
  var star$1 = "*".charCodeAt(0);
  var uLower = "u".charCodeAt(0);
  var uUpper = "U".charCodeAt(0);
  var plus$1 = "+".charCodeAt(0);
  var isUnicodeRange = /^[a-f0-9?-]+$/i;

  var parse$U = function (input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [{
      nodes: tokens
    }];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";

    while (pos < max) {
      // Whitespaces
      if (code <= 32) {
        next = pos;

        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);

        token = value.slice(pos, next);
        prev = tokens[tokens.length - 1];

        if (code === closeParentheses && balanced) {
          after = token;
        } else if (prev && prev.type === "div") {
          prev.after = token;
          prev.sourceEndIndex += token.length;
        } else if (code === comma || code === colon || code === slash$2 && value.charCodeAt(next + 1) !== star$1 && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
          before = token;
        } else {
          tokens.push({
            type: "space",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }

        pos = next; // Quotes
      } else if (code === singleQuote$1 || code === doubleQuote$1) {
        next = pos;
        quote = code === singleQuote$1 ? "'" : '"';
        token = {
          type: "string",
          sourceIndex: pos,
          quote: quote
        };

        do {
          escape = false;
          next = value.indexOf(quote, next + 1);

          if (~next) {
            escapePos = next;

            while (value.charCodeAt(escapePos - 1) === backslash$1) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += quote;
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);

        token.value = value.slice(pos + 1, next);
        token.sourceEndIndex = token.unclosed ? next : next + 1;
        tokens.push(token);
        pos = next + 1;
        code = value.charCodeAt(pos); // Comments
      } else if (code === slash$2 && value.charCodeAt(pos + 1) === star$1) {
        next = value.indexOf("*/", pos);
        token = {
          type: "comment",
          sourceIndex: pos,
          sourceEndIndex: next + 2
        };

        if (next === -1) {
          token.unclosed = true;
          next = value.length;
          token.sourceEndIndex = next;
        }

        token.value = value.slice(pos + 2, next);
        tokens.push(token);
        pos = next + 2;
        code = value.charCodeAt(pos); // Operation within calc
      } else if ((code === slash$2 || code === star$1) && parent && parent.type === "function" && parent.value === "calc") {
        token = value[pos];
        tokens.push({
          type: "word",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token
        });
        pos += 1;
        code = value.charCodeAt(pos); // Dividers
      } else if (code === slash$2 || code === comma || code === colon) {
        token = value[pos];
        tokens.push({
          type: "div",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token,
          before: before,
          after: ""
        });
        before = "";
        pos += 1;
        code = value.charCodeAt(pos); // Open parentheses
      } else if (openParentheses === code) {
        // Whitespaces after open parentheses
        next = pos;

        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);

        parenthesesOpenPos = pos;
        token = {
          type: "function",
          sourceIndex: pos - name.length,
          value: name,
          before: value.slice(parenthesesOpenPos + 1, next)
        };
        pos = next;

        if (name === "url" && code !== singleQuote$1 && code !== doubleQuote$1) {
          next -= 1;

          do {
            escape = false;
            next = value.indexOf(")", next + 1);

            if (~next) {
              escapePos = next;

              while (value.charCodeAt(escapePos - 1) === backslash$1) {
                escapePos -= 1;
                escape = !escape;
              }
            } else {
              value += ")";
              next = value.length - 1;
              token.unclosed = true;
            }
          } while (escape); // Whitespaces before closed


          whitespacePos = next;

          do {
            whitespacePos -= 1;
            code = value.charCodeAt(whitespacePos);
          } while (code <= 32);

          if (parenthesesOpenPos < whitespacePos) {
            if (pos !== whitespacePos + 1) {
              token.nodes = [{
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: whitespacePos + 1,
                value: value.slice(pos, whitespacePos + 1)
              }];
            } else {
              token.nodes = [];
            }

            if (token.unclosed && whitespacePos + 1 !== next) {
              token.after = "";
              token.nodes.push({
                type: "space",
                sourceIndex: whitespacePos + 1,
                sourceEndIndex: next,
                value: value.slice(whitespacePos + 1, next)
              });
            } else {
              token.after = value.slice(whitespacePos + 1, next);
              token.sourceEndIndex = next;
            }
          } else {
            token.after = "";
            token.nodes = [];
          }

          pos = next + 1;
          token.sourceEndIndex = token.unclosed ? next : pos;
          code = value.charCodeAt(pos);
          tokens.push(token);
        } else {
          balanced += 1;
          token.after = "";
          token.sourceEndIndex = pos + 1;
          tokens.push(token);
          stack.push(token);
          tokens = token.nodes = [];
          parent = token;
        }

        name = ""; // Close parentheses
      } else if (closeParentheses === code && balanced) {
        pos += 1;
        code = value.charCodeAt(pos);
        parent.after = after;
        parent.sourceEndIndex += after.length;
        after = "";
        balanced -= 1;
        stack[stack.length - 1].sourceEndIndex = pos;
        stack.pop();
        parent = stack[balanced];
        tokens = parent.nodes; // Words
      } else {
        next = pos;

        do {
          if (code === backslash$1) {
            next += 1;
          }

          next += 1;
          code = value.charCodeAt(next);
        } while (next < max && !(code <= 32 || code === singleQuote$1 || code === doubleQuote$1 || code === comma || code === colon || code === slash$2 || code === openParentheses || code === star$1 && parent && parent.type === "function" && parent.value === "calc" || code === slash$2 && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));

        token = value.slice(pos, next);

        if (openParentheses === code) {
          name = token;
        } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus$1 === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
          tokens.push({
            type: "unicode-range",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        } else {
          tokens.push({
            type: "word",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }

        pos = next;
      }
    }

    for (pos = stack.length - 1; pos; pos -= 1) {
      stack[pos].unclosed = true;
      stack[pos].sourceEndIndex = value.length;
    }

    return stack[0].nodes;
  };

  var walk$2 = function walk(nodes, cb, bubble) {
    var i, max, node, result;

    for (i = 0, max = nodes.length; i < max; i += 1) {
      node = nodes[i];

      if (!bubble) {
        result = cb(node, i, nodes);
      }

      if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
        walk(node.nodes, cb, bubble);
      }

      if (bubble) {
        cb(node, i, nodes);
      }
    }
  };

  function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;

    if (custom && (customResult = custom(node)) !== undefined) {
      return customResult;
    } else if (type === "word" || type === "space") {
      return value;
    } else if (type === "string") {
      buf = node.quote || "";
      return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
      return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
      return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
      buf = stringify$6(node.nodes, custom);

      if (type !== "function") {
        return buf;
      }

      return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }

    return value;
  }

  function stringify$6(nodes, custom) {
    var result, i;

    if (Array.isArray(nodes)) {
      result = "";

      for (i = nodes.length - 1; ~i; i -= 1) {
        result = stringifyNode(nodes[i], custom) + result;
      }

      return result;
    }

    return stringifyNode(nodes, custom);
  }

  var stringify_1$2 = stringify$6;

  var minus = "-".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0); // Check if three code points would start a number
  // https://www.w3.org/TR/css-syntax-3/#starts-with-a-number

  function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;

    if (code === plus || code === minus) {
      nextCode = value.charCodeAt(1);

      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }

      var nextNextCode = value.charCodeAt(2);

      if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
        return true;
      }

      return false;
    }

    if (code === dot) {
      nextCode = value.charCodeAt(1);

      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }

      return false;
    }

    if (code >= 48 && code <= 57) {
      return true;
    }

    return false;
  } // Consume a number
  // https://www.w3.org/TR/css-syntax-3/#consume-number


  var unit = function (value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;

    if (length === 0 || !likeNumber(value)) {
      return false;
    }

    code = value.charCodeAt(pos);

    if (code === plus || code === minus) {
      pos++;
    }

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }

    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);

    if (code === dot && nextCode >= 48 && nextCode <= 57) {
      pos += 2;

      while (pos < length) {
        code = value.charCodeAt(pos);

        if (code < 48 || code > 57) {
          break;
        }

        pos += 1;
      }
    }

    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);

    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
      pos += nextCode === plus || nextCode === minus ? 3 : 2;

      while (pos < length) {
        code = value.charCodeAt(pos);

        if (code < 48 || code > 57) {
          break;
        }

        pos += 1;
      }
    }

    return {
      number: value.slice(0, pos),
      unit: value.slice(pos)
    };
  };

  function ValueParser(value) {
    if (this instanceof ValueParser) {
      this.nodes = parse$U(value);
      return this;
    }

    return new ValueParser(value);
  }

  ValueParser.prototype.toString = function () {
    return Array.isArray(this.nodes) ? stringify_1$2(this.nodes) : "";
  };

  ValueParser.prototype.walk = function (cb, bubble) {
    walk$2(this.nodes, cb, bubble);
    return this;
  };

  ValueParser.unit = unit;
  ValueParser.walk = walk$2;
  ValueParser.stringify = stringify_1$2;
  var lib$6 = ValueParser;

  const {
    isObject: isObject$5,
    isString: isString$1i
  } = validateTypes;
  /**
   * Get the index of a declaration's value
   *
   * @param {import('postcss').Declaration} decl
   * @returns {number}
   */


  var declarationValueIndex = function declarationValueIndex(decl) {
    const raws = decl.raws;
    const prop = raws.prop;
    return [isObject$5(prop) && 'prefix' in prop && prop.prefix, isObject$5(prop) && 'raw' in prop && prop.raw || decl.prop, isObject$5(prop) && 'suffix' in prop && prop.suffix, raws.between || ':', raws.value && 'prefix' in raws.value && raws.value.prefix].reduce((
    /** @type {number} */
    count, str) => {
      if (isString$1i(str)) {
        return count + str.length;
      }

      return count;
    }, 0);
  };

  /**
   * @param {import('postcss').Declaration} decl
   * @returns {string}
   */

  var getDeclarationValue = function getDeclarationValue(decl) {
    const raws = decl.raws;
    return raws.value && raws.value.raw || decl.value;
  };

  const HAS_LESS_INTERPOLATION = /@\{.+?\}/;
  /**
   * Check whether a string has less interpolation
   *
   * @param {string} string
   * @return {boolean} If `true`, a string has less interpolation
   */

  var hasLessInterpolation = function hasLessInterpolation(string) {
    return HAS_LESS_INTERPOLATION.test(string);
  };

  const HAS_PSV_INTERPOLATION = /\$\(.+?\)/;
  /**
   * Check whether a string has postcss-simple-vars interpolation
   *
   * @param {string} string
   */

  var hasPsvInterpolation = function hasPsvInterpolation(string) {
    return HAS_PSV_INTERPOLATION.test(string);
  };

  const HAS_SCSS_INTERPOLATION = /#\{.+?\}/;
  /**
   * Check whether a string has scss interpolation
   *
   * @param {string} string
   */

  var hasScssInterpolation = function hasScssInterpolation(string) {
    return HAS_SCSS_INTERPOLATION.test(string);
  };

  const HAS_TPL_INTERPOLATION = /\{.+?\}/;
  /**
   * Check whether a string has JS template literal interpolation or HTML-like template
   *
   * @param {string} string
   * @return {boolean} If `true`, a string has template literal interpolation
   */

  var hasTplInterpolation = function hasTplInterpolation(string) {
    return HAS_TPL_INTERPOLATION.test(string);
  };

  /**
   * Check whether a string has interpolation
   *
   * @param {string} string
   * @return {boolean} If `true`, a string has interpolation
   */


  var hasInterpolation = function hasInterpolation(string) {
    // SCSS or Less interpolation
    if (hasLessInterpolation(string) || hasScssInterpolation(string) || hasTplInterpolation(string) || hasPsvInterpolation(string)) {
      return true;
    }

    return false;
  };

  /**
   * Check whether a value is standard
   *
   * @param {string} value
   * @returns {boolean}
   */


  var isStandardSyntaxValue = function isStandardSyntaxValue(value) {
    let normalizedValue = value; // Ignore operators before variables (example -$variable)

    if (/^[-+*/]/.test(value.charAt(0))) {
      normalizedValue = normalizedValue.slice(1);
    } // SCSS variable (example $variable)


    if (normalizedValue.startsWith('$')) {
      return false;
    } // SCSS namespace (example namespace.$variable)


    if (/^.+\.\$/.test(value)) {
      return false;
    } // SCSS namespace (example namespace.function-name())


    if (/^.+\.[-\w]+\(/.test(value)) {
      return false;
    } // Less variable


    if (normalizedValue.startsWith('@')) {
      return false;
    } // SCSS or Less interpolation


    if (hasInterpolation(normalizedValue)) {
      return false;
    } // WebExtension replacement keyword used by Chrome/Firefox
    // more information: https://developer.chrome.com/extensions/i18n
    // and https://github.com/stylelint/stylelint/issues/4707


    if (/__MSG_\S+__/.test(value)) {
      return false;
    }

    return true;
  };

  /**
   * Compares a string to a second value that, if it fits a certain convention,
   * is converted to a regular expression before the comparison.
   * If it doesn't fit the convention, then two strings are compared.
   *
   * Any strings starting and ending with `/` are interpreted
   * as regular expressions.
   *
   * @param {string | Array<string>} input
   * @param {string | RegExp | Array<string | RegExp>} comparison
   *
   * @returns {false | {match: string, pattern: (string | RegExp), substring: string}}
   */

  var matchesStringOrRegExp = function matchesStringOrRegExp(input, comparison) {
    if (!Array.isArray(input)) {
      return testAgainstStringOrRegExpOrArray(input, comparison);
    }

    for (const inputItem of input) {
      const testResult = testAgainstStringOrRegExpOrArray(inputItem, comparison);

      if (testResult) {
        return testResult;
      }
    }

    return false;
  };
  /**
   * @param {string} value
   * @param {string | RegExp | Array<string | RegExp>} comparison
   */


  function testAgainstStringOrRegExpOrArray(value, comparison) {
    if (!Array.isArray(comparison)) {
      return testAgainstStringOrRegExp(value, comparison);
    }

    for (const comparisonItem of comparison) {
      const testResult = testAgainstStringOrRegExp(value, comparisonItem);

      if (testResult) {
        return testResult;
      }
    }

    return false;
  }
  /**
   * @param {string} value
   * @param {string | RegExp} comparison
   */


  function testAgainstStringOrRegExp(value, comparison) {
    // If it's a RegExp, test directly
    if (comparison instanceof RegExp) {
      const match = value.match(comparison);
      return match ? {
        match: value,
        pattern: comparison,
        substring: match[0] || ''
      } : false;
    } // Check if it's RegExp in a string


    const firstComparisonChar = comparison[0];
    const lastComparisonChar = comparison[comparison.length - 1];
    const secondToLastComparisonChar = comparison[comparison.length - 2];
    const comparisonIsRegex = firstComparisonChar === '/' && (lastComparisonChar === '/' || secondToLastComparisonChar === '/' && lastComparisonChar === 'i');
    const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i'; // If so, create a new RegExp from it

    if (comparisonIsRegex) {
      const valueMatch = hasCaseInsensitiveFlag ? value.match(new RegExp(comparison.slice(1, -2), 'i')) : value.match(new RegExp(comparison.slice(1, -1)));
      return valueMatch ? {
        match: value,
        pattern: comparison,
        substring: valueMatch[0] || ''
      } : false;
    } // Otherwise, it's a string. Do a strict comparison


    return value === comparison ? {
      match: value,
      pattern: comparison,
      substring: value
    } : false;
  }

  /**
   * Check if an options object's propertyName contains a user-defined string or
   * regex that matches the passed in input.
   *
   * @param {{ [x: string]: any; }} options
   * @param {string} propertyName
   * @param {unknown} input
   *
   * @returns {boolean}
   */


  var optionsMatches = function optionsMatches(options, propertyName, input) {
    return Boolean(options && options[propertyName] && typeof input === 'string' && matchesStringOrRegExp(input, options[propertyName]));
  };

  /**
   * Report a problem.
   *
   * This function accounts for `disabledRanges` attached to the result.
   * That is, if the reported problem is within a disabledRange,
   * it is ignored. Otherwise, it is attached to the result as a
   * postcss warning.
   *
   * It also accounts for the rule's severity.
   *
   * You *must* pass *either* a node or a line number.
   *
   * @type {import('stylelint').Utils['report']}
   */

  var report$1 = function report(problem) {
    const {
      ruleName,
      result,
      message,
      messageArgs,
      line,
      node,
      index,
      endIndex,
      word,
      severity
    } = problem;
    result.stylelint = result.stylelint || {
      ruleSeverities: {},
      customMessages: {},
      ruleMetadata: {}
    };
    const ruleSeverity = severity || result.stylelint.ruleSeverities && result.stylelint.ruleSeverities[ruleName]; // In quiet mode, mere warnings are ignored

    if (result.stylelint.quiet && ruleSeverity !== 'error') {
      return;
    }

    const {
      start
    } = node && node.rangeBy({
      index,
      endIndex
    }) || {}; // If a line is not passed, use the node.rangeBy method to get the
    // line number that the complaint pertains to

    const startLine = line || start && start.line;

    if (!startLine) {
      throw new Error('You must pass either a node or a line number');
    }

    const {
      ignoreDisables
    } = result.stylelint.config || {};

    if (result.stylelint.disabledRanges) {
      const ranges = result.stylelint.disabledRanges[ruleName] || result.stylelint.disabledRanges.all || [];

      for (const range of ranges) {
        if ( // If the problem is within a disabledRange,
        // and that disabledRange's rules include this one,
        // do not register a warning
        range.start <= startLine && (range.end === undefined || range.end >= startLine) && (!range.rules || range.rules.includes(ruleName))) {
          // Collect disabled warnings
          // Used to report `needlessDisables` in subsequent processing.
          const disabledWarnings = result.stylelint.disabledWarnings || (result.stylelint.disabledWarnings = []);
          disabledWarnings.push({
            rule: ruleName,
            line: startLine
          });

          if (!ignoreDisables) {
            return;
          }

          break;
        }
      }
    }

    if (!result.stylelint.stylelintError && ruleSeverity === 'error') {
      result.stylelint.stylelintError = true;
    }

    if (!result.stylelint.stylelintWarning && ruleSeverity === 'warning') {
      result.stylelint.stylelintWarning = true;
    }
    /** @type {import('stylelint').WarningOptions} */


    const warningProperties = {
      severity: ruleSeverity,
      rule: ruleName
    };

    if (node) {
      warningProperties.node = node;
    }

    if (problem.start) {
      warningProperties.start = problem.start;
    } else if (index) {
      warningProperties.index = index;
    }

    if (problem.end) {
      warningProperties.end = problem.end;
    } else if (endIndex) {
      warningProperties.endIndex = endIndex;
    }

    if (word) {
      warningProperties.word = word;
    }

    const {
      customMessages
    } = result.stylelint;
    const warningMessage = buildWarningMessage(customMessages && customMessages[ruleName] || message, messageArgs);
    result.warn(warningMessage, warningProperties);
  };
  /**
   * @param {import('stylelint').RuleMessage} message
   * @param {import('stylelint').Problem['messageArgs']} messageArgs
   * @returns {string}
   */


  function buildWarningMessage(message, messageArgs) {
    const args = messageArgs || [];

    if (typeof message === 'string') {
      return printfLike(message, ...args);
    }

    return message(...args);
  }
  /**
   * @param {string} format
   * @param {Array<unknown>} args
   * @returns {string}
   */


  function printfLike(format, ...args) {
    return args.reduce((
    /** @type {string} */
    result, arg) => {
      return result.replace(/%[ds]/, String(arg));
    }, format);
  }

  /**
   * @type {import('stylelint').Utils['ruleMessages']}
   */

  var ruleMessages$1 = function ruleMessages(ruleName, messages) {
    /** @type {import('stylelint').RuleMessages} */
    const newMessages = {};

    for (const [messageId, messageText] of Object.entries(messages)) {
      if (typeof messageText === 'string') {
        newMessages[messageId] = `${messageText} (${ruleName})`;
      } else {
        newMessages[messageId] = (...args) => `${messageText(...args)} (${ruleName})`;
      }
    } // @ts-expect-error -- TS2322: Type 'RuleMessages' is not assignable to type 'R'.


    return newMessages;
  };

  /** @typedef {import('postcss').Declaration} Declaration */

  /**
   * @param {Declaration} decl
   * @param {string} value
   * @returns {Declaration} The declaration that was passed in.
   */

  var setDeclarationValue = function setDeclarationValue(decl, value) {
    const raws = decl.raws;

    if (raws.value) {
      raws.value.raw = value;
    } else {
      decl.value = value;
    }

    return decl;
  };

  /**
   * Tests if two arrays are equal.
   *
   * @param {unknown} a
   * @param {unknown} b
   * @returns {boolean}
   */

  var arrayEqual = function arrayEqual(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    return a.every((elem, index) => elem === b[index]);
  };

  const {
    isPlainObject: isPlainObject$4
  } = validateTypes;

  const IGNORED_OPTIONS = new Set(['severity', 'message', 'reportDisables', 'disableFix']);
  /** @typedef {import('stylelint').RuleOptions} RuleOptions */

  /** @typedef {import('stylelint').RuleOptionsPossible} RuleOptionsPossible */

  /**
   * @type {import('stylelint').Utils['validateOptions']}
   */

  var validateOptions$1 = function validateOptions(result, ruleName, ...optionDescriptions) {
    let noErrors = true;

    for (const optionDescription of optionDescriptions) {
      validate(optionDescription, ruleName, complain);
    }
    /**
     * @param {string} message
     */


    function complain(message) {
      noErrors = false;
      result.warn(message, {
        stylelintType: 'invalidOption'
      });
      result.stylelint = result.stylelint || {
        disabledRanges: {},
        ruleSeverities: {},
        customMessages: {},
        ruleMetadata: {}
      };
      result.stylelint.stylelintError = true;
    }

    return noErrors;
  };
  /**
   * @param {RuleOptions} opts
   * @param {string} ruleName
   * @param {(message: string) => void} complain
   */


  function validate(opts, ruleName, complain) {
    const possible = opts.possible;
    const actual = opts.actual;
    const optional = opts.optional;

    if (actual === false && !ruleName.startsWith('report')) {
      return complain(`Invalid option value "false" for rule "${ruleName}". Are you trying to disable this rule? If so use "null" instead`);
    }

    if (actual === null || arrayEqual(actual, [null])) {
      return;
    }

    const nothingPossible = possible === undefined || Array.isArray(possible) && possible.length === 0;

    if (nothingPossible && actual === true) {
      return;
    }

    if (actual === undefined) {
      if (nothingPossible || optional) {
        return;
      }

      complain(`Expected option value for rule "${ruleName}"`);
      return;
    }

    if (nothingPossible) {
      if (optional) {
        complain(`Incorrect configuration for rule "${ruleName}". Rule should have "possible" values for options validation`);
        return;
      }

      complain(`Unexpected option value ${stringify$5(actual)} for rule "${ruleName}"`);
      return;
    }

    if (typeof possible === 'function') {
      if (!possible(actual)) {
        complain(`Invalid option ${stringify$5(actual)} for rule "${ruleName}"`);
      }

      return;
    } // If `possible` is an array instead of an object ...


    if (Array.isArray(possible)) {
      for (const a of [actual].flat()) {
        if (isValid(possible, a)) {
          continue;
        }

        complain(`Invalid option value ${stringify$5(a)} for rule "${ruleName}"`);
      }

      return;
    } // If actual is NOT an object ...


    if (!isPlainObject$4(actual) || typeof actual !== 'object' || actual === null) {
      complain(`Invalid option value ${stringify$5(actual)} for rule "${ruleName}": should be an object`);
      return;
    }

    for (const [optionName, optionValue] of Object.entries(actual)) {
      if (IGNORED_OPTIONS.has(optionName)) {
        continue;
      }

      const possibleValue = possible && possible[optionName];

      if (!possibleValue) {
        complain(`Invalid option name "${optionName}" for rule "${ruleName}"`);
        continue;
      }

      for (const a of [optionValue].flat()) {
        if (isValid(possibleValue, a)) {
          continue;
        }

        complain(`Invalid value ${stringify$5(a)} for option "${optionName}" of rule "${ruleName}"`);
      }
    }
  }
  /**
   * @param {RuleOptionsPossible | RuleOptionsPossible[]} possible
   * @param {unknown} actual
   * @returns {boolean}
   */


  function isValid(possible, actual) {
    for (const possibility of [possible].flat()) {
      if (typeof possibility === 'function' && possibility(actual)) {
        return true;
      }

      if (actual === possibility) {
        return true;
      }
    }

    return false;
  }
  /**
   * @param {unknown} value
   * @returns {string}
   */


  function stringify$5(value) {
    if (typeof value === 'string') {
      return `"${value}"`;
    }

    return `"${JSON.stringify(value)}"`;
  }

  const {
    isRegExp: isRegExp$$,
    isString: isString$1h,
    assert: assert$b
  } = validateTypes;

  const ruleName$39 = 'alpha-value-notation';
  const messages$39 = ruleMessages$1(ruleName$39, {
    expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"`
  });
  const meta$39 = {
    url: 'https://stylelint.io/user-guide/rules/alpha-value-notation',
    fixable: true
  };
  const ALPHA_PROPS = /^(?:opacity|shape-image-threshold|fill-opacity|flood-opacity|stop-opacity|stroke-opacity)$/i;
  const ALPHA_FUNCTION = /(?:color|hsla?|rgba?|hwb|lab|lch|oklab|oklch)\(/i;
  const ALPHA_FUNCTION_NAME = /^(?:color|hsla?|rgba?|hwb|lab|lch|oklab|oklch)$/i;
  const DIGIT$2 = /\d/;
  /** @type {import('stylelint').Rule} */

  const rule$39 = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$39, {
        actual: primary,
        possible: ['number', 'percentage']
      }, {
        actual: secondaryOptions,
        possible: {
          exceptProperties: [isString$1h, isRegExp$$]
        },
        optional: true
      });
      if (!validOptions) return;
      const optionFuncs = Object.freeze({
        number: {
          expFunc: isNumber$f,
          fixFunc: asNumber$1
        },
        percentage: {
          expFunc: isPercentage,
          fixFunc: asPercentage
        }
      });
      root.walkDecls(decl => {
        const declarationValue = getDeclarationValue(decl);
        const isAlphaProp = ALPHA_PROPS.test(decl.prop);

        if ( // If the property is not an alpha property
        !isAlphaProp && // And the value is not an alpha function
        !ALPHA_FUNCTION.test(declarationValue) || // Or the value does not contain digits
        !DIGIT$2.test(declarationValue)) {
          // Abort early
          return;
        }

        let needsFix = false;
        const parsedValue = lib$6(declarationValue);
        parsedValue.walk(node => {
          /** @type {import('postcss-value-parser').Node | undefined} */
          let alpha;

          if (isAlphaProp && DIGIT$2.test(node.value)) {
            alpha = findAlphaInValue(node);
          } else if (node.type === 'function' && ALPHA_FUNCTION_NAME.test(node.value)) {
            alpha = findAlphaInFunction(node);
          }

          if (!alpha) return;
          const {
            value
          } = alpha;
          if (!isStandardSyntaxValue(value)) return;
          if (!isNumber$f(value) && !isPercentage(value)) return;
          /** @type {'number' | 'percentage'} */

          let expectation = primary;

          if (optionsMatches(secondaryOptions, 'exceptProperties', decl.prop)) {
            if (expectation === 'number') {
              expectation = 'percentage';
            } else if (expectation === 'percentage') {
              expectation = 'number';
            }
          }

          if (optionFuncs[expectation].expFunc(value)) return;
          const fixed = optionFuncs[expectation].fixFunc(value);
          const unfixed = value;

          if (context.fix) {
            alpha.value = String(fixed);
            needsFix = true;
            return;
          }

          const index = declarationValueIndex(decl) + alpha.sourceIndex;
          const endIndex = index + alpha.value.length;
          report$1({
            message: messages$39.expected,
            messageArgs: [unfixed, fixed],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$39
          });
        });

        if (needsFix) {
          setDeclarationValue(decl, parsedValue.toString());
        }
      });
    };
  };
  /**
   * @param {string} value
   * @returns {string}
   */


  function asPercentage(value) {
    const number = Number(value);
    return `${Number((number * 100).toPrecision(3))}%`;
  }
  /**
   * @param {string} value
   * @returns {string}
   */


  function asNumber$1(value) {
    const dimension = lib$6.unit(value);
    assert$b(dimension);
    const number = Number(dimension.number);
    return Number((number / 100).toPrecision(3)).toString();
  }
  /**
   * @template {import('postcss-value-parser').Node} T
   * @param {T} node
   * @returns {T | undefined}
   */


  function findAlphaInValue(node) {
    return node.type === 'word' || node.type === 'function' ? node : undefined;
  }
  /**
   * @param {import('postcss-value-parser').FunctionNode} node
   * @returns {import('postcss-value-parser').Node | undefined}
   */


  function findAlphaInFunction(node) {
    const legacySyntax = node.nodes.some(({
      type,
      value
    }) => type === 'div' && value === ',');

    if (legacySyntax) {
      const args = node.nodes.filter(({
        type
      }) => type === 'word' || type === 'function');
      if (args.length === 4) return args[3];
      return undefined;
    }

    const slashNodeIndex = node.nodes.findIndex(({
      type,
      value
    }) => type === 'div' && value === '/');

    if (slashNodeIndex !== -1) {
      const nodesAfterSlash = node.nodes.slice(slashNodeIndex + 1, node.nodes.length);
      return nodesAfterSlash.find(({
        type
      }) => type === 'word');
    }

    return undefined;
  }
  /**
   * @param {string} value
   * @returns {boolean}
   */


  function isPercentage(value) {
    const dimension = lib$6.unit(value);
    return dimension && dimension.unit === '%';
  }
  /**
   * @param {string} value
   * @returns {boolean}
   */


  function isNumber$f(value) {
    const dimension = lib$6.unit(value);
    return dimension && dimension.unit === '';
  }

  rule$39.ruleName = ruleName$39;
  rule$39.messages = messages$39;
  rule$39.meta = meta$39;
  var alphaValueNotation = rule$39;

  const {
    isRegExp: isRegExp$_,
    isString: isString$1g
  } = validateTypes;

  const ruleName$38 = 'annotation-no-unknown';
  const messages$38 = ruleMessages$1(ruleName$38, {
    rejected: annotation => `Unexpected unknown annotation "${annotation}"`
  });
  const meta$38 = {
    url: 'https://stylelint.io/user-guide/rules/annotation-no-unknown'
  };
  /** @type {import('stylelint').Rule} */

  const rule$38 = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$38, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreAnnotations: [isString$1g, isRegExp$_]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(checkStatement);
      /**
       * @param {import('postcss').Declaration} decl
       */

      function checkStatement(decl) {
        if (!isStandardSyntaxValue(decl.value)) return;
        if (decl.important) return;
        if (!decl.value.includes('!')) return;
        const parsedValue = lib$6(getDeclarationValue(decl));
        parsedValue.walk(node => {
          if (!isAnnotation(node)) return;
          const value = node.value;
          const tokenValue = value.slice(1);

          if (optionsMatches(secondaryOptions, 'ignoreAnnotations', tokenValue)) {
            return;
          }

          report$1({
            message: messages$38.rejected,
            messageArgs: [value],
            node: decl,
            result,
            ruleName: ruleName$38,
            word: value
          });
        });
      }
      /**
       * @param {valueParser.Node} node
       */


      function isAnnotation(node) {
        return node.type === 'word' && node.value.startsWith('!');
      }
    };
  };

  rule$38.ruleName = ruleName$38;
  rule$38.messages = messages$38;
  rule$38.meta = meta$38;
  var annotationNoUnknown = rule$38;

  /**
   * Check whether a at-rule is standard
   *
   * @param {import('postcss').AtRule | import('postcss-less').AtRule} atRule postcss at-rule node
   * @return {boolean} If `true`, the declaration is standard
   */

  var isStandardSyntaxAtRule = function isStandardSyntaxAtRule(atRule) {
    // Ignore scss `@content` inside mixins
    if (!atRule.nodes && atRule.params === '') {
      return false;
    } // Ignore Less mixins


    if ('mixin' in atRule && atRule.mixin) {
      return false;
    } // Ignore Less detached ruleset `@detached-ruleset: { background: red; }; .top { @detached-ruleset(); }`


    if ('variable' in atRule && atRule.variable || !atRule.nodes && atRule.raws.afterName === '' && atRule.params[0] === '(') {
      return false;
    }

    return true;
  };

  /**
   * Contains helpers for working with vendor prefixes.
   *
   * Copied from https://github.com/postcss/postcss/commit/777c55b5d2a10605313a4972888f4f32005f5ac2
   *
   * @namespace vendor
   */

  var vendor = {
    /**
     * Returns the vendor prefix extracted from an input string.
     *
     * @param {string} prop String with or without vendor prefix.
     *
     * @return {string} vendor prefix or empty string
     *
     * @example
     * vendor.prefix('-moz-tab-size') //=> '-moz-'
     * vendor.prefix('tab-size')      //=> ''
     */
    prefix(prop) {
      const match = prop.match(/^(-\w+-)/);

      if (match) {
        return match[0] || '';
      }

      return '';
    },

    /**
     * Returns the input string stripped of its vendor prefix.
     *
     * @param {string} prop String with or without vendor prefix.
     *
     * @return {string} String name without vendor prefixes.
     *
     * @example
     * vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
     */
    unprefixed(prop) {
      return prop.replace(/^-\w+-/, '');
    }

  };

  const {
    isString: isString$1f
  } = validateTypes;

  const ruleName$37 = 'at-rule-allowed-list';
  const messages$37 = ruleMessages$1(ruleName$37, {
    rejected: name => `Unexpected at-rule "${name}"`
  });
  const meta$37 = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | string[]>} */

  const rule$37 = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$37, {
        actual: primary,
        possible: [isString$1f]
      });

      if (!validOptions) {
        return;
      }

      const primaryValues = [primary].flat();
      root.walkAtRules(atRule => {
        const name = atRule.name;

        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        }

        if (primaryValues.includes(vendor.unprefixed(name).toLowerCase())) {
          return;
        }

        report$1({
          message: messages$37.rejected,
          messageArgs: [name],
          node: atRule,
          result,
          ruleName: ruleName$37,
          word: `@${name}`
        });
      });
    };
  };

  rule$37.primaryOptionArray = true;
  rule$37.ruleName = ruleName$37;
  rule$37.messages = messages$37;
  rule$37.meta = meta$37;
  var atRuleAllowedList = rule$37;

  const {
    isString: isString$1e
  } = validateTypes;

  const ruleName$36 = 'at-rule-disallowed-list';
  const messages$36 = ruleMessages$1(ruleName$36, {
    rejected: name => `Unexpected at-rule "${name}"`
  });
  const meta$36 = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | string[]>} */

  const rule$36 = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$36, {
        actual: primary,
        possible: [isString$1e]
      });

      if (!validOptions) {
        return;
      }

      const primaryValues = [primary].flat();
      root.walkAtRules(atRule => {
        const name = atRule.name;

        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        }

        if (!primaryValues.includes(vendor.unprefixed(name).toLowerCase())) {
          return;
        }

        report$1({
          message: messages$36.rejected,
          messageArgs: [name],
          node: atRule,
          result,
          ruleName: ruleName$36,
          word: `@${atRule.name}`
        });
      });
    };
  };

  rule$36.primaryOptionArray = true;
  rule$36.ruleName = ruleName$36;
  rule$36.messages = messages$36;
  rule$36.meta = meta$36;
  var atRuleDisallowedList = rule$36;

  /**
   * Add an empty line before a node. Mutates the node.
   *
   * @template {import('postcss').ChildNode} T
   * @param {T} node
   * @param {string} newline
   * @returns {T}
   */

  var addEmptyLineBefore = function addEmptyLineBefore(node, newline) {
    const {
      raws
    } = node;

    if (typeof raws.before !== 'string') {
      return node;
    }

    raws.before = !/\r?\n/.test(raws.before) ? newline.repeat(2) + raws.before : raws.before.replace(/(\r?\n)/, `${newline}$1`);
    return node;
  };

  /** @typedef {import('postcss').Node} Node */

  /**
   * @param {Node} node
   */

  function getNodeLine$1(node) {
    return node.source && node.source.start && node.source.start.line;
  }
  /**
   * @param {Node | undefined} node
   * @returns {Node | undefined}
   */


  var getPreviousNonSharedLineCommentNode = function getPreviousNonSharedLineCommentNode(node) {
    if (node === undefined) {
      return undefined;
    }

    const previousNode = node.prev();

    if (!previousNode || previousNode.type !== 'comment') {
      return previousNode;
    }

    if (getNodeLine$1(node) === getNodeLine$1(previousNode)) {
      return getPreviousNonSharedLineCommentNode(previousNode);
    }

    const previousNode2 = previousNode.prev();

    if (previousNode2 && getNodeLine$1(previousNode) === getNodeLine$1(previousNode2)) {
      return getPreviousNonSharedLineCommentNode(previousNode);
    }

    return previousNode;
  };

  const HAS_EMPTY_LINE = /\n[\r\t ]*\n/;
  /**
   * Check if a string contains at least one empty line
   *
   * @param {string | undefined} string
   * @returns {boolean}
   */

  var hasEmptyLine = function hasEmptyLine(string) {
    if (string === '' || string === undefined) return false;
    return HAS_EMPTY_LINE.test(string);
  };

  /** @typedef {import('postcss').Node} Node */

  /**
   * @param {Node | void} node
   */

  function getNodeLine(node) {
    return node && node.source && node.source.start && node.source.start.line;
  }
  /**
   * @param {Node | void} node
   * @returns {Node | void}
   */


  var getNextNonSharedLineCommentNode = function getNextNonSharedLineCommentNode(node) {
    if (node === undefined) {
      return undefined;
    }
    /** @type {Node | void} */


    const nextNode = node.next();

    if (!nextNode || nextNode.type !== 'comment') {
      return nextNode;
    }

    if (getNodeLine(node) === getNodeLine(nextNode) || getNodeLine(nextNode) === getNodeLine(nextNode.next())) {
      return getNextNonSharedLineCommentNode(nextNode);
    }

    return nextNode;
  };

  /** @typedef {import('postcss').Node} Node */

  /** @typedef {import('postcss').Source} NodeSource */

  /**
   * @param {Node} node
   * @returns {node is import('postcss').Root}
   */

  var isRoot$7 = function isRoot(node) {
    return node.type === 'root';
  };
  /**
   * @param {Node} node
   * @returns {node is import('postcss').Rule}
   */


  var isRule$f = function isRule(node) {
    return node.type === 'rule';
  };
  /**
   * @param {Node} node
   * @returns {node is import('postcss').AtRule}
   */


  var isAtRule$r = function isAtRule(node) {
    return node.type === 'atrule';
  };
  /**
   * @param {Node} node
   * @returns {node is import('postcss').Comment}
   */


  var isComment$4 = function isComment(node) {
    return node.type === 'comment';
  };
  /**
   * @param {Node} node
   * @returns {node is import('postcss').Declaration}
   */


  var isDeclaration$5 = function isDeclaration(node) {
    return node.type === 'decl';
  };
  /**
   * @param {Node} node
   * @returns {node is import('postcss').Document}
   */


  var isDocument$1 = function isDocument(node) {
    return node.type === 'document';
  };
  /**
   * @param {import('postcss-value-parser').Node} node
   * @returns {node is import('postcss-value-parser').FunctionNode}
   */


  var isValueFunction$3 = function isValueFunction(node) {
    return node.type === 'function';
  };
  /**
   * @param {Node} node
   * @returns {node is (Node & {source: NodeSource})}
   */


  var hasSource$1 = function hasSource(node) {
    return Boolean(node.source);
  };

  var typeGuards = {
  	isRoot: isRoot$7,
  	isRule: isRule$f,
  	isAtRule: isAtRule$r,
  	isComment: isComment$4,
  	isDeclaration: isDeclaration$5,
  	isDocument: isDocument$1,
  	isValueFunction: isValueFunction$3,
  	hasSource: hasSource$1
  };

  const {
    isRoot: isRoot$6,
    isComment: isComment$3
  } = typeGuards;
  /** @typedef {import('postcss').Node} PostcssNode */

  /**
   *
   * @param {PostcssNode | void} a
   * @param {PostcssNode | void} b
   */


  function nodesShareLines(a, b) {
    const endLine = a && a.source && a.source.end && a.source.end.line;
    const startLine = b && b.source && b.source.start && b.source.start.line;
    return endLine === startLine;
  }
  /**
   * @param {PostcssNode} node
   * @returns {boolean}
   */


  var isSharedLineComment = function isSharedLineComment(node) {
    if (!isComment$3(node)) {
      return false;
    }

    const previousNonSharedLineCommentNode = getPreviousNonSharedLineCommentNode(node);

    if (nodesShareLines(previousNonSharedLineCommentNode, node)) {
      return true;
    }

    const nextNonSharedLineCommentNode = getNextNonSharedLineCommentNode(node);

    if (nextNonSharedLineCommentNode && nodesShareLines(node, nextNonSharedLineCommentNode)) {
      return true;
    }

    const parentNode = node.parent; // It's a first child and located on the same line as block start

    if (parentNode !== undefined && !isRoot$6(parentNode) && parentNode.index(node) === 0 && node.raws.before !== undefined && !node.raws.before.includes('\n')) {
      return true;
    }

    return false;
  };

  /**
   * @param {import('postcss').Node} node
   */


  var isAfterComment = function isAfterComment(node) {
    const previousNode = node.prev();

    if (!previousNode || previousNode.type !== 'comment') {
      return false;
    }

    return !isSharedLineComment(previousNode);
  };

  /**
   * Check if a statement has an block (empty or otherwise).
   *
   * @param {import('postcss').Container} statement
   * @return {boolean} True if `statement` has a block (empty or otherwise)
   */

  var hasBlock = function hasBlock(statement) {
    return statement.nodes !== undefined;
  };

  const {
    isAtRule: isAtRule$q
  } = typeGuards;
  /**
   * @param {import('postcss').AtRule} atRule
   * @returns {boolean}
   */


  var isBlocklessAtRuleAfterBlocklessAtRule = function isBlocklessAtRuleAfterBlocklessAtRule(atRule) {
    if (atRule.type !== 'atrule') {
      return false;
    }

    const previousNode = getPreviousNonSharedLineCommentNode(atRule);

    if (previousNode === undefined) {
      return false;
    }

    return isAtRule$q(previousNode) && !hasBlock(previousNode) && !hasBlock(atRule);
  };

  const {
    isAtRule: isAtRule$p
  } = typeGuards;
  /**
   * @param {import('postcss').AtRule} atRule
   * @returns {boolean}
   */


  var isBlocklessAtRuleAfterSameNameBlocklessAtRule = function isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule) {
    if (!isBlocklessAtRuleAfterBlocklessAtRule(atRule)) {
      return false;
    }

    const previousNode = getPreviousNonSharedLineCommentNode(atRule);

    if (previousNode && isAtRule$p(previousNode)) {
      return previousNode.name === atRule.name;
    }

    return false;
  };

  const {
    isComment: isComment$2,
    isDocument,
    isRoot: isRoot$5,
    hasSource
  } = typeGuards;
  /**
   * @param {import('postcss').Node} statement
   * @returns {boolean}
   */


  var isFirstNested = function isFirstNested(statement) {
    const parentNode = statement.parent;

    if (parentNode === undefined) {
      return false;
    }

    if (isRoot$5(parentNode) && !isInDocument(parentNode)) {
      return false;
    }

    if (statement === parentNode.first) {
      return true;
    }
    /*
     * Search for the statement in the parent's nodes, ignoring comment
     * nodes on the same line as the parent's opening brace.
     */


    const parentNodes = parentNode.nodes;

    if (!parentNodes) {
      return false;
    }

    const firstNode = parentNodes[0];

    if (!firstNode) {
      return false;
    }

    if (!isComment$2(firstNode) || typeof firstNode.raws.before === 'string' && firstNode.raws.before.includes('\n')) {
      return false;
    }

    if (!hasSource(firstNode) || !firstNode.source.start) {
      return false;
    }

    const openingBraceLine = firstNode.source.start.line;

    if (!firstNode.source.end || openingBraceLine !== firstNode.source.end.line) {
      return false;
    }

    for (const [index, node] of parentNodes.entries()) {
      if (index === 0) {
        continue;
      }

      if (node === statement) {
        return true;
      }

      if (!isComment$2(node) || hasSource(node) && node.source.end && node.source.end.line !== openingBraceLine) {
        return false;
      }
    }
    /* istanbul ignore next: Should always return in the loop */


    return false;
  };
  /**
   * @param {import('postcss').Node} node
   * @returns {boolean}
   */


  function isInDocument({
    parent
  }) {
    return Boolean(parent && isDocument(parent));
  }

  const {
    isRoot: isRoot$4
  } = typeGuards;
  /**
   * @param {import('postcss').Node} node
   * @returns {boolean}
   */


  var isFirstNodeOfRoot = function isFirstNodeOfRoot(node) {
    if (isRoot$4(node)) return false;
    const parentNode = node.parent;

    if (!parentNode) {
      return false;
    }

    return isRoot$4(parentNode) && node === parentNode.first;
  };

  /**
   * Remove empty lines before a node. Mutates the node.
   *
   * @template {import('postcss').Node} T
   * @param {T} node
   * @param {string} newline
   * @returns {T}
   */

  var removeEmptyLinesBefore = function removeEmptyLinesBefore(node, newline) {
    node.raws.before = node.raws.before ? node.raws.before.replace(/(\r?\n\s*\n)+/g, newline) : '';
    return node;
  };

  const {
    isAtRule: isAtRule$o
  } = typeGuards;



  const {
    isString: isString$1d
  } = validateTypes;

  const ruleName$35 = 'at-rule-empty-line-before';
  const messages$35 = ruleMessages$1(ruleName$35, {
    expected: 'Expected empty line before at-rule',
    rejected: 'Unexpected empty line before at-rule'
  });
  const meta$35 = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-empty-line-before',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$35 = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$35, {
        actual: primary,
        possible: ['always', 'never']
      }, {
        actual: secondaryOptions,
        possible: {
          except: ['after-same-name', 'inside-block', 'blockless-after-same-name-blockless', 'blockless-after-blockless', 'first-nested'],
          ignore: ['after-comment', 'first-nested', 'inside-block', 'blockless-after-same-name-blockless', 'blockless-after-blockless'],
          ignoreAtRules: [isString$1d]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }
      /** @type {'always' | 'never'} */


      const expectation = primary;
      root.walkAtRules(atRule => {
        const isNested = atRule.parent && atRule.parent.type !== 'root'; // Ignore the first node

        if (isFirstNodeOfRoot(atRule)) {
          return;
        }

        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        } // Return early if at-rule is to be ignored


        if (optionsMatches(secondaryOptions, 'ignoreAtRules', atRule.name)) {
          return;
        } // Optionally ignore the expectation if the node is blockless


        if (optionsMatches(secondaryOptions, 'ignore', 'blockless-after-blockless') && isBlocklessAtRuleAfterBlocklessAtRule(atRule)) {
          return;
        } // Optionally ignore the node if it is the first nested


        if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(atRule)) {
          return;
        } // Optionally ignore the expectation if the node is blockless
        // and following another blockless at-rule with the same name


        if (optionsMatches(secondaryOptions, 'ignore', 'blockless-after-same-name-blockless') && isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule)) {
          return;
        } // Optionally ignore the expectation if the node is inside a block


        if (optionsMatches(secondaryOptions, 'ignore', 'inside-block') && isNested) {
          return;
        } // Optionally ignore the expectation if a comment precedes this node


        if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(atRule)) {
          return;
        }

        const hasEmptyLineBefore = hasEmptyLine(atRule.raws.before);
        let expectEmptyLineBefore = expectation === 'always'; // Optionally reverse the expectation if any exceptions apply

        if (optionsMatches(secondaryOptions, 'except', 'after-same-name') && isAtRuleAfterSameNameAtRule(atRule) || optionsMatches(secondaryOptions, 'except', 'inside-block') && isNested || optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(atRule) || optionsMatches(secondaryOptions, 'except', 'blockless-after-blockless') && isBlocklessAtRuleAfterBlocklessAtRule(atRule) || optionsMatches(secondaryOptions, 'except', 'blockless-after-same-name-blockless') && isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule)) {
          expectEmptyLineBefore = !expectEmptyLineBefore;
        } // Return if the expectation is met


        if (expectEmptyLineBefore === hasEmptyLineBefore) {
          return;
        } // Fix


        if (context.fix && context.newline) {
          if (expectEmptyLineBefore) {
            addEmptyLineBefore(atRule, context.newline);
          } else {
            removeEmptyLinesBefore(atRule, context.newline);
          }

          return;
        }

        const message = expectEmptyLineBefore ? messages$35.expected : messages$35.rejected;
        report$1({
          message,
          node: atRule,
          result,
          ruleName: ruleName$35
        });
      });
    };
  };
  /**
   * @param {import('postcss').AtRule} atRule
   */


  function isAtRuleAfterSameNameAtRule(atRule) {
    const previousNode = getPreviousNonSharedLineCommentNode(atRule);
    return previousNode && isAtRule$o(previousNode) && previousNode.name === atRule.name;
  }

  rule$35.ruleName = ruleName$35;
  rule$35.messages = messages$35;
  rule$35.meta = meta$35;
  var atRuleEmptyLineBefore = rule$35;

  const ruleName$34 = 'at-rule-name-case';
  const messages$34 = ruleMessages$1(ruleName$34, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$34 = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-name-case',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$34 = (primary, _secondary, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$34, {
        actual: primary,
        possible: ['lower', 'upper']
      });

      if (!validOptions) {
        return;
      }
      /** @type {'lower' | 'upper'} */


      const expectation = primary;
      root.walkAtRules(atRule => {
        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        }

        const name = atRule.name;
        const expectedName = expectation === 'lower' ? name.toLowerCase() : name.toUpperCase();

        if (name === expectedName) {
          return;
        }

        if (context.fix) {
          atRule.name = expectedName;
          return;
        }

        report$1({
          message: messages$34.expected(name, expectedName),
          node: atRule,
          ruleName: ruleName$34,
          result
        });
      });
    };
  };

  rule$34.ruleName = ruleName$34;
  rule$34.messages = messages$34;
  rule$34.meta = meta$34;
  var atRuleNameCase = rule$34;

  /**
   * @param {{
   *   root: import('postcss').Root,
   *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void, errTarget: string }) => void,
   *   result: import('stylelint').PostcssResult,
   *   checkedRuleName: string,
   *   fix?: ((atRule: import('postcss').AtRule) => void) | null,
   * }} options
   */


  var atRuleNameSpaceChecker = function atRuleNameSpaceChecker(options) {
    options.root.walkAtRules(atRule => {
      if (!isStandardSyntaxAtRule(atRule)) {
        return;
      }

      checkColon(`@${atRule.name}${atRule.raws.afterName || ''}${atRule.params}`, atRule.name.length, atRule);
    });
    /**
     * @param {string} source
     * @param {number} index
     * @param {import('postcss').AtRule} node
     */

    function checkColon(source, index, node) {
      options.locationChecker({
        source,
        index,
        err: m => {
          if (options.fix) {
            options.fix(node);
            return;
          }

          report$1({
            message: m,
            node,
            index,
            result: options.result,
            ruleName: options.checkedRuleName
          });
        },
        errTarget: `@${node.name}`
      });
    }
  };

  /** @typedef {Error & { code: number }} ConfigurationError */

  /**
   * Create configurationError from text and set CLI exit code.
   *
   * @param {string} text
   * @returns {ConfigurationError}
   */

  var configurationError = function configurationError(text) {
    const err =
    /** @type {ConfigurationError} */
    new Error(text);
    err.code = 78;
    return err;
  };

  /**
   * Check if a string is a single line (i.e. does not contain
   * any newline characters).
   *
   * @param {string} input
   * @return {boolean}
   */

  var isSingleLineString = function isSingleLineString(input) {
    return !/[\n\r]/.test(input);
  };

  /**
   * Check if a character is whitespace.
   *
   * @param {string} char
   * @returns {boolean}
   */

  var isWhitespace$2 = function isWhitespace(char) {
    return [' ', '\n', '\t', '\r', '\f'].includes(char);
  };

  const {
    assertFunction,
    isNullish
  } = validateTypes;
  /**
   * @typedef {(message: string) => string} MessageFunction
   */

  /**
   * @typedef {Object} Messages
   * @property {MessageFunction} [expectedBefore]
   * @property {MessageFunction} [rejectedBefore]
   * @property {MessageFunction} [expectedAfter]
   * @property {MessageFunction} [rejectedAfter]
   * @property {MessageFunction} [expectedBeforeSingleLine]
   * @property {MessageFunction} [rejectedBeforeSingleLine]
   * @property {MessageFunction} [expectedBeforeMultiLine]
   * @property {MessageFunction} [rejectedBeforeMultiLine]
   * @property {MessageFunction} [expectedAfterSingleLine]
   * @property {MessageFunction} [rejectedAfterSingleLine]
   * @property {MessageFunction} [expectedAfterMultiLine]
   * @property {MessageFunction} [rejectedAfterMultiLine]
   */

  /**
   * @typedef {Object} WhitespaceCheckerArgs
   * @property {string} source - The source string
   * @property {number} index - The index of the character to check before
   * @property {(message: string) => void} err - If a problem is found, this callback
   *   will be invoked with the relevant warning message.
   *   Typically this callback will report() the problem.
   * @property {string} [errTarget] - If a problem is found, this string
   *   will be sent to the relevant warning message.
   * @property {string} [lineCheckStr] - Single- and multi-line checkers
   *   will use this string to determine whether they should proceed,
   *   i.e. if this string is one line only, single-line checkers will check,
   *   multi-line checkers will ignore.
   *   If none is passed, they will use `source`.
   * @property {boolean} [onlyOneChar=false] - Only check *one* character before.
   *   By default, "always-*" checks will look for the `targetWhitespace` one
   *   before and then ensure there is no whitespace two before. This option
   *   bypasses that second check.
   * @property {boolean} [allowIndentation=false] - Allow arbitrary indentation
   *   between the `targetWhitespace` (almost definitely a newline) and the `index`.
   *   With this option, the checker will see if a newline *begins* the whitespace before
   *   the `index`.
   */

  /**
   * @typedef {(args: WhitespaceCheckerArgs) => void} WhitespaceChecker
   */

  /**
   * @typedef {{
   *   before: WhitespaceChecker,
   *   beforeAllowingIndentation: WhitespaceChecker,
   *   after: WhitespaceChecker,
   *   afterOneOnly: WhitespaceChecker,
   * }} WhitespaceCheckers
   */

  /**
   * Create a whitespaceChecker, which exposes the following functions:
   * - `before()`
   * - `beforeAllowingIndentation()`
   * - `after()`
   * - `afterOneOnly()`
   *
   * @param {"space" | "newline"} targetWhitespace - This is a keyword instead
   *   of the actual character (e.g. " ") in order to accommodate
   *   different styles of newline ("\n" vs "\r\n")
   * @param {"always" | "never" | "always-single-line" | "always-multi-line" | "never-single-line" | "never-multi-line"} expectation
   * @param {Messages} messages - An object of message functions;
   *   calling `before*()` or `after*()` and the `expectation` that is passed
   *   determines which message functions are required
   *
   * @returns {WhitespaceCheckers} The checker, with its exposed checking functions
   */


  var whitespaceChecker = function whitespaceChecker(targetWhitespace, expectation, messages) {
    // Keep track of active arguments in order to avoid passing
    // too much stuff around, making signatures long and confusing.
    // This variable gets reset anytime a checking function is called.

    /** @type {WhitespaceCheckerArgs} */
    let activeArgs;
    /**
     * Check for whitespace *before* a character.
     * @type {WhitespaceChecker}
     */

    function before({
      source,
      index,
      err,
      errTarget,
      lineCheckStr,
      onlyOneChar = false,
      allowIndentation = false
    }) {
      activeArgs = {
        source,
        index,
        err,
        errTarget,
        onlyOneChar,
        allowIndentation
      };

      switch (expectation) {
        case 'always':
          expectBefore();
          break;

        case 'never':
          rejectBefore();
          break;

        case 'always-single-line':
          if (!isSingleLineString(lineCheckStr || source)) {
            return;
          }

          expectBefore(messages.expectedBeforeSingleLine);
          break;

        case 'never-single-line':
          if (!isSingleLineString(lineCheckStr || source)) {
            return;
          }

          rejectBefore(messages.rejectedBeforeSingleLine);
          break;

        case 'always-multi-line':
          if (isSingleLineString(lineCheckStr || source)) {
            return;
          }

          expectBefore(messages.expectedBeforeMultiLine);
          break;

        case 'never-multi-line':
          if (isSingleLineString(lineCheckStr || source)) {
            return;
          }

          rejectBefore(messages.rejectedBeforeMultiLine);
          break;

        default:
          throw configurationError(`Unknown expectation "${expectation}"`);
      }
    }
    /**
     * Check for whitespace *after* a character.
     * @type {WhitespaceChecker}
     */


    function after({
      source,
      index,
      err,
      errTarget,
      lineCheckStr,
      onlyOneChar = false
    }) {
      activeArgs = {
        source,
        index,
        err,
        errTarget,
        onlyOneChar
      };

      switch (expectation) {
        case 'always':
          expectAfter();
          break;

        case 'never':
          rejectAfter();
          break;

        case 'always-single-line':
          if (!isSingleLineString(lineCheckStr || source)) {
            return;
          }

          expectAfter(messages.expectedAfterSingleLine);
          break;

        case 'never-single-line':
          if (!isSingleLineString(lineCheckStr || source)) {
            return;
          }

          rejectAfter(messages.rejectedAfterSingleLine);
          break;

        case 'always-multi-line':
          if (isSingleLineString(lineCheckStr || source)) {
            return;
          }

          expectAfter(messages.expectedAfterMultiLine);
          break;

        case 'never-multi-line':
          if (isSingleLineString(lineCheckStr || source)) {
            return;
          }

          rejectAfter(messages.rejectedAfterMultiLine);
          break;

        default:
          throw configurationError(`Unknown expectation "${expectation}"`);
      }
    }
    /**
     * @type {WhitespaceChecker}
     */


    function beforeAllowingIndentation(obj) {
      before({ ...obj,
        allowIndentation: true
      });
    }

    function expectBefore(messageFunc = messages.expectedBefore) {
      if (activeArgs.allowIndentation) {
        expectBeforeAllowingIndentation(messageFunc);
        return;
      }

      const _activeArgs = activeArgs;
      const source = _activeArgs.source;
      const index = _activeArgs.index;
      const oneCharBefore = source[index - 1];
      const twoCharsBefore = source[index - 2];

      if (isNullish(oneCharBefore)) {
        return;
      }

      if (targetWhitespace === 'space' && oneCharBefore === ' ' && (activeArgs.onlyOneChar || isNullish(twoCharsBefore) || !isWhitespace$2(twoCharsBefore))) {
        return;
      }

      assertFunction(messageFunc);
      activeArgs.err(messageFunc(activeArgs.errTarget || source.charAt(index)));
    }

    function expectBeforeAllowingIndentation(messageFunc = messages.expectedBefore) {
      const _activeArgs2 = activeArgs;
      const source = _activeArgs2.source;
      const index = _activeArgs2.index;
      const err = _activeArgs2.err;
      const expectedChar = targetWhitespace === 'newline' ? '\n' : undefined;
      let i = index - 1;

      while (source[i] !== expectedChar) {
        if (source[i] === '\t' || source[i] === ' ') {
          i--;
          continue;
        }

        assertFunction(messageFunc);
        err(messageFunc(activeArgs.errTarget || source.charAt(index)));
        return;
      }
    }

    function rejectBefore(messageFunc = messages.rejectedBefore) {
      const _activeArgs3 = activeArgs;
      const source = _activeArgs3.source;
      const index = _activeArgs3.index;
      const oneCharBefore = source[index - 1];

      if (!isNullish(oneCharBefore) && isWhitespace$2(oneCharBefore)) {
        assertFunction(messageFunc);
        activeArgs.err(messageFunc(activeArgs.errTarget || source.charAt(index)));
      }
    }
    /**
     * @type {WhitespaceChecker}
     */


    function afterOneOnly(obj) {
      after({ ...obj,
        onlyOneChar: true
      });
    }

    function expectAfter(messageFunc = messages.expectedAfter) {
      const _activeArgs4 = activeArgs;
      const source = _activeArgs4.source;
      const index = _activeArgs4.index;
      const oneCharAfter = source[index + 1];
      const twoCharsAfter = source[index + 2];
      const threeCharsAfter = source[index + 3];

      if (isNullish(oneCharAfter)) {
        return;
      }

      if (targetWhitespace === 'newline') {
        // If index is followed by a Windows CR-LF ...
        if (oneCharAfter === '\r' && twoCharsAfter === '\n' && (activeArgs.onlyOneChar || isNullish(threeCharsAfter) || !isWhitespace$2(threeCharsAfter))) {
          return;
        } // If index is followed by a Unix LF ...


        if (oneCharAfter === '\n' && (activeArgs.onlyOneChar || isNullish(twoCharsAfter) || !isWhitespace$2(twoCharsAfter))) {
          return;
        }
      }

      if (targetWhitespace === 'space' && oneCharAfter === ' ' && (activeArgs.onlyOneChar || isNullish(twoCharsAfter) || !isWhitespace$2(twoCharsAfter))) {
        return;
      }

      assertFunction(messageFunc);
      activeArgs.err(messageFunc(activeArgs.errTarget || source.charAt(index)));
    }

    function rejectAfter(messageFunc = messages.rejectedAfter) {
      const _activeArgs5 = activeArgs;
      const source = _activeArgs5.source;
      const index = _activeArgs5.index;
      const oneCharAfter = source[index + 1];

      if (!isNullish(oneCharAfter) && isWhitespace$2(oneCharAfter)) {
        assertFunction(messageFunc);
        activeArgs.err(messageFunc(activeArgs.errTarget || source.charAt(index)));
      }
    }

    return {
      before,
      beforeAllowingIndentation,
      after,
      afterOneOnly
    };
  };

  const ruleName$33 = 'at-rule-name-newline-after';
  const messages$33 = ruleMessages$1(ruleName$33, {
    expectedAfter: name => `Expected newline after at-rule name "${name}"`
  });
  const meta$33 = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-name-newline-after',
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$33 = primary => {
    const checker = whitespaceChecker('newline', primary, messages$33);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$33, {
        actual: primary,
        possible: ['always', 'always-multi-line']
      });

      if (!validOptions) {
        return;
      }

      atRuleNameSpaceChecker({
        root,
        result,
        locationChecker: checker.afterOneOnly,
        checkedRuleName: ruleName$33
      });
    };
  };

  rule$33.ruleName = ruleName$33;
  rule$33.messages = messages$33;
  rule$33.meta = meta$33;
  var atRuleNameNewlineAfter = rule$33;

  /**
   * Stringify PostCSS node including its raw "before" string.
   *
   * @param {import('postcss').Node} node
   *
   * @returns {string}
   */

  var rawNodeString = function rawNodeString(node) {
    let result = '';

    if (node.raws.before) {
      result += node.raws.before;
    }

    result += node.toString();
    return result;
  };

  const ruleName$32 = 'at-rule-semicolon-space-before';
  const messages$32 = ruleMessages$1(ruleName$32, {
    expectedBefore: () => 'Expected single space before ";"',
    rejectedBefore: () => 'Unexpected whitespace before ";"'
  });
  const meta$32 = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-semicolon-space-before',
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$32 = primary => {
    const checker = whitespaceChecker('space', primary, messages$32);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$32, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(atRule => {
        if (hasBlock(atRule)) {
          return;
        }

        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        }

        const nodeString = rawNodeString(atRule);
        checker.before({
          source: nodeString,
          index: nodeString.length,
          err: m => {
            report$1({
              message: m,
              node: atRule,
              index: nodeString.length - 1,
              result,
              ruleName: ruleName$32
            });
          }
        });
      });
    };
  };

  rule$32.ruleName = ruleName$32;
  rule$32.messages = messages$32;
  rule$32.meta = meta$32;
  var atRuleSemicolonSpaceBefore = rule$32;

  const ruleName$31 = 'at-rule-name-space-after';
  const messages$31 = ruleMessages$1(ruleName$31, {
    expectedAfter: name => `Expected single space after at-rule name "${name}"`
  });
  const meta$31 = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-name-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$31 = (primary, _secondary, context) => {
    const checker = whitespaceChecker('space', primary, messages$31);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$31, {
        actual: primary,
        possible: ['always', 'always-single-line']
      });

      if (!validOptions) {
        return;
      }

      atRuleNameSpaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$31,
        fix: context.fix ? atRule => {
          if (typeof atRule.raws.afterName === 'string') {
            atRule.raws.afterName = atRule.raws.afterName.replace(/^\s*/, ' ');
          }
        } : null
      });
    };
  };

  rule$31.ruleName = ruleName$31;
  rule$31.messages = messages$31;
  rule$31.meta = meta$31;
  var atRuleNameSpaceAfter = rule$31;

  /**
   * Unite two or more sets
   *
   * @param {Iterable<string>[]} args
   */
  var uniteSets = function uniteSets(...args) {
    return new Set([...args].reduce((result, set) => [...result, ...set], []));
  };

  // https://www.w3.org/TR/css-page-3/#syntax-page-selector


  const pageMarginAtKeywords = new Set(['top-left-corner', 'top-left', 'top-center', 'top-right', 'top-right-corner', 'bottom-left-corner', 'bottom-left', 'bottom-center', 'bottom-right', 'bottom-right-corner', 'left-top', 'left-middle', 'left-bottom', 'right-top', 'right-middle', 'right-bottom']); // https://developer.mozilla.org/en/docs/Web/CSS/At-rule

  const atKeywords$1 = uniteSets(pageMarginAtKeywords, ['annotation', 'apply', 'character-variant', 'charset', 'container', 'counter-style', 'custom-media', 'custom-selector', 'document', 'font-face', 'font-feature-values', 'import', 'keyframes', 'layer', 'media', 'namespace', 'nest', 'ornaments', 'page', 'property', 'scroll-timeline', 'styleset', 'stylistic', 'supports', 'swash', 'viewport']);
  var atKeywords_1 = {
    atKeywords: atKeywords$1
  };

  const {
    atKeywords
  } = atKeywords_1;











  const {
    isRegExp: isRegExp$Z,
    isString: isString$1c
  } = validateTypes;

  const ruleName$30 = 'at-rule-no-unknown';
  const messages$30 = ruleMessages$1(ruleName$30, {
    rejected: atRule => `Unexpected unknown at-rule "${atRule}"`
  });
  const meta$30 = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-no-unknown'
  };
  /** @type {import('stylelint').Rule} */

  const rule$30 = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$30, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreAtRules: [isString$1c, isRegExp$Z]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(atRule => {
        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        }

        const name = atRule.name; // Return early if at-rule is to be ignored

        if (optionsMatches(secondaryOptions, 'ignoreAtRules', atRule.name)) {
          return;
        }

        if (vendor.prefix(name) || atKeywords.has(name.toLowerCase())) {
          return;
        }

        const atName = `@${name}`;
        report$1({
          message: messages$30.rejected,
          messageArgs: [atName],
          node: atRule,
          ruleName: ruleName$30,
          result,
          word: atName
        });
      });
    };
  };

  rule$30.ruleName = ruleName$30;
  rule$30.messages = messages$30;
  rule$30.meta = meta$30;
  var atRuleNoUnknown = rule$30;

  /**
   * Extract each list using the internal API of Autoprefixer 10.2.5.
   *
   * @see https://github.com/postcss/autoprefixer/tree/10.2.5
   *
   * @example
   * const autoprefixer = require('autoprefixer');
   * const Browsers = require('autoprefixer/lib/browsers');
   * const Prefixes = require('autoprefixer/lib/prefixes');
   * const utils = require('autoprefixer/lib/utils');
   *
   * const prefixes = new Prefixes(autoprefixer.data.prefixes, new Browsers(autoprefixer.data.browsers, []));
   */

  /**
   * @example
   * Object.keys(prefixes.remove).filter((s) => s.startsWith('@'));
   */


  const AT_RULES = new Set(['@-khtml-keyframes', '@-moz-keyframes', '@-ms-keyframes', '@-ms-viewport', '@-o-keyframes', '@-o-viewport', '@-webkit-keyframes', '@resolution']);
  /**
   * @example
   * prefixes.remove.selectors.map((s) => s.prefixed);
   */

  const SELECTORS = new Set([':-moz-any-link', ':-moz-full-screen', ':-moz-placeholder', ':-moz-placeholder-shown', ':-moz-read-only', ':-moz-read-write', ':-ms-fullscreen', ':-ms-input-placeholder', ':-webkit-any-link', ':-webkit-full-screen', '::-moz-placeholder', '::-moz-selection', '::-ms-input-placeholder', '::-webkit-backdrop', '::-webkit-input-placeholder']);
  /**
   * @example
   * Object.entries(autoprefixer.data.prefixes)
   *   .filter(([key, value]) => !value.selector && !value.props && !key.startsWith('@'))
   *   .map(([key, value]) => key);
   */

  const PROPERTIES = new Set(['align-content', 'align-items', 'align-self', 'animation', 'animation-delay', 'animation-direction', 'animation-duration', 'animation-fill-mode', 'animation-iteration-count', 'animation-name', 'animation-play-state', 'animation-timing-function', 'appearance', 'backdrop-filter', 'backface-visibility', 'background-clip', 'background-origin', 'background-size', 'border-block-end', 'border-block-start', 'border-bottom-left-radius', 'border-bottom-right-radius', 'border-image', 'border-inline-end', 'border-inline-start', 'border-radius', 'border-top-left-radius', 'border-top-right-radius', 'box-decoration-break', 'box-shadow', 'box-sizing', 'break-after', 'break-before', 'break-inside', 'clip-path', 'color-adjust', 'column-count', 'column-fill', 'column-gap', 'column-rule', 'column-rule-color', 'column-rule-style', 'column-rule-width', 'column-span', 'column-width', 'columns', 'filter', 'flex', 'flex-basis', 'flex-direction', 'flex-flow', 'flex-grow', 'flex-shrink', 'flex-wrap', 'flow-from', 'flow-into', 'font-feature-settings', 'font-kerning', 'font-language-override', 'font-variant-ligatures', 'grid-area', 'grid-column', 'grid-column-align', 'grid-column-end', 'grid-column-start', 'grid-row', 'grid-row-align', 'grid-row-end', 'grid-row-start', 'grid-template', 'grid-template-areas', 'grid-template-columns', 'grid-template-rows', 'hyphens', 'image-rendering', 'justify-content', 'margin-block-end', 'margin-block-start', 'margin-inline-end', 'margin-inline-start', 'mask', 'mask-border', 'mask-border-outset', 'mask-border-repeat', 'mask-border-slice', 'mask-border-source', 'mask-border-width', 'mask-clip', 'mask-composite', 'mask-image', 'mask-origin', 'mask-position', 'mask-repeat', 'mask-size', 'object-fit', 'object-position', 'order', 'overscroll-behavior', 'padding-block-end', 'padding-block-start', 'padding-inline-end', 'padding-inline-start', 'perspective', 'perspective-origin', 'place-self', 'region-fragment', 'scroll-snap-coordinate', 'scroll-snap-destination', 'scroll-snap-points-x', 'scroll-snap-points-y', 'scroll-snap-type', 'shape-image-threshold', 'shape-margin', 'shape-outside', 'tab-size', 'text-align-last', 'text-decoration', 'text-decoration-color', 'text-decoration-line', 'text-decoration-skip', 'text-decoration-skip-ink', 'text-decoration-style', 'text-emphasis', 'text-emphasis-color', 'text-emphasis-position', 'text-emphasis-style', 'text-orientation', 'text-overflow', 'text-size-adjust', 'text-spacing', 'touch-action', 'transform', 'transform-origin', 'transform-style', 'transition', 'transition-delay', 'transition-duration', 'transition-property', 'transition-timing-function', 'user-select', 'writing-mode']);
  /**
   * @example
   * Object.values(prefixes.remove)
   *   .filter((p) => Array.isArray(p.values))
   *   .flatMap((p) => p.values)
   *   .map((p) => utils.removeNote(p.prefixed)) // normalize '-webkit- old'
   *   .filter((p) => !p.endsWith('-'));         // remove '-webkit-' only
   *
   * @see https://github.com/stylelint/stylelint/pull/5312/files#r636018013
   */

  const PROPERTY_VALUES = new Set(['-moz-available', '-moz-box', '-moz-calc', '-moz-crisp-edges', '-moz-element', '-moz-fit-content', '-moz-grab', '-moz-grabbing', '-moz-inline-box', '-moz-isolate', '-moz-isolate-override', '-moz-linear-gradient', '-moz-max-content', '-moz-min-content', '-moz-plaintext', '-moz-radial-gradient', '-moz-repeating-linear-gradient', '-moz-repeating-radial-gradient', '-moz-zoom-in', '-moz-zoom-out', '-ms-flexbox', '-ms-grid', '-ms-inline-flexbox', '-ms-inline-grid', '-ms-linear-gradient', '-ms-radial-gradient', '-ms-repeating-linear-gradient', '-ms-repeating-radial-gradient', '-o-linear-gradient', '-o-pixelated', '-o-radial-gradient', '-o-repeating-linear-gradient', '-o-repeating-radial-gradient', '-webkit-box', '-webkit-calc', '-webkit-cross-fade', '-webkit-fill-available', '-webkit-filter', '-webkit-fit-content', '-webkit-flex', '-webkit-grab', '-webkit-grabbing', '-webkit-image-set', '-webkit-inline-box', '-webkit-inline-flex', '-webkit-isolate', '-webkit-linear-gradient', '-webkit-max-content', '-webkit-min-content', '-webkit-optimize-contrast', '-webkit-radial-gradient', '-webkit-repeating-linear-gradient', '-webkit-repeating-radial-gradient', '-webkit-sticky', '-webkit-zoom-in', '-webkit-zoom-out']);
  /**
   * Most identifier types have to be looked up in a unique way,
   * so we're exposing special functions for each.
   */

  var isAutoprefixable = {
    /**
     * @param {string} identifier
     * @returns {boolean}
     */
    atRuleName(identifier) {
      return AT_RULES.has(`@${identifier.toLowerCase()}`);
    },

    /**
     * @param {string} identifier
     * @returns {boolean}
     */
    selector(identifier) {
      return SELECTORS.has(identifier.toLowerCase());
    },

    /**
     * @param {string} identifier
     * @returns {boolean}
     */
    mediaFeatureName(identifier) {
      return identifier.toLowerCase().includes('device-pixel-ratio');
    },

    /**
     * @param {string} identifier
     * @returns {boolean}
     */
    property(identifier) {
      const ident = identifier.toLowerCase(); // HACK: `interpolation-mode` does not exist. This is an IE extension for `image-rendering`.
      //       See <https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering#examples>

      if (ident === '-ms-interpolation-mode') {
        return true;
      }

      if (vendor.prefix(ident).length === 0) {
        return false;
      }

      return PROPERTIES.has(vendor.unprefixed(ident));
    },

    /**
     * @param {string} value
     * @returns {boolean}
     */
    propertyValue(value) {
      return PROPERTY_VALUES.has(value.toLowerCase());
    },

    /**
     * @param {string} value
     * @returns {string}
     */
    unprefix(value) {
      return value.replace(/-\w+-/, '');
    }

  };

  const ruleName$2$ = 'at-rule-no-vendor-prefix';
  const messages$2$ = ruleMessages$1(ruleName$2$, {
    rejected: p => `Unexpected vendor-prefixed at-rule "@${p}"`
  });
  const meta$2$ = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-no-vendor-prefix',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2$ = (primary, _secondary, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2$, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(atRule => {
        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        }

        const name = atRule.name;

        if (!name.startsWith('-')) {
          return;
        }

        if (!isAutoprefixable.atRuleName(name)) {
          return;
        }

        if (context.fix) {
          atRule.name = isAutoprefixable.unprefix(atRule.name);
          return;
        }

        report$1({
          message: messages$2$.rejected,
          messageArgs: [name],
          node: atRule,
          word: `@${name}`,
          result,
          ruleName: ruleName$2$
        });
      });
    };
  };

  rule$2$.ruleName = ruleName$2$;
  rule$2$.messages = messages$2$;
  rule$2$.meta = meta$2$;
  var atRuleNoVendorPrefix = rule$2$;

  /**
   * Create a map with unique sets of values from a record.
   *
   * @template T
   * @param {Record<string, T | T[]>} record
   * @returns {Map<string, Set<T>>}
   */

  var createMapWithSet = function createMapWithSet(record) {
    /** @type {Map<string, Set<T>>} */
    const map = new Map();

    for (const [key, value] of Object.entries(record)) {
      const list = Array.isArray(value) ? value : [value];
      map.set(key, new Set(list));
    }

    return map;
  };

  const {
    isPlainObject: isPlainObject$3
  } = validateTypes;
  /**
   * Check whether the variable is an object and all its properties are one or more values
   * that satisfy the specified validator(s):
   *
   * @example
   * ignoreProperties = {
   *   value1: ["item11", "item12", "item13"],
   *   value2: "item2",
   * };
   * validateObjectWithArrayProps(isString)(ignoreProperties);
   * //=> true
   *
   * @typedef {(value: unknown) => boolean} Validator
   * @param {...Validator} validators
   * @returns {Validator}
   */


  var validateObjectWithArrayProps = function validateObjectWithArrayProps(...validators) {
    return value => {
      if (!isPlainObject$3(value)) {
        return false;
      }

      return Object.values(value).flat().every(item => validators.some(v => v(item)));
    };
  };

  const {
    isString: isString$1b
  } = validateTypes;

  const ruleName$2_ = 'at-rule-property-required-list';
  const messages$2_ = ruleMessages$1(ruleName$2_, {
    expected: (atRule, property) => `Expected property "${property}" for at-rule "${atRule}"`
  });
  const meta$2_ = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-property-required-list'
  };
  /** @type {import('stylelint').Rule<Record<string, string | string[]>>} */

  const rule$2_ = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2_, {
        actual: primary,
        possible: [validateObjectWithArrayProps(isString$1b)]
      });

      if (!validOptions) {
        return;
      }

      const propLists = createMapWithSet(primary);
      /** @type {Set<string>} */

      const currentPropList = new Set();
      root.walkAtRules(atRule => {
        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        }

        const {
          name,
          nodes
        } = atRule;
        const atRuleName = name.toLowerCase();
        const propList = propLists.get(atRuleName);

        if (!propList) {
          return;
        }

        currentPropList.clear();

        for (const node of nodes) {
          if (!node || node.type !== 'decl') continue;
          const propName = node.prop.toLowerCase();
          if (!propList.has(propName)) continue;
          currentPropList.add(propName);
        }

        if (currentPropList.size === propList.size) {
          return;
        }

        for (const requiredProp of propList) {
          if (currentPropList.has(requiredProp)) continue;
          report$1({
            message: messages$2_.expected,
            messageArgs: [atRuleName, requiredProp],
            node: atRule,
            word: `@${atRule.name}`,
            result,
            ruleName: ruleName$2_
          });
        }
      });
    };
  };

  rule$2_.ruleName = ruleName$2_;
  rule$2_.messages = messages$2_;
  rule$2_.meta = meta$2_;
  var atRulePropertyRequiredList = rule$2_;

  /** @typedef {import('postcss').Node} PostcssNode */

  /**
   * Get the next non-comment node in a PostCSS AST
   * at or after a given node.
   *
   * @param {PostcssNode | void} startNode
   * @returns {PostcssNode | null}
   */

  var nextNonCommentNode = function nextNonCommentNode(startNode) {
    if (!startNode || !startNode.next) return null;

    if (startNode.type === 'comment') {
      return nextNonCommentNode(startNode.next());
    }

    return startNode;
  };

  const ruleName$2Z = 'at-rule-semicolon-newline-after';
  const messages$2Z = ruleMessages$1(ruleName$2Z, {
    expectedAfter: () => 'Expected newline after ";"'
  });
  const meta$2Z = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-semicolon-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2Z = (primary, _secondary, context) => {
    const checker = whitespaceChecker('newline', primary, messages$2Z);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2Z, {
        actual: primary,
        possible: ['always']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(atRule => {
        const nextNode = atRule.next();

        if (!nextNode) {
          return;
        }

        if (hasBlock(atRule)) {
          return;
        }

        if (!isStandardSyntaxAtRule(atRule)) {
          return;
        } // Allow an end-of-line comment


        const nodeToCheck = nextNonCommentNode(nextNode);

        if (!nodeToCheck) {
          return;
        }

        checker.afterOneOnly({
          source: rawNodeString(nodeToCheck),
          index: -1,
          err: msg => {
            if (context.fix) {
              nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;
            } else {
              report$1({
                message: msg,
                node: atRule,
                index: atRule.toString().length + 1,
                result,
                ruleName: ruleName$2Z
              });
            }
          }
        });
      });
    };
  };

  rule$2Z.ruleName = ruleName$2Z;
  rule$2Z.messages = messages$2Z;
  rule$2Z.meta = meta$2Z;
  var atRuleSemicolonNewlineAfter = rule$2Z;

  /**
   * Add an empty line after a node. Mutates the node.
   *
   * @template {import('postcss').Rule | import('postcss').AtRule} T
   * @param {T} node
   * @param {string} newline
   * @returns {T}
   */

  var addEmptyLineAfter = function addEmptyLineAfter(node, newline) {
    const {
      raws
    } = node;

    if (typeof raws.after !== 'string') {
      return node;
    }

    const spaces = raws.after.split(';');
    const after = spaces[spaces.length - 1] || '';

    if (!/\r?\n/.test(after)) {
      raws.after += newline.repeat(2);
    } else {
      raws.after = raws.after.replace(/(\r?\n)/, `${newline}$1`);
    }

    return node;
  };

  const {
    isAtRule: isAtRule$n,
    isRule: isRule$e
  } = typeGuards;
  /**
   * @param {import('postcss').Container} statement
   * @returns {string}
   */


  var beforeBlockString = function beforeBlockString(statement, {
    noRawBefore
  } = {
    noRawBefore: false
  }) {
    let result = '';
    const before = statement.raws.before || '';

    if (!noRawBefore) {
      result += before;
    }

    if (isRule$e(statement)) {
      result += statement.selector;
    } else if (isAtRule$n(statement)) {
      result += `@${statement.name}${statement.raws.afterName || ''}${statement.params}`;
    } else {
      return '';
    }

    result += statement.raws.between || '';
    return result;
  };

  /**
   * Return a CSS statement's block -- the string that starts and `{` and ends with `}`.
   *
   * If the statement has no block (e.g. `@import url(foo.css);`), returns an empty string.
   *
   * @param {import('postcss').Container} statement
   * @returns {string}
   */


  var blockString = function blockString(statement) {
    if (!hasBlock(statement)) {
      return '';
    }

    return rawNodeString(statement).slice(beforeBlockString(statement).length);
  };

  /**
   * Check if a statement has an empty block.
   *
   * @param {import('postcss').Rule | import('postcss').AtRule} statement - postcss rule or at-rule node
   * @return {boolean} True if the statement has a block and it is empty
   */


  var hasEmptyBlock = function hasEmptyBlock(statement) {
    return hasBlock(statement) && statement.nodes.length === 0;
  };

  /**
   * Remove empty lines before a node. Mutates the node.
   *
   * @template {import('postcss').Rule | import('postcss').AtRule} T
   * @param {T} node
   * @param {string} newline
   * @returns {T}
   */

  var removeEmptyLinesAfter = function removeEmptyLinesAfter(node, newline) {
    node.raws.after = node.raws.after ? node.raws.after.replace(/(\r?\n\s*\n)+/g, newline) : '';
    return node;
  };

  const ruleName$2Y = 'block-closing-brace-empty-line-before';
  const messages$2Y = ruleMessages$1(ruleName$2Y, {
    expected: 'Expected empty line before closing brace',
    rejected: 'Unexpected empty line before closing brace'
  });
  const meta$2Y = {
    url: 'https://stylelint.io/user-guide/rules/block-closing-brace-empty-line-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2Y = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2Y, {
        actual: primary,
        possible: ['always-multi-line', 'never']
      }, {
        actual: secondaryOptions,
        possible: {
          except: ['after-closing-brace']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statements: rules and at-rules


      root.walkRules(check);
      root.walkAtRules(check);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function check(statement) {
        // Return early if blockless or has empty block
        if (!hasBlock(statement) || hasEmptyBlock(statement)) {
          return;
        } // Get whitespace after ""}", ignoring extra semicolon


        const before = (statement.raws.after || '').replace(/;+/, ''); // Calculate index

        const statementString = statement.toString();
        let index = statementString.length - 1;

        if (statementString[index - 1] === '\r') {
          index -= 1;
        } // Set expectation


        const expectEmptyLineBefore = (() => {
          const childNodeTypes = statement.nodes.map(item => item.type); // Reverse the primary options if `after-closing-brace` is set

          if (optionsMatches(secondaryOptions, 'except', 'after-closing-brace') && statement.type === 'atrule' && !childNodeTypes.includes('decl')) {
            return primary === 'never';
          }

          return primary === 'always-multi-line' && !isSingleLineString(blockString(statement));
        })(); // Check for at least one empty line


        const hasEmptyLineBefore = hasEmptyLine(before); // Return if the expectation is met

        if (expectEmptyLineBefore === hasEmptyLineBefore) {
          return;
        }

        if (context.fix) {
          const {
            newline
          } = context;
          if (typeof newline !== 'string') return;

          if (expectEmptyLineBefore) {
            addEmptyLineAfter(statement, newline);
          } else {
            removeEmptyLinesAfter(statement, newline);
          }

          return;
        }

        const message = expectEmptyLineBefore ? messages$2Y.expected : messages$2Y.rejected;
        report$1({
          message,
          result,
          ruleName: ruleName$2Y,
          node: statement,
          index
        });
      }
    };
  };

  rule$2Y.ruleName = ruleName$2Y;
  rule$2Y.messages = messages$2Y;
  rule$2Y.meta = meta$2Y;
  var blockClosingBraceEmptyLineBefore = rule$2Y;

  const {
    isString: isString$1a
  } = validateTypes;

  const ruleName$2X = 'block-closing-brace-newline-after';
  const messages$2X = ruleMessages$1(ruleName$2X, {
    expectedAfter: () => 'Expected newline after "}"',
    expectedAfterSingleLine: () => 'Expected newline after "}" of a single-line block',
    rejectedAfterSingleLine: () => 'Unexpected whitespace after "}" of a single-line block',
    expectedAfterMultiLine: () => 'Expected newline after "}" of a multi-line block',
    rejectedAfterMultiLine: () => 'Unexpected whitespace after "}" of a multi-line block'
  });
  const meta$2X = {
    url: 'https://stylelint.io/user-guide/rules/block-closing-brace-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2X = (primary, secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$2X);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2X, {
        actual: primary,
        possible: ['always', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreAtRules: [isString$1a]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statements: rules and at-rules


      root.walkRules(check);
      root.walkAtRules(check);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function check(statement) {
        if (!hasBlock(statement)) {
          return;
        }

        if (statement.type === 'atrule' && optionsMatches(secondaryOptions, 'ignoreAtRules', statement.name)) {
          return;
        }

        const nextNode = statement.next();

        if (!nextNode) {
          return;
        } // Allow an end-of-line comment x spaces after the brace


        const nextNodeIsSingleLineComment = nextNode.type === 'comment' && !/[^ ]/.test(nextNode.raws.before || '') && !nextNode.toString().includes('\n');
        const nodeToCheck = nextNodeIsSingleLineComment ? nextNode.next() : nextNode;

        if (!nodeToCheck) {
          return;
        }

        let reportIndex = statement.toString().length;
        let source = rawNodeString(nodeToCheck); // Skip a semicolon at the beginning, if any

        if (source && source.startsWith(';')) {
          source = source.slice(1);
          reportIndex++;
        } // Only check one after, because there might be other
        // spaces handled by the indentation rule


        checker.afterOneOnly({
          source,
          index: -1,
          lineCheckStr: blockString(statement),
          err: msg => {
            if (context.fix) {
              const nodeToCheckRaws = nodeToCheck.raws;
              if (typeof nodeToCheckRaws.before !== 'string') return;

              if (primary.startsWith('always')) {
                const index = nodeToCheckRaws.before.search(/\r?\n/);
                nodeToCheckRaws.before = index >= 0 ? nodeToCheckRaws.before.slice(index) : context.newline + nodeToCheckRaws.before;
                return;
              }

              if (primary.startsWith('never')) {
                nodeToCheckRaws.before = '';
                return;
              }
            }

            report$1({
              message: msg,
              node: statement,
              index: reportIndex,
              result,
              ruleName: ruleName$2X
            });
          }
        });
      }
    };
  };

  rule$2X.ruleName = ruleName$2X;
  rule$2X.messages = messages$2X;
  rule$2X.meta = meta$2X;
  var blockClosingBraceNewlineAfter = rule$2X;

  const ruleName$2W = 'block-closing-brace-newline-before';
  const messages$2W = ruleMessages$1(ruleName$2W, {
    expectedBefore: 'Expected newline before "}"',
    expectedBeforeMultiLine: 'Expected newline before "}" of a multi-line block',
    rejectedBeforeMultiLine: 'Unexpected whitespace before "}" of a multi-line block'
  });
  const meta$2W = {
    url: 'https://stylelint.io/user-guide/rules/block-closing-brace-newline-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2W = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2W, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statements: rules and at-rules


      root.walkRules(check);
      root.walkAtRules(check);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function check(statement) {
        // Return early if blockless or has empty block
        if (!hasBlock(statement) || hasEmptyBlock(statement)) {
          return;
        } // Ignore extra semicolon


        const after = (statement.raws.after || '').replace(/;+/, '');

        if (after === undefined) {
          return;
        }

        const blockIsMultiLine = !isSingleLineString(blockString(statement));
        const statementString = statement.toString();
        let index = statementString.length - 2;

        if (statementString[index - 1] === '\r') {
          index -= 1;
        } // We're really just checking whether a
        // newline *starts* the block's final space -- between
        // the last declaration and the closing brace. We can
        // ignore any other whitespace between them, because that
        // will be checked by the indentation rule.


        if (!after.startsWith('\n') && !after.startsWith('\r\n')) {
          if (primary === 'always') {
            complain(messages$2W.expectedBefore);
          } else if (blockIsMultiLine && primary === 'always-multi-line') {
            complain(messages$2W.expectedBeforeMultiLine);
          }
        }

        if (after !== '' && blockIsMultiLine && primary === 'never-multi-line') {
          complain(messages$2W.rejectedBeforeMultiLine);
        }
        /**
         * @param {string} message
         */


        function complain(message) {
          if (context.fix) {
            const statementRaws = statement.raws;
            if (typeof statementRaws.after !== 'string') return;

            if (primary.startsWith('always')) {
              const firstWhitespaceIndex = statementRaws.after.search(/\s/);
              const newlineBefore = firstWhitespaceIndex >= 0 ? statementRaws.after.slice(0, firstWhitespaceIndex) : statementRaws.after;
              const newlineAfter = firstWhitespaceIndex >= 0 ? statementRaws.after.slice(firstWhitespaceIndex) : '';
              const newlineIndex = newlineAfter.search(/\r?\n/);
              statementRaws.after = newlineIndex >= 0 ? newlineBefore + newlineAfter.slice(newlineIndex) : newlineBefore + context.newline + newlineAfter;
              return;
            }

            if (primary === 'never-multi-line') {
              statementRaws.after = statementRaws.after.replace(/\s/g, '');
              return;
            }
          }

          report$1({
            message,
            result,
            ruleName: ruleName$2W,
            node: statement,
            index
          });
        }
      }
    };
  };

  rule$2W.ruleName = ruleName$2W;
  rule$2W.messages = messages$2W;
  rule$2W.meta = meta$2W;
  var blockClosingBraceNewlineBefore = rule$2W;

  const ruleName$2V = 'block-closing-brace-space-after';
  const messages$2V = ruleMessages$1(ruleName$2V, {
    expectedAfter: () => 'Expected single space after "}"',
    rejectedAfter: () => 'Unexpected whitespace after "}"',
    expectedAfterSingleLine: () => 'Expected single space after "}" of a single-line block',
    rejectedAfterSingleLine: () => 'Unexpected whitespace after "}" of a single-line block',
    expectedAfterMultiLine: () => 'Expected single space after "}" of a multi-line block',
    rejectedAfterMultiLine: () => 'Unexpected whitespace after "}" of a multi-line block'
  });
  const meta$2V = {
    url: 'https://stylelint.io/user-guide/rules/block-closing-brace-space-after',
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2V = primary => {
    const checker = whitespaceChecker('space', primary, messages$2V);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2V, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statements: rules and at-rules


      root.walkRules(check);
      root.walkAtRules(check);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function check(statement) {
        const nextNode = statement.next();

        if (!nextNode) {
          return;
        }

        if (!hasBlock(statement)) {
          return;
        }

        let reportIndex = statement.toString().length;
        let source = rawNodeString(nextNode); // Skip a semicolon at the beginning, if any

        if (source && source.startsWith(';')) {
          source = source.slice(1);
          reportIndex++;
        }

        checker.after({
          source,
          index: -1,
          lineCheckStr: blockString(statement),
          err: msg => {
            report$1({
              message: msg,
              node: statement,
              index: reportIndex,
              result,
              ruleName: ruleName$2V
            });
          }
        });
      }
    };
  };

  rule$2V.ruleName = ruleName$2V;
  rule$2V.messages = messages$2V;
  rule$2V.meta = meta$2V;
  var blockClosingBraceSpaceAfter = rule$2V;

  const ruleName$2U = 'block-closing-brace-space-before';
  const messages$2U = ruleMessages$1(ruleName$2U, {
    expectedBefore: () => 'Expected single space before "}"',
    rejectedBefore: () => 'Unexpected whitespace before "}"',
    expectedBeforeSingleLine: () => 'Expected single space before "}" of a single-line block',
    rejectedBeforeSingleLine: () => 'Unexpected whitespace before "}" of a single-line block',
    expectedBeforeMultiLine: () => 'Expected single space before "}" of a multi-line block',
    rejectedBeforeMultiLine: () => 'Unexpected whitespace before "}" of a multi-line block'
  });
  const meta$2U = {
    url: 'https://stylelint.io/user-guide/rules/block-closing-brace-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2U = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2U);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2U, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statement: rules and at-rules


      root.walkRules(check);
      root.walkAtRules(check);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function check(statement) {
        // Return early if blockless or has empty block
        if (!hasBlock(statement) || hasEmptyBlock(statement)) {
          return;
        }

        const source = blockString(statement);
        const statementString = statement.toString();
        let index = statementString.length - 2;

        if (statementString[index - 1] === '\r') {
          index -= 1;
        }

        checker.before({
          source,
          index: source.length - 1,
          err: msg => {
            if (context.fix) {
              const statementRaws = statement.raws;
              if (typeof statementRaws.after !== 'string') return;

              if (primary.startsWith('always')) {
                statementRaws.after = statementRaws.after.replace(/\s*$/, ' ');
                return;
              }

              if (primary.startsWith('never')) {
                statementRaws.after = statementRaws.after.replace(/\s*$/, '');
                return;
              }
            }

            report$1({
              message: msg,
              node: statement,
              index,
              result,
              ruleName: ruleName$2U
            });
          }
        });
      }
    };
  };

  rule$2U.ruleName = ruleName$2U;
  rule$2U.messages = messages$2U;
  rule$2U.meta = meta$2U;
  var blockClosingBraceSpaceBefore = rule$2U;

  const {
    assertString: assertString$6
  } = validateTypes;

  const DISABLE_COMMAND$1 = '-disable';
  const DISABLE_LINE_COMMAND$1 = '-disable-line';
  const DISABLE_NEXT_LINE_COMMAND$1 = '-disable-next-line';
  const ENABLE_COMMAND$1 = '-enable';
  const ALL_COMMANDS = new Set([DISABLE_COMMAND$1, DISABLE_LINE_COMMAND$1, DISABLE_NEXT_LINE_COMMAND$1, ENABLE_COMMAND$1]);
  const DEFAULT_CONFIGURATION_COMMENT$1 = 'stylelint';
  /** @typedef {import('postcss').Comment} Comment */

  /**
   * Extract a command from a given comment.
   *
   * @param {Comment} comment
   * @param {string} [configurationComment]
   * @returns {string}
   */

  function extractConfigurationComment$1(comment, configurationComment = DEFAULT_CONFIGURATION_COMMENT$1) {
    const [command] = comment.text.split(/\s/, 1);
    assertString$6(command);
    return command.replace(configurationComment, '');
  }
  /**
   * Tests if the given comment is a Stylelint command.
   *
   * @param {Comment} comment
   * @param {string} [configurationComment]
   * @returns {boolean}
   */


  function isConfigurationComment$3(comment, configurationComment = DEFAULT_CONFIGURATION_COMMENT$1) {
    const command = extractConfigurationComment$1(comment, configurationComment);
    return command !== undefined && ALL_COMMANDS.has(command);
  }
  /**
   * Get full stylelint command
   *
   * @param {string} command
   * @param {string} [configurationComment]
   * @returns {string}
   */


  function getConfigurationComment$1(command, configurationComment = DEFAULT_CONFIGURATION_COMMENT$1) {
    return `${configurationComment}${command}`;
  }

  var configurationComment = {
    DEFAULT_CONFIGURATION_COMMENT: DEFAULT_CONFIGURATION_COMMENT$1,
    DISABLE_COMMAND: DISABLE_COMMAND$1,
    DISABLE_LINE_COMMAND: DISABLE_LINE_COMMAND$1,
    DISABLE_NEXT_LINE_COMMAND: DISABLE_NEXT_LINE_COMMAND$1,
    ENABLE_COMMAND: ENABLE_COMMAND$1,
    extractConfigurationComment: extractConfigurationComment$1,
    getConfigurationComment: getConfigurationComment$1,
    isConfigurationComment: isConfigurationComment$3
  };

  const {
    isConfigurationComment: isConfigurationComment$2
  } = configurationComment;

  const {
    isComment: isComment$1
  } = typeGuards;



  const {
    isBoolean: isBoolean$9
  } = validateTypes;

  const ruleName$2T = 'block-no-empty';
  const messages$2T = ruleMessages$1(ruleName$2T, {
    rejected: 'Unexpected empty block'
  });
  const meta$2T = {
    url: 'https://stylelint.io/user-guide/rules/block-no-empty'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2T = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2T, {
        actual: primary,
        possible: isBoolean$9
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['comments']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments'); // Check both kinds of statements: rules and at-rules

      root.walkRules(check);
      root.walkAtRules(check);
      /** @typedef {import('postcss').Rule | import('postcss').AtRule} Statement */

      /**
       * @param {Statement} statement
       */

      function check(statement) {
        if (!hasBlock(statement)) {
          return;
        }

        if (hasNotableChild(statement)) {
          return;
        }

        if (hasNonWhitespace(statement)) {
          return;
        }

        let index = beforeBlockString(statement, {
          noRawBefore: true
        }).length; // For empty blocks when using SugarSS parser

        if (statement.raws.between === undefined) {
          index--;
        }

        report$1({
          message: messages$2T.rejected,
          node: statement,
          start: statement.positionBy({
            index
          }),
          result,
          ruleName: ruleName$2T
        });
      }
      /**
       * @param {Statement} statement
       * @returns {boolean}
       */


      function hasNotableChild(statement) {
        return statement.nodes.some(child => {
          if (isComment$1(child)) {
            if (ignoreComments) return false;
            if (isConfigurationComment$2(child, context.configurationComment)) return false;
          }

          return true;
        });
      }
      /**
       * @param {Statement} statement
       * @returns {boolean}
       */


      function hasNonWhitespace(statement) {
        const {
          after
        } = statement.raws;
        return typeof after === 'string' && /\S/.test(after);
      }
    };
  };

  rule$2T.ruleName = ruleName$2T;
  rule$2T.messages = messages$2T;
  rule$2T.meta = meta$2T;
  var blockNoEmpty = rule$2T;

  const ruleName$2S = 'block-opening-brace-newline-after';
  const messages$2S = ruleMessages$1(ruleName$2S, {
    expectedAfter: () => 'Expected newline after "{"',
    expectedAfterMultiLine: () => 'Expected newline after "{" of a multi-line block',
    rejectedAfterMultiLine: () => 'Unexpected whitespace after "{" of a multi-line block'
  });
  const meta$2S = {
    url: 'https://stylelint.io/user-guide/rules/block-opening-brace-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2S = (primary, secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$2S);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2S, {
        actual: primary,
        possible: ['always', 'rules', 'always-multi-line', 'never-multi-line']
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['rules']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statement: rules and at-rules


      if (!optionsMatches(secondaryOptions, 'ignore', 'rules')) {
        root.walkRules(check);
      }

      root.walkAtRules(check);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function check(statement) {
        // Return early if blockless or has an empty block
        if (!hasBlock(statement) || hasEmptyBlock(statement)) {
          return;
        }

        const backupCommentNextBefores = new Map();
        /**
         * next node with checking newlines after comment
         *
         * @param {import('postcss').ChildNode | undefined} startNode
         * @returns {import('postcss').ChildNode | undefined}
         */

        function nextNode(startNode) {
          if (!startNode || !startNode.next) return;

          if (startNode.type === 'comment') {
            const reNewLine = /\r?\n/;
            const newLineMatch = reNewLine.test(startNode.raws.before || '');
            const next = startNode.next();

            if (next && newLineMatch && !reNewLine.test(next.raws.before || '')) {
              backupCommentNextBefores.set(next, next.raws.before);
              next.raws.before = startNode.raws.before;
            }

            return nextNode(next);
          }

          return startNode;
        } // Allow an end-of-line comment


        const nodeToCheck = nextNode(statement.first);

        if (!nodeToCheck) {
          return;
        }

        checker.afterOneOnly({
          source: rawNodeString(nodeToCheck),
          index: -1,
          lineCheckStr: blockString(statement),
          err: m => {
            if (context.fix) {
              const nodeToCheckRaws = nodeToCheck.raws;
              if (typeof nodeToCheckRaws.before !== 'string') return;

              if (primary.startsWith('always')) {
                const index = nodeToCheckRaws.before.search(/\r?\n/);
                nodeToCheckRaws.before = index >= 0 ? nodeToCheckRaws.before.slice(index) : context.newline + nodeToCheckRaws.before;
                backupCommentNextBefores.delete(nodeToCheck);
                return;
              }

              if (primary === 'never-multi-line') {
                // Restore the `before` of the node next to the comment node.
                for (const [node, before] of backupCommentNextBefores.entries()) {
                  node.raws.before = before;
                }

                backupCommentNextBefores.clear(); // Fix

                const reNewLine = /\r?\n/;
                let fixTarget = statement.first;

                while (fixTarget) {
                  const fixTargetRaws = fixTarget.raws;
                  if (typeof fixTargetRaws.before !== 'string') continue;

                  if (reNewLine.test(fixTargetRaws.before || '')) {
                    fixTargetRaws.before = fixTargetRaws.before.replace(/\r?\n/g, '');
                  }

                  if (fixTarget.type !== 'comment') {
                    break;
                  }

                  fixTarget = fixTarget.next();
                }

                nodeToCheckRaws.before = '';
                return;
              }
            }

            report$1({
              message: m,
              node: statement,
              index: beforeBlockString(statement, {
                noRawBefore: true
              }).length + 1,
              result,
              ruleName: ruleName$2S
            });
          }
        }); // Restore the `before` of the node next to the comment node.

        for (const [node, before] of backupCommentNextBefores.entries()) {
          node.raws.before = before;
        }
      }
    };
  };

  rule$2S.ruleName = ruleName$2S;
  rule$2S.messages = messages$2S;
  rule$2S.meta = meta$2S;
  var blockOpeningBraceNewlineAfter = rule$2S;

  const ruleName$2R = 'block-opening-brace-newline-before';
  const messages$2R = ruleMessages$1(ruleName$2R, {
    expectedBefore: () => 'Expected newline before "{"',
    expectedBeforeSingleLine: () => 'Expected newline before "{" of a single-line block',
    rejectedBeforeSingleLine: () => 'Unexpected whitespace before "{" of a single-line block',
    expectedBeforeMultiLine: () => 'Expected newline before "{" of a multi-line block',
    rejectedBeforeMultiLine: () => 'Unexpected whitespace before "{" of a multi-line block'
  });
  const meta$2R = {
    url: 'https://stylelint.io/user-guide/rules/block-opening-brace-newline-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2R = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$2R);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2R, {
        actual: primary,
        possible: ['always', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statement: rules and at-rules


      root.walkRules(check);
      root.walkAtRules(check);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function check(statement) {
        // Return early if blockless or has an empty block
        if (!hasBlock(statement) || hasEmptyBlock(statement)) {
          return;
        }

        const source = beforeBlockString(statement);
        const beforeBraceNoRaw = beforeBlockString(statement, {
          noRawBefore: true
        });
        let index = beforeBraceNoRaw.length - 1;

        if (beforeBraceNoRaw[index - 1] === '\r') {
          index -= 1;
        }

        checker.beforeAllowingIndentation({
          lineCheckStr: blockString(statement),
          source,
          index: source.length,
          err: m => {
            if (context.fix) {
              const statementRaws = statement.raws;
              if (typeof statementRaws.between !== 'string') return;

              if (primary.startsWith('always')) {
                const spaceIndex = statementRaws.between.search(/\s+$/);

                if (spaceIndex >= 0) {
                  statement.raws.between = statementRaws.between.slice(0, spaceIndex) + context.newline + statementRaws.between.slice(spaceIndex);
                } else {
                  statementRaws.between += context.newline;
                }

                return;
              }

              if (primary.startsWith('never')) {
                statementRaws.between = statementRaws.between.replace(/\s*$/, '');
                return;
              }
            }

            report$1({
              message: m,
              node: statement,
              index,
              result,
              ruleName: ruleName$2R
            });
          }
        });
      }
    };
  };

  rule$2R.ruleName = ruleName$2R;
  rule$2R.messages = messages$2R;
  rule$2R.meta = meta$2R;
  var blockOpeningBraceNewlineBefore = rule$2R;

  const ruleName$2Q = 'block-opening-brace-space-after';
  const messages$2Q = ruleMessages$1(ruleName$2Q, {
    expectedAfter: () => 'Expected single space after "{"',
    rejectedAfter: () => 'Unexpected whitespace after "{"',
    expectedAfterSingleLine: () => 'Expected single space after "{" of a single-line block',
    rejectedAfterSingleLine: () => 'Unexpected whitespace after "{" of a single-line block',
    expectedAfterMultiLine: () => 'Expected single space after "{" of a multi-line block',
    rejectedAfterMultiLine: () => 'Unexpected whitespace after "{" of a multi-line block'
  });
  const meta$2Q = {
    url: 'https://stylelint.io/user-guide/rules/block-opening-brace-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2Q = (primary, secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2Q);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2Q, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['at-rules']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statements: rules and at-rules


      root.walkRules(check);

      if (!optionsMatches(secondaryOptions, 'ignore', 'at-rules')) {
        root.walkAtRules(check);
      }
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */


      function check(statement) {
        // Return early if blockless or has an empty block
        if (!hasBlock(statement) || hasEmptyBlock(statement)) {
          return;
        }

        checker.after({
          source: blockString(statement),
          index: 0,
          err: m => {
            if (context.fix) {
              const statementFirst = statement.first;
              if (statementFirst == null) return;

              if (primary.startsWith('always')) {
                statementFirst.raws.before = ' ';
                return;
              }

              if (primary.startsWith('never')) {
                statementFirst.raws.before = '';
                return;
              }
            }

            report$1({
              message: m,
              node: statement,
              index: beforeBlockString(statement, {
                noRawBefore: true
              }).length + 1,
              result,
              ruleName: ruleName$2Q
            });
          }
        });
      }
    };
  };

  rule$2Q.ruleName = ruleName$2Q;
  rule$2Q.messages = messages$2Q;
  rule$2Q.meta = meta$2Q;
  var blockOpeningBraceSpaceAfter = rule$2Q;

  const {
    isRegExp: isRegExp$Y,
    isString: isString$19
  } = validateTypes;

  const ruleName$2P = 'block-opening-brace-space-before';
  const messages$2P = ruleMessages$1(ruleName$2P, {
    expectedBefore: () => 'Expected single space before "{"',
    rejectedBefore: () => 'Unexpected whitespace before "{"',
    expectedBeforeSingleLine: () => 'Expected single space before "{" of a single-line block',
    rejectedBeforeSingleLine: () => 'Unexpected whitespace before "{" of a single-line block',
    expectedBeforeMultiLine: () => 'Expected single space before "{" of a multi-line block',
    rejectedBeforeMultiLine: () => 'Unexpected whitespace before "{" of a multi-line block'
  });
  const meta$2P = {
    url: 'https://stylelint.io/user-guide/rules/block-opening-brace-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2P = (primary, secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2P);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2P, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line', 'always-multi-line', 'never-multi-line']
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreAtRules: [isString$19, isRegExp$Y],
          ignoreSelectors: [isString$19, isRegExp$Y]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      } // Check both kinds of statements: rules and at-rules


      root.walkRules(check);
      root.walkAtRules(check);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function check(statement) {
        // Return early if blockless or has an empty block
        if (!hasBlock(statement) || hasEmptyBlock(statement)) {
          return;
        } // Return early if at-rule is to be ignored


        if (statement.type === 'atrule' && optionsMatches(secondaryOptions, 'ignoreAtRules', statement.name)) {
          return;
        } // Return early if selector is to be ignored


        if (statement.type === 'rule' && optionsMatches(secondaryOptions, 'ignoreSelectors', statement.selector)) {
          return;
        }

        const source = beforeBlockString(statement);
        const beforeBraceNoRaw = beforeBlockString(statement, {
          noRawBefore: true
        });
        let index = beforeBraceNoRaw.length - 1;

        if (beforeBraceNoRaw[index - 1] === '\r') {
          index -= 1;
        }

        checker.before({
          source,
          index: source.length,
          lineCheckStr: blockString(statement),
          err: m => {
            if (context.fix) {
              if (primary.startsWith('always')) {
                statement.raws.between = ' ';
                return;
              }

              if (primary.startsWith('never')) {
                statement.raws.between = '';
                return;
              }
            }

            report$1({
              message: m,
              node: statement,
              index,
              result,
              ruleName: ruleName$2P
            });
          }
        });
      }
    };
  };

  rule$2P.ruleName = ruleName$2P;
  rule$2P.messages = messages$2P;
  rule$2P.meta = meta$2P;
  var blockOpeningBraceSpaceBefore = rule$2P;

  /**
   * Check whether a function is standard
   *
   * @param {import('postcss-value-parser').Node} node
   * @returns {boolean}
   */

  var isStandardSyntaxFunction = function isStandardSyntaxFunction(node) {
    // Function nodes without names are things in parentheses like Sass lists
    if (!node.value) {
      return false;
    }

    if (node.value.startsWith('#{')) {
      return false;
    } // CSS-in-JS interpolation


    if (node.value.startsWith('${')) {
      return false;
    } // CSS-in-JS syntax


    if (node.value.startsWith('`')) {
      return false;
    }

    return true;
  };

  /**
   * Check whether a function is standard syntax color function
   *
   * @param {import('postcss-value-parser').FunctionNode} node
   * @returns {boolean}
   */


  var isStandardSyntaxColorFunction = function isStandardSyntaxColorFunction(node) {
    if (!isStandardSyntaxFunction(node)) return false; // scss can accept a #hex, or $var variables and we need to check all nested fn nodes

    for (const fnNode of node.nodes) {
      if (fnNode.type === 'function') return isStandardSyntaxColorFunction(fnNode);
      if (fnNode.type === 'word' && (fnNode.value.startsWith('#') || fnNode.value.startsWith('$') || fnNode.value.includes('.$'))) return false;
    }

    return true;
  };

  const {
    isValueFunction: isValueFunction$2
  } = typeGuards;





  const ruleName$2O = 'color-function-notation';
  const messages$2O = ruleMessages$1(ruleName$2O, {
    expected: primary => `Expected ${primary} color-function notation`
  });
  const meta$2O = {
    url: 'https://stylelint.io/user-guide/rules/color-function-notation',
    fixable: true
  };
  const LEGACY_FUNCTION_NAME = /^(?:rgba|hsla)$/i;
  const LEGACY_NOTATION_FUNCTION = /\b(?:rgba?|hsla?)\(/i;
  const LEGACY_NOTATION_FUNCTION_NAME = /^(?:rgba?|hsla?)$/i;
  /** @type {import('stylelint').Rule} */

  const rule$2O = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2O, {
        actual: primary,
        possible: ['modern', 'legacy']
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['with-var-inside']
        },
        optional: true
      });
      if (!validOptions) return;
      const ignoreWithVarInside = optionsMatches(secondaryOptions, 'ignore', 'with-var-inside');
      root.walkDecls(decl => {
        if (!LEGACY_NOTATION_FUNCTION.test(decl.value)) return;
        if (primary === 'modern' && !decl.value.includes(',')) return;
        let needsFix = false;
        const parsedValue = lib$6(getDeclarationValue(decl));
        parsedValue.walk(node => {
          if (!isValueFunction$2(node)) return;
          if (!isStandardSyntaxColorFunction(node)) return;
          const {
            value,
            sourceIndex,
            sourceEndIndex,
            nodes
          } = node;

          if (ignoreWithVarInside && containsVariable(nodes)) {
            return;
          }

          if (!LEGACY_NOTATION_FUNCTION_NAME.test(value)) return;
          if (primary === 'modern' && !hasCommas(node)) return;
          if (primary === 'legacy' && hasCommas(node)) return;

          if (context.fix && primary === 'modern') {
            let commaCount = 0; // Convert punctuation

            node.nodes = nodes.map(childNode => {
              if (isComma(childNode)) {
                // Non-alpha commas to space and alpha commas to slashes
                if (commaCount < 2) {
                  // @ts-expect-error -- TS2322: Type '"space"' is not assignable to type '"div"'.
                  childNode.type = 'space';
                  childNode.value = atLeastOneSpace(childNode.after);
                  commaCount++;
                } else {
                  childNode.value = '/';
                  childNode.before = atLeastOneSpace(childNode.before);
                  childNode.after = atLeastOneSpace(childNode.after);
                }
              }

              return childNode;
            }); // Remove trailing 'a' from legacy function name

            if (LEGACY_FUNCTION_NAME.test(value)) {
              node.value = value.slice(0, -1);
            }

            needsFix = true;
            return;
          }

          const index = declarationValueIndex(decl) + sourceIndex;
          const endIndex = index + (sourceEndIndex - sourceIndex);
          report$1({
            message: messages$2O.expected,
            messageArgs: [primary],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2O
          });
        });

        if (needsFix) {
          setDeclarationValue(decl, parsedValue.toString());
        }
      });
    };
  };
  /**
   * @param {string} whitespace
   */


  function atLeastOneSpace(whitespace) {
    return whitespace !== '' ? whitespace : ' ';
  }
  /**
   * @param {import('postcss-value-parser').Node[]} nodes
   */


  function containsVariable(nodes) {
    return nodes.some(({
      type,
      value
    }) => type === 'function' && value.toLowerCase() === 'var');
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   * @returns {node is import('postcss-value-parser').DivNode}
   */


  function isComma(node) {
    return node.type === 'div' && node.value === ',';
  }
  /**
   * @param {import('postcss-value-parser').FunctionNode} node
   */


  function hasCommas(node) {
    return node.nodes && node.nodes.some(childNode => isComma(childNode));
  }

  rule$2O.ruleName = ruleName$2O;
  rule$2O.messages = messages$2O;
  rule$2O.meta = meta$2O;
  var colorFunctionNotation = rule$2O;

  const HAS_VALID_HEX = /#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})(?:$|[^\da-f])/i;
  /**
   * Check if a value contains a valid 3, 4, 6 or 8 digit hex
   *
   * @param {string} value
   * @returns {boolean}
   */

  var hasValidHex = function hasValidHex(value) {
    return HAS_VALID_HEX.test(value);
  };

  const IS_VALID_HEX = /^#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;
  /**
   * Check if a value is a valid 3, 4, 6 or 8 digit hex
   *
   * @param {string} value
   * @returns {boolean}
   */

  var isValidHex = function isValidHex(value) {
    return IS_VALID_HEX.test(value);
  };

  const ruleName$2N = 'color-hex-alpha';
  const messages$2N = ruleMessages$1(ruleName$2N, {
    expected: hex => `Expected alpha channel in "${hex}"`,
    unexpected: hex => `Unexpected alpha channel in "${hex}"`
  });
  const meta$2N = {
    url: 'https://stylelint.io/user-guide/rules/color-hex-alpha'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2N = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2N, {
        actual: primary,
        possible: ['always', 'never']
      });
      if (!validOptions) return;
      root.walkDecls(decl => {
        if (!hasValidHex(decl.value)) return;
        const parsedValue = lib$6(decl.value);
        parsedValue.walk(node => {
          if (isUrlFunction(node)) return false;
          if (!isHexColor$3(node)) return;
          const {
            value
          } = node;
          if (primary === 'always' && hasAlphaChannel(value)) return;
          if (primary === 'never' && !hasAlphaChannel(value)) return;
          const index = declarationValueIndex(decl) + node.sourceIndex;
          const endIndex = index + value.length;
          report$1({
            message: primary === 'never' ? messages$2N.unexpected : messages$2N.expected,
            messageArgs: [value],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2N
          });
        });
      });
    };
  };
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isUrlFunction({
    type,
    value
  }) {
    return type === 'function' && value === 'url';
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isHexColor$3({
    type,
    value
  }) {
    return type === 'word' && isValidHex(value);
  }
  /**
   * @param {string} hex
   */


  function hasAlphaChannel(hex) {
    return hex.length === 5 || hex.length === 9;
  }

  rule$2N.ruleName = ruleName$2N;
  rule$2N.messages = messages$2N;
  rule$2N.meta = meta$2N;
  var colorHexAlpha = rule$2N;

  const ruleName$2M = 'color-hex-case';
  const messages$2M = ruleMessages$1(ruleName$2M, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$2M = {
    url: 'https://stylelint.io/user-guide/rules/color-hex-case',
    fixable: true,
    deprecated: true
  };
  const HEX$2 = /^#[\da-z]+/i;
  const CONTAINS_HEX$3 = /#[\da-z]+/i;
  const IGNORED_FUNCTIONS$2 = new Set(['url']);
  /** @type {import('stylelint').Rule} */

  const rule$2M = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2M, {
        actual: primary,
        possible: ['lower', 'upper']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!CONTAINS_HEX$3.test(decl.value)) return;
        const parsedValue = lib$6(getDeclarationValue(decl));
        let needsFix = false;
        parsedValue.walk(node => {
          const {
            value
          } = node;
          if (isIgnoredFunction$2(node)) return false;
          if (!isHexColor$2(node)) return;
          const expected = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();
          if (value === expected) return;

          if (context.fix) {
            node.value = expected;
            needsFix = true;
            return;
          }

          report$1({
            message: messages$2M.expected(value, expected),
            node: decl,
            index: declarationValueIndex(decl) + node.sourceIndex,
            result,
            ruleName: ruleName$2M
          });
        });

        if (needsFix) {
          setDeclarationValue(decl, parsedValue.toString());
        }
      });
    };
  };
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isIgnoredFunction$2({
    type,
    value
  }) {
    return type === 'function' && IGNORED_FUNCTIONS$2.has(value.toLowerCase());
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isHexColor$2({
    type,
    value
  }) {
    return type === 'word' && HEX$2.test(value);
  }

  rule$2M.ruleName = ruleName$2M;
  rule$2M.messages = messages$2M;
  rule$2M.meta = meta$2M;
  var colorHexCase = rule$2M;

  const ruleName$2L = 'color-hex-length';
  const messages$2L = ruleMessages$1(ruleName$2L, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$2L = {
    url: 'https://stylelint.io/user-guide/rules/color-hex-length',
    fixable: true
  };
  const HEX$1 = /^#[\da-z]+$/i;
  const CONTAINS_HEX$2 = /#[\da-z]+/i;
  const IGNORED_FUNCTIONS$1 = new Set(['url']);
  /** @type {import('stylelint').Rule} */

  const rule$2L = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2L, {
        actual: primary,
        possible: ['short', 'long']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!CONTAINS_HEX$2.test(decl.value)) return;
        const parsedValue = lib$6(getDeclarationValue(decl));
        let needsFix = false;
        parsedValue.walk(node => {
          const {
            value: hexValue
          } = node;
          if (isIgnoredFunction$1(node)) return false;
          if (!isHexColor$1(node)) return;

          if (primary === 'long' && hexValue.length !== 4 && hexValue.length !== 5) {
            return;
          }

          if (primary === 'short' && (hexValue.length < 6 || !canShrink(hexValue))) {
            return;
          }

          const variant = primary === 'long' ? longer : shorter;
          const expectedHex = variant(hexValue);

          if (context.fix) {
            node.value = expectedHex;
            needsFix = true;
            return;
          }

          const index = declarationValueIndex(decl) + node.sourceIndex;
          const endIndex = index + node.value.length;
          report$1({
            message: messages$2L.expected,
            messageArgs: [hexValue, expectedHex],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2L
          });
        });

        if (needsFix) {
          setDeclarationValue(decl, parsedValue.toString());
        }
      });
    };
  };
  /**
   * @param {string} hex
   */


  function canShrink(hex) {
    hex = hex.toLowerCase();
    return hex[1] === hex[2] && hex[3] === hex[4] && hex[5] === hex[6] && (hex.length === 7 || hex.length === 9 && hex[7] === hex[8]);
  }
  /**
   * @param {string} hex
   */


  function shorter(hex) {
    let hexVariant = '#';

    for (let i = 1; i < hex.length; i += 2) {
      hexVariant += hex[i];
    }

    return hexVariant;
  }
  /**
   * @param {string} hex
   */


  function longer(hex) {
    let hexVariant = '#';

    for (let i = 1; i < hex.length; i++) {
      hexVariant += hex.charAt(i).repeat(2);
    }

    return hexVariant;
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isIgnoredFunction$1({
    type,
    value
  }) {
    return type === 'function' && IGNORED_FUNCTIONS$1.has(value.toLowerCase());
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isHexColor$1({
    type,
    value
  }) {
    return type === 'word' && HEX$1.test(value);
  }

  rule$2L.ruleName = ruleName$2L;
  rule$2L.messages = messages$2L;
  rule$2L.meta = meta$2L;
  var colorHexLength = rule$2L;

  const acceptCustomIdentsProperties$1 = new Set(['animation', 'animation-name', 'font', 'font-family', 'counter-increment', 'grid-row', 'grid-column', 'grid-area', 'list-style', 'list-style-type']);
  /** @type {import('stylelint').LonghandSubPropertiesOfShorthandProperties} */

  const longhandSubPropertiesOfShorthandProperties$3 = new Map([// Sort alphabetically
  ['animation', new Set([// prettier-ignore
  'animation-name', 'animation-duration', 'animation-timing-function', 'animation-delay', 'animation-iteration-count', 'animation-direction', 'animation-fill-mode', 'animation-play-state'])], ['background', new Set([// prettier-ignore
  'background-image', 'background-size', 'background-position', 'background-repeat', 'background-origin', 'background-clip', 'background-attachment', 'background-color'])], ['border', new Set([// prettier-ignore
  'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width', 'border-top-style', 'border-right-style', 'border-bottom-style', 'border-left-style', 'border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color'])], ['border-block-end', new Set([// prettier-ignore
  'border-block-end-width', 'border-block-end-style', 'border-block-end-color'])], ['border-block-start', new Set([// prettier-ignore
  'border-block-start-width', 'border-block-start-style', 'border-block-start-color'])], ['border-bottom', new Set([// prettier-ignore
  'border-bottom-width', 'border-bottom-style', 'border-bottom-color'])], ['border-color', new Set([// prettier-ignore
  'border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color'])], ['border-image', new Set([// prettier-ignore
  'border-image-source', 'border-image-slice', 'border-image-width', 'border-image-outset', 'border-image-repeat'])], ['border-inline-end', new Set([// prettier-ignore
  'border-inline-end-width', 'border-inline-end-style', 'border-inline-end-color'])], ['border-inline-start', new Set([// prettier-ignore
  'border-inline-start-width', 'border-inline-start-style', 'border-inline-start-color'])], ['border-left', new Set([// prettier-ignore
  'border-left-width', 'border-left-style', 'border-left-color'])], ['border-radius', new Set([// prettier-ignore
  'border-top-left-radius', 'border-top-right-radius', 'border-bottom-right-radius', 'border-bottom-left-radius'])], ['border-right', new Set([// prettier-ignore
  'border-right-width', 'border-right-style', 'border-right-color'])], ['border-style', new Set([// prettier-ignore
  'border-top-style', 'border-right-style', 'border-bottom-style', 'border-left-style'])], ['border-top', new Set([// prettier-ignore
  'border-top-width', 'border-top-style', 'border-top-color'])], ['border-width', new Set([// prettier-ignore
  'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'])], ['column-rule', new Set([// prettier-ignore
  'column-rule-width', 'column-rule-style', 'column-rule-color'])], ['columns', new Set([// prettier-ignore
  'column-width', 'column-count'])], ['flex', new Set([// prettier-ignore
  'flex-grow', 'flex-shrink', 'flex-basis'])], ['flex-flow', new Set([// prettier-ignore
  'flex-direction', 'flex-wrap'])], ['font', new Set([// prettier-ignore
  'font-style', 'font-variant', 'font-weight', 'font-stretch', 'font-size', 'line-height', 'font-family'])], ['grid', new Set([// prettier-ignore
  'grid-template-rows', 'grid-template-columns', 'grid-template-areas', 'grid-auto-rows', 'grid-auto-columns', 'grid-auto-flow', 'grid-column-gap', 'grid-row-gap'])], ['grid-area', new Set([// prettier-ignore
  'grid-row-start', 'grid-column-start', 'grid-row-end', 'grid-column-end'])], ['grid-column', new Set([// prettier-ignore
  'grid-column-start', 'grid-column-end'])], ['grid-gap', new Set([// prettier-ignore
  'grid-row-gap', 'grid-column-gap'])], ['grid-row', new Set([// prettier-ignore
  'grid-row-start', 'grid-row-end'])], ['grid-template', new Set([// prettier-ignore
  'grid-template-columns', 'grid-template-rows', 'grid-template-areas'])], ['inset', new Set([// prettier-ignore
  'top', 'right', 'bottom', 'left'])], ['list-style', new Set([// prettier-ignore
  'list-style-type', 'list-style-position', 'list-style-image'])], ['margin', new Set([// prettier-ignore
  'margin-top', 'margin-right', 'margin-bottom', 'margin-left'])], ['mask', new Set([// prettier-ignore
  'mask-image', 'mask-mode', 'mask-position', 'mask-size', 'mask-repeat', 'mask-origin', 'mask-clip', 'mask-composite'])], ['outline', new Set([// prettier-ignore
  'outline-color', 'outline-style', 'outline-width'])], ['padding', new Set([// prettier-ignore
  'padding-top', 'padding-right', 'padding-bottom', 'padding-left'])], ['text-decoration', new Set([// prettier-ignore
  'text-decoration-line', 'text-decoration-style', 'text-decoration-color' // TODO: add support for text-decoration-thickness, Level 4
  // https://w3c.github.io/csswg-drafts/css-text-decor-4/#text-decoration-width-property
  ])], ['text-emphasis', new Set([// prettier-ignore
  'text-emphasis-style', 'text-emphasis-color'])], ['transition', new Set([// prettier-ignore
  'transition-property', 'transition-duration', 'transition-timing-function', 'transition-delay'])]]);
  const longhandTimeProperties$1 = new Set(['transition-duration', 'transition-delay', 'animation-duration', 'animation-delay']);
  const shorthandTimeProperties$1 = new Set(['transition', 'animation']);
  var properties$4 = {
    acceptCustomIdentsProperties: acceptCustomIdentsProperties$1,
    longhandSubPropertiesOfShorthandProperties: longhandSubPropertiesOfShorthandProperties$3,
    longhandTimeProperties: longhandTimeProperties$1,
    shorthandTimeProperties: shorthandTimeProperties$1
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  function createCommonjsModule(fn) {
    var module = { exports: {} };
  	return fn(module, module.exports), module.exports;
  }

  function commonjsRequire (path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var colord$2 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });

  var r = {
    grad: .9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  },
      t = function (r) {
    return "string" == typeof r ? r.length > 0 : "number" == typeof r;
  },
      n = function (r, t, n) {
    return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * r) / n + 0;
  },
      e = function (r, t, n) {
    return void 0 === t && (t = 0), void 0 === n && (n = 1), r > n ? n : r > t ? r : t;
  },
      u = function (r) {
    return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;
  },
      o = function (r) {
    return {
      r: e(r.r, 0, 255),
      g: e(r.g, 0, 255),
      b: e(r.b, 0, 255),
      a: e(r.a)
    };
  },
      a = function (r) {
    return {
      r: n(r.r),
      g: n(r.g),
      b: n(r.b),
      a: n(r.a, 3)
    };
  },
      s = /^#([0-9a-f]{3,8})$/i,
      i = function (r) {
    var t = r.toString(16);
    return t.length < 2 ? "0" + t : t;
  },
      h = function (r) {
    var t = r.r,
        n = r.g,
        e = r.b,
        u = r.a,
        o = Math.max(t, n, e),
        a = o - Math.min(t, n, e),
        s = a ? o === t ? (n - e) / a : o === n ? 2 + (e - t) / a : 4 + (t - n) / a : 0;
    return {
      h: 60 * (s < 0 ? s + 6 : s),
      s: o ? a / o * 100 : 0,
      v: o / 255 * 100,
      a: u
    };
  },
      b = function (r) {
    var t = r.h,
        n = r.s,
        e = r.v,
        u = r.a;
    t = t / 360 * 6, n /= 100, e /= 100;
    var o = Math.floor(t),
        a = e * (1 - n),
        s = e * (1 - (t - o) * n),
        i = e * (1 - (1 - t + o) * n),
        h = o % 6;
    return {
      r: 255 * [e, s, a, a, i, e][h],
      g: 255 * [i, e, e, s, a, a][h],
      b: 255 * [a, a, i, e, e, s][h],
      a: u
    };
  },
      d = function (r) {
    return {
      h: u(r.h),
      s: e(r.s, 0, 100),
      l: e(r.l, 0, 100),
      a: e(r.a)
    };
  },
      g = function (r) {
    return {
      h: n(r.h),
      s: n(r.s),
      l: n(r.l),
      a: n(r.a, 3)
    };
  },
      f = function (r) {
    return b((n = (t = r).s, {
      h: t.h,
      s: (n *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * n / (e + n) * 100 : 0,
      v: e + n,
      a: t.a
    }));
    var t, n, e;
  },
      p = function (r) {
    return {
      h: (t = h(r)).h,
      s: (u = (200 - (n = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? n * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0,
      l: u / 2,
      a: t.a
    };
    var t, n, e, u;
  },
      l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      c = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      y = {
    string: [[function (r) {
      var t = s.exec(r);
      return t ? (r = t[1]).length <= 4 ? {
        r: parseInt(r[0] + r[0], 16),
        g: parseInt(r[1] + r[1], 16),
        b: parseInt(r[2] + r[2], 16),
        a: 4 === r.length ? n(parseInt(r[3] + r[3], 16) / 255, 2) : 1
      } : 6 === r.length || 8 === r.length ? {
        r: parseInt(r.substr(0, 2), 16),
        g: parseInt(r.substr(2, 2), 16),
        b: parseInt(r.substr(4, 2), 16),
        a: 8 === r.length ? n(parseInt(r.substr(6, 2), 16) / 255, 2) : 1
      } : null : null;
    }, "hex"], [function (r) {
      var t = v.exec(r) || m.exec(r);
      return t ? t[2] !== t[4] || t[4] !== t[6] ? null : o({
        r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
        g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
        b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
        a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
      }) : null;
    }, "rgb"], [function (t) {
      var n = l.exec(t) || c.exec(t);
      if (!n) return null;
      var e,
          u,
          o = d({
        h: (e = n[1], u = n[2], void 0 === u && (u = "deg"), Number(e) * (r[u] || 1)),
        s: Number(n[3]),
        l: Number(n[4]),
        a: void 0 === n[5] ? 1 : Number(n[5]) / (n[6] ? 100 : 1)
      });
      return f(o);
    }, "hsl"]],
    object: [[function (r) {
      var n = r.r,
          e = r.g,
          u = r.b,
          a = r.a,
          s = void 0 === a ? 1 : a;
      return t(n) && t(e) && t(u) ? o({
        r: Number(n),
        g: Number(e),
        b: Number(u),
        a: Number(s)
      }) : null;
    }, "rgb"], [function (r) {
      var n = r.h,
          e = r.s,
          u = r.l,
          o = r.a,
          a = void 0 === o ? 1 : o;
      if (!t(n) || !t(e) || !t(u)) return null;
      var s = d({
        h: Number(n),
        s: Number(e),
        l: Number(u),
        a: Number(a)
      });
      return f(s);
    }, "hsl"], [function (r) {
      var n = r.h,
          o = r.s,
          a = r.v,
          s = r.a,
          i = void 0 === s ? 1 : s;
      if (!t(n) || !t(o) || !t(a)) return null;

      var h = function (r) {
        return {
          h: u(r.h),
          s: e(r.s, 0, 100),
          v: e(r.v, 0, 100),
          a: e(r.a)
        };
      }({
        h: Number(n),
        s: Number(o),
        v: Number(a),
        a: Number(i)
      });

      return b(h);
    }, "hsv"]]
  },
      N = function (r, t) {
    for (var n = 0; n < t.length; n++) {
      var e = t[n][0](r);
      if (e) return [e, t[n][1]];
    }

    return [null, void 0];
  },
      x = function (r) {
    return "string" == typeof r ? N(r.trim(), y.string) : "object" == typeof r && null !== r ? N(r, y.object) : [null, void 0];
  },
      M = function (r, t) {
    var n = p(r);
    return {
      h: n.h,
      s: e(n.s + 100 * t, 0, 100),
      l: n.l,
      a: n.a
    };
  },
      I = function (r) {
    return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;
  },
      H = function (r, t) {
    var n = p(r);
    return {
      h: n.h,
      s: n.s,
      l: e(n.l + 100 * t, 0, 100),
      a: n.a
    };
  },
      $ = function () {
    function r(r) {
      this.parsed = x(r)[0], this.rgba = this.parsed || {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      };
    }

    return r.prototype.isValid = function () {
      return null !== this.parsed;
    }, r.prototype.brightness = function () {
      return n(I(this.rgba), 2);
    }, r.prototype.isDark = function () {
      return I(this.rgba) < .5;
    }, r.prototype.isLight = function () {
      return I(this.rgba) >= .5;
    }, r.prototype.toHex = function () {
      return r = a(this.rgba), t = r.r, e = r.g, u = r.b, s = (o = r.a) < 1 ? i(n(255 * o)) : "", "#" + i(t) + i(e) + i(u) + s;
      var r, t, e, u, o, s;
    }, r.prototype.toRgb = function () {
      return a(this.rgba);
    }, r.prototype.toRgbString = function () {
      return r = a(this.rgba), t = r.r, n = r.g, e = r.b, (u = r.a) < 1 ? "rgba(" + t + ", " + n + ", " + e + ", " + u + ")" : "rgb(" + t + ", " + n + ", " + e + ")";
      var r, t, n, e, u;
    }, r.prototype.toHsl = function () {
      return g(p(this.rgba));
    }, r.prototype.toHslString = function () {
      return r = g(p(this.rgba)), t = r.h, n = r.s, e = r.l, (u = r.a) < 1 ? "hsla(" + t + ", " + n + "%, " + e + "%, " + u + ")" : "hsl(" + t + ", " + n + "%, " + e + "%)";
      var r, t, n, e, u;
    }, r.prototype.toHsv = function () {
      return r = h(this.rgba), {
        h: n(r.h),
        s: n(r.s),
        v: n(r.v),
        a: n(r.a, 3)
      };
      var r;
    }, r.prototype.invert = function () {
      return j({
        r: 255 - (r = this.rgba).r,
        g: 255 - r.g,
        b: 255 - r.b,
        a: r.a
      });
      var r;
    }, r.prototype.saturate = function (r) {
      return void 0 === r && (r = .1), j(M(this.rgba, r));
    }, r.prototype.desaturate = function (r) {
      return void 0 === r && (r = .1), j(M(this.rgba, -r));
    }, r.prototype.grayscale = function () {
      return j(M(this.rgba, -1));
    }, r.prototype.lighten = function (r) {
      return void 0 === r && (r = .1), j(H(this.rgba, r));
    }, r.prototype.darken = function (r) {
      return void 0 === r && (r = .1), j(H(this.rgba, -r));
    }, r.prototype.rotate = function (r) {
      return void 0 === r && (r = 15), this.hue(this.hue() + r);
    }, r.prototype.alpha = function (r) {
      return "number" == typeof r ? j({
        r: (t = this.rgba).r,
        g: t.g,
        b: t.b,
        a: r
      }) : n(this.rgba.a, 3);
      var t;
    }, r.prototype.hue = function (r) {
      var t = p(this.rgba);
      return "number" == typeof r ? j({
        h: r,
        s: t.s,
        l: t.l,
        a: t.a
      }) : n(t.h);
    }, r.prototype.isEqual = function (r) {
      return this.toHex() === j(r).toHex();
    }, r;
  }(),
      j = function (r) {
    return r instanceof $ ? r : new $(r);
  },
      w = [];

  exports.Colord = $, exports.colord = j, exports.extend = function (r) {
    r.forEach(function (r) {
      w.indexOf(r) < 0 && (r($, y), w.push(r));
    });
  }, exports.getFormat = function (r) {
    return x(r)[1];
  }, exports.random = function () {
    return new $({
      r: 255 * Math.random(),
      g: 255 * Math.random(),
      b: 255 * Math.random()
    });
  };
  });

  var names$2 = function (e, f) {
    var a = {
      white: "#ffffff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000"
    },
        r = {};

    for (var d in a) r[a[d]] = d;

    var l = {};

    e.prototype.toName = function (f) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var d,
          i,
          o = r[this.toHex()];
      if (o) return o;

      if (null == f ? void 0 : f.closest) {
        var n = this.toRgb(),
            t = 1 / 0,
            b = "black";
        if (!l.length) for (var c in a) l[c] = new e(a[c]).toRgb();

        for (var g in a) {
          var u = (d = n, i = l[g], Math.pow(d.r - i.r, 2) + Math.pow(d.g - i.g, 2) + Math.pow(d.b - i.b, 2));
          u < t && (t = u, b = g);
        }

        return b;
      }
    };

    f.string.push([function (f) {
      var r = f.toLowerCase(),
          d = "transparent" === r ? "#0000" : a[r];
      return d ? new e(d).toRgb() : null;
    }, "name"]);
  };

  var r$4 = {
    grad: .9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  },
      n$5 = function (r) {
    return "string" == typeof r ? r.length > 0 : "number" == typeof r;
  },
      t$4 = function (r, n, t) {
    return void 0 === n && (n = 0), void 0 === t && (t = Math.pow(10, n)), Math.round(t * r) / t + 0;
  },
      u$4 = function (r, n, t) {
    return void 0 === n && (n = 0), void 0 === t && (t = 1), r > t ? t : r > n ? r : n;
  },
      a$4 = function (r) {
    return {
      h: (n = r.h, (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360),
      w: u$4(r.w, 0, 100),
      b: u$4(r.b, 0, 100),
      a: u$4(r.a)
    };
    var n;
  },
      e$5 = function (r) {
    return {
      h: t$4(r.h),
      w: t$4(r.w),
      b: t$4(r.b),
      a: t$4(r.a, 3)
    };
  },
      o$4 = function (r) {
    return {
      h: function (r) {
        var n = r.r,
            t = r.g,
            u = r.b,
            a = r.a,
            e = Math.max(n, t, u),
            o = e - Math.min(n, t, u),
            b = o ? e === n ? (t - u) / o : e === t ? 2 + (u - n) / o : 4 + (n - t) / o : 0;
        return {
          h: 60 * (b < 0 ? b + 6 : b),
          s: e ? o / e * 100 : 0,
          v: e / 255 * 100,
          a: a
        };
      }(r).h,
      w: Math.min(r.r, r.g, r.b) / 255 * 100,
      b: 100 - Math.max(r.r, r.g, r.b) / 255 * 100,
      a: r.a
    };
  },
      b$3 = function (r) {
    return function (r) {
      var n = r.h,
          t = r.s,
          u = r.v,
          a = r.a;
      n = n / 360 * 6, t /= 100, u /= 100;
      var e = Math.floor(n),
          o = u * (1 - t),
          b = u * (1 - (n - e) * t),
          i = u * (1 - (1 - n + e) * t),
          h = e % 6;
      return {
        r: 255 * [u, b, o, o, i, u][h],
        g: 255 * [i, u, u, b, o, o][h],
        b: 255 * [o, o, i, u, u, b][h],
        a: a
      };
    }({
      h: r.h,
      s: 100 === r.b ? 0 : 100 - r.w / (100 - r.b) * 100,
      v: 100 - r.b,
      a: r.a
    });
  },
      i$5 = function (r) {
    var t = r.h,
        u = r.w,
        e = r.b,
        o = r.a,
        i = void 0 === o ? 1 : o;
    if (!n$5(t) || !n$5(u) || !n$5(e)) return null;
    var h = a$4({
      h: Number(t),
      w: Number(u),
      b: Number(e),
      a: Number(i)
    });
    return b$3(h);
  },
      h$4 = /^hwb\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      d$4 = function (n) {
    var t = h$4.exec(n);
    if (!t) return null;
    var u,
        e,
        o = a$4({
      h: (u = t[1], e = t[2], void 0 === e && (e = "deg"), Number(u) * (r$4[e] || 1)),
      w: Number(t[3]),
      b: Number(t[4]),
      a: void 0 === t[5] ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
    });
    return b$3(o);
  };

  var hwb = function (r, n) {
    r.prototype.toHwb = function () {
      return e$5(o$4(this.rgba));
    }, r.prototype.toHwbString = function () {
      return r = e$5(o$4(this.rgba)), n = r.h, t = r.w, u = r.b, (a = r.a) < 1 ? "hwb(" + n + " " + t + "% " + u + "% / " + a + ")" : "hwb(" + n + " " + t + "% " + u + "%)";
      var r, n, t, u, a;
    }, n.string.push([d$4, "hwb"]), n.object.push([i$5, "hwb"]);
  };

  var a$3 = function (a) {
    return "string" == typeof a ? a.length > 0 : "number" == typeof a;
  },
      t$3 = function (a, t, o) {
    return void 0 === t && (t = 0), void 0 === o && (o = Math.pow(10, t)), Math.round(o * a) / o + 0;
  },
      o$3 = function (a, t, o) {
    return void 0 === t && (t = 0), void 0 === o && (o = 1), a > o ? o : a > t ? a : t;
  },
      r$3 = function (a) {
    var t = a / 255;
    return t < .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
  },
      h$3 = function (a) {
    return 255 * (a > .0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : 12.92 * a);
  },
      n$4 = 96.422,
      p$2 = 100,
      M$2 = 82.521,
      u$3 = function (a) {
    var t,
        r,
        n = {
      x: .9555766 * (t = a).x + -.0230393 * t.y + .0631636 * t.z,
      y: -.0282895 * t.x + 1.0099416 * t.y + .0210077 * t.z,
      z: .0122982 * t.x + -.020483 * t.y + 1.3299098 * t.z
    };
    return r = {
      r: h$3(.032404542 * n.x - .015371385 * n.y - .004985314 * n.z),
      g: h$3(-.00969266 * n.x + .018760108 * n.y + 41556e-8 * n.z),
      b: h$3(556434e-9 * n.x - .002040259 * n.y + .010572252 * n.z),
      a: a.a
    }, {
      r: o$3(r.r, 0, 255),
      g: o$3(r.g, 0, 255),
      b: o$3(r.b, 0, 255),
      a: o$3(r.a)
    };
  },
      e$4 = function (a) {
    var t = r$3(a.r),
        h = r$3(a.g),
        u = r$3(a.b);
    return function (a) {
      return {
        x: o$3(a.x, 0, n$4),
        y: o$3(a.y, 0, p$2),
        z: o$3(a.z, 0, M$2),
        a: o$3(a.a)
      };
    }(function (a) {
      return {
        x: 1.0478112 * a.x + .0228866 * a.y + -.050127 * a.z,
        y: .0295424 * a.x + .9904844 * a.y + -.0170491 * a.z,
        z: -.0092345 * a.x + .0150436 * a.y + .7521316 * a.z,
        a: a.a
      };
    }({
      x: 100 * (.4124564 * t + .3575761 * h + .1804375 * u),
      y: 100 * (.2126729 * t + .7151522 * h + .072175 * u),
      z: 100 * (.0193339 * t + .119192 * h + .9503041 * u),
      a: a.a
    }));
  },
      w$2 = 216 / 24389,
      b$2 = 24389 / 27,
      i$4 = function (t) {
    var r = t.l,
        h = t.a,
        n = t.b,
        p = t.alpha,
        M = void 0 === p ? 1 : p;
    if (!a$3(r) || !a$3(h) || !a$3(n)) return null;

    var u = function (a) {
      return {
        l: o$3(a.l, 0, 400),
        a: a.a,
        b: a.b,
        alpha: o$3(a.alpha)
      };
    }({
      l: Number(r),
      a: Number(h),
      b: Number(n),
      alpha: Number(M)
    });

    return l$2(u);
  },
      l$2 = function (a) {
    var t = (a.l + 16) / 116,
        o = a.a / 500 + t,
        r = t - a.b / 200;
    return u$3({
      x: (Math.pow(o, 3) > w$2 ? Math.pow(o, 3) : (116 * o - 16) / b$2) * n$4,
      y: (a.l > 8 ? Math.pow((a.l + 16) / 116, 3) : a.l / b$2) * p$2,
      z: (Math.pow(r, 3) > w$2 ? Math.pow(r, 3) : (116 * r - 16) / b$2) * M$2,
      a: a.alpha
    });
  };

  var lab = function (a, r) {
    a.prototype.toLab = function () {
      return o = e$4(this.rgba), h = o.y / p$2, u = o.z / M$2, r = (r = o.x / n$4) > w$2 ? Math.cbrt(r) : (b$2 * r + 16) / 116, a = {
        l: 116 * (h = h > w$2 ? Math.cbrt(h) : (b$2 * h + 16) / 116) - 16,
        a: 500 * (r - h),
        b: 200 * (h - (u = u > w$2 ? Math.cbrt(u) : (b$2 * u + 16) / 116)),
        alpha: o.a
      }, {
        l: t$3(a.l, 2),
        a: t$3(a.a, 2),
        b: t$3(a.b, 2),
        alpha: t$3(a.alpha, 3)
      };
      var a, o, r, h, u;
    }, a.prototype.delta = function (r) {
      void 0 === r && (r = "#FFF");

      var h = r instanceof a ? r : new a(r),
          n = function (a, t) {
        var o = a.l,
            r = a.a,
            h = a.b,
            n = t.l,
            p = t.a,
            M = t.b,
            u = 180 / Math.PI,
            e = Math.PI / 180,
            w = Math.pow(Math.pow(r, 2) + Math.pow(h, 2), .5),
            b = Math.pow(Math.pow(p, 2) + Math.pow(M, 2), .5),
            i = (o + n) / 2,
            l = Math.pow((w + b) / 2, 7),
            c = .5 * (1 - Math.pow(l / (l + Math.pow(25, 7)), .5)),
            f = r * (1 + c),
            y = p * (1 + c),
            v = Math.pow(Math.pow(f, 2) + Math.pow(h, 2), .5),
            x = Math.pow(Math.pow(y, 2) + Math.pow(M, 2), .5),
            z = (v + x) / 2,
            s = 0 === f && 0 === h ? 0 : Math.atan2(h, f) * u,
            d = 0 === y && 0 === M ? 0 : Math.atan2(M, y) * u;
        s < 0 && (s += 360), d < 0 && (d += 360);
        var g = d - s,
            m = Math.abs(d - s);
        m > 180 && d <= s ? g += 360 : m > 180 && d > s && (g -= 360);
        var N = s + d;
        m <= 180 ? N /= 2 : N = (s + d < 360 ? N + 360 : N - 360) / 2;
        var F = 1 - .17 * Math.cos(e * (N - 30)) + .24 * Math.cos(2 * e * N) + .32 * Math.cos(e * (3 * N + 6)) - .2 * Math.cos(e * (4 * N - 63)),
            L = n - o,
            I = x - v,
            P = 2 * Math.sin(e * g / 2) * Math.pow(v * x, .5),
            j = 1 + .015 * Math.pow(i - 50, 2) / Math.pow(20 + Math.pow(i - 50, 2), .5),
            k = 1 + .045 * z,
            q = 1 + .015 * z * F,
            A = 30 * Math.exp(-1 * Math.pow((N - 275) / 25, 2)),
            B = -2 * Math.pow(l / (l + Math.pow(25, 7)), .5) * Math.sin(2 * e * A);
        return Math.pow(Math.pow(L / 1 / j, 2) + Math.pow(I / 1 / k, 2) + Math.pow(P / 1 / q, 2) + B * I * P / (1 * k * 1 * q), .5);
      }(this.toLab(), h.toLab()) / 100;

      return o$3(t$3(n, 3));
    }, r.object.push([i$4, "lab"]);
  };

  var r$2 = {
    grad: .9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  },
      t$2 = function (r) {
    return "string" == typeof r ? r.length > 0 : "number" == typeof r;
  },
      a$2 = function (r, t, a) {
    return void 0 === t && (t = 0), void 0 === a && (a = Math.pow(10, t)), Math.round(a * r) / a + 0;
  },
      n$3 = function (r, t, a) {
    return void 0 === t && (t = 0), void 0 === a && (a = 1), r > a ? a : r > t ? r : t;
  },
      u$2 = function (r) {
    var t = r / 255;
    return t < .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
  },
      h$2 = function (r) {
    return 255 * (r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r);
  },
      o$2 = 96.422,
      e$3 = 100,
      c$1 = 82.521,
      i$3 = function (r) {
    var t,
        a,
        u = {
      x: .9555766 * (t = r).x + -.0230393 * t.y + .0631636 * t.z,
      y: -.0282895 * t.x + 1.0099416 * t.y + .0210077 * t.z,
      z: .0122982 * t.x + -.020483 * t.y + 1.3299098 * t.z
    };
    return a = {
      r: h$2(.032404542 * u.x - .015371385 * u.y - .004985314 * u.z),
      g: h$2(-.00969266 * u.x + .018760108 * u.y + 41556e-8 * u.z),
      b: h$2(556434e-9 * u.x - .002040259 * u.y + .010572252 * u.z),
      a: r.a
    }, {
      r: n$3(a.r, 0, 255),
      g: n$3(a.g, 0, 255),
      b: n$3(a.b, 0, 255),
      a: n$3(a.a)
    };
  },
      l$1 = function (r) {
    var t = u$2(r.r),
        a = u$2(r.g),
        h = u$2(r.b);
    return function (r) {
      return {
        x: n$3(r.x, 0, o$2),
        y: n$3(r.y, 0, e$3),
        z: n$3(r.z, 0, c$1),
        a: n$3(r.a)
      };
    }(function (r) {
      return {
        x: 1.0478112 * r.x + .0228866 * r.y + -.050127 * r.z,
        y: .0295424 * r.x + .9904844 * r.y + -.0170491 * r.z,
        z: -.0092345 * r.x + .0150436 * r.y + .7521316 * r.z,
        a: r.a
      };
    }({
      x: 100 * (.4124564 * t + .3575761 * a + .1804375 * h),
      y: 100 * (.2126729 * t + .7151522 * a + .072175 * h),
      z: 100 * (.0193339 * t + .119192 * a + .9503041 * h),
      a: r.a
    }));
  },
      b$1 = 216 / 24389,
      d$3 = 24389 / 27,
      f$1 = function (r) {
    return {
      l: n$3(r.l, 0, 100),
      c: r.c,
      h: (t = r.h, (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360),
      a: r.a
    };
    var t;
  },
      p$1 = function (r) {
    return {
      l: a$2(r.l, 2),
      c: a$2(r.c, 2),
      h: a$2(r.h, 2),
      a: a$2(r.a, 3)
    };
  },
      v$1 = function (r) {
    var a = r.l,
        n = r.c,
        u = r.h,
        h = r.a,
        o = void 0 === h ? 1 : h;
    if (!t$2(a) || !t$2(n) || !t$2(u)) return null;
    var e = f$1({
      l: Number(a),
      c: Number(n),
      h: Number(u),
      a: Number(o)
    });
    return M$1(e);
  },
      y$2 = function (r) {
    var t = function (r) {
      var t = l$1(r),
          a = t.x / o$2,
          n = t.y / e$3,
          u = t.z / c$1;
      return a = a > b$1 ? Math.cbrt(a) : (d$3 * a + 16) / 116, {
        l: 116 * (n = n > b$1 ? Math.cbrt(n) : (d$3 * n + 16) / 116) - 16,
        a: 500 * (a - n),
        b: 200 * (n - (u = u > b$1 ? Math.cbrt(u) : (d$3 * u + 16) / 116)),
        alpha: t.a
      };
    }(r),
        n = a$2(t.a, 3),
        u = a$2(t.b, 3),
        h = Math.atan2(u, n) / Math.PI * 180;

    return {
      l: t.l,
      c: Math.sqrt(n * n + u * u),
      h: h < 0 ? h + 360 : h,
      a: t.alpha
    };
  },
      M$1 = function (r) {
    return t = {
      l: r.l,
      a: r.c * Math.cos(r.h * Math.PI / 180),
      b: r.c * Math.sin(r.h * Math.PI / 180),
      alpha: r.a
    }, n = t.a / 500 + (a = (t.l + 16) / 116), u = a - t.b / 200, i$3({
      x: (Math.pow(n, 3) > b$1 ? Math.pow(n, 3) : (116 * n - 16) / d$3) * o$2,
      y: (t.l > 8 ? Math.pow((t.l + 16) / 116, 3) : t.l / d$3) * e$3,
      z: (Math.pow(u, 3) > b$1 ? Math.pow(u, 3) : (116 * u - 16) / d$3) * c$1,
      a: t.alpha
    });
    var t, a, n, u;
  },
      x$1 = /^lch\(\s*([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      s$3 = function (t) {
    var a = x$1.exec(t);
    if (!a) return null;
    var n,
        u,
        h = f$1({
      l: Number(a[1]),
      c: Number(a[2]),
      h: (n = a[3], u = a[4], void 0 === u && (u = "deg"), Number(n) * (r$2[u] || 1)),
      a: void 0 === a[5] ? 1 : Number(a[5]) / (a[6] ? 100 : 1)
    });
    return M$1(h);
  };

  var lch = function (r, t) {
    r.prototype.toLch = function () {
      return p$1(y$2(this.rgba));
    }, r.prototype.toLchString = function () {
      return r = p$1(y$2(this.rgba)), t = r.l, a = r.c, n = r.h, (u = r.a) < 1 ? "lch(" + t + "% " + a + " " + n + " / " + u + ")" : "lch(" + t + "% " + a + " " + n + ")";
      var r, t, a, n, u;
    }, t.string.push([s$3, "lch"]), t.object.push([v$1, "lch"]);
  };

  const {
    colord: colord$1,
    extend: extend$2
  } = colord$2;











  extend$2([// Type definitions are not compatible with commonjs.

  /** @type {any} */
  names$2,
  /** @type {any} */
  hwb,
  /** @type {any} */
  lab,
  /** @type {any} */
  lch,
  /* Syntaxes that is removed in Color Module Level 4 specification. */
  // hwb() with comma
  (_colordClass, parsers) => {
    parsers.string.push([parseHwbWithCommaString,
    /** @type {any} */
    'hwb-with-comma']);
  }, // gray()
  (_colordClass, parsers) => {
    parsers.string.push([parseGrayString,
    /** @type {any} */
    'gray']);
  }]);
  var colordUtils = {
    colord: colord$1
  };
  /**
   * Parses a valid hwb with comma CSS color function
   * https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb()#syntax
   * @type {import('colord/types').ParseFunction<string>}
   */

  function parseHwbWithCommaString(input) {
    input = input.toLowerCase();

    if (!input.startsWith('hwb(') || !input.endsWith(')') || input.includes('/')) {
      return null;
    }

    const [hue, whiteness = '', blackness = '', alpha, ...extraArgs] = input.slice(4, -1).split(',');

    if (!hue || !hue.trim() || !whiteness.trim() || !blackness.trim() || extraArgs.length > 0) {
      return null;
    } // Change the delimiter and parse with colord.


    const colordInstance = colord$1(`hwb(${hue} ${whiteness} ${blackness}${alpha ? ` / ${alpha}` : ''})`);

    if (!colordInstance.isValid()) {
      return null;
    }

    return colordInstance.rgba;
  }
  /**
   * Parses a valid gray() CSS color function
   * @type {import('colord/types').ParseFunction<string>}
   */


  function parseGrayString(input) {
    input = input.toLowerCase();

    if (!input.startsWith('gray(') || !input.endsWith(')')) {
      return null;
    }

    const [lightness, alpha, ...extraArgs] = input.slice(5, -1).split(',');

    if (!lightness || extraArgs.length > 0) {
      return null;
    }

    const lightnessWithUnit = lib$6.unit(lightness.trim());

    if (!lightnessWithUnit || !['', '%'].includes(lightnessWithUnit.unit)) {
      return null;
    }
    /**
     * @type {import('colord/types').LabColor | import('colord/types').LabaColor}
     */


    let colorObject = {
      l: Number(lightnessWithUnit.number),
      a: 0,
      b: 0
    };

    if (alpha) {
      const alphaWithUnit = lib$6.unit(alpha.trim());

      if (!alphaWithUnit || !['', '%'].includes(alphaWithUnit.unit)) {
        return null;
      }

      colorObject = { ...colorObject,
        alpha: Number(alphaWithUnit.number) / (alphaWithUnit.unit ? 100 : 1)
      };
    }

    return colord$1(colorObject).rgba;
  }

  const basicKeywords$3 = new Set(['initial', 'inherit', 'revert', 'revert-layer', 'unset']);
  const systemFontKeywords$1 = uniteSets(basicKeywords$3, ['caption', 'icon', 'menu', 'message-box', 'small-caption', 'status-bar']);
  const fontFamilyKeywords$5 = uniteSets(basicKeywords$3, ['serif', 'sans-serif', 'cursive', 'fantasy', 'monospace', 'system-ui', 'ui-serif', 'ui-sans-serif', 'ui-monospace', 'ui-rounded']);
  const fontWeightRelativeKeywords$1 = new Set(['bolder', 'lighter']);
  const fontWeightAbsoluteKeywords = new Set(['normal', 'bold']);
  const fontWeightNonNumericKeywords$1 = uniteSets(fontWeightRelativeKeywords$1, fontWeightAbsoluteKeywords);
  const fontWeightNumericKeywords = new Set(['100', '200', '300', '400', '500', '600', '700', '800', '900']);
  const fontWeightKeywords = uniteSets(basicKeywords$3, fontWeightNonNumericKeywords$1, fontWeightNumericKeywords);
  const fontStyleKeywords = uniteSets(basicKeywords$3, ['normal', 'italic', 'oblique']);
  const fontVariantKeywords = uniteSets(basicKeywords$3, ['normal', 'none', 'historical-forms', 'none', 'common-ligatures', 'no-common-ligatures', 'discretionary-ligatures', 'no-discretionary-ligatures', 'historical-ligatures', 'no-historical-ligatures', 'contextual', 'no-contextual', 'small-caps', 'small-caps', 'all-small-caps', 'petite-caps', 'all-petite-caps', 'unicase', 'titling-caps', 'lining-nums', 'oldstyle-nums', 'proportional-nums', 'tabular-nums', 'diagonal-fractions', 'stacked-fractions', 'ordinal', 'slashed-zero', 'jis78', 'jis83', 'jis90', 'jis04', 'simplified', 'traditional', 'full-width', 'proportional-width', 'ruby']);
  const fontStretchKeywords = uniteSets(basicKeywords$3, ['semi-condensed', 'condensed', 'extra-condensed', 'ultra-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded']);
  const fontSizeKeywords$1 = uniteSets(basicKeywords$3, ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'larger', 'smaller']);
  const lineHeightKeywords = uniteSets(basicKeywords$3, ['normal']);
  const fontShorthandKeywords$2 = uniteSets(basicKeywords$3, fontStyleKeywords, fontVariantKeywords, fontWeightKeywords, fontStretchKeywords, fontSizeKeywords$1, lineHeightKeywords, fontFamilyKeywords$5);
  const animationNameKeywords$2 = uniteSets(basicKeywords$3, ['none']);
  const animationTimingFunctionKeywords = uniteSets(basicKeywords$3, ['linear', 'ease', 'ease-in', 'ease-in-out', 'ease-out', 'step-start', 'step-end', 'steps', 'cubic-bezier']);
  const animationIterationCountKeywords = new Set(['infinite']);
  const animationDirectionKeywords = uniteSets(basicKeywords$3, ['normal', 'reverse', 'alternate', 'alternate-reverse']);
  const animationFillModeKeywords = new Set(['none', 'forwards', 'backwards', 'both']);
  const animationPlayStateKeywords = uniteSets(basicKeywords$3, ['running', 'paused']); // cf. https://developer.mozilla.org/en-US/docs/Web/CSS/animation

  const animationShorthandKeywords$2 = uniteSets(basicKeywords$3, animationNameKeywords$2, animationTimingFunctionKeywords, animationIterationCountKeywords, animationDirectionKeywords, animationFillModeKeywords, animationPlayStateKeywords);
  const gridRowKeywords$1 = uniteSets(basicKeywords$3, ['auto', 'span']);
  const gridColumnKeywords$1 = uniteSets(basicKeywords$3, ['auto', 'span']);
  const gridAreaKeywords$1 = uniteSets(basicKeywords$3, ['auto', 'span']); // https://developer.mozilla.org/docs/Web/CSS/counter-increment

  const counterIncrementKeywords$1 = uniteSets(basicKeywords$3, ['none']);
  const counterResetKeywords$1 = uniteSets(basicKeywords$3, ['none']); // https://developer.mozilla.org/ru/docs/Web/CSS/list-style-type

  const listStyleTypeKeywords$1 = uniteSets(basicKeywords$3, ['none', 'disc', 'circle', 'square', 'decimal', 'cjk-decimal', 'decimal-leading-zero', 'lower-roman', 'upper-roman', 'lower-greek', 'lower-alpha', 'lower-latin', 'upper-alpha', 'upper-latin', 'arabic-indic', 'armenian', 'bengali', 'cambodian', 'cjk-earthly-branch', 'cjk-ideographic', 'devanagari', 'ethiopic-numeric', 'georgian', 'gujarati', 'gurmukhi', 'hebrew', 'hiragana', 'hiragana-iroha', 'japanese-formal', 'japanese-informal', 'kannada', 'katakana', 'katakana-iroha', 'khmer', 'korean-hangul-formal', 'korean-hanja-formal', 'korean-hanja-informal', 'lao', 'lower-armenian', 'malayalam', 'mongolian', 'myanmar', 'oriya', 'persian', 'simp-chinese-formal', 'simp-chinese-informal', 'tamil', 'telugu', 'thai', 'tibetan', 'trad-chinese-formal', 'trad-chinese-informal', 'upper-armenian', 'disclosure-open', 'disclosure-closed', // Non-standard extensions (without prefixe)
  'ethiopic-halehame', 'ethiopic-halehame-am', 'ethiopic-halehame-ti-er', 'ethiopic-halehame-ti-et', 'hangul', 'hangul-consonant', 'urdu']);
  const listStylePositionKeywords = uniteSets(basicKeywords$3, ['inside', 'outside']);
  const listStyleImageKeywords = uniteSets(basicKeywords$3, ['none']);
  const listStyleShorthandKeywords$1 = uniteSets(basicKeywords$3, listStyleTypeKeywords$1, listStylePositionKeywords, listStyleImageKeywords);
  const camelCaseKeywords$1 = new Set(['optimizeSpeed', 'optimizeQuality', 'optimizeLegibility', 'geometricPrecision', 'currentColor', 'crispEdges', 'visiblePainted', 'visibleFill', 'visibleStroke', 'sRGB', 'linearRGB']);
  const keyframeSelectorKeywords$1 = new Set(['from', 'to']);
  const systemColorsKeywords$1 = new Set([// https://www.w3.org/TR/CSS22/ui.html#system-colors
  'activeborder', 'activecaption', 'appworkspace', 'background', 'buttonface', 'buttonhighlight', 'buttonshadow', 'buttontext', 'captiontext', 'graytext', 'highlight', 'highlighttext', 'inactiveborder', 'inactivecaption', 'inactivecaptiontext', 'infobackground', 'infotext', 'menu', 'menutext', 'scrollbar', 'threeddarkshadow', 'threedface', 'threedhighlight', 'threedlightshadow', 'threedshadow', 'window', 'windowframe', 'windowtext', // https://www.w3.org/TR/css-color-4/#css-system-colors
  'accentcolor', 'accentcolortext', 'activetext', 'buttonborder', 'buttonface', 'buttontext', 'canvas', 'canvastext', 'field', 'fieldtext', 'graytext', 'highlight', 'highlighttext', 'linktext', 'mark', 'marktext', 'selecteditem', 'selecteditemtext', 'visitedtext']);
  const namedColorsKeywords$2 = new Set([// https://www.w3.org/TR/css-color-4/#named-colors
  'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen']);
  var keywords$4 = {
    animationNameKeywords: animationNameKeywords$2,
    animationShorthandKeywords: animationShorthandKeywords$2,
    basicKeywords: basicKeywords$3,
    camelCaseKeywords: camelCaseKeywords$1,
    counterIncrementKeywords: counterIncrementKeywords$1,
    counterResetKeywords: counterResetKeywords$1,
    fontFamilyKeywords: fontFamilyKeywords$5,
    fontShorthandKeywords: fontShorthandKeywords$2,
    fontSizeKeywords: fontSizeKeywords$1,
    fontWeightAbsoluteKeywords,
    fontWeightKeywords,
    fontWeightNonNumericKeywords: fontWeightNonNumericKeywords$1,
    fontWeightRelativeKeywords: fontWeightRelativeKeywords$1,
    gridAreaKeywords: gridAreaKeywords$1,
    gridColumnKeywords: gridColumnKeywords$1,
    gridRowKeywords: gridRowKeywords$1,
    keyframeSelectorKeywords: keyframeSelectorKeywords$1,
    listStyleImageKeywords,
    listStylePositionKeywords,
    listStyleShorthandKeywords: listStyleShorthandKeywords$1,
    listStyleTypeKeywords: listStyleTypeKeywords$1,
    namedColorsKeywords: namedColorsKeywords$2,
    systemColorsKeywords: systemColorsKeywords$1,
    systemFontKeywords: systemFontKeywords$1
  };

  const {
    namedColorsKeywords: namedColorsKeywords$1
  } = keywords$4;

  const HAS_NAMED_COLOR = new RegExp(`\\b(?:${[...namedColorsKeywords$1.values()].join('|')})\\b`, 'i');
  /**
   * Check if a value contains any standard CSS named color
   *
   * `transparent` and `currentcolor` are not named colors
   *
   * @param {string} value
   * @returns {boolean}
   */

  var hasNamedColor = function hasNamedColor(value) {
    return HAS_NAMED_COLOR.test(value);
  };

  const camelCaseFunctions$1 = new Set(['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY']);
  const colorFunctions$1 = new Set(['color', 'color-mix', 'hsl', 'hsla', 'hwb', 'lab', 'lch', 'oklab', 'oklch', 'rgb', 'rgba']);
  const mathFunctions$2 = new Set(['abs', 'acos', 'asin', 'atan', 'atan2', 'calc', 'clamp', 'cos', 'exp', 'hypot', 'log', 'max', 'min', 'mod', 'pow', 'rem', 'round', 'sign', 'sin', 'sqrt', 'tan']);
  var functions = {
    camelCaseFunctions: camelCaseFunctions$1,
    colorFunctions: colorFunctions$1,
    mathFunctions: mathFunctions$2
  };

  const {
    colorFunctions
  } = functions;

  const HAS_COLOR_FUNCTION = new RegExp(`\\b(?:${[...colorFunctions.values()].join('|')})\\(`, 'i');
  /**
   * Check if a value contains any standard CSS color function
   *
   * @param {string} value
   * @returns {boolean}
   */

  var hasColorFunction = function hasColorFunction(value) {
    return HAS_COLOR_FUNCTION.test(value);
  };

  const {
    acceptCustomIdentsProperties
  } = properties$4;









  const {
    isRegExp: isRegExp$X,
    isString: isString$18
  } = validateTypes;

  const {
    colord
  } = colordUtils;







  const {
    namedColorsKeywords
  } = keywords$4;

  const ruleName$2K = 'color-named';
  const messages$2K = ruleMessages$1(ruleName$2K, {
    expected: (named, original) => `Expected "${original}" to be "${named}"`,
    rejected: named => `Unexpected named color "${named}"`
  });
  const meta$2K = {
    url: 'https://stylelint.io/user-guide/rules/color-named'
  }; // Todo tested on case insensitivity

  const NODE_TYPES = new Set(['word', 'function']);
  const HAS_GRAY_FUNCTION = /\bgray\(/i;
  /** @type {import('stylelint').Rule} */

  const rule$2K = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2K, {
        actual: primary,
        possible: ['never', 'always-where-possible']
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreProperties: [isString$18, isRegExp$X],
          ignore: ['inside-function']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (acceptCustomIdentsProperties.has(decl.prop)) {
          return;
        } // Return early if the property is to be ignored


        if (optionsMatches(secondaryOptions, 'ignoreProperties', decl.prop)) {
          return;
        }

        const {
          value: declValue
        } = decl;

        if (primary === 'never' && !hasNamedColor(declValue)) {
          return;
        }

        if (primary === 'always-where-possible' && !hasValidHex(declValue) && !hasColorFunction(declValue) && !HAS_GRAY_FUNCTION.test(declValue)) {
          return;
        }

        lib$6(declValue).walk(node => {
          const value = node.value;
          const type = node.type;
          const sourceIndex = node.sourceIndex;

          if (optionsMatches(secondaryOptions, 'ignore', 'inside-function') && type === 'function') {
            return false;
          }

          if (!isStandardSyntaxFunction(node)) {
            return false;
          }

          if (!isStandardSyntaxValue(value)) {
            return;
          } // Return early if neither a word nor a function


          if (!NODE_TYPES.has(type)) {
            return;
          } // Check for named colors for "never" option


          if (primary === 'never' && type === 'word' && namedColorsKeywords.has(value.toLowerCase())) {
            complain(messages$2K.rejected(value), decl, declarationValueIndex(decl) + sourceIndex, value.length);
            return;
          } // Check "always-where-possible" option ...


          if (primary !== 'always-where-possible') {
            return;
          }

          let rawColorString = null;
          let colorString = null;

          if (type === 'function') {
            rawColorString = lib$6.stringify(node); // First by checking for alternative color function representations ...
            // Remove all spaces to match what's in `representations`

            colorString = rawColorString.replace(/\s*([,/()])\s*/g, '$1').replace(/\s{2,}/g, ' ');
          } else if (type === 'word' && value.startsWith('#')) {
            // Then by checking for alternative hex representations
            rawColorString = colorString = value;
          } else {
            return;
          }

          const color = colord(colorString);

          if (!color.isValid()) {
            return;
          }

          const namedColor = color.toName();

          if (namedColor && namedColor.toLowerCase() !== 'transparent') {
            complain(messages$2K.expected(namedColor, colorString), decl, declarationValueIndex(decl) + sourceIndex, rawColorString.length);
          }
        });
      });
      /**
       * @param {string} message
       * @param {import('postcss').Node} node
       * @param {number} index
       * @param {number} length
       */

      function complain(message, node, index, length) {
        report$1({
          result,
          ruleName: ruleName$2K,
          message,
          node,
          index,
          endIndex: index + length
        });
      }
    };
  };

  rule$2K.ruleName = ruleName$2K;
  rule$2K.messages = messages$2K;
  rule$2K.meta = meta$2K;
  var colorNamed = rule$2K;

  const ruleName$2J = 'color-no-hex';
  const messages$2J = ruleMessages$1(ruleName$2J, {
    rejected: hex => `Unexpected hex color "${hex}"`
  });
  const meta$2J = {
    url: 'https://stylelint.io/user-guide/rules/color-no-hex'
  };
  const HEX = /^#[\da-z]+$/i;
  const CONTAINS_HEX$1 = /#[\da-z]+/i;
  const IGNORED_FUNCTIONS = new Set(['url']);
  /** @type {import('stylelint').Rule} */

  const rule$2J = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2J, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!CONTAINS_HEX$1.test(decl.value)) return;
        const parsedValue = lib$6(getDeclarationValue(decl));
        parsedValue.walk(node => {
          if (isIgnoredFunction(node)) return false;
          if (!isHexColor(node)) return;
          const index = declarationValueIndex(decl) + node.sourceIndex;
          const endIndex = index + node.value.length;
          report$1({
            message: messages$2J.rejected,
            messageArgs: [node.value],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2J
          });
        });
      });
    };
  };
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isIgnoredFunction({
    type,
    value
  }) {
    return type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isHexColor({
    type,
    value
  }) {
    return type === 'word' && HEX.test(value);
  }

  rule$2J.ruleName = ruleName$2J;
  rule$2J.messages = messages$2J;
  rule$2J.meta = meta$2J;
  var colorNoHex = rule$2J;

  /**
   * Check whether a hex color is standard
   *
   * @param {string} hex
   * @returns {boolean}
   */

  var isStandardSyntaxHexColor = function isStandardSyntaxHexColor(hex) {
    // Less map usage (e.g. .myclass { color: #colors[somecolor]; })
    if (hex.includes('[')) {
      return false;
    }

    return true;
  };

  const ruleName$2I = 'color-no-invalid-hex';
  const messages$2I = ruleMessages$1(ruleName$2I, {
    rejected: hex => `Unexpected invalid hex color "${hex}"`
  });
  const meta$2I = {
    url: 'https://stylelint.io/user-guide/rules/color-no-invalid-hex'
  };
  const CONTAINS_HEX = /#[\da-z]+/i;
  /** @type {import('stylelint').Rule} */

  const rule$2I = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2I, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!isStandardSyntaxHexColor(decl.value)) {
          return;
        }

        if (!CONTAINS_HEX.test(decl.value)) {
          return;
        }

        lib$6(decl.value).walk(({
          value,
          type,
          sourceIndex
        }) => {
          if (type === 'function' && value.endsWith('url')) return false;
          if (type !== 'word') return;
          const hexMatch = /^#[\da-z]+/i.exec(value);
          if (!hexMatch) return;
          const hexValue = hexMatch[0];
          if (!hexValue || isValidHex(hexValue)) return;
          const index = declarationValueIndex(decl) + sourceIndex;
          const endIndex = index + hexValue.length;
          report$1({
            message: messages$2I.rejected,
            messageArgs: [hexValue],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2I
          });
        });
      });
    };
  };

  rule$2I.ruleName = ruleName$2I;
  rule$2I.messages = messages$2I;
  rule$2I.meta = meta$2I;
  var colorNoInvalidHex = rule$2I;

  /**
   * @param {import('postcss').Comment} comment
   * @returns {boolean}
   */

  var isStandardSyntaxComment = function isStandardSyntaxComment(comment) {
    // We check both here because the Sass parser uses `raws.inline` to indicate
    // inline comments, while the Less parser uses `inline`.
    if ('inline' in comment) return false;
    if ('inline' in comment.raws) return false;
    return true;
  };

  const {
    isConfigurationComment: isConfigurationComment$1
  } = configurationComment;

  const {
    isRegExp: isRegExp$W,
    isString: isString$17
  } = validateTypes;

  const ruleName$2H = 'comment-empty-line-before';
  const messages$2H = ruleMessages$1(ruleName$2H, {
    expected: 'Expected empty line before comment',
    rejected: 'Unexpected empty line before comment'
  });
  const meta$2H = {
    url: 'https://stylelint.io/user-guide/rules/comment-empty-line-before',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2H = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2H, {
        actual: primary,
        possible: ['always', 'never']
      }, {
        actual: secondaryOptions,
        possible: {
          except: ['first-nested'],
          ignore: ['stylelint-commands', 'after-comment'],
          ignoreComments: [isString$17, isRegExp$W]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkComments(comment => {
        // Ignore the first node
        if (isFirstNodeOfRoot(comment)) {
          return;
        } // Optionally ignore stylelint commands


        if (isConfigurationComment$1(comment, context.configurationComment) && optionsMatches(secondaryOptions, 'ignore', 'stylelint-commands')) {
          return;
        } // Optionally ignore newlines between comments


        if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(comment)) {
          return;
        } // Ignore comments matching the ignoreComments option.


        if (optionsMatches(secondaryOptions, 'ignoreComments', comment.text)) {
          return;
        } // Ignore shared-line comments


        if (isSharedLineComment(comment)) {
          return;
        } // Ignore non-standard comments


        if (!isStandardSyntaxComment(comment)) {
          return;
        }

        const expectEmptyLineBefore = (() => {
          if (optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(comment)) {
            return false;
          }

          return primary === 'always';
        })();

        const before = comment.raws.before || '';
        const hasEmptyLineBefore = hasEmptyLine(before); // Return if the expectation is met

        if (expectEmptyLineBefore === hasEmptyLineBefore) {
          return;
        } // Fix


        if (context.fix) {
          if (typeof context.newline !== 'string') return;

          if (expectEmptyLineBefore) {
            addEmptyLineBefore(comment, context.newline);
          } else {
            removeEmptyLinesBefore(comment, context.newline);
          }

          return;
        }

        const message = expectEmptyLineBefore ? messages$2H.expected : messages$2H.rejected;
        report$1({
          message,
          node: comment,
          result,
          ruleName: ruleName$2H
        });
      });
    };
  };

  rule$2H.ruleName = ruleName$2H;
  rule$2H.messages = messages$2H;
  rule$2H.meta = meta$2H;
  var commentEmptyLineBefore = rule$2H;

  const ruleName$2G = 'comment-no-empty';
  const messages$2G = ruleMessages$1(ruleName$2G, {
    rejected: 'Unexpected empty comment'
  });
  const meta$2G = {
    url: 'https://stylelint.io/user-guide/rules/comment-no-empty'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2G = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2G, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkComments(comment => {
        // To ignore non-standard comments
        if (!isStandardSyntaxComment(comment)) {
          return;
        } // To ignore comments that are not empty


        if (comment.text && comment.text.length !== 0) {
          return;
        }

        report$1({
          message: messages$2G.rejected,
          node: comment,
          result,
          ruleName: ruleName$2G
        });
      });
    };
  };

  rule$2G.ruleName = ruleName$2G;
  rule$2G.messages = messages$2G;
  rule$2G.meta = meta$2G;
  var commentNoEmpty = rule$2G;

  const {
    isRegExp: isRegExp$V,
    isString: isString$16
  } = validateTypes;

  const ruleName$2F = 'comment-pattern';
  const messages$2F = ruleMessages$1(ruleName$2F, {
    expected: pattern => `Expected comment to match pattern "${pattern}"`
  });
  const meta$2F = {
    url: 'https://stylelint.io/user-guide/rules/comment-pattern'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2F = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2F, {
        actual: primary,
        possible: [isRegExp$V, isString$16]
      });

      if (!validOptions) {
        return;
      }

      const normalizedPattern = isString$16(primary) ? new RegExp(primary) : primary;
      root.walkComments(comment => {
        const text = comment.text;

        if (normalizedPattern.test(text)) {
          return;
        }

        report$1({
          message: messages$2F.expected,
          messageArgs: [primary],
          node: comment,
          result,
          ruleName: ruleName$2F
        });
      });
    };
  };

  rule$2F.ruleName = ruleName$2F;
  rule$2F.messages = messages$2F;
  rule$2F.meta = meta$2F;
  var commentPattern = rule$2F;

  const ruleName$2E = 'comment-whitespace-inside';
  const messages$2E = ruleMessages$1(ruleName$2E, {
    expectedOpening: 'Expected whitespace after "/*"',
    rejectedOpening: 'Unexpected whitespace after "/*"',
    expectedClosing: 'Expected whitespace before "*/"',
    rejectedClosing: 'Unexpected whitespace before "*/"'
  });
  const meta$2E = {
    url: 'https://stylelint.io/user-guide/rules/comment-whitespace-inside',
    fixable: true
  };
  /**
   * @param {import('postcss').Comment} comment
   */

  function addWhitespaceBefore(comment) {
    if (comment.text.startsWith('*')) {
      comment.text = comment.text.replace(/^(\*+)/, `$1 `);
    } else {
      comment.raws.left = ' ';
    }
  }
  /**
   * @param {import('postcss').Comment} comment
   */


  function addWhitespaceAfter(comment) {
    if (comment.text[comment.text.length - 1] === '*') {
      comment.text = comment.text.replace(/(\*+)$/, ` $1`);
    } else {
      comment.raws.right = ' ';
    }
  }
  /** @type {import('stylelint').Rule} */


  const rule$2E = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2E, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkComments(comment => {
        if (!isStandardSyntaxComment(comment)) {
          return;
        }

        const rawComment = comment.toString();
        const firstFourChars = rawComment.slice(0, 4); // Return early if sourcemap or copyright comment

        if (/^\/\*[#!]\s/.test(firstFourChars)) {
          return;
        }

        const leftMatches = rawComment.match(/(^\/\*+)(\s)?/);

        if (leftMatches == null || leftMatches[1] == null) {
          throw new Error(`Invalid comment: "${rawComment}"`);
        }

        const rightMatches = rawComment.match(/(\s)?(\*+\/)$/);

        if (rightMatches == null || rightMatches[2] == null) {
          throw new Error(`Invalid comment: "${rawComment}"`);
        }

        const opener = leftMatches[1];
        const leftSpace = leftMatches[2] || '';
        const rightSpace = rightMatches[1] || '';
        const closer = rightMatches[2];

        if (primary === 'never' && leftSpace !== '') {
          complain(messages$2E.rejectedOpening, opener.length);
        }

        if (primary === 'always' && !isWhitespace$2(leftSpace)) {
          complain(messages$2E.expectedOpening, opener.length);
        }

        if (primary === 'never' && rightSpace !== '') {
          complain(messages$2E.rejectedClosing, comment.toString().length - closer.length - 1);
        }

        if (primary === 'always' && !isWhitespace$2(rightSpace)) {
          complain(messages$2E.expectedClosing, comment.toString().length - closer.length - 1);
        }
        /**
         * @param {string} message
         * @param {number} index
         */


        function complain(message, index) {
          if (context.fix) {
            if (primary === 'never') {
              comment.raws.left = '';
              comment.raws.right = '';
              comment.text = comment.text.replace(/^(\*+)(\s+)?/, '$1').replace(/(\s+)?(\*+)$/, '$2');
            } else {
              if (!leftSpace) {
                addWhitespaceBefore(comment);
              }

              if (!rightSpace) {
                addWhitespaceAfter(comment);
              }
            }

            return;
          }

          report$1({
            message,
            index,
            result,
            ruleName: ruleName$2E,
            node: comment
          });
        }
      });
    };
  };

  rule$2E.ruleName = ruleName$2E;
  rule$2E.messages = messages$2E;
  rule$2E.meta = meta$2E;
  var commentWhitespaceInside = rule$2E;

  const {
    isString: isString$15
  } = validateTypes;
  /** @typedef {false | { match: string, pattern: string, substring: string }} ReturnValue */

  /**
   * Checks if a string contains a value. The comparison value can be a string or
   * an array of strings.
   *
   * Any strings starting and ending with `/` are ignored. Use the
   * matchesStringOrRegExp() util to match regexes.
   *
   * @template {unknown} T
   * @param {string} input
   * @param {T | T[]} comparison
   * @returns {ReturnValue}
   */


  var containsString = function containsString(input, comparison) {
    if (!Array.isArray(comparison)) {
      return testAgainstString(input, comparison);
    }

    for (const comparisonItem of comparison) {
      const testResult = testAgainstString(input, comparisonItem);

      if (testResult) {
        return testResult;
      }
    }

    return false;
  };
  /**
   * @param {string} value
   * @param {unknown} comparison
   * @returns {ReturnValue}
   */


  function testAgainstString(value, comparison) {
    if (!comparison) return false;
    if (!isString$15(comparison)) return false;

    if (comparison.startsWith('/') && comparison.endsWith('/')) {
      return false;
    }

    if (value.includes(comparison)) {
      return {
        match: value,
        pattern: comparison,
        substring: comparison
      };
    }

    return false;
  }

  const {
    isRegExp: isRegExp$U,
    isString: isString$14
  } = validateTypes;

  const ruleName$2D = 'comment-word-disallowed-list';
  const messages$2D = ruleMessages$1(ruleName$2D, {
    rejected: pattern => `Unexpected word matching pattern "${pattern}"`
  });
  const meta$2D = {
    url: 'https://stylelint.io/user-guide/rules/comment-word-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$2D = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2D, {
        actual: primary,
        possible: [isString$14, isRegExp$U]
      });

      if (!validOptions) {
        return;
      }

      root.walkComments(comment => {
        const text = comment.text;
        const rawComment = comment.toString();
        const firstFourChars = rawComment.slice(0, 4); // Return early if sourcemap

        if (firstFourChars === '/*# ') {
          return;
        }

        const matchesWord = matchesStringOrRegExp(text, primary) || containsString(text, primary);

        if (!matchesWord) {
          return;
        }

        report$1({
          message: messages$2D.rejected,
          messageArgs: [matchesWord.pattern],
          node: comment,
          word: matchesWord.substring,
          result,
          ruleName: ruleName$2D
        });
      });
    };
  };

  rule$2D.primaryOptionArray = true;
  rule$2D.ruleName = ruleName$2D;
  rule$2D.messages = messages$2D;
  rule$2D.meta = meta$2D;
  var commentWordDisallowedList = rule$2D;

  /**
   * @param {import('postcss').AtRule} atRule
   * @returns {number}
   */

  var atRuleParamIndex = function atRuleParamIndex(atRule) {
    // Initial 1 is for the `@`
    let index = 1 + atRule.name.length;

    if (atRule.raws.afterName) {
      index += atRule.raws.afterName.length;
    }

    return index;
  };

  const {
    isRegExp: isRegExp$T,
    isString: isString$13
  } = validateTypes;

  const ruleName$2C = 'custom-media-pattern';
  const messages$2C = ruleMessages$1(ruleName$2C, {
    expected: (mediaName, pattern) => `Expected "${mediaName}" to match pattern "${pattern}"`
  });
  const meta$2C = {
    url: 'https://stylelint.io/user-guide/rules/custom-media-pattern'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2C = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2C, {
        actual: primary,
        possible: [isRegExp$T, isString$13]
      });

      if (!validOptions) {
        return;
      }

      const regexpPattern = isString$13(primary) ? new RegExp(primary) : primary;
      root.walkAtRules(atRule => {
        if (atRule.name.toLowerCase() !== 'custom-media') {
          return;
        }

        const [fullName, customMediaName] = atRule.params.match(/^--(\S+)\b/) || [];

        if (fullName === undefined || customMediaName === undefined) {
          throw new Error(`Unexpected at-rule params: "${atRule.params}"`);
        }

        if (regexpPattern.test(customMediaName)) {
          return;
        }

        const index = atRuleParamIndex(atRule);
        report$1({
          message: messages$2C.expected,
          messageArgs: [fullName, primary],
          node: atRule,
          index,
          endIndex: index + fullName.length,
          result,
          ruleName: ruleName$2C
        });
      });
    };
  };

  rule$2C.ruleName = ruleName$2C;
  rule$2C.messages = messages$2C;
  rule$2C.meta = meta$2C;
  var customMediaPattern = rule$2C;

  /**
   * Check whether a property is a custom one
   * @param {string} property
   * @returns {boolean}
   */

  var isCustomProperty$2 = function isCustomProperty(property) {
    return property.startsWith('--');
  };

  /**
   * Check whether a property is SCSS variable
   *
   * @param {string} property
   * @returns {boolean}
   */

  var isScssVariable = function isScssVariable(property) {
    // SCSS var (e.g. $var: x), list (e.g. $list: (x)) or map (e.g. $map: (key:value))
    if (property.startsWith('$')) {
      return true;
    } // SCSS var within a namespace (e.g. namespace.$var: x)


    if (property.includes('.$')) {
      return true;
    }

    return false;
  };

  const {
    isRule: isRule$d
  } = typeGuards;
  /**
   * Check whether a declaration is standard
   *
   * @param {import('postcss').Declaration | import('postcss-less').Declaration} decl
   */


  var isStandardSyntaxDeclaration = function isStandardSyntaxDeclaration(decl) {
    const prop = decl.prop;
    const parent = decl.parent; // SCSS var; covers map and list declarations

    if (isScssVariable(prop)) {
      return false;
    } // Less var (e.g. @var: x), but exclude variable interpolation (e.g. @{var})


    if (prop[0] === '@' && prop[1] !== '{') {
      return false;
    } // Less map declaration


    if (parent && parent.type === 'atrule' && parent.raws.afterName === ':') {
      return false;
    } // Less map (e.g. #my-map() { myprop: red; })


    if (parent && isRule$d(parent) && parent.selector && parent.selector.startsWith('#') && parent.selector.endsWith('()')) {
      return false;
    } // Sass nested properties (e.g. border: { style: solid; color: red; })


    if (parent && isRule$d(parent) && parent.selector && parent.selector[parent.selector.length - 1] === ':' && parent.selector.substring(0, 2) !== '--') {
      return false;
    } // Less &:extend


    if ('extend' in decl && decl.extend) {
      return false;
    }

    return true;
  };

  const {
    isAtRule: isAtRule$m,
    isDeclaration: isDeclaration$4,
    isRule: isRule$c
  } = typeGuards;

  const ruleName$2B = 'custom-property-empty-line-before';
  const messages$2B = ruleMessages$1(ruleName$2B, {
    expected: 'Expected empty line before custom property',
    rejected: 'Unexpected empty line before custom property'
  });
  const meta$2B = {
    url: 'https://stylelint.io/user-guide/rules/custom-property-empty-line-before',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2B = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2B, {
        actual: primary,
        possible: ['always', 'never']
      }, {
        actual: secondaryOptions,
        possible: {
          except: ['first-nested', 'after-comment', 'after-custom-property'],
          ignore: ['after-comment', 'first-nested', 'inside-single-line-block']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;
        const parent = decl.parent;

        if (!isStandardSyntaxDeclaration(decl)) {
          return;
        }

        if (!isCustomProperty$2(prop)) {
          return;
        } // Optionally ignore the node if a comment precedes it


        if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(decl)) {
          return;
        } // Optionally ignore the node if it is the first nested


        if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(decl)) {
          return;
        } // Optionally ignore nodes inside single-line blocks


        if (optionsMatches(secondaryOptions, 'ignore', 'inside-single-line-block') && parent != null && (isAtRule$m(parent) || isRule$c(parent)) && isSingleLineString(blockString(parent))) {
          return;
        }

        let expectEmptyLineBefore = primary === 'always'; // Optionally reverse the expectation if any exceptions apply

        if (optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(decl) || optionsMatches(secondaryOptions, 'except', 'after-comment') && isAfterComment(decl) || optionsMatches(secondaryOptions, 'except', 'after-custom-property') && isAfterCustomProperty(decl)) {
          expectEmptyLineBefore = !expectEmptyLineBefore;
        }

        const hasEmptyLineBefore = hasEmptyLine(decl.raws.before); // Return if the expectation is met

        if (expectEmptyLineBefore === hasEmptyLineBefore) {
          return;
        } // Fix


        if (context.fix) {
          if (context.newline == null) return;

          if (expectEmptyLineBefore) {
            addEmptyLineBefore(decl, context.newline);
          } else {
            removeEmptyLinesBefore(decl, context.newline);
          }

          return;
        }

        const message = expectEmptyLineBefore ? messages$2B.expected : messages$2B.rejected;
        report$1({
          message,
          node: decl,
          result,
          ruleName: ruleName$2B
        });
      });
    };
  };
  /**
   * @param {import('postcss').Declaration} decl
   */


  function isAfterCustomProperty(decl) {
    const prevNode = getPreviousNonSharedLineCommentNode(decl);
    return prevNode != null && isDeclaration$4(prevNode) && isCustomProperty$2(prevNode.prop);
  }

  rule$2B.ruleName = ruleName$2B;
  rule$2B.messages = messages$2B;
  rule$2B.meta = meta$2B;
  var customPropertyEmptyLineBefore = rule$2B;

  const ruleName$2A = 'custom-property-no-missing-var-function';
  const messages$2A = ruleMessages$1(ruleName$2A, {
    rejected: customProperty => `Unexpected missing var function for "${customProperty}"`
  });
  const meta$2A = {
    url: 'https://stylelint.io/user-guide/rules/custom-property-no-missing-var-function'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2A = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2A, {
        actual: primary
      });
      if (!validOptions) return;
      /** @type {Set<string>} */

      const knownCustomProperties = new Set();
      root.walkAtRules(/^property$/i, atRule => {
        knownCustomProperties.add(atRule.params);
      });
      root.walkDecls(/^--/, ({
        prop
      }) => {
        knownCustomProperties.add(prop);
      });
      root.walkDecls(decl => {
        const {
          value
        } = decl;
        if (!value.includes('--')) return;
        const parsedValue = lib$6(value);
        parsedValue.walk(node => {
          if (isVarFunction(node)) return false;
          if (!isDashedIdent(node)) return;
          if (!knownCustomProperties.has(node.value)) return;
          const index = declarationValueIndex(decl) + node.sourceIndex;
          const endIndex = index + node.value.length;
          report$1({
            message: messages$2A.rejected,
            messageArgs: [node.value],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2A
          });
          return false;
        });
      });
    };
  };
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isDashedIdent({
    type,
    value
  }) {
    return type === 'word' && value.startsWith('--');
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isVarFunction({
    type,
    value
  }) {
    return type === 'function' && value === 'var';
  }

  rule$2A.ruleName = ruleName$2A;
  rule$2A.messages = messages$2A;
  rule$2A.meta = meta$2A;
  var customPropertyNoMissingVarFunction = rule$2A;

  /**
   * Check whether a property is standard
   *
   * @param {string} property
   * @returns {boolean}
   */


  var isStandardSyntaxProperty = function isStandardSyntaxProperty(property) {
    // SCSS var
    if (isScssVariable(property)) {
      return false;
    } // Less var (e.g. @var: x)


    if (property.startsWith('@')) {
      return false;
    } // Less append property value with space (e.g. transform+_: scale(2))


    if (property.endsWith('+') || property.endsWith('+_')) {
      return false;
    } // SCSS or Less interpolation


    if (hasInterpolation(property)) {
      return false;
    }

    return true;
  };

  const {
    isRegExp: isRegExp$S,
    isString: isString$12
  } = validateTypes;

  const {
    isValueFunction: isValueFunction$1
  } = typeGuards;



  const ruleName$2z = 'custom-property-pattern';
  const messages$2z = ruleMessages$1(ruleName$2z, {
    expected: (propName, pattern) => `Expected "${propName}" to match pattern "${pattern}"`
  });
  const meta$2z = {
    url: 'https://stylelint.io/user-guide/rules/custom-property-pattern'
  };
  const VAR_FUNC_REGEX = /var\(/i;
  /** @type {import('stylelint').Rule} */

  const rule$2z = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2z, {
        actual: primary,
        possible: [isRegExp$S, isString$12]
      });

      if (!validOptions) {
        return;
      }

      const regexpPattern = isString$12(primary) ? new RegExp(primary) : primary;
      /**
       * @param {string} property
       * @returns {boolean}
       */

      function check(property) {
        return !isCustomProperty$2(property) || !isStandardSyntaxProperty(property) || regexpPattern.test(property.slice(2));
      }

      root.walkDecls(decl => {
        const {
          prop,
          value
        } = decl;

        if (VAR_FUNC_REGEX.test(value)) {
          const parsedValue = lib$6(value);
          parsedValue.walk(node => {
            if (!isValueFunction$1(node)) return;
            if (node.value.toLowerCase() !== 'var') return;
            const {
              nodes
            } = node;
            const firstNode = nodes[0];
            if (!firstNode || check(firstNode.value)) return;
            complain(declarationValueIndex(decl) + firstNode.sourceIndex, firstNode.value, decl);
          });
        }

        if (check(prop)) return;
        complain(0, prop, decl);
      });
      /**
       * @param {number} index
       * @param {string} propName
       * @param {import('postcss').Declaration} decl
       */

      function complain(index, propName, decl) {
        report$1({
          result,
          ruleName: ruleName$2z,
          message: messages$2z.expected,
          messageArgs: [propName, primary],
          node: decl,
          index,
          endIndex: index + propName.length
        });
      }
    };
  };

  rule$2z.ruleName = ruleName$2z;
  rule$2z.messages = messages$2z;
  rule$2z.meta = meta$2z;
  var customPropertyPattern = rule$2z;

  var SKIP = 'skip';
  var ONLY = 'only';

  var styleSearch = function (options, callback) {
    var source = options.source;
    var target = options.target;
    var skipComments = options.comments ? options.comments === SKIP : true;
    var skipStrings = options.strings ? options.strings === SKIP : true;
    var skipFunctionNames = options.functionNames ? options.functionNames === SKIP : true;
    var skipFunctionArguments = options.functionArguments === SKIP;
    var skipParentheticals = options.parentheticals === SKIP;
    var onceOptionUsed = false;
    Object.keys(options).forEach(function (key) {
      if (options[key] !== ONLY) return;

      if (!onceOptionUsed) {
        onceOptionUsed = true;
      } else {
        throw new Error('Only one syntax feature option can be the "only" one to check');
      }
    });
    var onlyComments = options.comments === ONLY;
    var onlyStrings = options.strings === ONLY;
    var onlyFunctionNames = options.functionNames === ONLY;
    var onlyFunctionArguments = options.functionArguments === ONLY;
    var onlyParentheticals = options.parentheticals === ONLY;
    var insideString = false;
    var insideComment = false;
    var insideSingleLineComment = false;
    var insideParens = false;
    var insideFunctionArguments = false;
    var openingParenCount = 0;
    var matchCount = 0;
    var openingQuote;
    var targetIsArray = Array.isArray(target); // If the target is just a string, it is easy to check whether
    // some index of the source matches it.
    // If the target is an array of strings, though, we have to
    // check whether some index of the source matches *any* of
    // those target strings (stopping after the first match).

    var getMatch = function () {
      if (!targetIsArray) {
        return getMatchBase.bind(null, target);
      }

      return function (index) {
        for (var ti = 0, tl = target.length; ti < tl; ti++) {
          var checkResult = getMatchBase(target[ti], index);
          if (checkResult) return checkResult;
        }

        return false;
      };
    }();

    function getMatchBase(targetString, index) {
      var targetStringLength = targetString.length; // Target is a single character

      if (targetStringLength === 1 && source[index] !== targetString) return false; // Target is multiple characters

      if (source.substr(index, targetStringLength) !== targetString) return false;
      return {
        insideParens: insideParens,
        insideFunctionArguments: insideFunctionArguments,
        insideComment: insideComment,
        insideString: insideString,
        startIndex: index,
        endIndex: index + targetStringLength,
        target: targetString
      };
    }

    for (var i = 0, l = source.length; i < l; i++) {
      var currentChar = source[i]; // Register the beginning of a comment

      if (!insideString && !insideComment && currentChar === "/" && source[i - 1] !== "\\" // escaping
      ) {
          // standard comments
          if (source[i + 1] === "*") {
            insideComment = true;
            continue;
          } // single-line comments


          if (source[i + 1] === "/") {
            insideComment = true;
            insideSingleLineComment = true;
            continue;
          }
        }

      if (insideComment) {
        // Register the end of a standard comment
        if (!insideSingleLineComment && currentChar === "*" && source[i - 1] !== "\\" // escaping
        && source[i + 1] === "/" && source[i - 1] !== "/" // don't end if it's /*/
        ) {
            insideComment = false;
            continue;
          } // Register the end of a single-line comment


        if (insideSingleLineComment && currentChar === "\n") {
          insideComment = false;
          insideSingleLineComment = false;
        }

        if (skipComments) continue;
      } // Register the beginning of a string


      if (!insideComment && !insideString && (currentChar === "\"" || currentChar === "'")) {
        if (source[i - 1] === "\\") continue; // escaping

        openingQuote = currentChar;
        insideString = true; // For string-quotes rule

        if (target === currentChar) handleMatch(getMatch(i));
        continue;
      }

      if (insideString) {
        // Register the end of a string
        if (currentChar === openingQuote) {
          if (source[i - 1] === "\\") continue; // escaping

          insideString = false;
          continue;
        }

        if (skipStrings) continue;
      } // Register the beginning of parens/functions


      if (!insideString && !insideComment && currentChar === "(") {
        // Keep track of opening parentheticals so that we
        // know when the outermost function (possibly
        // containing nested functions) is closing
        openingParenCount++;
        insideParens = true; // Only inside a function if there is a function name
        // before the opening paren

        if (/[a-zA-Z]/.test(source[i - 1])) {
          insideFunctionArguments = true;
        }

        if (target === "(") handleMatch(getMatch(i));
        continue;
      }

      if (insideParens) {
        // Register the end of a function
        if (currentChar === ")") {
          openingParenCount--; // Do this here so the match is still technically inside a function

          if (target === ")") handleMatch(getMatch(i));

          if (openingParenCount === 0) {
            insideParens = false;
            insideFunctionArguments = false;
          }

          continue;
        }
      }

      var isFunctionName = /^[a-zA-Z]*\(/.test(source.slice(i));
      if (skipFunctionNames && isFunctionName) continue;
      if (onlyFunctionNames && !isFunctionName) continue;
      var match = getMatch(i);
      if (!match) continue;
      handleMatch(match);
      if (options.once) return;
    }

    function handleMatch(match) {
      if (onlyParentheticals && !insideParens) return;
      if (skipParentheticals && insideParens) return;
      if (onlyFunctionArguments && !insideFunctionArguments) return;
      if (skipFunctionArguments && insideFunctionArguments) return;
      if (onlyStrings && !insideString) return;
      if (onlyComments && !insideComment) return;
      matchCount++;
      callback(match, matchCount);
    }
  };

  /** @typedef {import('postcss').Declaration} Declaration */

  /** @typedef {(args: { source: string, index: number, err: (message: string) => void }) => void} LocationChecker */

  /**
   * @param {{
   *   root: import('postcss').Root,
   *   locationChecker: LocationChecker,
   *   result: import('stylelint').PostcssResult,
   *   checkedRuleName: string,
   *   fix: ((decl: Declaration, index: number) => boolean) | null,
   * }} opts
   * @returns {void}
   */


  var declarationBangSpaceChecker = function declarationBangSpaceChecker(opts) {
    opts.root.walkDecls(decl => {
      const indexOffset = declarationValueIndex(decl);
      const declString = decl.toString();
      const valueString = decl.toString().slice(indexOffset);

      if (!valueString.includes('!')) {
        return;
      }

      styleSearch({
        source: valueString,
        target: '!'
      }, match => {
        check(declString, match.startIndex + indexOffset, decl);
      });
    });
    /**
     * @param {string} source
     * @param {number} index
     * @param {Declaration} decl
     */

    function check(source, index, decl) {
      opts.locationChecker({
        source,
        index,
        err: message => {
          if (opts.fix && opts.fix(decl, index)) {
            return;
          }

          report$1({
            message,
            node: decl,
            index,
            result: opts.result,
            ruleName: opts.checkedRuleName
          });
        }
      });
    }
  };

  const ruleName$2y = 'declaration-bang-space-after';
  const messages$2y = ruleMessages$1(ruleName$2y, {
    expectedAfter: () => 'Expected single space after "!"',
    rejectedAfter: () => 'Unexpected whitespace after "!"'
  });
  const meta$2y = {
    url: 'https://stylelint.io/user-guide/rules/declaration-bang-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2y = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2y);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2y, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      declarationBangSpaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$2y,
        fix: context.fix ? (decl, index) => {
          let bangIndex = index - declarationValueIndex(decl);
          const declValue = getDeclarationValue(decl);
          let target;
          /** @type {(value: string) => void} */

          let setFixed;

          if (bangIndex < declValue.length) {
            target = declValue;

            setFixed = value => {
              setDeclarationValue(decl, value);
            };
          } else if (decl.important) {
            target = decl.raws.important || ' !important';
            bangIndex -= declValue.length;

            setFixed = value => {
              decl.raws.important = value;
            };
          } else {
            return false; // not standard
          }

          const targetBefore = target.slice(0, bangIndex + 1);
          const targetAfter = target.slice(bangIndex + 1);

          if (primary === 'always') {
            setFixed(targetBefore + targetAfter.replace(/^\s*/, ' '));
            return true;
          }

          if (primary === 'never') {
            setFixed(targetBefore + targetAfter.replace(/^\s*/, ''));
            return true;
          }

          return false;
        } : null
      });
    };
  };

  rule$2y.ruleName = ruleName$2y;
  rule$2y.messages = messages$2y;
  rule$2y.meta = meta$2y;
  var declarationBangSpaceAfter = rule$2y;

  const ruleName$2x = 'declaration-bang-space-before';
  const messages$2x = ruleMessages$1(ruleName$2x, {
    expectedBefore: () => 'Expected single space before "!"',
    rejectedBefore: () => 'Unexpected whitespace before "!"'
  });
  const meta$2x = {
    url: 'https://stylelint.io/user-guide/rules/declaration-bang-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2x = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2x);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2x, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      declarationBangSpaceChecker({
        root,
        result,
        locationChecker: checker.before,
        checkedRuleName: ruleName$2x,
        fix: context.fix ? (decl, index) => {
          let bangIndex = index - declarationValueIndex(decl);
          const value = getDeclarationValue(decl);
          let target;
          /** @type {(val: string) => void} */

          let setFixed;

          if (bangIndex < value.length) {
            target = value;

            setFixed = val => {
              setDeclarationValue(decl, val);
            };
          } else if (decl.important) {
            target = decl.raws.important || ' !important';
            bangIndex -= value.length;

            setFixed = val => {
              decl.raws.important = val;
            };
          } else {
            return false; // not standard
          }

          const targetBefore = target.slice(0, bangIndex);
          const targetAfter = target.slice(bangIndex);

          if (primary === 'always') {
            // eslint-disable-next-line prefer-template
            setFixed(targetBefore.replace(/\s*$/, '') + ' ' + targetAfter);
            return true;
          }

          if (primary === 'never') {
            setFixed(targetBefore.replace(/\s*$/, '') + targetAfter);
            return true;
          }

          return false;
        } : null
      });
    };
  };

  rule$2x.ruleName = ruleName$2x;
  rule$2x.messages = messages$2x;
  rule$2x.meta = meta$2x;
  var declarationBangSpaceBefore = rule$2x;

  const {
    isRoot: isRoot$3,
    isAtRule: isAtRule$l,
    isRule: isRule$b
  } = typeGuards;
  /** @typedef {import('postcss').Root} Root */

  /** @typedef {import('postcss').Root} Document */

  /** @typedef {import('postcss').Node} PostcssNode */

  /** @typedef {import('postcss').Container} PostcssContainerNode */

  /** @typedef {import('postcss').Declaration} Declaration */

  /** @typedef {(callbackFn: (decl: Declaration, index: number, decls: Declaration[]) => void) => void} EachDeclaration */

  /**
   * @param {PostcssNode} node
   * @returns {node is PostcssContainerNode}
   */


  function isContainerNode(node) {
    return isRule$b(node) || isAtRule$l(node) || isRoot$3(node);
  }
  /**
   * In order to accommodate nested blocks (postcss-nested),
   * we need to run a shallow loop (instead of eachDecl() or eachRule(),
   * which loop recursively) and allow each nested block to accumulate
   * its own list of properties -- so that a property in a nested rule
   * does not conflict with the same property in the parent rule
   * executes a provided function once for each declaration block.
   *
   * @param {Root | Document} root - root element of file.
   * @param {(eachDecl: EachDeclaration) => void} callback - Function to execute for each declaration block
   *
   * @returns {void}
   */


  var eachDeclarationBlock = function eachDeclarationBlock(root, callback) {
    /**
     * @param {PostcssNode} statement
     *
     * @returns {void}
     */
    function each(statement) {
      if (!isContainerNode(statement)) return;

      if (statement.nodes && statement.nodes.length) {
        /** @type {Declaration[]} */
        const decls = [];

        for (const node of statement.nodes) {
          if (node.type === 'decl') {
            decls.push(node);
          }

          each(node);
        }

        if (decls.length) {
          callback(decls.forEach.bind(decls));
        }
      }
    }

    each(root);
  };

  const {
    isRegExp: isRegExp$R,
    isString: isString$11
  } = validateTypes;





  const ruleName$2w = 'declaration-block-no-duplicate-custom-properties';
  const messages$2w = ruleMessages$1(ruleName$2w, {
    rejected: property => `Unexpected duplicate "${property}"`
  });
  const meta$2w = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-no-duplicate-custom-properties'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2w = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2w, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreProperties: [isString$11, isRegExp$R]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      eachDeclarationBlock(root, eachDecl => {
        const decls = new Set();
        eachDecl(decl => {
          const prop = decl.prop;

          if (!isStandardSyntaxProperty(prop)) {
            return;
          }

          if (!isCustomProperty$2(prop)) {
            return;
          }

          if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
            return;
          }

          const isDuplicate = decls.has(prop);

          if (isDuplicate) {
            report$1({
              message: messages$2w.rejected,
              messageArgs: [prop],
              node: decl,
              result,
              ruleName: ruleName$2w,
              word: prop
            });
            return;
          }

          decls.add(prop);
        });
      });
    };
  };

  rule$2w.ruleName = ruleName$2w;
  rule$2w.messages = messages$2w;
  rule$2w.meta = meta$2w;
  var declarationBlockNoDuplicateCustomProperties = rule$2w;

  // https://www.w3.org/TR/css-syntax-3/

  const EOF$2 = 0; // <EOF-token>

  const Ident$1 = 1; // <ident-token>

  const Function$1 = 2; // <function-token>

  const AtKeyword$1 = 3; // <at-keyword-token>

  const Hash$2 = 4; // <hash-token>

  const String$1 = 5; // <string-token>

  const BadString$1 = 6; // <bad-string-token>

  const Url$2 = 7; // <url-token>

  const BadUrl$1 = 8; // <bad-url-token>

  const Delim$1 = 9; // <delim-token>

  const Number$1 = 10; // <number-token>

  const Percentage$2 = 11; // <percentage-token>

  const Dimension$2 = 12; // <dimension-token>

  const WhiteSpace$2 = 13; // <whitespace-token>

  const CDO$2 = 14; // <CDO-token>

  const CDC$2 = 15; // <CDC-token>

  const Colon$1 = 16; // <colon-token>     :

  const Semicolon$1 = 17; // <semicolon-token> ;

  const Comma$1 = 18; // <comma-token>     ,

  const LeftSquareBracket$1 = 19; // <[-token>

  const RightSquareBracket$1 = 20; // <]-token>

  const LeftParenthesis$1 = 21; // <(-token>

  const RightParenthesis$1 = 22; // <)-token>

  const LeftCurlyBracket$1 = 23; // <{-token>

  const RightCurlyBracket$1 = 24; // <}-token>

  const Comment$3 = 25;
  var AtKeyword_1 = AtKeyword$1;
  var BadString_1 = BadString$1;
  var BadUrl_1 = BadUrl$1;
  var CDC_1$2 = CDC$2;
  var CDO_1$2 = CDO$2;
  var Colon_1 = Colon$1;
  var Comma_1 = Comma$1;
  var Comment_1$2 = Comment$3;
  var Delim_1 = Delim$1;
  var Dimension_1$2 = Dimension$2;
  var EOF_1 = EOF$2;
  var _Function$4 = Function$1;
  var Hash_1$2 = Hash$2;
  var Ident_1 = Ident$1;
  var LeftCurlyBracket_1 = LeftCurlyBracket$1;
  var LeftParenthesis_1 = LeftParenthesis$1;
  var LeftSquareBracket_1 = LeftSquareBracket$1;
  var _Number$4 = Number$1;
  var Percentage_1$2 = Percentage$2;
  var RightCurlyBracket_1 = RightCurlyBracket$1;
  var RightParenthesis_1 = RightParenthesis$1;
  var RightSquareBracket_1 = RightSquareBracket$1;
  var Semicolon_1 = Semicolon$1;
  var _String$4 = String$1;
  var Url_1$2 = Url$2;
  var WhiteSpace_1$2 = WhiteSpace$2;

  var types$4 = {
  	AtKeyword: AtKeyword_1,
  	BadString: BadString_1,
  	BadUrl: BadUrl_1,
  	CDC: CDC_1$2,
  	CDO: CDO_1$2,
  	Colon: Colon_1,
  	Comma: Comma_1,
  	Comment: Comment_1$2,
  	Delim: Delim_1,
  	Dimension: Dimension_1$2,
  	EOF: EOF_1,
  	Function: _Function$4,
  	Hash: Hash_1$2,
  	Ident: Ident_1,
  	LeftCurlyBracket: LeftCurlyBracket_1,
  	LeftParenthesis: LeftParenthesis_1,
  	LeftSquareBracket: LeftSquareBracket_1,
  	Number: _Number$4,
  	Percentage: Percentage_1$2,
  	RightCurlyBracket: RightCurlyBracket_1,
  	RightParenthesis: RightParenthesis_1,
  	RightSquareBracket: RightSquareBracket_1,
  	Semicolon: Semicolon_1,
  	String: _String$4,
  	Url: Url_1$2,
  	WhiteSpace: WhiteSpace_1$2
  };

  const EOF$1 = 0; // https://drafts.csswg.org/css-syntax-3/
  // § 4.2. Definitions
  // digit
  // A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).

  function isDigit$1(code) {
    return code >= 0x0030 && code <= 0x0039;
  } // hex digit
  // A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
  // or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).


  function isHexDigit$1(code) {
    return isDigit$1(code) || // 0 .. 9
    code >= 0x0041 && code <= 0x0046 || // A .. F
    code >= 0x0061 && code <= 0x0066 // a .. f
    ;
  } // uppercase letter
  // A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).


  function isUppercaseLetter$1(code) {
    return code >= 0x0041 && code <= 0x005A;
  } // lowercase letter
  // A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).


  function isLowercaseLetter$1(code) {
    return code >= 0x0061 && code <= 0x007A;
  } // letter
  // An uppercase letter or a lowercase letter.


  function isLetter$1(code) {
    return isUppercaseLetter$1(code) || isLowercaseLetter$1(code);
  } // non-ASCII code point
  // A code point with a value equal to or greater than U+0080 <control>.


  function isNonAscii$1(code) {
    return code >= 0x0080;
  } // name-start code point
  // A letter, a non-ASCII code point, or U+005F LOW LINE (_).


  function isNameStart$1(code) {
    return isLetter$1(code) || isNonAscii$1(code) || code === 0x005F;
  } // name code point
  // A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).


  function isName$1(code) {
    return isNameStart$1(code) || isDigit$1(code) || code === 0x002D;
  } // non-printable code point
  // A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
  // or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.


  function isNonPrintable$1(code) {
    return code >= 0x0000 && code <= 0x0008 || code === 0x000B || code >= 0x000E && code <= 0x001F || code === 0x007F;
  } // newline
  // U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
  // as they are converted to U+000A LINE FEED during preprocessing.
  // TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED


  function isNewline$1(code) {
    return code === 0x000A || code === 0x000D || code === 0x000C;
  } // whitespace
  // A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.


  function isWhiteSpace$1(code) {
    return isNewline$1(code) || code === 0x0020 || code === 0x0009;
  } // § 4.3.8. Check if two code points are a valid escape


  function isValidEscape$1(first, second) {
    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    if (first !== 0x005C) {
      return false;
    } // Otherwise, if the second code point is a newline or EOF, return false.


    if (isNewline$1(second) || second === EOF$1) {
      return false;
    } // Otherwise, return true.


    return true;
  } // § 4.3.9. Check if three code points would start an identifier


  function isIdentifierStart$2(first, second, third) {
    // Look at the first code point:
    // U+002D HYPHEN-MINUS
    if (first === 0x002D) {
      // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
      // or the second and third code points are a valid escape, return true. Otherwise, return false.
      return isNameStart$1(second) || second === 0x002D || isValidEscape$1(second, third);
    } // name-start code point


    if (isNameStart$1(first)) {
      // Return true.
      return true;
    } // U+005C REVERSE SOLIDUS (\)


    if (first === 0x005C) {
      // If the first and second code points are a valid escape, return true. Otherwise, return false.
      return isValidEscape$1(first, second);
    } // anything else
    // Return false.


    return false;
  } // § 4.3.10. Check if three code points would start a number


  function isNumberStart$1(first, second, third) {
    // Look at the first code point:
    // U+002B PLUS SIGN (+)
    // U+002D HYPHEN-MINUS (-)
    if (first === 0x002B || first === 0x002D) {
      // If the second code point is a digit, return true.
      if (isDigit$1(second)) {
        return 2;
      } // Otherwise, if the second code point is a U+002E FULL STOP (.)
      // and the third code point is a digit, return true.
      // Otherwise, return false.


      return second === 0x002E && isDigit$1(third) ? 3 : 0;
    } // U+002E FULL STOP (.)


    if (first === 0x002E) {
      // If the second code point is a digit, return true. Otherwise, return false.
      return isDigit$1(second) ? 2 : 0;
    } // digit


    if (isDigit$1(first)) {
      // Return true.
      return 1;
    } // anything else
    // Return false.


    return 0;
  } //
  // Misc
  //
  // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)


  function isBOM$1(code) {
    // UTF-16BE
    if (code === 0xFEFF) {
      return 1;
    } // UTF-16LE


    if (code === 0xFFFE) {
      return 1;
    }

    return 0;
  } // Fast code category
  // Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only


  const CATEGORY = new Array(0x80);
  const EofCategory$1 = 0x80;
  const WhiteSpaceCategory$1 = 0x82;
  const DigitCategory$1 = 0x83;
  const NameStartCategory$1 = 0x84;
  const NonPrintableCategory$1 = 0x85;

  for (let i = 0; i < CATEGORY.length; i++) {
    CATEGORY[i] = isWhiteSpace$1(i) && WhiteSpaceCategory$1 || isDigit$1(i) && DigitCategory$1 || isNameStart$1(i) && NameStartCategory$1 || isNonPrintable$1(i) && NonPrintableCategory$1 || i || EofCategory$1;
  }

  function charCodeCategory$1(code) {
    return code < 0x80 ? CATEGORY[code] : NameStartCategory$1;
  }

  var DigitCategory_1 = DigitCategory$1;
  var EofCategory_1 = EofCategory$1;
  var NameStartCategory_1 = NameStartCategory$1;
  var NonPrintableCategory_1 = NonPrintableCategory$1;
  var WhiteSpaceCategory_1 = WhiteSpaceCategory$1;
  var charCodeCategory_1 = charCodeCategory$1;
  var isBOM_1 = isBOM$1;
  var isDigit_1 = isDigit$1;
  var isHexDigit_1 = isHexDigit$1;
  var isIdentifierStart_1$1 = isIdentifierStart$2;
  var isLetter_1 = isLetter$1;
  var isLowercaseLetter_1 = isLowercaseLetter$1;
  var isName_1 = isName$1;
  var isNameStart_1 = isNameStart$1;
  var isNewline_1 = isNewline$1;
  var isNonAscii_1 = isNonAscii$1;
  var isNonPrintable_1 = isNonPrintable$1;
  var isNumberStart_1 = isNumberStart$1;
  var isUppercaseLetter_1 = isUppercaseLetter$1;
  var isValidEscape_1 = isValidEscape$1;
  var isWhiteSpace_1 = isWhiteSpace$1;

  var charCodeDefinitions = {
  	DigitCategory: DigitCategory_1,
  	EofCategory: EofCategory_1,
  	NameStartCategory: NameStartCategory_1,
  	NonPrintableCategory: NonPrintableCategory_1,
  	WhiteSpaceCategory: WhiteSpaceCategory_1,
  	charCodeCategory: charCodeCategory_1,
  	isBOM: isBOM_1,
  	isDigit: isDigit_1,
  	isHexDigit: isHexDigit_1,
  	isIdentifierStart: isIdentifierStart_1$1,
  	isLetter: isLetter_1,
  	isLowercaseLetter: isLowercaseLetter_1,
  	isName: isName_1,
  	isNameStart: isNameStart_1,
  	isNewline: isNewline_1,
  	isNonAscii: isNonAscii_1,
  	isNonPrintable: isNonPrintable_1,
  	isNumberStart: isNumberStart_1,
  	isUppercaseLetter: isUppercaseLetter_1,
  	isValidEscape: isValidEscape_1,
  	isWhiteSpace: isWhiteSpace_1
  };

  function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
  }

  function getNewlineLength$1(source, offset, code) {
    if (code === 13
    /* \r */
    && getCharCode(source, offset + 1) === 10
    /* \n */
    ) {
        return 2;
      }

    return 1;
  }

  function cmpChar$1(testStr, offset, referenceCode) {
    let code = testStr.charCodeAt(offset); // code.toLowerCase() for A..Z

    if (charCodeDefinitions.isUppercaseLetter(code)) {
      code = code | 32;
    }

    return code === referenceCode;
  }

  function cmpStr$1(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
      return false;
    }

    if (start < 0 || end > testStr.length) {
      return false;
    }

    for (let i = start; i < end; i++) {
      const referenceCode = referenceStr.charCodeAt(i - start);
      let testCode = testStr.charCodeAt(i); // testCode.toLowerCase() for A..Z

      if (charCodeDefinitions.isUppercaseLetter(testCode)) {
        testCode = testCode | 32;
      }

      if (testCode !== referenceCode) {
        return false;
      }
    }

    return true;
  }

  function findWhiteSpaceStart$1(source, offset) {
    for (; offset >= 0; offset--) {
      if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }

    return offset + 1;
  }

  function findWhiteSpaceEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
      if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }

    return offset;
  }

  function findDecimalNumberEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
      if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {
        break;
      }
    }

    return offset;
  } // § 4.3.7. Consume an escaped code point


  function consumeEscaped$1(source, offset) {
    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    // that the next input code point has already been verified to be part of a valid escape.
    offset += 2; // hex digit

    if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {
      // Consume as many hex digits as possible, but no more than 5.
      // Note that this means 1-6 hex digits have been consumed in total.
      for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
        if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {
          break;
        }
      } // If the next input code point is whitespace, consume it as well.


      const code = getCharCode(source, offset);

      if (charCodeDefinitions.isWhiteSpace(code)) {
        offset += getNewlineLength$1(source, offset, code);
      }
    }

    return offset;
  } // §4.3.11. Consume a name
  // Note: This algorithm does not do the verification of the first few code points that are necessary
  // to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
  // ensure that the stream starts with an identifier before calling this algorithm.


  function consumeName$1(source, offset) {
    // Let result initially be an empty string.
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
      const code = source.charCodeAt(offset); // name code point

      if (charCodeDefinitions.isName(code)) {
        // Append the code point to result.
        continue;
      } // the stream starts with a valid escape


      if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
        // Consume an escaped code point. Append the returned code point to result.
        offset = consumeEscaped$1(source, offset) - 1;
        continue;
      } // anything else
      // Reconsume the current input code point. Return result.


      break;
    }

    return offset;
  } // §4.3.12. Consume a number


  function consumeNumber$3(source, offset) {
    let code = source.charCodeAt(offset); // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    // consume it and append it to repr.

    if (code === 0x002B || code === 0x002D) {
      code = source.charCodeAt(offset += 1);
    } // 3. While the next input code point is a digit, consume it and append it to repr.


    if (charCodeDefinitions.isDigit(code)) {
      offset = findDecimalNumberEnd$1(source, offset + 1);
      code = source.charCodeAt(offset);
    } // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:


    if (code === 0x002E && charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))) {
      // 4.1 Consume them.
      // 4.2 Append them to repr.
      offset += 2; // 4.3 Set type to "number".
      // TODO
      // 4.4 While the next input code point is a digit, consume it and append it to repr.

      offset = findDecimalNumberEnd$1(source, offset);
    } // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:


    if (cmpChar$1(source, offset, 101
    /* e */
    )) {
      let sign = 0;
      code = source.charCodeAt(offset + 1); // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...

      if (code === 0x002D || code === 0x002B) {
        sign = 1;
        code = source.charCodeAt(offset + 2);
      } // ... followed by a digit


      if (charCodeDefinitions.isDigit(code)) {
        // 5.1 Consume them.
        // 5.2 Append them to repr.
        // 5.3 Set type to "number".
        // TODO
        // 5.4 While the next input code point is a digit, consume it and append it to repr.
        offset = findDecimalNumberEnd$1(source, offset + 1 + sign + 1);
      }
    }

    return offset;
  } // § 4.3.14. Consume the remnants of a bad url
  // ... its sole use is to consume enough of the input stream to reach a recovery point
  // where normal tokenizing can resume.


  function consumeBadUrlRemnants$1(source, offset) {
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
      const code = source.charCodeAt(offset); // U+0029 RIGHT PARENTHESIS ())
      // EOF

      if (code === 0x0029) {
        // Return.
        offset++;
        break;
      }

      if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
        // Consume an escaped code point.
        // Note: This allows an escaped right parenthesis ("\)") to be encountered
        // without ending the <bad-url-token>. This is otherwise identical to
        // the "anything else" clause.
        offset = consumeEscaped$1(source, offset);
      }
    }

    return offset;
  } // § 4.3.7. Consume an escaped code point
  // Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\)


  function decodeEscaped$1(escaped) {
    // Single char escaped that's not a hex digit
    if (escaped.length === 1 && !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))) {
      return escaped[0];
    } // Interpret the hex digits as a hexadecimal number.


    let code = parseInt(escaped, 16);

    if (code === 0 || // If this number is zero,
    code >= 0xD800 && code <= 0xDFFF || // or is for a surrogate,
    code > 0x10FFFF // or is greater than the maximum allowed code point
    ) {
        // ... return U+FFFD REPLACEMENT CHARACTER
        code = 0xFFFD;
      } // Otherwise, return the code point with that value.


    return String.fromCodePoint(code);
  }

  var cmpChar_1 = cmpChar$1;
  var cmpStr_1 = cmpStr$1;
  var consumeBadUrlRemnants_1 = consumeBadUrlRemnants$1;
  var consumeEscaped_1 = consumeEscaped$1;
  var consumeName_1 = consumeName$1;
  var consumeNumber_1 = consumeNumber$3;
  var decodeEscaped_1 = decodeEscaped$1;
  var findDecimalNumberEnd_1 = findDecimalNumberEnd$1;
  var findWhiteSpaceEnd_1 = findWhiteSpaceEnd$1;
  var findWhiteSpaceStart_1 = findWhiteSpaceStart$1;
  var getNewlineLength_1 = getNewlineLength$1;

  var utils$9 = {
  	cmpChar: cmpChar_1,
  	cmpStr: cmpStr_1,
  	consumeBadUrlRemnants: consumeBadUrlRemnants_1,
  	consumeEscaped: consumeEscaped_1,
  	consumeName: consumeName_1,
  	consumeNumber: consumeNumber_1,
  	decodeEscaped: decodeEscaped_1,
  	findDecimalNumberEnd: findDecimalNumberEnd_1,
  	findWhiteSpaceEnd: findWhiteSpaceEnd_1,
  	findWhiteSpaceStart: findWhiteSpaceStart_1,
  	getNewlineLength: getNewlineLength_1
  };

  const tokenNames$2 = ['EOF-token', 'ident-token', 'function-token', 'at-keyword-token', 'hash-token', 'string-token', 'bad-string-token', 'url-token', 'bad-url-token', 'delim-token', 'number-token', 'percentage-token', 'dimension-token', 'whitespace-token', 'CDO-token', 'CDC-token', 'colon-token', 'semicolon-token', 'comma-token', '[-token', ']-token', '(-token', ')-token', '{-token', '}-token'];
  var names$1 = tokenNames$2;

  const MIN_SIZE = 16 * 1024;

  function adoptBuffer(buffer = null, size) {
    if (buffer === null || buffer.length < size) {
      return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }

    return buffer;
  }

  var adoptBuffer_2 = adoptBuffer;

  var adoptBuffer_1 = {
  	adoptBuffer: adoptBuffer_2
  };

  const N$5 = 10;
  const F$3 = 12;
  const R$3 = 13;

  function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? charCodeDefinitions.isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer_1.adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer_1.adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;

    for (let i = startOffset; i < sourceLength; i++) {
      const code = source.charCodeAt(i);
      lines[i] = line;
      columns[i] = column++;

      if (code === N$5 || code === R$3 || code === F$3) {
        if (code === R$3 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$5) {
          i++;
          lines[i] = line;
          columns[i] = column;
        }

        line++;
        column = 1;
      }
    }

    lines[sourceLength] = line;
    columns[sourceLength] = column;
    host.lines = lines;
    host.columns = columns;
    host.computed = true;
  }

  class OffsetToLocation {
    constructor() {
      this.lines = null;
      this.columns = null;
      this.computed = false;
    }

    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
      this.source = source;
      this.startOffset = startOffset;
      this.startLine = startLine;
      this.startColumn = startColumn;
      this.computed = false;
    }

    getLocation(offset, filename) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }

      return {
        source: filename,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
      };
    }

    getLocationRange(start, end, filename) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }

      return {
        source: filename,
        start: {
          offset: this.startOffset + start,
          line: this.lines[start],
          column: this.columns[start]
        },
        end: {
          offset: this.startOffset + end,
          line: this.lines[end],
          column: this.columns[end]
        }
      };
    }

  }

  var OffsetToLocation_2 = OffsetToLocation;

  var OffsetToLocation_1$1 = {
  	OffsetToLocation: OffsetToLocation_2
  };

  const OFFSET_MASK = 0x00FFFFFF;
  const TYPE_SHIFT = 24;
  const balancePair$1 = new Map([[types$4.Function, types$4.RightParenthesis], [types$4.LeftParenthesis, types$4.RightParenthesis], [types$4.LeftSquareBracket, types$4.RightSquareBracket], [types$4.LeftCurlyBracket, types$4.RightCurlyBracket]]);

  class TokenStream {
    constructor(source, tokenize) {
      this.setSource(source, tokenize);
    }

    reset() {
      this.eof = false;
      this.tokenIndex = -1;
      this.tokenType = 0;
      this.tokenStart = this.firstCharOffset;
      this.tokenEnd = this.firstCharOffset;
    }

    setSource(source = '', tokenize = () => {}) {
      source = String(source || '');
      const sourceLength = source.length;
      const offsetAndType = adoptBuffer_1.adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token

      const balance = adoptBuffer_1.adoptBuffer(this.balance, source.length + 1);
      let tokenCount = 0;
      let balanceCloseType = 0;
      let balanceStart = 0;
      let firstCharOffset = -1; // capture buffers

      this.offsetAndType = null;
      this.balance = null;
      tokenize(source, (type, start, end) => {
        switch (type) {
          default:
            balance[tokenCount] = sourceLength;
            break;

          case balanceCloseType:
            {
              let balancePrev = balanceStart & OFFSET_MASK;
              balanceStart = balance[balancePrev];
              balanceCloseType = balanceStart >> TYPE_SHIFT;
              balance[tokenCount] = balancePrev;
              balance[balancePrev++] = tokenCount;

              for (; balancePrev < tokenCount; balancePrev++) {
                if (balance[balancePrev] === sourceLength) {
                  balance[balancePrev] = tokenCount;
                }
              }

              break;
            }

          case types$4.LeftParenthesis:
          case types$4.Function:
          case types$4.LeftSquareBracket:
          case types$4.LeftCurlyBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = balancePair$1.get(type);
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
        }

        offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;

        if (firstCharOffset === -1) {
          firstCharOffset = start;
        }
      }); // finalize buffers

      offsetAndType[tokenCount] = types$4.EOF << TYPE_SHIFT | sourceLength; // <EOF-token>

      balance[tokenCount] = sourceLength;
      balance[sourceLength] = sourceLength; // prevents false positive balance match with any token

      while (balanceStart !== 0) {
        const balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
      }

      this.source = source;
      this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
      this.tokenCount = tokenCount;
      this.offsetAndType = offsetAndType;
      this.balance = balance;
      this.reset();
      this.next();
    }

    lookupType(offset) {
      offset += this.tokenIndex;

      if (offset < this.tokenCount) {
        return this.offsetAndType[offset] >> TYPE_SHIFT;
      }

      return types$4.EOF;
    }

    lookupOffset(offset) {
      offset += this.tokenIndex;

      if (offset < this.tokenCount) {
        return this.offsetAndType[offset - 1] & OFFSET_MASK;
      }

      return this.source.length;
    }

    lookupValue(offset, referenceStr) {
      offset += this.tokenIndex;

      if (offset < this.tokenCount) {
        return utils$9.cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
      }

      return false;
    }

    getTokenStart(tokenIndex) {
      if (tokenIndex === this.tokenIndex) {
        return this.tokenStart;
      }

      if (tokenIndex > 0) {
        return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
      }

      return this.firstCharOffset;
    }

    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    }

    isBalanceEdge(pos) {
      return this.balance[this.tokenIndex] < pos;
    }

    isDelim(code, offset) {
      if (offset) {
        return this.lookupType(offset) === types$4.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
      }

      return this.tokenType === types$4.Delim && this.source.charCodeAt(this.tokenStart) === code;
    }

    skip(tokenCount) {
      let next = this.tokenIndex + tokenCount;

      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.tokenIndex = this.tokenCount;
        this.next();
      }
    }

    next() {
      let next = this.tokenIndex + 1;

      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.tokenEnd;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.eof = true;
        this.tokenIndex = this.tokenCount;
        this.tokenType = types$4.EOF;
        this.tokenStart = this.tokenEnd = this.source.length;
      }
    }

    skipSC() {
      while (this.tokenType === types$4.WhiteSpace || this.tokenType === types$4.Comment) {
        this.next();
      }
    }

    skipUntilBalanced(startToken, stopConsume) {
      let cursor = startToken;
      let balanceEnd;
      let offset;

      loop: for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor]; // stop scanning on balance edge that points to offset before start token

        if (balanceEnd < startToken) {
          break loop;
        }

        offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset; // check stop condition

        switch (stopConsume(this.source.charCodeAt(offset))) {
          case 1:
            // just stop
            break loop;

          case 2:
            // stop & included
            cursor++;
            break loop;

          default:
            // fast forward to the end of balanced block
            if (this.balance[balanceEnd] === cursor) {
              cursor = balanceEnd;
            }

        }
      }

      this.skip(cursor - this.tokenIndex);
    }

    forEachToken(fn) {
      for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
        const start = offset;
        const item = this.offsetAndType[i];
        const end = item & OFFSET_MASK;
        const type = item >> TYPE_SHIFT;
        offset = end;
        fn(type, start, end, i);
      }
    }

    dump() {
      const tokens = new Array(this.tokenCount);
      this.forEachToken((type, start, end, index) => {
        tokens[index] = {
          idx: index,
          type: names$1[type],
          chunk: this.source.substring(start, end),
          balance: this.balance[index]
        };
      });
      return tokens;
    }

  }

  var TokenStream_2 = TokenStream;

  var TokenStream_1$2 = {
  	TokenStream: TokenStream_2
  };

  function tokenize$8(source, onToken) {
    function getCharCode(offset) {
      return offset < sourceLength ? source.charCodeAt(offset) : 0;
    } // § 4.3.3. Consume a numeric token


    function consumeNumericToken() {
      // Consume a number and let number be the result.
      offset = utils$9.consumeNumber(source, offset); // If the next 3 input code points would start an identifier, then:

      if (charCodeDefinitions.isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
        // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
        // Consume a name. Set the <dimension-token>’s unit to the returned value.
        // Return the <dimension-token>.
        type = types$4.Dimension;
        offset = utils$9.consumeName(source, offset);
        return;
      } // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.


      if (getCharCode(offset) === 0x0025) {
        // Create a <percentage-token> with the same value as number, and return it.
        type = types$4.Percentage;
        offset++;
        return;
      } // Otherwise, create a <number-token> with the same value and type flag as number, and return it.


      type = types$4.Number;
    } // § 4.3.4. Consume an ident-like token


    function consumeIdentLikeToken() {
      const nameStartOffset = offset; // Consume a name, and let string be the result.

      offset = utils$9.consumeName(source, offset); // If string’s value is an ASCII case-insensitive match for "url",
      // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.

      if (utils$9.cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
        // While the next two input code points are whitespace, consume the next input code point.
        offset = utils$9.findWhiteSpaceEnd(source, offset + 1); // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
        // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
        // then create a <function-token> with its value set to string and return it.

        if (getCharCode(offset) === 0x0022 || getCharCode(offset) === 0x0027) {
          type = types$4.Function;
          offset = nameStartOffset + 4;
          return;
        } // Otherwise, consume a url token, and return it.


        consumeUrlToken();
        return;
      } // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
      // Create a <function-token> with its value set to string and return it.


      if (getCharCode(offset) === 0x0028) {
        type = types$4.Function;
        offset++;
        return;
      } // Otherwise, create an <ident-token> with its value set to string and return it.


      type = types$4.Ident;
    } // § 4.3.5. Consume a string token


    function consumeStringToken(endingCodePoint) {
      // This algorithm may be called with an ending code point, which denotes the code point
      // that ends the string. If an ending code point is not specified,
      // the current input code point is used.
      if (!endingCodePoint) {
        endingCodePoint = getCharCode(offset++);
      } // Initially create a <string-token> with its value set to the empty string.


      type = types$4.String; // Repeatedly consume the next input code point from the stream:

      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);

        switch (charCodeDefinitions.charCodeCategory(code)) {
          // ending code point
          case endingCodePoint:
            // Return the <string-token>.
            offset++;
            return;
          // EOF
          // case EofCategory:
          // This is a parse error. Return the <string-token>.
          // return;
          // newline

          case charCodeDefinitions.WhiteSpaceCategory:
            if (charCodeDefinitions.isNewline(code)) {
              // This is a parse error. Reconsume the current input code point,
              // create a <bad-string-token>, and return it.
              offset += utils$9.getNewlineLength(source, offset, code);
              type = types$4.BadString;
              return;
            }

            break;
          // U+005C REVERSE SOLIDUS (\)

          case 0x005C:
            // If the next input code point is EOF, do nothing.
            if (offset === source.length - 1) {
              break;
            }

            const nextCode = getCharCode(offset + 1); // Otherwise, if the next input code point is a newline, consume it.

            if (charCodeDefinitions.isNewline(nextCode)) {
              offset += utils$9.getNewlineLength(source, offset + 1, nextCode);
            } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {
              // Otherwise, (the stream starts with a valid escape) consume
              // an escaped code point and append the returned code point to
              // the <string-token>’s value.
              offset = utils$9.consumeEscaped(source, offset) - 1;
            }

            break;
          // anything else
          // Append the current input code point to the <string-token>’s value.
        }
      }
    } // § 4.3.6. Consume a url token
    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.


    function consumeUrlToken() {
      // Initially create a <url-token> with its value set to the empty string.
      type = types$4.Url; // Consume as much whitespace as possible.

      offset = utils$9.findWhiteSpaceEnd(source, offset); // Repeatedly consume the next input code point from the stream:

      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);

        switch (charCodeDefinitions.charCodeCategory(code)) {
          // U+0029 RIGHT PARENTHESIS ())
          case 0x0029:
            // Return the <url-token>.
            offset++;
            return;
          // EOF
          // case EofCategory:
          // This is a parse error. Return the <url-token>.
          // return;
          // whitespace

          case charCodeDefinitions.WhiteSpaceCategory:
            // Consume as much whitespace as possible.
            offset = utils$9.findWhiteSpaceEnd(source, offset); // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
            // consume it and return the <url-token>
            // (if EOF was encountered, this is a parse error);

            if (getCharCode(offset) === 0x0029 || offset >= source.length) {
              if (offset < source.length) {
                offset++;
              }

              return;
            } // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
            // and return it.


            offset = utils$9.consumeBadUrlRemnants(source, offset);
            type = types$4.BadUrl;
            return;
          // U+0022 QUOTATION MARK (")
          // U+0027 APOSTROPHE (')
          // U+0028 LEFT PARENTHESIS (()
          // non-printable code point

          case 0x0022:
          case 0x0027:
          case 0x0028:
          case charCodeDefinitions.NonPrintableCategory:
            // This is a parse error. Consume the remnants of a bad url,
            // create a <bad-url-token>, and return it.
            offset = utils$9.consumeBadUrlRemnants(source, offset);
            type = types$4.BadUrl;
            return;
          // U+005C REVERSE SOLIDUS (\)

          case 0x005C:
            // If the stream starts with a valid escape, consume an escaped code point and
            // append the returned code point to the <url-token>’s value.
            if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
              offset = utils$9.consumeEscaped(source, offset) - 1;
              break;
            } // Otherwise, this is a parse error. Consume the remnants of a bad url,
            // create a <bad-url-token>, and return it.


            offset = utils$9.consumeBadUrlRemnants(source, offset);
            type = types$4.BadUrl;
            return;
          // anything else
          // Append the current input code point to the <url-token>’s value.
        }
      }
    } // ensure source is a string


    source = String(source || '');
    const sourceLength = source.length;
    let start = charCodeDefinitions.isBOM(getCharCode(0));
    let offset = start;
    let type; // https://drafts.csswg.org/css-syntax-3/#consume-token
    // § 4.3.1. Consume a token

    while (offset < sourceLength) {
      const code = source.charCodeAt(offset);

      switch (charCodeDefinitions.charCodeCategory(code)) {
        // whitespace
        case charCodeDefinitions.WhiteSpaceCategory:
          // Consume as much whitespace as possible. Return a <whitespace-token>.
          type = types$4.WhiteSpace;
          offset = utils$9.findWhiteSpaceEnd(source, offset + 1);
          break;
        // U+0022 QUOTATION MARK (")

        case 0x0022:
          // Consume a string token and return it.
          consumeStringToken();
          break;
        // U+0023 NUMBER SIGN (#)

        case 0x0023:
          // If the next input code point is a name code point or the next two input code points are a valid escape, then:
          if (charCodeDefinitions.isName(getCharCode(offset + 1)) || charCodeDefinitions.isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
            // Create a <hash-token>.
            type = types$4.Hash; // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
            // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
            //     // TODO: set id flag
            // }
            // Consume a name, and set the <hash-token>’s value to the returned string.

            offset = utils$9.consumeName(source, offset + 1); // Return the <hash-token>.
          } else {
            // Otherwise, return a <delim-token> with its value set to the current input code point.
            type = types$4.Delim;
            offset++;
          }

          break;
        // U+0027 APOSTROPHE (')

        case 0x0027:
          // Consume a string token and return it.
          consumeStringToken();
          break;
        // U+0028 LEFT PARENTHESIS (()

        case 0x0028:
          // Return a <(-token>.
          type = types$4.LeftParenthesis;
          offset++;
          break;
        // U+0029 RIGHT PARENTHESIS ())

        case 0x0029:
          // Return a <)-token>.
          type = types$4.RightParenthesis;
          offset++;
          break;
        // U+002B PLUS SIGN (+)

        case 0x002B:
          // If the input stream starts with a number, ...
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            // ... reconsume the current input code point, consume a numeric token, and return it.
            consumeNumericToken();
          } else {
            // Otherwise, return a <delim-token> with its value set to the current input code point.
            type = types$4.Delim;
            offset++;
          }

          break;
        // U+002C COMMA (,)

        case 0x002C:
          // Return a <comma-token>.
          type = types$4.Comma;
          offset++;
          break;
        // U+002D HYPHEN-MINUS (-)

        case 0x002D:
          // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            consumeNumericToken();
          } else {
            // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
            if (getCharCode(offset + 1) === 0x002D && getCharCode(offset + 2) === 0x003E) {
              type = types$4.CDC;
              offset = offset + 3;
            } else {
              // Otherwise, if the input stream starts with an identifier, ...
              if (charCodeDefinitions.isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                // ... reconsume the current input code point, consume an ident-like token, and return it.
                consumeIdentLikeToken();
              } else {
                // Otherwise, return a <delim-token> with its value set to the current input code point.
                type = types$4.Delim;
                offset++;
              }
            }
          }

          break;
        // U+002E FULL STOP (.)

        case 0x002E:
          // If the input stream starts with a number, ...
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            // ... reconsume the current input code point, consume a numeric token, and return it.
            consumeNumericToken();
          } else {
            // Otherwise, return a <delim-token> with its value set to the current input code point.
            type = types$4.Delim;
            offset++;
          }

          break;
        // U+002F SOLIDUS (/)

        case 0x002F:
          // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
          if (getCharCode(offset + 1) === 0x002A) {
            // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
            // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
            type = types$4.Comment;
            offset = source.indexOf('*/', offset + 2);
            offset = offset === -1 ? source.length : offset + 2;
          } else {
            type = types$4.Delim;
            offset++;
          }

          break;
        // U+003A COLON (:)

        case 0x003A:
          // Return a <colon-token>.
          type = types$4.Colon;
          offset++;
          break;
        // U+003B SEMICOLON (;)

        case 0x003B:
          // Return a <semicolon-token>.
          type = types$4.Semicolon;
          offset++;
          break;
        // U+003C LESS-THAN SIGN (<)

        case 0x003C:
          // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
          if (getCharCode(offset + 1) === 0x0021 && getCharCode(offset + 2) === 0x002D && getCharCode(offset + 3) === 0x002D) {
            // ... consume them and return a <CDO-token>.
            type = types$4.CDO;
            offset = offset + 4;
          } else {
            // Otherwise, return a <delim-token> with its value set to the current input code point.
            type = types$4.Delim;
            offset++;
          }

          break;
        // U+0040 COMMERCIAL AT (@)

        case 0x0040:
          // If the next 3 input code points would start an identifier, ...
          if (charCodeDefinitions.isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
            // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
            type = types$4.AtKeyword;
            offset = utils$9.consumeName(source, offset + 1);
          } else {
            // Otherwise, return a <delim-token> with its value set to the current input code point.
            type = types$4.Delim;
            offset++;
          }

          break;
        // U+005B LEFT SQUARE BRACKET ([)

        case 0x005B:
          // Return a <[-token>.
          type = types$4.LeftSquareBracket;
          offset++;
          break;
        // U+005C REVERSE SOLIDUS (\)

        case 0x005C:
          // If the input stream starts with a valid escape, ...
          if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
            // ... reconsume the current input code point, consume an ident-like token, and return it.
            consumeIdentLikeToken();
          } else {
            // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
            type = types$4.Delim;
            offset++;
          }

          break;
        // U+005D RIGHT SQUARE BRACKET (])

        case 0x005D:
          // Return a <]-token>.
          type = types$4.RightSquareBracket;
          offset++;
          break;
        // U+007B LEFT CURLY BRACKET ({)

        case 0x007B:
          // Return a <{-token>.
          type = types$4.LeftCurlyBracket;
          offset++;
          break;
        // U+007D RIGHT CURLY BRACKET (})

        case 0x007D:
          // Return a <}-token>.
          type = types$4.RightCurlyBracket;
          offset++;
          break;
        // digit

        case charCodeDefinitions.DigitCategory:
          // Reconsume the current input code point, consume a numeric token, and return it.
          consumeNumericToken();
          break;
        // name-start code point

        case charCodeDefinitions.NameStartCategory:
          // Reconsume the current input code point, consume an ident-like token, and return it.
          consumeIdentLikeToken();
          break;
        // EOF
        // case EofCategory:
        // Return an <EOF-token>.
        // break;
        // anything else

        default:
          // Return a <delim-token> with its value set to the current input code point.
          type = types$4.Delim;
          offset++;
      } // put token to stream


      onToken(type, start, start = offset);
    }
  }

  var AtKeyword = types$4.AtKeyword;
  var BadString = types$4.BadString;
  var BadUrl = types$4.BadUrl;
  var CDC$1 = types$4.CDC;
  var CDO$1 = types$4.CDO;
  var Colon = types$4.Colon;
  var Comma = types$4.Comma;
  var Comment$2 = types$4.Comment;
  var Delim = types$4.Delim;
  var Dimension$1 = types$4.Dimension;
  var EOF = types$4.EOF;
  var _Function$3 = types$4.Function;
  var Hash$1 = types$4.Hash;
  var Ident = types$4.Ident;
  var LeftCurlyBracket = types$4.LeftCurlyBracket;
  var LeftParenthesis = types$4.LeftParenthesis;
  var LeftSquareBracket = types$4.LeftSquareBracket;
  var _Number$3 = types$4.Number;
  var Percentage$1 = types$4.Percentage;
  var RightCurlyBracket = types$4.RightCurlyBracket;
  var RightParenthesis = types$4.RightParenthesis;
  var RightSquareBracket = types$4.RightSquareBracket;
  var Semicolon = types$4.Semicolon;
  var _String$3 = types$4.String;
  var Url$1 = types$4.Url;
  var WhiteSpace$1 = types$4.WhiteSpace;
  var tokenTypes$3 = types$4;
  var DigitCategory = charCodeDefinitions.DigitCategory;
  var EofCategory = charCodeDefinitions.EofCategory;
  var NameStartCategory = charCodeDefinitions.NameStartCategory;
  var NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;
  var WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;
  var charCodeCategory = charCodeDefinitions.charCodeCategory;
  var isBOM = charCodeDefinitions.isBOM;
  var isDigit = charCodeDefinitions.isDigit;
  var isHexDigit = charCodeDefinitions.isHexDigit;
  var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
  var isLetter = charCodeDefinitions.isLetter;
  var isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;
  var isName = charCodeDefinitions.isName;
  var isNameStart = charCodeDefinitions.isNameStart;
  var isNewline = charCodeDefinitions.isNewline;
  var isNonAscii = charCodeDefinitions.isNonAscii;
  var isNonPrintable = charCodeDefinitions.isNonPrintable;
  var isNumberStart = charCodeDefinitions.isNumberStart;
  var isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;
  var isValidEscape = charCodeDefinitions.isValidEscape;
  var isWhiteSpace = charCodeDefinitions.isWhiteSpace;
  var cmpChar = utils$9.cmpChar;
  var cmpStr = utils$9.cmpStr;
  var consumeBadUrlRemnants = utils$9.consumeBadUrlRemnants;
  var consumeEscaped = utils$9.consumeEscaped;
  var consumeName = utils$9.consumeName;
  var consumeNumber$2 = utils$9.consumeNumber;
  var decodeEscaped = utils$9.decodeEscaped;
  var findDecimalNumberEnd = utils$9.findDecimalNumberEnd;
  var findWhiteSpaceEnd = utils$9.findWhiteSpaceEnd;
  var findWhiteSpaceStart = utils$9.findWhiteSpaceStart;
  var getNewlineLength = utils$9.getNewlineLength;
  var tokenNames$1 = names$1;
  var OffsetToLocation_1 = OffsetToLocation_1$1.OffsetToLocation;
  var TokenStream_1$1 = TokenStream_1$2.TokenStream;
  var tokenize_1$2 = tokenize$8;

  var tokenizer$2 = {
  	AtKeyword: AtKeyword,
  	BadString: BadString,
  	BadUrl: BadUrl,
  	CDC: CDC$1,
  	CDO: CDO$1,
  	Colon: Colon,
  	Comma: Comma,
  	Comment: Comment$2,
  	Delim: Delim,
  	Dimension: Dimension$1,
  	EOF: EOF,
  	Function: _Function$3,
  	Hash: Hash$1,
  	Ident: Ident,
  	LeftCurlyBracket: LeftCurlyBracket,
  	LeftParenthesis: LeftParenthesis,
  	LeftSquareBracket: LeftSquareBracket,
  	Number: _Number$3,
  	Percentage: Percentage$1,
  	RightCurlyBracket: RightCurlyBracket,
  	RightParenthesis: RightParenthesis,
  	RightSquareBracket: RightSquareBracket,
  	Semicolon: Semicolon,
  	String: _String$3,
  	Url: Url$1,
  	WhiteSpace: WhiteSpace$1,
  	tokenTypes: tokenTypes$3,
  	DigitCategory: DigitCategory,
  	EofCategory: EofCategory,
  	NameStartCategory: NameStartCategory,
  	NonPrintableCategory: NonPrintableCategory,
  	WhiteSpaceCategory: WhiteSpaceCategory,
  	charCodeCategory: charCodeCategory,
  	isBOM: isBOM,
  	isDigit: isDigit,
  	isHexDigit: isHexDigit,
  	isIdentifierStart: isIdentifierStart$1,
  	isLetter: isLetter,
  	isLowercaseLetter: isLowercaseLetter,
  	isName: isName,
  	isNameStart: isNameStart,
  	isNewline: isNewline,
  	isNonAscii: isNonAscii,
  	isNonPrintable: isNonPrintable,
  	isNumberStart: isNumberStart,
  	isUppercaseLetter: isUppercaseLetter,
  	isValidEscape: isValidEscape,
  	isWhiteSpace: isWhiteSpace,
  	cmpChar: cmpChar,
  	cmpStr: cmpStr,
  	consumeBadUrlRemnants: consumeBadUrlRemnants,
  	consumeEscaped: consumeEscaped,
  	consumeName: consumeName,
  	consumeNumber: consumeNumber$2,
  	decodeEscaped: decodeEscaped,
  	findDecimalNumberEnd: findDecimalNumberEnd,
  	findWhiteSpaceEnd: findWhiteSpaceEnd,
  	findWhiteSpaceStart: findWhiteSpaceStart,
  	getNewlineLength: getNewlineLength,
  	tokenNames: tokenNames$1,
  	OffsetToLocation: OffsetToLocation_1,
  	TokenStream: TokenStream_1$1,
  	tokenize: tokenize_1$2
  };

  //                              list
  //                            ┌──────┐
  //             ┌──────────────┼─head │
  //             │              │ tail─┼──────────────┐
  //             │              └──────┘              │
  //             ▼                                    ▼
  //            item        item        item        item
  //          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
  //  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
  //          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
  //          ├──────┤    ├──────┤    ├──────┤    ├──────┤
  //          │ data │    │ data │    │ data │    │ data │
  //          └──────┘    └──────┘    └──────┘    └──────┘
  //

  let releasedCursors = null;

  class List$1 {
    static createItem(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }

    constructor() {
      this.head = null;
      this.tail = null;
      this.cursor = null;
    }

    createItem(data) {
      return List$1.createItem(data);
    } // cursor helpers


    allocateCursor(prev, next) {
      let cursor;

      if (releasedCursors !== null) {
        cursor = releasedCursors;
        releasedCursors = releasedCursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = this.cursor;
      } else {
        cursor = {
          prev,
          next,
          cursor: this.cursor
        };
      }

      this.cursor = cursor;
      return cursor;
    }

    releaseCursor() {
      const {
        cursor
      } = this;
      this.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = releasedCursors;
      releasedCursors = cursor;
    }

    updateCursors(prevOld, prevNew, nextOld, nextNew) {
      let {
        cursor
      } = this;

      while (cursor !== null) {
        if (cursor.prev === prevOld) {
          cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
          cursor.next = nextNew;
        }

        cursor = cursor.cursor;
      }
    }

    *[Symbol.iterator]() {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        yield cursor.data;
      }
    } // getters


    get size() {
      let size = 0;

      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        size++;
      }

      return size;
    }

    get isEmpty() {
      return this.head === null;
    }

    get first() {
      return this.head && this.head.data;
    }

    get last() {
      return this.tail && this.tail.data;
    } // convertors


    fromArray(array) {
      let cursor = null;
      this.head = null;

      for (let data of array) {
        const item = List$1.createItem(data);

        if (cursor !== null) {
          cursor.next = item;
        } else {
          this.head = item;
        }

        item.prev = cursor;
        cursor = item;
      }

      this.tail = cursor;
      return this;
    }

    toArray() {
      return [...this];
    }

    toJSON() {
      return [...this];
    } // array-like methods


    forEach(fn, thisArg = this) {
      // push cursor
      const cursor = this.allocateCursor(null, this.head);

      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        fn.call(thisArg, item.data, item, this);
      } // pop cursor


      this.releaseCursor();
    }

    forEachRight(fn, thisArg = this) {
      // push cursor
      const cursor = this.allocateCursor(this.tail, null);

      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        fn.call(thisArg, item.data, item, this);
      } // pop cursor


      this.releaseCursor();
    }

    reduce(fn, initialValue, thisArg = this) {
      // push cursor
      let cursor = this.allocateCursor(null, this.head);
      let acc = initialValue;
      let item;

      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn.call(thisArg, acc, item.data, item, this);
      } // pop cursor


      this.releaseCursor();
      return acc;
    }

    reduceRight(fn, initialValue, thisArg = this) {
      // push cursor
      let cursor = this.allocateCursor(this.tail, null);
      let acc = initialValue;
      let item;

      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn.call(thisArg, acc, item.data, item, this);
      } // pop cursor


      this.releaseCursor();
      return acc;
    }

    some(fn, thisArg = this) {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this)) {
          return true;
        }
      }

      return false;
    }

    map(fn, thisArg = this) {
      const result = new List$1();

      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        result.appendData(fn.call(thisArg, cursor.data, cursor, this));
      }

      return result;
    }

    filter(fn, thisArg = this) {
      const result = new List$1();

      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this)) {
          result.appendData(cursor.data);
        }
      }

      return result;
    }

    nextUntil(start, fn, thisArg = this) {
      if (start === null) {
        return;
      } // push cursor


      const cursor = this.allocateCursor(null, start);

      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;

        if (fn.call(thisArg, item.data, item, this)) {
          break;
        }
      } // pop cursor


      this.releaseCursor();
    }

    prevUntil(start, fn, thisArg = this) {
      if (start === null) {
        return;
      } // push cursor


      const cursor = this.allocateCursor(start, null);

      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(thisArg, item.data, item, this)) {
          break;
        }
      } // pop cursor


      this.releaseCursor();
    } // mutation


    clear() {
      this.head = null;
      this.tail = null;
    }

    copy() {
      const result = new List$1();

      for (let data of this) {
        result.appendData(data);
      }

      return result;
    }

    prepend(item) {
      //      head
      //    ^
      // item
      this.updateCursors(null, item, this.head, item); // insert to the beginning of the list

      if (this.head !== null) {
        // new item <- first item
        this.head.prev = item; // new item -> first item

        item.next = this.head;
      } else {
        // if list has no head, then it also has no tail
        // in this case tail points to the new item
        this.tail = item;
      } // head always points to new item


      this.head = item;
      return this;
    }

    prependData(data) {
      return this.prepend(List$1.createItem(data));
    }

    append(item) {
      return this.insert(item);
    }

    appendData(data) {
      return this.insert(List$1.createItem(data));
    }

    insert(item, before = null) {
      if (before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
          // insert to the beginning of list
          if (this.head !== before) {
            throw new Error('before doesn\'t belong to list');
          } // since head points to before therefore list doesn't empty
          // no need to check tail


          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          // insert between two items
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        // tail
        //      ^
        //      item
        this.updateCursors(this.tail, item, null, item); // insert to the ending of the list

        if (this.tail !== null) {
          // last item -> new item
          this.tail.next = item; // last item <- new item

          item.prev = this.tail;
        } else {
          // if list has no tail, then it also has no head
          // in this case head points to new item
          this.head = item;
        } // tail always points to new item


        this.tail = item;
      }

      return this;
    }

    insertData(data, before) {
      return this.insert(List$1.createItem(data), before);
    }

    remove(item) {
      //      item
      //       ^
      // prev     next
      this.updateCursors(item, item.prev, item, item.next);

      if (item.prev !== null) {
        item.prev.next = item.next;
      } else {
        if (this.head !== item) {
          throw new Error('item doesn\'t belong to list');
        }

        this.head = item.next;
      }

      if (item.next !== null) {
        item.next.prev = item.prev;
      } else {
        if (this.tail !== item) {
          throw new Error('item doesn\'t belong to list');
        }

        this.tail = item.prev;
      }

      item.prev = null;
      item.next = null;
      return item;
    }

    push(data) {
      this.insert(List$1.createItem(data));
    }

    pop() {
      return this.tail !== null ? this.remove(this.tail) : null;
    }

    unshift(data) {
      this.prepend(List$1.createItem(data));
    }

    shift() {
      return this.head !== null ? this.remove(this.head) : null;
    }

    prependList(list) {
      return this.insertList(list, this.head);
    }

    appendList(list) {
      return this.insertList(list);
    }

    insertList(list, before) {
      // ignore empty lists
      if (list.head === null) {
        return this;
      }

      if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head); // insert in the middle of dist list

        if (before.prev !== null) {
          // before.prev <-> list.head
          before.prev.next = list.head;
          list.head.prev = before.prev;
        } else {
          this.head = list.head;
        }

        before.prev = list.tail;
        list.tail.next = before;
      } else {
        this.updateCursors(this.tail, list.tail, null, list.head); // insert to end of the list

        if (this.tail !== null) {
          // if destination list has a tail, then it also has a head,
          // but head doesn't change
          // dest tail -> source head
          this.tail.next = list.head; // dest tail <- source head

          list.head.prev = this.tail;
        } else {
          // if list has no a tail, then it also has no a head
          // in this case points head to new item
          this.head = list.head;
        } // tail always start point to new item


        this.tail = list.tail;
      }

      list.head = null;
      list.tail = null;
      return this;
    }

    replace(oldItem, newItemOrList) {
      if ('head' in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
      } else {
        this.insert(newItemOrList, oldItem);
      }

      this.remove(oldItem);
    }

  }

  var List_2 = List$1;

  var List_1$1 = {
  	List: List_2
  };

  function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error();
    return Object.assign(error, {
      name,
      message,

      get stack() {
        return (errorStack.stack || '').replace(/^(.+\n){1,3}/, `${name}: ${message}\n`);
      }

    });
  }

  var createCustomError_2 = createCustomError;

  var createCustomError_1 = {
  	createCustomError: createCustomError_2
  };

  const MAX_LINE_LENGTH = 100;
  const OFFSET_CORRECTION = 60;
  const TAB_REPLACEMENT = '    ';

  function sourceFragment({
    source,
    line,
    column
  }, extraLines) {
    function processLines(start, end) {
      return lines.slice(start, end).map((line, idx) => String(start + idx + 1).padStart(maxNumLength) + ' |' + line).join('\n');
    }

    const lines = source.split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0; // column correction according to replaced tab before column

    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
      cutLeft = column - OFFSET_CORRECTION + 3;
      column = OFFSET_CORRECTION - 2;
    }

    for (let i = startLine; i <= endLine; i++) {
      if (i >= 0 && i < lines.length) {
        lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
        lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
      }
    }

    return [processLines(startLine, line), new Array(column + maxNumLength + 2).join('-') + '^', processLines(line, endLine)].filter(Boolean).join('\n');
  }

  function SyntaxError$2(message, source, offset, line, column) {
    const error = Object.assign(createCustomError_1.createCustomError('SyntaxError', message), {
      source,
      offset,
      line,
      column,

      sourceFragment(extraLines) {
        return sourceFragment({
          source,
          line,
          column
        }, isNaN(extraLines) ? 0 : extraLines);
      },

      get formattedMessage() {
        return `Parse error: ${message}\n` + sourceFragment({
          source,
          line,
          column
        }, 2);
      }

    });
    return error;
  }

  var SyntaxError_1$1 = SyntaxError$2;

  var _SyntaxError$2 = {
  	SyntaxError: SyntaxError_1$1
  };

  function readSequence$1(recognizer) {
    const children = this.createList();
    let space = false;
    const context = {
      recognizer
    };

    while (!this.eof) {
      switch (this.tokenType) {
        case types$4.Comment:
          this.next();
          continue;

        case types$4.WhiteSpace:
          space = true;
          this.next();
          continue;
      }

      let child = recognizer.getNode.call(this, context);

      if (child === undefined) {
        break;
      }

      if (space) {
        if (recognizer.onWhiteSpace) {
          recognizer.onWhiteSpace.call(this, child, children, context);
        }

        space = false;
      }

      children.push(child);
    }

    if (space && recognizer.onWhiteSpace) {
      recognizer.onWhiteSpace.call(this, null, children, context);
    }

    return children;
  }

  var readSequence_1 = readSequence$1;

  var sequence = {
  	readSequence: readSequence_1
  };

  const NOOP = () => {};

  const EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

  const NUMBERSIGN$4 = 0x0023; // U+0023 NUMBER SIGN (#)

  const SEMICOLON$1 = 0x003B; // U+003B SEMICOLON (;)

  const LEFTCURLYBRACKET$1 = 0x007B; // U+007B LEFT CURLY BRACKET ({)

  const NULL = 0;

  function createParseContext(name) {
    return function () {
      return this[name]();
    };
  }

  function fetchParseValues(dict) {
    const result = Object.create(null);

    for (const name in dict) {
      const item = dict[name];
      const fn = item.parse || item;

      if (fn) {
        result[name] = fn;
      }
    }

    return result;
  }

  function processConfig(config) {
    const parseConfig = {
      context: Object.create(null),
      scope: Object.assign(Object.create(null), config.scope),
      atrule: fetchParseValues(config.atrule),
      pseudo: fetchParseValues(config.pseudo),
      node: fetchParseValues(config.node)
    };

    for (const name in config.parseContext) {
      switch (typeof config.parseContext[name]) {
        case 'function':
          parseConfig.context[name] = config.parseContext[name];
          break;

        case 'string':
          parseConfig.context[name] = createParseContext(config.parseContext[name]);
          break;
      }
    }

    return {
      config: parseConfig,
      ...parseConfig,
      ...parseConfig.node
    };
  }

  function createParser(config) {
    let source = '';
    let filename = '<unknown>';
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;
    const locationMap = new OffsetToLocation_1$1.OffsetToLocation();
    const parser = Object.assign(new TokenStream_1$2.TokenStream(), processConfig(config || {}), {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,
      readSequence: sequence.readSequence,
      consumeUntilBalanceEnd: () => 0,

      consumeUntilLeftCurlyBracket(code) {
        return code === LEFTCURLYBRACKET$1 ? 1 : 0;
      },

      consumeUntilLeftCurlyBracketOrSemicolon(code) {
        return code === LEFTCURLYBRACKET$1 || code === SEMICOLON$1 ? 1 : 0;
      },

      consumeUntilExclamationMarkOrSemicolon(code) {
        return code === EXCLAMATIONMARK$3 || code === SEMICOLON$1 ? 1 : 0;
      },

      consumeUntilSemicolonIncluded(code) {
        return code === SEMICOLON$1 ? 2 : 0;
      },

      createList() {
        return new List_1$1.List();
      },

      createSingleNodeList(node) {
        return new List_1$1.List().appendData(node);
      },

      getFirstListNode(list) {
        return list && list.first;
      },

      getLastListNode(list) {
        return list && list.last;
      },

      parseWithFallback(consumer, fallback) {
        const startToken = this.tokenIndex;

        try {
          return consumer.call(this);
        } catch (e) {
          if (onParseErrorThrow) {
            throw e;
          }

          const fallbackNode = fallback.call(this, startToken);
          onParseErrorThrow = true;
          onParseError(e, fallbackNode);
          onParseErrorThrow = false;
          return fallbackNode;
        }
      },

      lookupNonWSType(offset) {
        let type;

        do {
          type = this.lookupType(offset++);

          if (type !== types$4.WhiteSpace) {
            return type;
          }
        } while (type !== NULL);

        return NULL;
      },

      charCodeAt(offset) {
        return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
      },

      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },

      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },

      cmpChar(offset, charCode) {
        return utils$9.cmpChar(source, offset, charCode);
      },

      cmpStr(offsetStart, offsetEnd, str) {
        return utils$9.cmpStr(source, offsetStart, offsetEnd, str);
      },

      consume(tokenType) {
        const start = this.tokenStart;
        this.eat(tokenType);
        return this.substrToCursor(start);
      },

      consumeFunctionName() {
        const name = source.substring(this.tokenStart, this.tokenEnd - 1);
        this.eat(types$4.Function);
        return name;
      },

      consumeNumber(type) {
        const number = source.substring(this.tokenStart, utils$9.consumeNumber(source, this.tokenStart));
        this.eat(type);
        return number;
      },

      eat(tokenType) {
        if (this.tokenType !== tokenType) {
          const tokenName = names$1[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());
          let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
          let offset = this.tokenStart; // tweak message and offset

          switch (tokenType) {
            case types$4.Ident:
              // when identifier is expected but there is a function or url
              if (this.tokenType === types$4.Function || this.tokenType === types$4.Url) {
                offset = this.tokenEnd - 1;
                message = 'Identifier is expected but function found';
              } else {
                message = 'Identifier is expected';
              }

              break;

            case types$4.Hash:
              if (this.isDelim(NUMBERSIGN$4)) {
                this.next();
                offset++;
                message = 'Name is expected';
              }

              break;

            case types$4.Percentage:
              if (this.tokenType === types$4.Number) {
                offset = this.tokenEnd;
                message = 'Percent sign is expected';
              }

              break;
          }

          this.error(message, offset);
        }

        this.next();
      },

      eatIdent(name) {
        if (this.tokenType !== types$4.Ident || this.lookupValue(0, name) === false) {
          this.error(`Identifier "${name}" is expected`);
        }

        this.next();
      },

      eatDelim(code) {
        if (!this.isDelim(code)) {
          this.error(`Delim "${String.fromCharCode(code)}" is expected`);
        }

        this.next();
      },

      getLocation(start, end) {
        if (needPositions) {
          return locationMap.getLocationRange(start, end, filename);
        }

        return null;
      },

      getLocationFromList(list) {
        if (needPositions) {
          const head = this.getFirstListNode(list);
          const tail = this.getLastListNode(list);
          return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename);
        }

        return null;
      },

      error(message, offset) {
        const location = typeof offset !== 'undefined' && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(utils$9.findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
        throw new _SyntaxError$2.SyntaxError(message || 'Unexpected input', source, location.offset, location.line, location.column);
      }

    });

    const parse = function (source_, options) {
      source = source_;
      options = options || {};
      parser.setSource(source, tokenizer$2.tokenize);
      locationMap.setSource(source, options.offset, options.line, options.column);
      filename = options.filename || '<unknown>';
      needPositions = Boolean(options.positions);
      onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;
      onParseErrorThrow = false;
      parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
      parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
      parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
      parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;
      const {
        context = 'default',
        onComment
      } = options;

      if (context in parser.context === false) {
        throw new Error('Unknown context `' + context + '`');
      }

      if (typeof onComment === 'function') {
        parser.forEachToken((type, start, end) => {
          if (type === types$4.Comment) {
            const loc = parser.getLocation(start, end);
            const value = utils$9.cmpStr(source, end - 2, end, '*/') ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
            onComment(value, loc);
          }
        });
      }

      const ast = parser.context[context].call(parser, options);

      if (!parser.eof) {
        parser.error();
      }

      return ast;
    };

    return Object.assign(parse, {
      SyntaxError: _SyntaxError$2.SyntaxError,
      config: parser.config
    });
  }

  var createParser_1 = createParser;

  var create$3 = {
  	createParser: createParser_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */

  var encode$4 = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }

    throw new TypeError("Must be between 0 and 63: " + number);
  };
  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */


  var decode$4 = function (charCode) {
    var bigA = 65; // 'A'

    var bigZ = 90; // 'Z'

    var littleA = 97; // 'a'

    var littleZ = 122; // 'z'

    var zero = 48; // '0'

    var nine = 57; // '9'

    var plus = 43; // '+'

    var slash = 47; // '/'

    var littleOffset = 26;
    var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    } // 26 - 51: abcdefghijklmnopqrstuvwxyz


    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    } // 52 - 61: 0123456789


    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    } // 62: +


    if (charCode == plus) {
      return 62;
    } // 63: /


    if (charCode == slash) {
      return 63;
    } // Invalid base64 digit.


    return -1;
  };

  var base64 = {
  	encode: encode$4,
  	decode: decode$4
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
   // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011


  var VLQ_BASE_SHIFT = 5; // binary: 100000

  var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

  var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */

  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */


  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  /**
   * Returns the base 64 VLQ encoded value.
   */


  var encode$3 = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;

      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }

      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };
  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */


  var decode$3 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));

      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq = {
  	encode: encode$3,
  	decode: decode$3
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var util$1 = createCommonjsModule(function (module, exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }

  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);

    if (!match) {
      return null;
    }

    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }

  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';

    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }

    url += '//';

    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }

    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }

    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }

    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }

    return url;
  }

  exports.urlGenerate = urlGenerate;
  var MAX_CACHED_INPUTS = 32;
  /**
   * Takes some function `f(input) -> result` and returns a memoized version of
   * `f`.
   *
   * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
   * memoization is a dumb-simple, linear least-recently-used cache.
   */

  function lruMemoize(f) {
    var cache = [];
    return function (input) {
      for (var i = 0; i < cache.length; i++) {
        if (cache[i].input === input) {
          var temp = cache[0];
          cache[0] = cache[i];
          cache[i] = temp;
          return cache[0].result;
        }
      }

      var result = f(input);
      cache.unshift({
        input,
        result
      });

      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }

      return result;
    };
  }
  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */


  var normalize = lruMemoize(function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);

    if (url) {
      if (!url.path) {
        return aPath;
      }

      path = url.path;
    }

    var isAbsolute = exports.isAbsolute(path); // Split the path into parts between `/` characters. This is much faster than
    // using `.split(/\/+/g)`.

    var parts = [];
    var start = 0;
    var i = 0;

    while (true) {
      start = i;
      i = path.indexOf("/", start);

      if (i === -1) {
        parts.push(path.slice(start));
        break;
      } else {
        parts.push(path.slice(start, i));

        while (i < path.length && path[i] === "/") {
          i++;
        }
      }
    }

    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];

      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }

    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }

    return path;
  });
  exports.normalize = normalize;
  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */

  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    if (aPath === "") {
      aPath = ".";
    }

    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);

    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    } // `join(foo, '//www.example.org')`


    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }

      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    } // `join('http://', 'www.example.com')`


    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }

    return joined;
  }

  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
  };
  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */


  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.

    var level = 0;

    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");

      if (index < 0) {
        return aPath;
      } // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.


      aRoot = aRoot.slice(0, index);

      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    } // Make sure we add a "../" for each component we removed from the root.


    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }

  exports.relative = relative;

  var supportsNullProto = function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }();

  function identity(s) {
    return s;
  }
  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */


  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }

  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }

  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9
    /* "__proto__".length */
    ) {
        return false;
      }

    if (s.charCodeAt(length - 1) !== 95
    /* '_' */
    || s.charCodeAt(length - 2) !== 95
    /* '_' */
    || s.charCodeAt(length - 3) !== 111
    /* 'o' */
    || s.charCodeAt(length - 4) !== 116
    /* 't' */
    || s.charCodeAt(length - 5) !== 111
    /* 'o' */
    || s.charCodeAt(length - 6) !== 114
    /* 'r' */
    || s.charCodeAt(length - 7) !== 112
    /* 'p' */
    || s.charCodeAt(length - 8) !== 95
    /* '_' */
    || s.charCodeAt(length - 9) !== 95
    /* '_' */
    ) {
        return false;
      }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36
      /* '$' */
      ) {
          return false;
        }
    }

    return true;
  }
  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */


  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByOriginalPositions = compareByOriginalPositions;

  function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */

  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 === null) {
      return 1; // aStr2 !== null
    }

    if (aStr2 === null) {
      return -1; // aStr1 !== null
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }
  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */


  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  /**
   * Strip any JSON XSSI avoidance prefix from the string (as documented
   * in the source maps specification), and then parse the string as
   * JSON.
   */

  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
  }

  exports.parseSourceMapInput = parseSourceMapInput;
  /**
   * Compute the URL of a source given the the source root, the source's
   * URL, and the source map's URL.
   */

  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';

    if (sourceRoot) {
      // This follows what Chrome does.
      if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
        sourceRoot += '/';
      } // The spec says:
      //   Line 4: An optional source root, useful for relocating source
      //   files on a server or removing repeated values in the
      //   “sources” entry.  This value is prepended to the individual
      //   entries in the “source” field.


      sourceURL = sourceRoot + sourceURL;
    } // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).


    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);

      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }

      if (parsed.path) {
        // Strip the last path component, but keep the "/".
        var index = parsed.path.lastIndexOf('/');

        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }

      sourceURL = join(urlGenerate(parsed), sourceURL);
    }

    return normalize(sourceURL);
  }

  exports.computeSourceURL = computeSourceURL;
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */


  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */

  function ArraySet$2() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  /**
   * Static method for creating ArraySet instances from an existing array.
   */


  ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet$2();

    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }

    return set;
  };
  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */


  ArraySet$2.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */


  ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util$1.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;

    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }

    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */


  ArraySet$2.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util$1.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */


  ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);

      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util$1.toSetString(aStr);

      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };
  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */


  ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }

    throw new Error('No element indexed by ' + aIdx);
  };
  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */


  ArraySet$2.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1 = ArraySet$2;

  var arraySet = {
  	ArraySet: ArraySet_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */


  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util$1.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */


  function MappingList$1() {
    this._array = [];
    this._sorted = true; // Serves as infimum

    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }
  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */


  MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */


  MappingList$1.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;

      this._array.push(aMapping);
    } else {
      this._sorted = false;

      this._array.push(aMapping);
    }
  };
  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */


  MappingList$1.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util$1.compareByGeneratedPositionsInflated);

      this._sorted = true;
    }

    return this._array;
  };

  var MappingList_1 = MappingList$1;

  var mappingList = {
  	MappingList: MappingList_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */




  var ArraySet$1 = arraySet.ArraySet;

  var MappingList = mappingList.MappingList;
  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */


  function SourceMapGenerator$5(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }

    this._file = util$1.getArg(aArgs, 'file', null);
    this._sourceRoot = util$1.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util$1.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator$5.prototype._version = 3;
  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */

  SourceMapGenerator$5.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator$5({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;

        if (sourceRoot != null) {
          newMapping.source = util$1.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;

      if (sourceRoot !== null) {
        sourceRelative = util$1.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */


  SourceMapGenerator$5.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util$1.getArg(aArgs, 'generated');
    var original = util$1.getArg(aArgs, 'original', null);
    var source = util$1.getArg(aArgs, 'source', null);
    var name = util$1.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);

      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);

      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };
  /**
   * Set the source content for a source file.
   */


  SourceMapGenerator$5.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;

    if (this._sourceRoot != null) {
      source = util$1.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }

      this._sourcesContents[util$1.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util$1.toSetString(source)];

      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */


  SourceMapGenerator$5.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }

      sourceFile = aSourceMapConsumer.file;
    }

    var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

    if (sourceRoot != null) {
      sourceFile = util$1.relative(sourceRoot, sourceFile);
    } // Applying the SourceMap can add and remove items from the sources and
    // the names array.


    var newSources = new ArraySet$1();
    var newNames = new ArraySet$1(); // Find mappings for the "sourceFile"

    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });

        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;

          if (aSourceMapPath != null) {
            mapping.source = util$1.join(aSourceMapPath, mapping.source);
          }

          if (sourceRoot != null) {
            mapping.source = util$1.relative(sourceRoot, mapping.source);
          }

          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;

          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;

      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;

      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);

    this._sources = newSources;
    this._names = newNames; // Copy sourcesContents of applied map.

    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util$1.join(aSourceMapPath, sourceFile);
        }

        if (sourceRoot != null) {
          sourceFile = util$1.relative(sourceRoot, sourceFile);
        }

        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };
  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */


  SourceMapGenerator$5.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      // Cases 2 and 3.
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */


  SourceMapGenerator$5.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();

    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;

        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util$1.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }

          next += ',';
        }
      }

      next += base64Vlq.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64Vlq.encode(sourceIdx - previousSource);
        previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

        next += base64Vlq.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64Vlq.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64Vlq.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

  SourceMapGenerator$5.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }

      if (aSourceRoot != null) {
        source = util$1.relative(aSourceRoot, source);
      }

      var key = util$1.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  /**
   * Externalize the source map.
   */


  SourceMapGenerator$5.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };

    if (this._file != null) {
      map.file = this._file;
    }

    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }

    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };
  /**
   * Render the source map being generated to a string.
   */


  SourceMapGenerator$5.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

  var SourceMapGenerator_1 = SourceMapGenerator$5;

  var sourceMapGenerator = {
  	SourceMapGenerator: SourceMapGenerator_1
  };

  const trackNodes = new Set(['Atrule', 'Selector', 'Declaration']);

  function generateSourceMap(handlers) {
    const map = new sourceMapGenerator.SourceMapGenerator();
    const generated = {
      line: 1,
      column: 0
    };
    const original = {
      line: 0,
      // should be zero to add first mapping
      column: 0
    };
    const activatedGenerated = {
      line: 1,
      column: 0
    };
    const activatedMapping = {
      generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;
    const origHandlersNode = handlers.node;

    handlers.node = function (node) {
      if (node.loc && node.loc.start && trackNodes.has(node.type)) {
        const nodeLine = node.loc.start.line;
        const nodeColumn = node.loc.start.column - 1;

        if (original.line !== nodeLine || original.column !== nodeColumn) {
          original.line = nodeLine;
          original.column = nodeColumn;
          generated.line = line;
          generated.column = column;

          if (sourceMappingActive) {
            sourceMappingActive = false;

            if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
              map.addMapping(activatedMapping);
            }
          }

          sourceMappingActive = true;
          map.addMapping({
            source: node.loc.source,
            original,
            generated
          });
        }
      }

      origHandlersNode.call(this, node);

      if (sourceMappingActive && trackNodes.has(node.type)) {
        activatedGenerated.line = line;
        activatedGenerated.column = column;
      }
    };

    const origHandlersEmit = handlers.emit;

    handlers.emit = function (value, type, auto) {
      for (let i = 0; i < value.length; i++) {
        if (value.charCodeAt(i) === 10) {
          // \n
          line++;
          column = 0;
        } else {
          column++;
        }
      }

      origHandlersEmit(value, type, auto);
    };

    const origHandlersResult = handlers.result;

    handlers.result = function () {
      if (sourceMappingActive) {
        map.addMapping(activatedMapping);
      }

      return {
        css: origHandlersResult(),
        map
      };
    };

    return handlers;
  }

  var generateSourceMap_1 = generateSourceMap;

  var sourceMap$1 = {
  	generateSourceMap: generateSourceMap_1
  };

  const PLUSSIGN$9 = 0x002B; // U+002B PLUS SIGN (+)

  const HYPHENMINUS$6 = 0x002D; // U+002D HYPHEN-MINUS (-)

  const code = (type, value) => {
    if (type === types$4.Delim) {
      type = value;
    }

    if (typeof type === 'string') {
      const charCode = type.charCodeAt(0);
      return charCode > 0x7F ? 0x8000 : charCode << 8;
    }

    return type;
  }; // https://www.w3.org/TR/css-syntax-3/#serialization
  // The only requirement for serialization is that it must "round-trip" with parsing,
  // that is, parsing the stylesheet must produce the same data structures as parsing,
  // serializing, and parsing again, except for consecutive <whitespace-token>s,
  // which may be collapsed into a single token.


  const specPairs = [[types$4.Ident, types$4.Ident], [types$4.Ident, types$4.Function], [types$4.Ident, types$4.Url], [types$4.Ident, types$4.BadUrl], [types$4.Ident, '-'], [types$4.Ident, types$4.Number], [types$4.Ident, types$4.Percentage], [types$4.Ident, types$4.Dimension], [types$4.Ident, types$4.CDC], [types$4.Ident, types$4.LeftParenthesis], [types$4.AtKeyword, types$4.Ident], [types$4.AtKeyword, types$4.Function], [types$4.AtKeyword, types$4.Url], [types$4.AtKeyword, types$4.BadUrl], [types$4.AtKeyword, '-'], [types$4.AtKeyword, types$4.Number], [types$4.AtKeyword, types$4.Percentage], [types$4.AtKeyword, types$4.Dimension], [types$4.AtKeyword, types$4.CDC], [types$4.Hash, types$4.Ident], [types$4.Hash, types$4.Function], [types$4.Hash, types$4.Url], [types$4.Hash, types$4.BadUrl], [types$4.Hash, '-'], [types$4.Hash, types$4.Number], [types$4.Hash, types$4.Percentage], [types$4.Hash, types$4.Dimension], [types$4.Hash, types$4.CDC], [types$4.Dimension, types$4.Ident], [types$4.Dimension, types$4.Function], [types$4.Dimension, types$4.Url], [types$4.Dimension, types$4.BadUrl], [types$4.Dimension, '-'], [types$4.Dimension, types$4.Number], [types$4.Dimension, types$4.Percentage], [types$4.Dimension, types$4.Dimension], [types$4.Dimension, types$4.CDC], ['#', types$4.Ident], ['#', types$4.Function], ['#', types$4.Url], ['#', types$4.BadUrl], ['#', '-'], ['#', types$4.Number], ['#', types$4.Percentage], ['#', types$4.Dimension], ['#', types$4.CDC], // https://github.com/w3c/csswg-drafts/pull/6874
  ['-', types$4.Ident], ['-', types$4.Function], ['-', types$4.Url], ['-', types$4.BadUrl], ['-', '-'], ['-', types$4.Number], ['-', types$4.Percentage], ['-', types$4.Dimension], ['-', types$4.CDC], // https://github.com/w3c/csswg-drafts/pull/6874
  [types$4.Number, types$4.Ident], [types$4.Number, types$4.Function], [types$4.Number, types$4.Url], [types$4.Number, types$4.BadUrl], [types$4.Number, types$4.Number], [types$4.Number, types$4.Percentage], [types$4.Number, types$4.Dimension], [types$4.Number, '%'], [types$4.Number, types$4.CDC], // https://github.com/w3c/csswg-drafts/pull/6874
  ['@', types$4.Ident], ['@', types$4.Function], ['@', types$4.Url], ['@', types$4.BadUrl], ['@', '-'], ['@', types$4.CDC], // https://github.com/w3c/csswg-drafts/pull/6874
  ['.', types$4.Number], ['.', types$4.Percentage], ['.', types$4.Dimension], ['+', types$4.Number], ['+', types$4.Percentage], ['+', types$4.Dimension], ['/', '*']]; // validate with scripts/generate-safe

  const safePairs = specPairs.concat([[types$4.Ident, types$4.Hash], [types$4.Dimension, types$4.Hash], [types$4.Hash, types$4.Hash], [types$4.AtKeyword, types$4.LeftParenthesis], [types$4.AtKeyword, types$4.String], [types$4.AtKeyword, types$4.Colon], [types$4.Percentage, types$4.Percentage], [types$4.Percentage, types$4.Dimension], [types$4.Percentage, types$4.Function], [types$4.Percentage, '-'], [types$4.RightParenthesis, types$4.Ident], [types$4.RightParenthesis, types$4.Function], [types$4.RightParenthesis, types$4.Percentage], [types$4.RightParenthesis, types$4.Dimension], [types$4.RightParenthesis, types$4.Hash], [types$4.RightParenthesis, '-']]);

  function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(pairs.map(([prev, next]) => code(prev) << 16 | code(next)));
    return function (prevCode, type, value) {
      const nextCode = code(type, value);
      const nextCharCode = value.charCodeAt(0);
      const emitWs = nextCharCode === HYPHENMINUS$6 && type !== types$4.Ident && type !== types$4.Function && type !== types$4.CDC || nextCharCode === PLUSSIGN$9 ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);

      if (emitWs) {
        this.emit(' ', types$4.WhiteSpace, true);
      }

      return nextCode;
    };
  }

  const spec = createMap(specPairs);
  const safe = createMap(safePairs);
  var safe_1 = safe;
  var spec_1 = spec;

  var tokenBefore = {
  	safe: safe_1,
  	spec: spec_1
  };

  const REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

  function processChildren(node, delimeter) {
    if (typeof delimeter === 'function') {
      let prev = null;
      node.children.forEach(node => {
        if (prev !== null) {
          delimeter.call(this, prev);
        }

        this.node(node);
        prev = node;
      });
      return;
    }

    node.children.forEach(this.node, this);
  }

  function processChunk(chunk) {
    tokenizer$2.tokenize(chunk, (type, start, end) => {
      this.token(type, chunk.slice(start, end));
    });
  }

  function createGenerator(config) {
    const types$1 = new Map();

    for (let name in config.node) {
      const item = config.node[name];
      const fn = item.generate || item;

      if (typeof fn === 'function') {
        types$1.set(name, item.generate || item);
      }
    }

    return function (node, options) {
      let buffer = '';
      let prevCode = 0;
      let handlers = {
        node(node) {
          if (types$1.has(node.type)) {
            types$1.get(node.type).call(publicApi, node);
          } else {
            throw new Error('Unknown node type: ' + node.type);
          }
        },

        tokenBefore: tokenBefore.safe,

        token(type, value) {
          prevCode = this.tokenBefore(prevCode, type, value);
          this.emit(value, type, false);

          if (type === types$4.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
            this.emit('\n', types$4.WhiteSpace, true);
          }
        },

        emit(value) {
          buffer += value;
        },

        result() {
          return buffer;
        }

      };

      if (options) {
        if (typeof options.decorator === 'function') {
          handlers = options.decorator(handlers);
        }

        if (options.sourceMap) {
          handlers = sourceMap$1.generateSourceMap(handlers);
        }

        if (options.mode in tokenBefore) {
          handlers.tokenBefore = tokenBefore[options.mode];
        }
      }

      const publicApi = {
        node: node => handlers.node(node),
        children: processChildren,
        token: (type, value) => handlers.token(type, value),
        tokenize: processChunk
      };
      handlers.node(node);
      return handlers.result();
    };
  }

  var createGenerator_1 = createGenerator;

  var create$2 = {
  	createGenerator: createGenerator_1
  };

  function createConvertor(walk) {
    return {
      fromPlainObject(ast) {
        walk(ast, {
          enter(node) {
            if (node.children && node.children instanceof List_1$1.List === false) {
              node.children = new List_1$1.List().fromArray(node.children);
            }
          }

        });
        return ast;
      },

      toPlainObject(ast) {
        walk(ast, {
          leave(node) {
            if (node.children && node.children instanceof List_1$1.List) {
              node.children = node.children.toArray();
            }
          }

        });
        return ast;
      }

    };
  }

  var createConvertor_1 = createConvertor;

  var create$1 = {
  	createConvertor: createConvertor_1
  };

  const {
    hasOwnProperty: hasOwnProperty$4
  } = Object.prototype;

  const noop$4 = function () {};

  function ensureFunction$1(value) {
    return typeof value === 'function' ? value : noop$4;
  }

  function invokeForType(fn, type) {
    return function (node, item, list) {
      if (node.type === type) {
        fn.call(this, node, item, list);
      }
    };
  }

  function getWalkersFromStructure(name, nodeType) {
    const structure = nodeType.structure;
    const walkers = [];

    for (const key in structure) {
      if (hasOwnProperty$4.call(structure, key) === false) {
        continue;
      }

      let fieldTypes = structure[key];
      const walker = {
        name: key,
        type: false,
        nullable: false
      };

      if (!Array.isArray(fieldTypes)) {
        fieldTypes = [fieldTypes];
      }

      for (const fieldType of fieldTypes) {
        if (fieldType === null) {
          walker.nullable = true;
        } else if (typeof fieldType === 'string') {
          walker.type = 'node';
        } else if (Array.isArray(fieldType)) {
          walker.type = 'list';
        }
      }

      if (walker.type) {
        walkers.push(walker);
      }
    }

    if (walkers.length) {
      return {
        context: nodeType.walkContext,
        fields: walkers
      };
    }

    return null;
  }

  function getTypesFromConfig(config) {
    const types = {};

    for (const name in config.node) {
      if (hasOwnProperty$4.call(config.node, name)) {
        const nodeType = config.node[name];

        if (!nodeType.structure) {
          throw new Error('Missed `structure` field in `' + name + '` node type definition');
        }

        types[name] = getWalkersFromStructure(name, nodeType);
      }
    }

    return types;
  }

  function createTypeIterator(config, reverse) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === 'string';

    if (reverse) {
      fields.reverse();
    }

    return function (node, context, walk, walkReducer) {
      let prevContextValue;

      if (useContext) {
        prevContextValue = context[contextName];
        context[contextName] = node;
      }

      for (const field of fields) {
        const ref = node[field.name];

        if (!field.nullable || ref) {
          if (field.type === 'list') {
            const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);

            if (breakWalk) {
              return true;
            }
          } else if (walk(ref)) {
            return true;
          }
        }
      }

      if (useContext) {
        context[contextName] = prevContextValue;
      }
    };
  }

  function createFastTraveralMap({
    StyleSheet,
    Atrule,
    Rule,
    Block,
    DeclarationList
  }) {
    return {
      Atrule: {
        StyleSheet,
        Atrule,
        Rule,
        Block
      },
      Rule: {
        StyleSheet,
        Atrule,
        Rule,
        Block
      },
      Declaration: {
        StyleSheet,
        Atrule,
        Rule,
        Block,
        DeclarationList
      }
    };
  }

  function createWalker(config) {
    const types = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol('break-walk');
    const skipNode = Symbol('skip-node');

    for (const name in types) {
      if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
        iteratorsNatural[name] = createTypeIterator(types[name], false);
        iteratorsReverse[name] = createTypeIterator(types[name], true);
      }
    }

    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    const walk = function (root, options) {
      function walkNode(node, item, list) {
        const enterRet = enter.call(context, node, item, list);

        if (enterRet === breakWalk) {
          return true;
        }

        if (enterRet === skipNode) {
          return false;
        }

        if (iterators.hasOwnProperty(node.type)) {
          if (iterators[node.type](node, context, walkNode, walkReducer)) {
            return true;
          }
        }

        if (leave.call(context, node, item, list) === breakWalk) {
          return true;
        }

        return false;
      }

      let enter = noop$4;
      let leave = noop$4;
      let iterators = iteratorsNatural;

      let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);

      const context = {
        break: breakWalk,
        skip: skipNode,
        root,
        stylesheet: null,
        atrule: null,
        atrulePrelude: null,
        rule: null,
        selector: null,
        block: null,
        declaration: null,
        function: null
      };

      if (typeof options === 'function') {
        enter = options;
      } else if (options) {
        enter = ensureFunction$1(options.enter);
        leave = ensureFunction$1(options.leave);

        if (options.reverse) {
          iterators = iteratorsReverse;
        }

        if (options.visit) {
          if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
            iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
          } else if (!types.hasOwnProperty(options.visit)) {
            throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).sort().join(', ') + ')');
          }

          enter = invokeForType(enter, options.visit);
          leave = invokeForType(leave, options.visit);
        }
      }

      if (enter === noop$4 && leave === noop$4) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
      }

      walkNode(root);
    };

    walk.break = breakWalk;
    walk.skip = skipNode;

    walk.find = function (ast, fn) {
      let found = null;
      walk(ast, function (node, item, list) {
        if (fn.call(this, node, item, list)) {
          found = node;
          return breakWalk;
        }
      });
      return found;
    };

    walk.findLast = function (ast, fn) {
      let found = null;
      walk(ast, {
        reverse: true,

        enter(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        }

      });
      return found;
    };

    walk.findAll = function (ast, fn) {
      const found = [];
      walk(ast, function (node, item, list) {
        if (fn.call(this, node, item, list)) {
          found.push(node);
        }
      });
      return found;
    };

    return walk;
  }

  var createWalker_1 = createWalker;

  var create = {
  	createWalker: createWalker_1
  };

  function noop$3(value) {
    return value;
  }

  function generateMultiplier(multiplier) {
    const {
      min,
      max,
      comma
    } = multiplier;

    if (min === 0 && max === 0) {
      return comma ? '#?' : '*';
    }

    if (min === 0 && max === 1) {
      return '?';
    }

    if (min === 1 && max === 0) {
      return comma ? '#' : '+';
    }

    if (min === 1 && max === 1) {
      return '';
    }

    return (comma ? '#' : '') + (min === max ? '{' + min + '}' : '{' + min + ',' + (max !== 0 ? max : '') + '}');
  }

  function generateTypeOpts(node) {
    switch (node.type) {
      case 'Range':
        return ' [' + (node.min === null ? '-∞' : node.min) + ',' + (node.max === null ? '∞' : node.max) + ']';

      default:
        throw new Error('Unknown node type `' + node.type + '`');
    }
  }

  function generateSequence(node, decorate, forceBraces, compact) {
    const combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    const result = node.terms.map(term => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);

    if (node.explicit || forceBraces) {
      return (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    }

    return result;
  }

  function internalGenerate(node, decorate, forceBraces, compact) {
    let result;

    switch (node.type) {
      case 'Group':
        result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? '!' : '');
        break;

      case 'Multiplier':
        // return since node is a composition
        return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);

      case 'Type':
        result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
        break;

      case 'Property':
        result = '<\'' + node.name + '\'>';
        break;

      case 'Keyword':
        result = node.name;
        break;

      case 'AtKeyword':
        result = '@' + node.name;
        break;

      case 'Function':
        result = node.name + '(';
        break;

      case 'String':
      case 'Token':
        result = node.value;
        break;

      case 'Comma':
        result = ',';
        break;

      default:
        throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
  }

  function generate$G(node, options) {
    let decorate = noop$3;
    let forceBraces = false;
    let compact = false;

    if (typeof options === 'function') {
      decorate = options;
    } else if (options) {
      forceBraces = Boolean(options.forceBraces);
      compact = Boolean(options.compact);

      if (typeof options.decorate === 'function') {
        decorate = options.decorate;
      }
    }

    return internalGenerate(node, decorate, forceBraces, compact);
  }

  var generate_2 = generate$G;

  var generate_1$H = {
  	generate: generate_2
  };

  const defaultLoc = {
    offset: 0,
    line: 1,
    column: 1
  };

  function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = '';
    let start;
    let end;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i].value;

      if (i === longestMatch) {
        mismatchLength = token.length;
        mismatchOffset = css.length;
      }

      if (badNode !== null && tokens[i].node === badNode) {
        if (i <= longestMatch) {
          entries++;
        } else {
          entries = 0;
        }
      }

      css += token;
    }

    if (longestMatch === tokens.length || entries > 1) {
      // last
      start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
      end = buildLoc(start);
    } else {
      start = fromLoc(badNode, 'start') || buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
      end = fromLoc(badNode, 'end') || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }

    return {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    };
  }

  function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];

    if (value) {
      return 'line' in value ? buildLoc(value) : value;
    }

    return null;
  }

  function buildLoc({
    offset,
    line,
    column
  }, extra) {
    const loc = {
      offset,
      line,
      column
    };

    if (extra) {
      const lines = extra.split(/\n|\r\n?|\f/);
      loc.offset += extra.length;
      loc.line += lines.length - 1;
      loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }

    return loc;
  }

  const SyntaxReferenceError = function (type, referenceName) {
    const error = createCustomError_1.createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));
    error.reference = referenceName;
    return error;
  };

  const SyntaxMatchError = function (message, syntax, node, matchResult) {
    const error = createCustomError_1.createCustomError('SyntaxMatchError', message);
    const {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    } = locateMismatch(matchResult, node);
    error.rawMessage = message;
    error.syntax = syntax ? generate_1$H.generate(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + '\n' + '  syntax: ' + error.syntax + '\n' + '   value: ' + (css || '<empty string>') + '\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';
    Object.assign(error, start);
    error.loc = {
      source: node && node.loc && node.loc.source || '<unknown>',
      start,
      end
    };
    return error;
  };

  var SyntaxMatchError_1 = SyntaxMatchError;
  var SyntaxReferenceError_1 = SyntaxReferenceError;

  var error$2 = {
  	SyntaxMatchError: SyntaxMatchError_1,
  	SyntaxReferenceError: SyntaxReferenceError_1
  };

  const keywords$3 = new Map();
  const properties$3 = new Map();
  const HYPHENMINUS$5 = 45; // '-'.charCodeAt()

  const keyword$2 = getKeywordDescriptor;
  const property$1 = getPropertyDescriptor;
  const vendorPrefix$1 = getVendorPrefix;

  function isCustomProperty$1(str, offset) {
    offset = offset || 0;
    return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS$5 && str.charCodeAt(offset + 1) === HYPHENMINUS$5;
  }

  function getVendorPrefix(str, offset) {
    offset = offset || 0; // verdor prefix should be at least 3 chars length

    if (str.length - offset >= 3) {
      // vendor prefix starts with hyper minus following non-hyper minus
      if (str.charCodeAt(offset) === HYPHENMINUS$5 && str.charCodeAt(offset + 1) !== HYPHENMINUS$5) {
        // vendor prefix should contain a hyper minus at the ending
        const secondDashIndex = str.indexOf('-', offset + 2);

        if (secondDashIndex !== -1) {
          return str.substring(offset, secondDashIndex + 1);
        }
      }
    }

    return '';
  }

  function getKeywordDescriptor(keyword) {
    if (keywords$3.has(keyword)) {
      return keywords$3.get(keyword);
    }

    const name = keyword.toLowerCase();
    let descriptor = keywords$3.get(name);

    if (descriptor === undefined) {
      const custom = isCustomProperty$1(name, 0);
      const vendor = !custom ? getVendorPrefix(name, 0) : '';
      descriptor = Object.freeze({
        basename: name.substr(vendor.length),
        name,
        prefix: vendor,
        vendor,
        custom
      });
    }

    keywords$3.set(keyword, descriptor);
    return descriptor;
  }

  function getPropertyDescriptor(property) {
    if (properties$3.has(property)) {
      return properties$3.get(property);
    }

    let name = property;
    let hack = property[0];

    if (hack === '/') {
      hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' && hack !== '*' && hack !== '$' && hack !== '#' && hack !== '+' && hack !== '&') {
      hack = '';
    }

    const custom = isCustomProperty$1(name, hack.length); // re-use result when possible (the same as for lower case)

    if (!custom) {
      name = name.toLowerCase();

      if (properties$3.has(name)) {
        const descriptor = properties$3.get(name);
        properties$3.set(property, descriptor);
        return descriptor;
      }
    }

    const vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    const prefix = name.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
      basename: name.substr(prefix.length),
      name: name.substr(hack.length),
      hack,
      vendor,
      prefix,
      custom
    });
    properties$3.set(property, descriptor);
    return descriptor;
  }

  var isCustomProperty_1 = isCustomProperty$1;
  var keyword_1 = keyword$2;
  var property_1 = property$1;
  var vendorPrefix_1 = vendorPrefix$1;

  var names = {
  	isCustomProperty: isCustomProperty_1,
  	keyword: keyword_1,
  	property: property_1,
  	vendorPrefix: vendorPrefix_1
  };

  const cssWideKeywords = ['initial', 'inherit', 'unset', 'revert', 'revert-layer'];
  var cssWideKeywords_1 = cssWideKeywords;

  var genericConst = {
  	cssWideKeywords: cssWideKeywords_1
  };

  const PLUSSIGN$8 = 0x002B; // U+002B PLUS SIGN (+)

  const HYPHENMINUS$4 = 0x002D; // U+002D HYPHEN-MINUS (-)

  const N$4 = 0x006E; // U+006E LATIN SMALL LETTER N (n)

  const DISALLOW_SIGN$1 = true;
  const ALLOW_SIGN$1 = false;

  function isDelim$1(token, code) {
    return token !== null && token.type === types$4.Delim && token.value.charCodeAt(0) === code;
  }

  function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === types$4.WhiteSpace || token.type === types$4.Comment)) {
      token = getNextToken(++offset);
    }

    return offset;
  }

  function checkInteger$1(token, valueOffset, disallowSign, offset) {
    if (!token) {
      return 0;
    }

    const code = token.value.charCodeAt(valueOffset);

    if (code === PLUSSIGN$8 || code === HYPHENMINUS$4) {
      if (disallowSign) {
        // Number sign is not allowed
        return 0;
      }

      valueOffset++;
    }

    for (; valueOffset < token.value.length; valueOffset++) {
      if (!charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))) {
        // Integer is expected
        return 0;
      }
    }

    return offset + 1;
  } // ... <signed-integer>
  // ... ['+' | '-'] <signless-integer>


  function consumeB$1(token, offset_, getNextToken) {
    let sign = false;
    let offset = skipSC(token, offset_, getNextToken);
    token = getNextToken(offset);

    if (token === null) {
      return offset_;
    }

    if (token.type !== types$4.Number) {
      if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
        sign = true;
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);

        if (token === null || token.type !== types$4.Number) {
          return 0;
        }
      } else {
        return offset_;
      }
    }

    if (!sign) {
      const code = token.value.charCodeAt(0);

      if (code !== PLUSSIGN$8 && code !== HYPHENMINUS$4) {
        // Number sign is expected
        return 0;
      }
    }

    return checkInteger$1(token, sign ? 0 : 1, sign, offset);
  } // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb


  function anPlusB(token, getNextToken) {
    /* eslint-disable brace-style*/
    let offset = 0;

    if (!token) {
      return 0;
    } // <integer>


    if (token.type === types$4.Number) {
      return checkInteger$1(token, 0, ALLOW_SIGN$1, offset); // b
    } // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (token.type === types$4.Ident && token.value.charCodeAt(0) === HYPHENMINUS$4) {
        // expect 1st char is N
        if (!utils$9.cmpChar(token.value, 1, N$4)) {
          return 0;
        }

        switch (token.value.length) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            return consumeB$1(getNextToken(++offset), offset, getNextToken);
          // -n- <signless-integer>

          case 3:
            if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
              return 0;
            }

            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
          // <dashndashdigit-ident>

          default:
            if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
              return 0;
            }

            return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
        }
      } // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      // '+'? n- <signless-integer>
      // '+'? <ndashdigit-ident>
      else if (token.type === types$4.Ident || isDelim$1(token, PLUSSIGN$8) && getNextToken(offset + 1).type === types$4.Ident) {
          // just ignore a plus
          if (token.type !== types$4.Ident) {
            token = getNextToken(++offset);
          }

          if (token === null || !utils$9.cmpChar(token.value, 0, N$4)) {
            return 0;
          }

          switch (token.value.length) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
              return consumeB$1(getNextToken(++offset), offset, getNextToken);
            // '+'? n- <signless-integer>

            case 2:
              if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                return 0;
              }

              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
            // '+'? <ndashdigit-ident>

            default:
              if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                return 0;
              }

              return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
          }
        } // <ndashdigit-dimension>
        // <ndash-dimension> <signless-integer>
        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        else if (token.type === types$4.Dimension) {
            let code = token.value.charCodeAt(0);
            let sign = code === PLUSSIGN$8 || code === HYPHENMINUS$4 ? 1 : 0;
            let i = sign;

            for (; i < token.value.length; i++) {
              if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {
                break;
              }
            }

            if (i === sign) {
              // Integer is expected
              return 0;
            }

            if (!utils$9.cmpChar(token.value, i, N$4)) {
              return 0;
            } // <n-dimension>
            // <n-dimension> <signed-integer>
            // <n-dimension> ['+' | '-'] <signless-integer>


            if (i + 1 === token.value.length) {
              return consumeB$1(getNextToken(++offset), offset, getNextToken);
            } else {
              if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$4) {
                return 0;
              } // <ndash-dimension> <signless-integer>


              if (i + 2 === token.value.length) {
                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);
                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
              } // <ndashdigit-dimension>
              else {
                  return checkInteger$1(token, i + 2, DISALLOW_SIGN$1, offset);
                }
            }
          }

    return 0;
  }

  var genericAnPlusB = anPlusB;

  const PLUSSIGN$7 = 0x002B; // U+002B PLUS SIGN (+)

  const HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)

  const QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)

  const U$2 = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

  function isDelim(token, code) {
    return token !== null && token.type === types$4.Delim && token.value.charCodeAt(0) === code;
  }

  function startsWith$1(token, code) {
    return token.value.charCodeAt(0) === code;
  }

  function hexSequence(token, offset, allowDash) {
    let hexlen = 0;

    for (let pos = offset; pos < token.value.length; pos++) {
      const code = token.value.charCodeAt(pos);

      if (code === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
        hexSequence(token, offset + hexlen + 1, false);
        return 6; // dissallow following question marks
      }

      if (!charCodeDefinitions.isHexDigit(code)) {
        return 0; // not a hex digit
      }

      if (++hexlen > 6) {
        return 0; // too many hex digits
      }
    }

    return hexlen;
  }

  function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
      return 0; // nothing consumed
    }

    while (isDelim(getNextToken(length), QUESTIONMARK$2)) {
      if (++consumed > 6) {
        return 0; // too many question marks
      }

      length++;
    }

    return length;
  } // https://drafts.csswg.org/css-syntax/#urange
  // Informally, the <urange> production has three forms:
  // U+0001
  //      Defines a range consisting of a single code point, in this case the code point "1".
  // U+0001-00ff
  //      Defines a range of codepoints between the first and the second value, in this case
  //      the range between "1" and "ff" (255 in decimal) inclusive.
  // U+00??
  //      Defines a range of codepoints where the "?" characters range over all hex digits,
  //      in this case defining the same as the value U+0000-00ff.
  // In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
  //
  // <urange> =
  //   u '+' <ident-token> '?'* |
  //   u <dimension-token> '?'* |
  //   u <number-token> '?'* |
  //   u <number-token> <dimension-token> |
  //   u <number-token> <number-token> |
  //   u '+' '?'+


  function urange(token, getNextToken) {
    let length = 0; // should start with `u` or `U`

    if (token === null || token.type !== types$4.Ident || !utils$9.cmpChar(token.value, 0, U$2)) {
      return 0;
    }

    token = getNextToken(++length);

    if (token === null) {
      return 0;
    } // u '+' <ident-token> '?'*
    // u '+' '?'+


    if (isDelim(token, PLUSSIGN$7)) {
      token = getNextToken(++length);

      if (token === null) {
        return 0;
      }

      if (token.type === types$4.Ident) {
        // u '+' <ident-token> '?'*
        return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
      }

      if (isDelim(token, QUESTIONMARK$2)) {
        // u '+' '?'+
        return withQuestionMarkSequence(1, ++length, getNextToken);
      } // Hex digit or question mark is expected


      return 0;
    } // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>


    if (token.type === types$4.Number) {
      const consumedHexLength = hexSequence(token, 1, true);

      if (consumedHexLength === 0) {
        return 0;
      }

      token = getNextToken(++length);

      if (token === null) {
        // u <number-token> <eof>
        return length;
      }

      if (token.type === types$4.Dimension || token.type === types$4.Number) {
        // u <number-token> <dimension-token>
        // u <number-token> <number-token>
        if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
          return 0;
        }

        return length + 1;
      } // u <number-token> '?'*


      return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    } // u <dimension-token> '?'*


    if (token.type === types$4.Dimension) {
      return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }

    return 0;
  }

  var genericUrange = urange;

  const calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];
  const balancePair = new Map([[types$4.Function, types$4.RightParenthesis], [types$4.LeftParenthesis, types$4.RightParenthesis], [types$4.LeftSquareBracket, types$4.RightSquareBracket], [types$4.LeftCurlyBracket, types$4.RightCurlyBracket]]); // safe char code getter

  function charCodeAt(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
  }

  function eqStr(actual, expected) {
    return utils$9.cmpStr(actual, 0, actual.length, expected);
  }

  function eqStrAny(actual, expected) {
    for (let i = 0; i < expected.length; i++) {
      if (eqStr(actual, expected[i])) {
        return true;
      }
    }

    return false;
  } // IE postfix hack, i.e. 123\0 or 123px\9


  function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
      return false;
    }

    return charCodeAt(str, offset) === 0x005C && // U+005C REVERSE SOLIDUS (\)
    charCodeDefinitions.isDigit(charCodeAt(str, offset + 1));
  }

  function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === 'Range') {
      const num = Number(numEnd !== undefined && numEnd !== value.length ? value.substr(0, numEnd) : value);

      if (isNaN(num)) {
        return true;
      } // FIXME: when opts.min is a string it's a dimension, skip a range validation
      // for now since it requires a type covertation which is not implmented yet


      if (opts.min !== null && num < opts.min && typeof opts.min !== 'string') {
        return true;
      } // FIXME: when opts.max is a string it's a dimension, skip a range validation
      // for now since it requires a type covertation which is not implmented yet


      if (opts.max !== null && num > opts.max && typeof opts.max !== 'string') {
        return true;
      }
    }

    return false;
  }

  function consumeFunction$1(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0; // balanced token consuming

    scan: do {
      switch (token.type) {
        case types$4.RightCurlyBracket:
        case types$4.RightParenthesis:
        case types$4.RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }

          balanceCloseType = balanceStash.pop();

          if (balanceStash.length === 0) {
            length++;
            break scan;
          }

          break;

        case types$4.Function:
        case types$4.LeftParenthesis:
        case types$4.LeftSquareBracket:
        case types$4.LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }

      length++;
    } while (token = getNextToken(length));

    return length;
  } // TODO: implement
  // can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
  // https://drafts.csswg.org/css-values/#calc-notation


  function calc(next) {
    return function (token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }

      if (token.type === types$4.Function && eqStrAny(token.value, calcFunctionNames)) {
        return consumeFunction$1(token, getNextToken);
      }

      return next(token, getNextToken, opts);
    };
  }

  function tokenType(expectedTokenType) {
    return function (token) {
      if (token === null || token.type !== expectedTokenType) {
        return 0;
      }

      return 1;
    };
  } // =========================
  // Complex types
  //
  // https://drafts.csswg.org/css-values-4/#custom-idents
  // 4.2. Author-defined Identifiers: the <custom-ident> type
  // Some properties accept arbitrary author-defined identifiers as a component value.
  // This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
  // that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
  //
  // See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident


  function customIdent(token) {
    if (token === null || token.type !== types$4.Ident) {
      return 0;
    }

    const name = token.value.toLowerCase(); // The CSS-wide keywords are not valid <custom-ident>s

    if (eqStrAny(name, genericConst.cssWideKeywords)) {
      return 0;
    } // The default keyword is reserved and is also not a valid <custom-ident>


    if (eqStr(name, 'default')) {
      return 0;
    } // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    // Specifications using <custom-ident> must specify clearly what other keywords
    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
    // in that property’s value definition are excluded. Excluded keywords are excluded
    // in all ASCII case permutations.


    return 1;
  } // https://drafts.csswg.org/css-variables/#typedef-custom-property-name
  // A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
  // The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
  // that starts with two dashes, except -- itself, which is reserved for future use by CSS.
  // NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.


  function customPropertyName(token) {
    // ... defined as any valid identifier
    if (token === null || token.type !== types$4.Ident) {
      return 0;
    } // ... that starts with two dashes (U+002D HYPHEN-MINUS)


    if (charCodeAt(token.value, 0) !== 0x002D || charCodeAt(token.value, 1) !== 0x002D) {
      return 0;
    }

    return 1;
  } // https://drafts.csswg.org/css-color-4/#hex-notation
  // The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
  // In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
  // letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).


  function hexColor(token) {
    if (token === null || token.type !== types$4.Hash) {
      return 0;
    }

    const length = token.value.length; // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)

    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
      return 0;
    }

    for (let i = 1; i < length; i++) {
      if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {
        return 0;
      }
    }

    return 1;
  }

  function idSelector(token) {
    if (token === null || token.type !== types$4.Hash) {
      return 0;
    }

    if (!charCodeDefinitions.isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
      return 0;
    }

    return 1;
  } // https://drafts.csswg.org/css-syntax/#any-value
  // It represents the entirety of what a valid declaration can have as its value.


  function declarationValue(token, getNextToken) {
    if (!token) {
      return 0;
    }

    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0; // The <declaration-value> production matches any sequence of one or more tokens,
    // so long as the sequence does not contain ...

    scan: do {
      switch (token.type) {
        // ... <bad-string-token>, <bad-url-token>,
        case types$4.BadString:
        case types$4.BadUrl:
          break scan;
        // ... unmatched <)-token>, <]-token>, or <}-token>,

        case types$4.RightCurlyBracket:
        case types$4.RightParenthesis:
        case types$4.RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }

          balanceCloseType = balanceStash.pop();
          break;
        // ... or top-level <semicolon-token> tokens

        case types$4.Semicolon:
          if (balanceCloseType === 0) {
            break scan;
          }

          break;
        // ... or <delim-token> tokens with a value of "!"

        case types$4.Delim:
          if (balanceCloseType === 0 && token.value === '!') {
            break scan;
          }

          break;

        case types$4.Function:
        case types$4.LeftParenthesis:
        case types$4.LeftSquareBracket:
        case types$4.LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }

      length++;
    } while (token = getNextToken(length));

    return length;
  } // https://drafts.csswg.org/css-syntax/#any-value
  // The <any-value> production is identical to <declaration-value>, but also
  // allows top-level <semicolon-token> tokens and <delim-token> tokens
  // with a value of "!". It represents the entirety of what valid CSS can be in any context.


  function anyValue(token, getNextToken) {
    if (!token) {
      return 0;
    }

    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0; // The <any-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...

    scan: do {
      switch (token.type) {
        // ... does not contain <bad-string-token>, <bad-url-token>,
        case types$4.BadString:
        case types$4.BadUrl:
          break scan;
        // ... unmatched <)-token>, <]-token>, or <}-token>,

        case types$4.RightCurlyBracket:
        case types$4.RightParenthesis:
        case types$4.RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }

          balanceCloseType = balanceStash.pop();
          break;

        case types$4.Function:
        case types$4.LeftParenthesis:
        case types$4.LeftSquareBracket:
        case types$4.LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }

      length++;
    } while (token = getNextToken(length));

    return length;
  } // =========================
  // Dimensions
  //


  function dimension(type) {
    if (type) {
      type = new Set(type);
    }

    return function (token, getNextToken, opts) {
      if (token === null || token.type !== types$4.Dimension) {
        return 0;
      }

      const numberEnd = utils$9.consumeNumber(token.value, 0); // check unit

      if (type !== null) {
        // check for IE postfix hack, i.e. 123px\0 or 123px\9
        const reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
        const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);

        if (type.has(unit.toLowerCase()) === false) {
          return 0;
        }
      } // check range if specified


      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }

      return 1;
    };
  } // =========================
  // Percentage
  //
  // §5.5. Percentages: the <percentage> type
  // https://drafts.csswg.org/css-values-4/#percentages


  function percentage(token, getNextToken, opts) {
    // ... corresponds to the <percentage-token> production
    if (token === null || token.type !== types$4.Percentage) {
      return 0;
    } // check range if specified


    if (outOfRange(opts, token.value, token.value.length - 1)) {
      return 0;
    }

    return 1;
  } // =========================
  // Numeric
  //
  // https://drafts.csswg.org/css-values-4/#numbers
  // The value <zero> represents a literal number with the value 0. Expressions that merely
  // evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
  // only literal <number-token>s do.


  function zero(next) {
    if (typeof next !== 'function') {
      next = function () {
        return 0;
      };
    }

    return function (token, getNextToken, opts) {
      if (token !== null && token.type === types$4.Number) {
        if (Number(token.value) === 0) {
          return 1;
        }
      }

      return next(token, getNextToken, opts);
    };
  } // § 5.3. Real Numbers: the <number> type
  // https://drafts.csswg.org/css-values-4/#numbers
  // Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
  // ... It corresponds to the <number-token> production


  function number(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }

    const numberEnd = utils$9.consumeNumber(token.value, 0);
    const isNumber = numberEnd === token.value.length;

    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
      return 0;
    } // check range if specified


    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }

    return 1;
  } // §5.2. Integers: the <integer> type
  // https://drafts.csswg.org/css-values-4/#integers


  function integer(token, getNextToken, opts) {
    // ... corresponds to a subset of the <number-token> production
    if (token === null || token.type !== types$4.Number) {
      return 0;
    } // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.


    let i = charCodeAt(token.value, 0) === 0x002B || // U+002B PLUS SIGN (+)
    charCodeAt(token.value, 0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)
    // When written literally, an integer is one or more decimal digits 0 through 9 ...

    for (; i < token.value.length; i++) {
      if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {
        return 0;
      }
    } // check range if specified


    if (outOfRange(opts, token.value, i)) {
      return 0;
    }

    return 1;
  } // token types


  const tokenTypes$2 = {
    'ident-token': tokenType(types$4.Ident),
    'function-token': tokenType(types$4.Function),
    'at-keyword-token': tokenType(types$4.AtKeyword),
    'hash-token': tokenType(types$4.Hash),
    'string-token': tokenType(types$4.String),
    'bad-string-token': tokenType(types$4.BadString),
    'url-token': tokenType(types$4.Url),
    'bad-url-token': tokenType(types$4.BadUrl),
    'delim-token': tokenType(types$4.Delim),
    'number-token': tokenType(types$4.Number),
    'percentage-token': tokenType(types$4.Percentage),
    'dimension-token': tokenType(types$4.Dimension),
    'whitespace-token': tokenType(types$4.WhiteSpace),
    'CDO-token': tokenType(types$4.CDO),
    'CDC-token': tokenType(types$4.CDC),
    'colon-token': tokenType(types$4.Colon),
    'semicolon-token': tokenType(types$4.Semicolon),
    'comma-token': tokenType(types$4.Comma),
    '[-token': tokenType(types$4.LeftSquareBracket),
    ']-token': tokenType(types$4.RightSquareBracket),
    '(-token': tokenType(types$4.LeftParenthesis),
    ')-token': tokenType(types$4.RightParenthesis),
    '{-token': tokenType(types$4.LeftCurlyBracket),
    '}-token': tokenType(types$4.RightCurlyBracket)
  }; // token production types

  const productionTypes = {
    // token type aliases
    'string': tokenType(types$4.String),
    'ident': tokenType(types$4.Ident),
    // percentage
    'percentage': calc(percentage),
    // numeric
    'zero': zero(),
    'number': calc(number),
    'integer': calc(integer),
    // complex types
    'custom-ident': customIdent,
    'custom-property-name': customPropertyName,
    'hex-color': hexColor,
    'id-selector': idSelector,
    // element( <id-selector> )
    'an-plus-b': genericAnPlusB,
    'urange': genericUrange,
    'declaration-value': declarationValue,
    'any-value': anyValue
  }; // dimensions types depend on units set

  function createDemensionTypes(units) {
    const {
      angle,
      decibel,
      frequency,
      flex,
      length,
      resolution,
      semitones,
      time
    } = units || {};
    return {
      'dimension': calc(dimension(null)),
      'angle': calc(dimension(angle)),
      'decibel': calc(dimension(decibel)),
      'frequency': calc(dimension(frequency)),
      'flex': calc(dimension(flex)),
      'length': calc(zero(dimension(length))),
      'resolution': calc(dimension(resolution)),
      'semitones': calc(dimension(semitones)),
      'time': calc(dimension(time))
    };
  }

  function createGenericTypes(units) {
    return { ...tokenTypes$2,
      ...productionTypes,
      ...createDemensionTypes(units)
    };
  }

  var createDemensionTypes_1 = createDemensionTypes;
  var createGenericTypes_1 = createGenericTypes;
  var productionTypes_1 = productionTypes;
  var tokenTypes_1 = tokenTypes$2;

  var generic = {
  	createDemensionTypes: createDemensionTypes_1,
  	createGenericTypes: createGenericTypes_1,
  	productionTypes: productionTypes_1,
  	tokenTypes: tokenTypes_1
  };

  const length = [// absolute length units https://www.w3.org/TR/css-values-3/#lengths
  'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px', // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  'em', 'rem', 'ex', 'rex', 'cap', 'rcap', 'ch', 'rch', 'ic', 'ric', 'lh', 'rlh', // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  'vw', 'svw', 'lvw', 'dvw', 'vh', 'svh', 'lvh', 'dvh', 'vi', 'svi', 'lvi', 'dvi', 'vb', 'svb', 'lvb', 'dvb', 'vmin', 'svmin', 'lvmin', 'dvmin', 'vmax', 'svmax', 'lvmax', 'dvmax', // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax'];
  const angle = ['deg', 'grad', 'rad', 'turn']; // https://www.w3.org/TR/css-values-3/#angles

  const time = ['s', 'ms']; // https://www.w3.org/TR/css-values-3/#time

  const frequency = ['hz', 'khz']; // https://www.w3.org/TR/css-values-3/#frequency

  const resolution = ['dpi', 'dpcm', 'dppx', 'x']; // https://www.w3.org/TR/css-values-3/#resolution

  const flex$1 = ['fr']; // https://drafts.csswg.org/css-grid/#fr-unit

  const decibel = ['db']; // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume

  const semitones = ['st']; // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

  var angle_1 = angle;
  var decibel_1 = decibel;
  var flex_1 = flex$1;
  var frequency_1 = frequency;
  var length_1 = length;
  var resolution_1 = resolution;
  var semitones_1 = semitones;
  var time_1 = time;

  var units$2 = {
  	angle: angle_1,
  	decibel: decibel_1,
  	flex: flex_1,
  	frequency: frequency_1,
  	length: length_1,
  	resolution: resolution_1,
  	semitones: semitones_1,
  	time: time_1
  };

  const astToTokens = {
    decorator(handlers) {
      const tokens = [];
      let curNode = null;
      return { ...handlers,

        node(node) {
          const tmp = curNode;
          curNode = node;
          handlers.node.call(this, node);
          curNode = tmp;
        },

        emit(value, type, auto) {
          tokens.push({
            type,
            value,
            node: auto ? null : curNode
          });
        },

        result() {
          return tokens;
        }

      };
    }

  };

  function stringToTokens(str) {
    const tokens = [];
    tokenizer$2.tokenize(str, (type, start, end) => tokens.push({
      type,
      value: str.slice(start, end),
      node: null
    }));
    return tokens;
  }

  function prepareTokens(value, syntax) {
    if (typeof value === 'string') {
      return stringToTokens(value);
    }

    return syntax.generate(value, astToTokens);
  }

  var prepareTokens_1 = prepareTokens;

  function SyntaxError$1(message, input, offset) {
    return Object.assign(createCustomError_1.createCustomError('SyntaxError', message), {
      input,
      offset,
      rawMessage: message,
      message: message + '\n' + '  ' + input + '\n' + '--' + new Array((offset || input.length) + 1).join('-') + '^'
    });
  }

  var SyntaxError_1 = SyntaxError$1;

  var _SyntaxError$1 = {
  	SyntaxError: SyntaxError_1
  };

  const TAB$2 = 9;
  const N$3 = 10;
  const F$2 = 12;
  const R$2 = 13;
  const SPACE$6 = 32;

  class Tokenizer {
    constructor(str) {
      this.str = str;
      this.pos = 0;
    }

    charCodeAt(pos) {
      return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }

    charCode() {
      return this.charCodeAt(this.pos);
    }

    nextCharCode() {
      return this.charCodeAt(this.pos + 1);
    }

    nextNonWsCode(pos) {
      return this.charCodeAt(this.findWsEnd(pos));
    }

    findWsEnd(pos) {
      for (; pos < this.str.length; pos++) {
        const code = this.str.charCodeAt(pos);

        if (code !== R$2 && code !== N$3 && code !== F$2 && code !== SPACE$6 && code !== TAB$2) {
          break;
        }
      }

      return pos;
    }

    substringToPos(end) {
      return this.str.substring(this.pos, this.pos = end);
    }

    eat(code) {
      if (this.charCode() !== code) {
        this.error('Expect `' + String.fromCharCode(code) + '`');
      }

      this.pos++;
    }

    peek() {
      return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    }

    error(message) {
      throw new _SyntaxError$1.SyntaxError(message, this.str, this.pos);
    }

  }

  var Tokenizer_1 = Tokenizer;

  var tokenizer$1 = {
  	Tokenizer: Tokenizer_1
  };

  const TAB$1 = 9;
  const N$2 = 10;
  const F$1 = 12;
  const R$1 = 13;
  const SPACE$5 = 32;
  const EXCLAMATIONMARK$2 = 33; // !

  const NUMBERSIGN$3 = 35; // #

  const AMPERSAND$5 = 38; // &

  const APOSTROPHE$2 = 39; // '

  const LEFTPARENTHESIS$2 = 40; // (

  const RIGHTPARENTHESIS$2 = 41; // )

  const ASTERISK$7 = 42; // *

  const PLUSSIGN$6 = 43; // +

  const COMMA = 44; // ,

  const HYPERMINUS = 45; // -

  const LESSTHANSIGN = 60; // <

  const GREATERTHANSIGN$2 = 62; // >

  const QUESTIONMARK$1 = 63; // ?

  const COMMERCIALAT = 64; // @

  const LEFTSQUAREBRACKET = 91; // [

  const RIGHTSQUAREBRACKET = 93; // ]

  const LEFTCURLYBRACKET = 123; // {

  const VERTICALLINE$3 = 124; // |

  const RIGHTCURLYBRACKET = 125; // }

  const INFINITY = 8734; // ∞

  const NAME_CHAR = new Uint8Array(128).map((_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0);
  const COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
  };

  function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));
  }

  function scanWord(tokenizer) {
    let end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
      const code = tokenizer.str.charCodeAt(end);

      if (code >= 128 || NAME_CHAR[code] === 0) {
        break;
      }
    }

    if (tokenizer.pos === end) {
      tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
  }

  function scanNumber(tokenizer) {
    let end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
      const code = tokenizer.str.charCodeAt(end);

      if (code < 48 || code > 57) {
        break;
      }
    }

    if (tokenizer.pos === end) {
      tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
  }

  function scanString(tokenizer) {
    const end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
      tokenizer.pos = tokenizer.str.length;
      tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
  }

  function readMultiplierRange(tokenizer) {
    let min = null;
    let max = null;
    tokenizer.eat(LEFTCURLYBRACKET);
    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
      tokenizer.pos++;

      if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
        max = scanNumber(tokenizer);
      }
    } else {
      max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);
    return {
      min: Number(min),
      max: max ? Number(max) : 0
    };
  }

  function readMultiplier(tokenizer) {
    let range = null;
    let comma = false;

    switch (tokenizer.charCode()) {
      case ASTERISK$7:
        tokenizer.pos++;
        range = {
          min: 0,
          max: 0
        };
        break;

      case PLUSSIGN$6:
        tokenizer.pos++;
        range = {
          min: 1,
          max: 0
        };
        break;

      case QUESTIONMARK$1:
        tokenizer.pos++;
        range = {
          min: 0,
          max: 1
        };
        break;

      case NUMBERSIGN$3:
        tokenizer.pos++;
        comma = true;

        if (tokenizer.charCode() === LEFTCURLYBRACKET) {
          range = readMultiplierRange(tokenizer);
        } else if (tokenizer.charCode() === QUESTIONMARK$1) {
          // https://www.w3.org/TR/css-values-4/#component-multipliers
          // > the # and ? multipliers may be stacked as #?
          // In this case just treat "#?" as a single multiplier
          // { min: 0, max: 0, comma: true }
          tokenizer.pos++;
          range = {
            min: 0,
            max: 0
          };
        } else {
          range = {
            min: 1,
            max: 0
          };
        }

        break;

      case LEFTCURLYBRACKET:
        range = readMultiplierRange(tokenizer);
        break;

      default:
        return null;
    }

    return {
      type: 'Multiplier',
      comma,
      min: range.min,
      max: range.max,
      term: null
    };
  }

  function maybeMultiplied(tokenizer, node) {
    const multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
      multiplier.term = node; // https://www.w3.org/TR/css-values-4/#component-multipliers
      // > The + and # multipliers may be stacked as +#;
      // Represent "+#" as nested multipliers:
      // { ...<multiplier #>,
      //   term: {
      //     ...<multipler +>,
      //     term: node
      //   }
      // }

      if (tokenizer.charCode() === NUMBERSIGN$3 && tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN$6) {
        return maybeMultiplied(tokenizer, multiplier);
      }

      return multiplier;
    }

    return node;
  }

  function maybeToken(tokenizer) {
    const ch = tokenizer.peek();

    if (ch === '') {
      return null;
    }

    return {
      type: 'Token',
      value: ch
    };
  }

  function readProperty$1(tokenizer) {
    let name;
    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE$2);
    name = scanWord(tokenizer);
    tokenizer.eat(APOSTROPHE$2);
    tokenizer.eat(GREATERTHANSIGN$2);
    return maybeMultiplied(tokenizer, {
      type: 'Property',
      name
    });
  } // https://drafts.csswg.org/css-values-3/#numeric-ranges
  // 4.1. Range Restrictions and Range Definition Notation
  //
  // Range restrictions can be annotated in the numeric type notation using CSS bracketed
  // range notation—[min,max]—within the angle brackets, after the identifying keyword,
  // indicating a closed range between (and including) min and max.
  // For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.


  function readTypeRange(tokenizer) {
    // use null for Infinity to make AST format JSON serializable/deserializable
    let min = null; // -Infinity

    let max = null; // Infinity

    let sign = 1;
    tokenizer.eat(LEFTSQUAREBRACKET);

    if (tokenizer.charCode() === HYPERMINUS) {
      tokenizer.peek();
      sign = -1;
    }

    if (sign == -1 && tokenizer.charCode() === INFINITY) {
      tokenizer.peek();
    } else {
      min = sign * Number(scanNumber(tokenizer));

      if (NAME_CHAR[tokenizer.charCode()] !== 0) {
        min += scanWord(tokenizer);
      }
    }

    scanSpaces(tokenizer);
    tokenizer.eat(COMMA);
    scanSpaces(tokenizer);

    if (tokenizer.charCode() === INFINITY) {
      tokenizer.peek();
    } else {
      sign = 1;

      if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
      }

      max = sign * Number(scanNumber(tokenizer));

      if (NAME_CHAR[tokenizer.charCode()] !== 0) {
        max += scanWord(tokenizer);
      }
    }

    tokenizer.eat(RIGHTSQUAREBRACKET);
    return {
      type: 'Range',
      min,
      max
    };
  }

  function readType(tokenizer) {
    let name;
    let opts = null;
    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$2 && tokenizer.nextCharCode() === RIGHTPARENTHESIS$2) {
      tokenizer.pos += 2;
      name += '()';
    }

    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
      scanSpaces(tokenizer);
      opts = readTypeRange(tokenizer);
    }

    tokenizer.eat(GREATERTHANSIGN$2);
    return maybeMultiplied(tokenizer, {
      type: 'Type',
      name,
      opts
    });
  }

  function readKeywordOrFunction(tokenizer) {
    const name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$2) {
      tokenizer.pos++;
      return {
        type: 'Function',
        name
      };
    }

    return maybeMultiplied(tokenizer, {
      type: 'Keyword',
      name
    });
  }

  function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
      return {
        type: 'Group',
        terms,
        combinator,
        disallowEmpty: false,
        explicit: false
      };
    }

    let combinator;
    combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);

    while (combinators.length > 0) {
      combinator = combinators.shift();
      let i = 0;
      let subgroupStart = 0;

      for (; i < terms.length; i++) {
        const term = terms[i];

        if (term.type === 'Combinator') {
          if (term.value === combinator) {
            if (subgroupStart === -1) {
              subgroupStart = i - 1;
            }

            terms.splice(i, 1);
            i--;
          } else {
            if (subgroupStart !== -1 && i - subgroupStart > 1) {
              terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
              i = subgroupStart + 1;
            }

            subgroupStart = -1;
          }
        }
      }

      if (subgroupStart !== -1 && combinators.length) {
        terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
      }
    }

    return combinator;
  }

  function readImplicitGroup(tokenizer) {
    const terms = [];
    const combinators = {};
    let token;
    let prevToken = null;
    let prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
      if (token.type !== 'Spaces') {
        if (token.type === 'Combinator') {
          // check for combinator in group beginning and double combinator sequence
          if (prevToken === null || prevToken.type === 'Combinator') {
            tokenizer.pos = prevTokenPos;
            tokenizer.error('Unexpected combinator');
          }

          combinators[token.value] = true;
        } else if (prevToken !== null && prevToken.type !== 'Combinator') {
          combinators[' '] = true; // a b

          terms.push({
            type: 'Combinator',
            value: ' '
          });
        }

        terms.push(token);
        prevToken = token;
        prevTokenPos = tokenizer.pos;
      }
    } // check for combinator in group ending


    if (prevToken !== null && prevToken.type === 'Combinator') {
      tokenizer.pos -= prevTokenPos;
      tokenizer.error('Unexpected combinator');
    }

    return {
      type: 'Group',
      terms,
      combinator: regroupTerms(terms, combinators) || ' ',
      disallowEmpty: false,
      explicit: false
    };
  }

  function readGroup(tokenizer) {
    let result;
    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);
    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK$2) {
      tokenizer.pos++;
      result.disallowEmpty = true;
    }

    return result;
  }

  function peek(tokenizer) {
    let code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
      return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
      case RIGHTSQUAREBRACKET:
        // don't eat, stop scan a group
        break;

      case LEFTSQUAREBRACKET:
        return maybeMultiplied(tokenizer, readGroup(tokenizer));

      case LESSTHANSIGN:
        return tokenizer.nextCharCode() === APOSTROPHE$2 ? readProperty$1(tokenizer) : readType(tokenizer);

      case VERTICALLINE$3:
        return {
          type: 'Combinator',
          value: tokenizer.substringToPos(tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE$3 ? 2 : 1))
        };

      case AMPERSAND$5:
        tokenizer.pos++;
        tokenizer.eat(AMPERSAND$5);
        return {
          type: 'Combinator',
          value: '&&'
        };

      case COMMA:
        tokenizer.pos++;
        return {
          type: 'Comma'
        };

      case APOSTROPHE$2:
        return maybeMultiplied(tokenizer, {
          type: 'String',
          value: scanString(tokenizer)
        });

      case SPACE$5:
      case TAB$1:
      case N$2:
      case R$1:
      case F$1:
        return {
          type: 'Spaces',
          value: scanSpaces(tokenizer)
        };

      case COMMERCIALAT:
        code = tokenizer.nextCharCode();

        if (code < 128 && NAME_CHAR[code] === 1) {
          tokenizer.pos++;
          return {
            type: 'AtKeyword',
            name: scanWord(tokenizer)
          };
        }

        return maybeToken(tokenizer);

      case ASTERISK$7:
      case PLUSSIGN$6:
      case QUESTIONMARK$1:
      case NUMBERSIGN$3:
      case EXCLAMATIONMARK$2:
        // prohibited tokens (used as a multiplier start)
        break;

      case LEFTCURLYBRACKET:
        // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
        // check next char isn't a number, because it's likely a disjoined multiplier
        code = tokenizer.nextCharCode();

        if (code < 48 || code > 57) {
          return maybeToken(tokenizer);
        }

        break;

      default:
        return maybeToken(tokenizer);
    }
  }

  function parse$T(source) {
    const tokenizer$1$1 = new tokenizer$1.Tokenizer(source);
    const result = readImplicitGroup(tokenizer$1$1);

    if (tokenizer$1$1.pos !== source.length) {
      tokenizer$1$1.error('Unexpected input');
    } // reduce redundant groups with single group term


    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
      return result.terms[0];
    }

    return result;
  }

  var parse_2 = parse$T;

  var parse_1$N = {
  	parse: parse_2
  };

  const MATCH = {
    type: 'Match'
  };
  const MISMATCH = {
    type: 'Mismatch'
  };
  const DISALLOW_EMPTY = {
    type: 'DisallowEmpty'
  };
  const LEFTPARENTHESIS$1 = 40; // (

  const RIGHTPARENTHESIS$1 = 41; // )

  function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
      return match;
    }

    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
      return match;
    }

    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
      thenBranch = match.then;
      match = match.match;
    }

    return {
      type: 'If',
      match,
      then: thenBranch,
      else: elseBranch
    };
  }

  function isFunctionType(name) {
    return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1;
  }

  function isEnumCapatible(term) {
    return term.type === 'Keyword' || term.type === 'AtKeyword' || term.type === 'Function' || term.type === 'Type' && isFunctionType(term.name);
  }

  function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
      case ' ':
        {
          // Juxtaposing components means that all of them must occur, in the given order.
          //
          // a b c
          // =
          // match a
          //   then match b
          //     then match c
          //       then MATCH
          //       else MISMATCH
          //     else MISMATCH
          //   else MISMATCH
          let result = MATCH;

          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            result = createCondition(term, result, MISMATCH);
          }

          return result;
        }

      case '|':
        {
          // A bar (|) separates two or more alternatives: exactly one of them must occur.
          //
          // a | b | c
          // =
          // match a
          //   then MATCH
          //   else match b
          //     then MATCH
          //     else match c
          //       then MATCH
          //       else MISMATCH
          let result = MISMATCH;
          let map = null;

          for (let i = terms.length - 1; i >= 0; i--) {
            let term = terms[i]; // reduce sequence of keywords into a Enum

            if (isEnumCapatible(term)) {
              if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                map = Object.create(null);
                result = createCondition({
                  type: 'Enum',
                  map
                }, MATCH, result);
              }

              if (map !== null) {
                const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();

                if (key in map === false) {
                  map[key] = term;
                  continue;
                }
              }
            }

            map = null; // create a new conditonal node

            result = createCondition(term, MATCH, result);
          }

          return result;
        }

      case '&&':
        {
          // A double ampersand (&&) separates two or more components,
          // all of which must occur, in any order.
          // Use MatchOnce for groups with a large number of terms,
          // since &&-groups produces at least N!-node trees
          if (terms.length > 5) {
            return {
              type: 'MatchOnce',
              terms,
              all: true
            };
          } // Use a combination tree for groups with small number of terms
          //
          // a && b && c
          // =
          // match a
          //   then [b && c]
          //   else match b
          //     then [a && c]
          //     else match c
          //       then [a && b]
          //       else MISMATCH
          //
          // a && b
          // =
          // match a
          //   then match b
          //     then MATCH
          //     else MISMATCH
          //   else match b
          //     then match a
          //       then MATCH
          //       else MISMATCH
          //     else MISMATCH


          let result = MISMATCH;

          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            let thenClause;

            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {
                return newGroupTerm !== term;
              }), false);
            } else {
              thenClause = MATCH;
            }

            result = createCondition(term, thenClause, result);
          }

          return result;
        }

      case '||':
        {
          // A double bar (||) separates two or more options:
          // one or more of them must occur, in any order.
          // Use MatchOnce for groups with a large number of terms,
          // since ||-groups produces at least N!-node trees
          if (terms.length > 5) {
            return {
              type: 'MatchOnce',
              terms,
              all: false
            };
          } // Use a combination tree for groups with small number of terms
          //
          // a || b || c
          // =
          // match a
          //   then [b || c]
          //   else match b
          //     then [a || c]
          //     else match c
          //       then [a || b]
          //       else MISMATCH
          //
          // a || b
          // =
          // match a
          //   then match b
          //     then MATCH
          //     else MATCH
          //   else match b
          //     then match a
          //       then MATCH
          //       else MATCH
          //     else MISMATCH


          let result = atLeastOneTermMatched ? MATCH : MISMATCH;

          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            let thenClause;

            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {
                return newGroupTerm !== term;
              }), true);
            } else {
              thenClause = MATCH;
            }

            result = createCondition(term, thenClause, result);
          }

          return result;
        }
    }
  }

  function buildMultiplierMatchGraph(node) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node.term);

    if (node.max === 0) {
      // disable repeating of empty match to prevent infinite loop
      matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH); // an occurrence count is not limited, make a cycle;
      // to collect more terms on each following matching mismatch

      result = createCondition(matchTerm, null, // will be a loop
      MISMATCH);
      result.then = createCondition(MATCH, MATCH, result // make a loop
      );

      if (node.comma) {
        result.then.else = createCondition({
          type: 'Comma',
          syntax: node
        }, result, MISMATCH);
      }
    } else {
      // create a match node chain for [min .. max] interval with optional matches
      for (let i = node.min || 1; i <= node.max; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition({
            type: 'Comma',
            syntax: node
          }, result, MISMATCH);
        }

        result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
      }
    }

    if (node.min === 0) {
      // allow zero match
      result = createCondition(MATCH, MATCH, result);
    } else {
      // create a match node chain to collect [0 ... min - 1] required matches
      for (let i = 0; i < node.min - 1; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition({
            type: 'Comma',
            syntax: node
          }, result, MISMATCH);
        }

        result = createCondition(matchTerm, result, MISMATCH);
      }
    }

    return result;
  }

  function buildMatchGraphInternal(node) {
    if (typeof node === 'function') {
      return {
        type: 'Generic',
        fn: node
      };
    }

    switch (node.type) {
      case 'Group':
        {
          let result = buildGroupMatchGraph(node.combinator, node.terms.map(buildMatchGraphInternal), false);

          if (node.disallowEmpty) {
            result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
          }

          return result;
        }

      case 'Multiplier':
        return buildMultiplierMatchGraph(node);

      case 'Type':
      case 'Property':
        return {
          type: node.type,
          name: node.name,
          syntax: node
        };

      case 'Keyword':
        return {
          type: node.type,
          name: node.name.toLowerCase(),
          syntax: node
        };

      case 'AtKeyword':
        return {
          type: node.type,
          name: '@' + node.name.toLowerCase(),
          syntax: node
        };

      case 'Function':
        return {
          type: node.type,
          name: node.name.toLowerCase() + '(',
          syntax: node
        };

      case 'String':
        // convert a one char length String to a Token
        if (node.value.length === 3) {
          return {
            type: 'Token',
            value: node.value.charAt(1),
            syntax: node
          };
        } // otherwise use it as is


        return {
          type: node.type,
          value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
          syntax: node
        };

      case 'Token':
        return {
          type: node.type,
          value: node.value,
          syntax: node
        };

      case 'Comma':
        return {
          type: node.type,
          syntax: node
        };

      default:
        throw new Error('Unknown node type:', node.type);
    }
  }

  function buildMatchGraph(syntaxTree, ref) {
    if (typeof syntaxTree === 'string') {
      syntaxTree = parse_1$N.parse(syntaxTree);
    }

    return {
      type: 'MatchGraph',
      match: buildMatchGraphInternal(syntaxTree),
      syntax: ref || null,
      source: syntaxTree
    };
  }

  var DISALLOW_EMPTY_1 = DISALLOW_EMPTY;
  var MATCH_1 = MATCH;
  var MISMATCH_1 = MISMATCH;
  var buildMatchGraph_1 = buildMatchGraph;

  var matchGraph = {
  	DISALLOW_EMPTY: DISALLOW_EMPTY_1,
  	MATCH: MATCH_1,
  	MISMATCH: MISMATCH_1,
  	buildMatchGraph: buildMatchGraph_1
  };

  const {
    hasOwnProperty: hasOwnProperty$3
  } = Object.prototype;
  const STUB = 0;
  const TOKEN = 1;
  const OPEN_SYNTAX = 2;
  const CLOSE_SYNTAX = 3;
  const EXIT_REASON_MATCH = 'Match';
  const EXIT_REASON_MISMATCH = 'Mismatch';
  const EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';
  const ITERATION_LIMIT = 15000;

  function reverseList(list) {
    let prev = null;
    let next = null;
    let item = list;

    while (item !== null) {
      next = item.prev;
      item.prev = prev;
      prev = item;
      item = next;
    }

    return prev;
  }

  function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
      return false;
    }

    for (let i = 0; i < testStr.length; i++) {
      const referenceCode = referenceStr.charCodeAt(i);
      let testCode = testStr.charCodeAt(i); // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).

      if (testCode >= 0x0041 && testCode <= 0x005A) {
        testCode = testCode | 32;
      }

      if (testCode !== referenceCode) {
        return false;
      }
    }

    return true;
  }

  function isContextEdgeDelim(token) {
    if (token.type !== types$4.Delim) {
      return false;
    } // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    // Probably we need to check out previous match instead


    return token.value !== '?';
  }

  function isCommaContextStart(token) {
    if (token === null) {
      return true;
    }

    return token.type === types$4.Comma || token.type === types$4.Function || token.type === types$4.LeftParenthesis || token.type === types$4.LeftSquareBracket || token.type === types$4.LeftCurlyBracket || isContextEdgeDelim(token);
  }

  function isCommaContextEnd(token) {
    if (token === null) {
      return true;
    }

    return token.type === types$4.RightParenthesis || token.type === types$4.RightSquareBracket || token.type === types$4.RightCurlyBracket || token.type === types$4.Delim && token.value === '/';
  }

  function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
      do {
        tokenIndex++;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
      } while (token !== null && (token.type === types$4.WhiteSpace || token.type === types$4.Comment));
    }

    function getNextToken(offset) {
      const nextIndex = tokenIndex + offset;
      return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function stateSnapshotFromSyntax(nextState, prev) {
      return {
        nextState,
        matchStack,
        syntaxStack,
        thenStack,
        tokenIndex,
        prev
      };
    }

    function pushThenStack(nextState) {
      thenStack = {
        nextState,
        matchStack,
        syntaxStack,
        prev: thenStack
      };
    }

    function pushElseStack(nextState) {
      elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }

    function addTokenToMatch() {
      matchStack = {
        type: TOKEN,
        syntax: state.syntax,
        token,
        prev: matchStack
      };
      moveToNextToken();
      syntaxStash = null;

      if (tokenIndex > longestMatch) {
        longestMatch = tokenIndex;
      }
    }

    function openSyntax() {
      syntaxStack = {
        syntax: state.syntax,
        opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
        prev: syntaxStack
      };
      matchStack = {
        type: OPEN_SYNTAX,
        syntax: state.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }

    function closeSyntax() {
      if (matchStack.type === OPEN_SYNTAX) {
        matchStack = matchStack.prev;
      } else {
        matchStack = {
          type: CLOSE_SYNTAX,
          syntax: syntaxStack.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }

      syntaxStack = syntaxStack.prev;
    }

    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null; // null – stashing allowed, nothing stashed
    // false – stashing disabled, nothing stashed
    // anithing else – fail stashable syntaxes, some syntax stashed

    let syntaxStash = null;
    let iterationCount = 0; // count iterations and prevent infinite loop

    let exitReason = null;
    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
      type: STUB,
      syntax: null,
      token: null,
      prev: null
    };
    moveToNextToken();

    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
      // function mapList(list, fn) {
      //     const result = [];
      //     while (list) {
      //         result.unshift(fn(list));
      //         list = list.prev;
      //     }
      //     return result;
      // }
      // console.log('--\n',
      //     '#' + iterationCount,
      //     require('util').inspect({
      //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
      //         token: token && token.value,
      //         tokenIndex,
      //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
      //     }, { depth: null })
      // );
      switch (state.type) {
        case 'Match':
          if (thenStack === null) {
            // turn to MISMATCH when some tokens left unmatched
            if (token !== null) {
              // doesn't mismatch if just one token left and it's an IE hack
              if (tokenIndex !== tokens.length - 1 || token.value !== '\\0' && token.value !== '\\9') {
                state = matchGraph.MISMATCH;
                break;
              }
            } // break the main loop, return a result - MATCH


            exitReason = EXIT_REASON_MATCH;
            break;
          } // go to next syntax (`then` branch)


          state = thenStack.nextState; // check match is not empty

          if (state === matchGraph.DISALLOW_EMPTY) {
            if (thenStack.matchStack === matchStack) {
              state = matchGraph.MISMATCH;
              break;
            } else {
              state = matchGraph.MATCH;
            }
          } // close syntax if needed


          while (thenStack.syntaxStack !== syntaxStack) {
            closeSyntax();
          } // pop stack


          thenStack = thenStack.prev;
          break;

        case 'Mismatch':
          // when some syntax is stashed
          if (syntaxStash !== null && syntaxStash !== false) {
            // there is no else branches or a branch reduce match stack
            if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
              // restore state from the stash
              elseStack = syntaxStash;
              syntaxStash = false; // disable stashing
            }
          } else if (elseStack === null) {
            // no else branches -> break the main loop
            // return a result - MISMATCH
            exitReason = EXIT_REASON_MISMATCH;
            break;
          } // go to next syntax (`else` branch)


          state = elseStack.nextState; // restore all the rest stack states

          thenStack = elseStack.thenStack;
          syntaxStack = elseStack.syntaxStack;
          matchStack = elseStack.matchStack;
          tokenIndex = elseStack.tokenIndex;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null; // pop stack

          elseStack = elseStack.prev;
          break;

        case 'MatchGraph':
          state = state.match;
          break;

        case 'If':
          // IMPORTANT: else stack push must go first,
          // since it stores the state of thenStack before changes
          if (state.else !== matchGraph.MISMATCH) {
            pushElseStack(state.else);
          }

          if (state.then !== matchGraph.MATCH) {
            pushThenStack(state.then);
          }

          state = state.match;
          break;

        case 'MatchOnce':
          state = {
            type: 'MatchOnceBuffer',
            syntax: state,
            index: 0,
            mask: 0
          };
          break;

        case 'MatchOnceBuffer':
          {
            const terms = state.syntax.terms;

            if (state.index === terms.length) {
              // no matches at all or it's required all terms to be matched
              if (state.mask === 0 || state.syntax.all) {
                state = matchGraph.MISMATCH;
                break;
              } // a partial match is ok


              state = matchGraph.MATCH;
              break;
            } // all terms are matched


            if (state.mask === (1 << terms.length) - 1) {
              state = matchGraph.MATCH;
              break;
            }

            for (; state.index < terms.length; state.index++) {
              const matchFlag = 1 << state.index;

              if ((state.mask & matchFlag) === 0) {
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                pushElseStack(state);
                pushThenStack({
                  type: 'AddMatchOnce',
                  syntax: state.syntax,
                  mask: state.mask | matchFlag
                }); // match

                state = terms[state.index++];
                break;
              }
            }

            break;
          }

        case 'AddMatchOnce':
          state = {
            type: 'MatchOnceBuffer',
            syntax: state.syntax,
            index: 0,
            mask: state.mask
          };
          break;

        case 'Enum':
          if (token !== null) {
            let name = token.value.toLowerCase(); // drop \0 and \9 hack from keyword name

            if (name.indexOf('\\') !== -1) {
              name = name.replace(/\\[09].*$/, '');
            }

            if (hasOwnProperty$3.call(state.map, name)) {
              state = state.map[name];
              break;
            }
          }

          state = matchGraph.MISMATCH;
          break;

        case 'Generic':
          {
            const opts = syntaxStack !== null ? syntaxStack.opts : null;
            const lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

            if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
              while (tokenIndex < lastTokenIndex) {
                addTokenToMatch();
              }

              state = matchGraph.MATCH;
            } else {
              state = matchGraph.MISMATCH;
            }

            break;
          }

        case 'Type':
        case 'Property':
          {
            const syntaxDict = state.type === 'Type' ? 'types' : 'properties';
            const dictSyntax = hasOwnProperty$3.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

            if (!dictSyntax || !dictSyntax.match) {
              throw new Error('Bad syntax reference: ' + (state.type === 'Type' ? '<' + state.name + '>' : '<\'' + state.name + '\'>'));
            } // stash a syntax for types with low priority


            if (syntaxStash !== false && token !== null && state.type === 'Type') {
              const lowPriorityMatching = // https://drafts.csswg.org/css-values-4/#custom-idents
              // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
              // can only claim the keyword if no other unfulfilled production can claim it.
              state.name === 'custom-ident' && token.type === types$4.Ident || // https://drafts.csswg.org/css-values-4/#lengths
              // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
              // it must parse as a <number>
              state.name === 'length' && token.value === '0';

              if (lowPriorityMatching) {
                if (syntaxStash === null) {
                  syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                }

                state = matchGraph.MISMATCH;
                break;
              }
            }

            openSyntax();
            state = dictSyntax.match;
            break;
          }

        case 'Keyword':
          {
            const name = state.name;

            if (token !== null) {
              let keywordName = token.value; // drop \0 and \9 hack from keyword name

              if (keywordName.indexOf('\\') !== -1) {
                keywordName = keywordName.replace(/\\[09].*$/, '');
              }

              if (areStringsEqualCaseInsensitive(keywordName, name)) {
                addTokenToMatch();
                state = matchGraph.MATCH;
                break;
              }
            }

            state = matchGraph.MISMATCH;
            break;
          }

        case 'AtKeyword':
        case 'Function':
          if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
            addTokenToMatch();
            state = matchGraph.MATCH;
            break;
          }

          state = matchGraph.MISMATCH;
          break;

        case 'Token':
          if (token !== null && token.value === state.value) {
            addTokenToMatch();
            state = matchGraph.MATCH;
            break;
          }

          state = matchGraph.MISMATCH;
          break;

        case 'Comma':
          if (token !== null && token.type === types$4.Comma) {
            if (isCommaContextStart(matchStack.token)) {
              state = matchGraph.MISMATCH;
            } else {
              addTokenToMatch();
              state = isCommaContextEnd(token) ? matchGraph.MISMATCH : matchGraph.MATCH;
            }
          } else {
            state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph.MATCH : matchGraph.MISMATCH;
          }

          break;

        case 'String':
          let string = '';
          let lastTokenIndex = tokenIndex;

          for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
            string += tokens[lastTokenIndex].value;
          }

          if (areStringsEqualCaseInsensitive(string, state.value)) {
            while (tokenIndex < lastTokenIndex) {
              addTokenToMatch();
            }

            state = matchGraph.MATCH;
          } else {
            state = matchGraph.MISMATCH;
          }

          break;

        default:
          throw new Error('Unknown node type: ' + state.type);
      }
    }

    switch (exitReason) {
      case null:
        console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
        exitReason = EXIT_REASON_ITERATION_LIMIT;
        matchStack = null;
        break;

      case EXIT_REASON_MATCH:
        while (syntaxStack !== null) {
          closeSyntax();
        }

        break;

      default:
        matchStack = null;
    }

    return {
      tokens,
      reason: exitReason,
      iterations: iterationCount,
      match: matchStack,
      longestMatch
    };
  }

  function matchAsList(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
      let item = reverseList(matchResult.match).prev;
      matchResult.match = [];

      while (item !== null) {
        switch (item.type) {
          case OPEN_SYNTAX:
          case CLOSE_SYNTAX:
            matchResult.match.push({
              type: item.type,
              syntax: item.syntax
            });
            break;

          default:
            matchResult.match.push({
              token: item.token.value,
              node: item.token.node
            });
            break;
        }

        item = item.prev;
      }
    }

    return matchResult;
  }

  function matchAsTree(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
      return matchResult;
    }

    let item = matchResult.match;
    let host = matchResult.match = {
      syntax: matchGraph.syntax || null,
      match: []
    };
    const hostStack = [host]; // revert a list and start with 2nd item since 1st is a stub item

    item = reverseList(item).prev; // build a tree

    while (item !== null) {
      switch (item.type) {
        case OPEN_SYNTAX:
          host.match.push(host = {
            syntax: item.syntax,
            match: []
          });
          hostStack.push(host);
          break;

        case CLOSE_SYNTAX:
          hostStack.pop();
          host = hostStack[hostStack.length - 1];
          break;

        default:
          host.match.push({
            syntax: item.syntax || null,
            token: item.token.value,
            node: item.token.node
          });
      }

      item = item.prev;
    }

    return matchResult;
  }

  var matchAsList_1 = matchAsList;
  var matchAsTree_1 = matchAsTree;

  var match = {
  	matchAsList: matchAsList_1,
  	matchAsTree: matchAsTree_1
  };

  function getTrace(node) {
    function shouldPutToTrace(syntax) {
      if (syntax === null) {
        return false;
      }

      return syntax.type === 'Type' || syntax.type === 'Property' || syntax.type === 'Keyword';
    }

    function hasMatch(matchNode) {
      if (Array.isArray(matchNode.match)) {
        // use for-loop for better perfomance
        for (let i = 0; i < matchNode.match.length; i++) {
          if (hasMatch(matchNode.match[i])) {
            if (shouldPutToTrace(matchNode.syntax)) {
              result.unshift(matchNode.syntax);
            }

            return true;
          }
        }
      } else if (matchNode.node === node) {
        result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
        return true;
      }

      return false;
    }

    let result = null;

    if (this.matched !== null) {
      hasMatch(this.matched);
    }

    return result;
  }

  function isType$1(node, type) {
    return testNode(this, node, match => match.type === 'Type' && match.name === type);
  }

  function isProperty(node, property) {
    return testNode(this, node, match => match.type === 'Property' && match.name === property);
  }

  function isKeyword$1(node) {
    return testNode(this, node, match => match.type === 'Keyword');
  }

  function testNode(match, node, fn) {
    const trace = getTrace.call(match, node);

    if (trace === null) {
      return false;
    }

    return trace.some(fn);
  }

  var getTrace_1 = getTrace;
  var isKeyword_1$1 = isKeyword$1;
  var isProperty_1 = isProperty;
  var isType_1 = isType$1;

  var trace = {
  	getTrace: getTrace_1,
  	isKeyword: isKeyword_1$1,
  	isProperty: isProperty_1,
  	isType: isType_1
  };

  function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
      return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
  }

  function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
      return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
  }

  function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
      if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
        const start = getFirstMatchNode(matchNode);
        const end = getLastMatchNode(matchNode);
        lexer.syntax.walk(ast, function (node, item, list) {
          if (node === start) {
            const nodes = new List_1$1.List();

            do {
              nodes.appendData(item.data);

              if (item.data === end) {
                break;
              }

              item = item.next;
            } while (item !== null);

            fragments.push({
              parent: list,
              nodes
            });
          }
        });
      }

      if (Array.isArray(matchNode.match)) {
        matchNode.match.forEach(findFragments);
      }
    }

    const fragments = [];

    if (match.matched !== null) {
      findFragments(match.matched);
    }

    return fragments;
  }

  var matchFragments_1 = matchFragments;

  var search = {
  	matchFragments: matchFragments_1
  };

  const {
    hasOwnProperty: hasOwnProperty$2
  } = Object.prototype;

  function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value && value >= 0;
  }

  function isValidLocation(loc) {
    return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
  }

  function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
      if (!node || node.constructor !== Object) {
        return warn(node, 'Type of node should be an Object');
      }

      for (let key in node) {
        let valid = true;

        if (hasOwnProperty$2.call(node, key) === false) {
          continue;
        }

        if (key === 'type') {
          if (node.type !== type) {
            warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
          }
        } else if (key === 'loc') {
          if (node.loc === null) {
            continue;
          } else if (node.loc && node.loc.constructor === Object) {
            if (typeof node.loc.source !== 'string') {
              key += '.source';
            } else if (!isValidLocation(node.loc.start)) {
              key += '.start';
            } else if (!isValidLocation(node.loc.end)) {
              key += '.end';
            } else {
              continue;
            }
          }

          valid = false;
        } else if (fields.hasOwnProperty(key)) {
          valid = false;

          for (let i = 0; !valid && i < fields[key].length; i++) {
            const fieldType = fields[key][i];

            switch (fieldType) {
              case String:
                valid = typeof node[key] === 'string';
                break;

              case Boolean:
                valid = typeof node[key] === 'boolean';
                break;

              case null:
                valid = node[key] === null;
                break;

              default:
                if (typeof fieldType === 'string') {
                  valid = node[key] && node[key].type === fieldType;
                } else if (Array.isArray(fieldType)) {
                  valid = node[key] instanceof List_1$1.List;
                }

            }
          }
        } else {
          warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
        }

        if (!valid) {
          warn(node, 'Bad value for `' + type + '.' + key + '`');
        }
      }

      for (const key in fields) {
        if (hasOwnProperty$2.call(fields, key) && hasOwnProperty$2.call(node, key) === false) {
          warn(node, 'Field `' + type + '.' + key + '` is missed');
        }
      }
    };
  }

  function processStructure(name, nodeType) {
    const structure = nodeType.structure;
    const fields = {
      type: String,
      loc: true
    };
    const docs = {
      type: '"' + name + '"'
    };

    for (const key in structure) {
      if (hasOwnProperty$2.call(structure, key) === false) {
        continue;
      }

      const docsTypes = [];
      const fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];

      for (let i = 0; i < fieldTypes.length; i++) {
        const fieldType = fieldTypes[i];

        if (fieldType === String || fieldType === Boolean) {
          docsTypes.push(fieldType.name);
        } else if (fieldType === null) {
          docsTypes.push('null');
        } else if (typeof fieldType === 'string') {
          docsTypes.push('<' + fieldType + '>');
        } else if (Array.isArray(fieldType)) {
          docsTypes.push('List'); // TODO: use type enum
        } else {
          throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
        }
      }

      docs[key] = docsTypes.join(' | ');
    }

    return {
      docs,
      check: createNodeStructureChecker(name, fields)
    };
  }

  function getStructureFromConfig(config) {
    const structure = {};

    if (config.node) {
      for (const name in config.node) {
        if (hasOwnProperty$2.call(config.node, name)) {
          const nodeType = config.node[name];

          if (nodeType.structure) {
            structure[name] = processStructure(name, nodeType);
          } else {
            throw new Error('Missed `structure` field in `' + name + '` node type definition');
          }
        }
      }
    }

    return structure;
  }

  var getStructureFromConfig_1 = getStructureFromConfig;

  var structure$F = {
  	getStructureFromConfig: getStructureFromConfig_1
  };

  const noop$2 = function () {};

  function ensureFunction(value) {
    return typeof value === 'function' ? value : noop$2;
  }

  function walk$1(node, options, context) {
    function walk(node) {
      enter.call(context, node);

      switch (node.type) {
        case 'Group':
          node.terms.forEach(walk);
          break;

        case 'Multiplier':
          walk(node.term);
          break;

        case 'Type':
        case 'Property':
        case 'Keyword':
        case 'AtKeyword':
        case 'Function':
        case 'String':
        case 'Token':
        case 'Comma':
          break;

        default:
          throw new Error('Unknown type: ' + node.type);
      }

      leave.call(context, node);
    }

    let enter = noop$2;
    let leave = noop$2;

    if (typeof options === 'function') {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);
    }

    if (enter === noop$2 && leave === noop$2) {
      throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node);
  }

  var walk_2 = walk$1;

  var walk_1$2 = {
  	walk: walk_2
  };

  const cssWideKeywordsSyntax = matchGraph.buildMatchGraph(genericConst.cssWideKeywords.join(' | '));

  function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const name in map) {
      if (map[name].syntax) {
        result[name] = syntaxAsAst ? map[name].syntax : generate_1$H.generate(map[name].syntax, {
          compact
        });
      }
    }

    return result;
  }

  function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const [name, atrule] of Object.entries(map)) {
      result[name] = {
        prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate_1$H.generate(atrule.prelude.syntax, {
          compact
        })),
        descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
      };
    }

    return result;
  }

  function valueHasVar(tokens) {
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].value.toLowerCase() === 'var(') {
        return true;
      }
    }

    return false;
  }

  function buildMatchResult(matched, error, iterations) {
    return {
      matched,
      iterations,
      error,
      ...trace
    };
  }

  function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
    const tokens = prepareTokens_1(value, lexer.syntax);
    let result;

    if (valueHasVar(tokens)) {
      return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCssWideKeywords) {
      result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
    }

    if (!useCssWideKeywords || !result.match) {
      result = match.matchAsTree(tokens, syntax.match, lexer);

      if (!result.match) {
        return buildMatchResult(null, new error$2.SyntaxMatchError(result.reason, syntax.syntax, value, result), result.iterations);
      }
    }

    return buildMatchResult(result.match, null, result.iterations);
  }

  class Lexer {
    constructor(config, syntax, structure$1) {
      this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
      this.syntax = syntax;
      this.generic = false;
      this.units = { ...units$2
      };
      this.atrules = Object.create(null);
      this.properties = Object.create(null);
      this.types = Object.create(null);
      this.structure = structure$1 || structure$F.getStructureFromConfig(config);

      if (config) {
        if (config.units) {
          for (const group of Object.keys(units$2)) {
            if (Array.isArray(config.units[group])) {
              this.units[group] = config.units[group];
            }
          }
        }

        if (config.types) {
          for (const name in config.types) {
            this.addType_(name, config.types[name]);
          }
        }

        if (config.generic) {
          this.generic = true;

          for (const [name, value] of Object.entries(generic.createGenericTypes(this.units))) {
            this.addType_(name, value);
          }
        }

        if (config.atrules) {
          for (const name in config.atrules) {
            this.addAtrule_(name, config.atrules[name]);
          }
        }

        if (config.properties) {
          for (const name in config.properties) {
            this.addProperty_(name, config.properties[name]);
          }
        }
      }
    }

    checkStructure(ast) {
      function collectWarning(node, message) {
        warns.push({
          node,
          message
        });
      }

      const structure = this.structure;
      const warns = [];
      this.syntax.walk(ast, function (node) {
        if (structure.hasOwnProperty(node.type)) {
          structure[node.type].check(node, collectWarning);
        } else {
          collectWarning(node, 'Unknown node type `' + node.type + '`');
        }
      });
      return warns.length ? warns : false;
    }

    createDescriptor(syntax, type, name, parent = null) {
      const ref = {
        type,
        name
      };
      const descriptor = {
        type,
        name,
        parent,
        serializable: typeof syntax === 'string' || syntax && typeof syntax.type === 'string',
        syntax: null,
        match: null
      };

      if (typeof syntax === 'function') {
        descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
      } else {
        if (typeof syntax === 'string') {
          // lazy parsing on first access
          Object.defineProperty(descriptor, 'syntax', {
            get() {
              Object.defineProperty(descriptor, 'syntax', {
                value: parse_1$N.parse(syntax)
              });
              return descriptor.syntax;
            }

          });
        } else {
          descriptor.syntax = syntax;
        } // lazy graph build on first access


        Object.defineProperty(descriptor, 'match', {
          get() {
            Object.defineProperty(descriptor, 'match', {
              value: matchGraph.buildMatchGraph(descriptor.syntax, ref)
            });
            return descriptor.match;
          }

        });
      }

      return descriptor;
    }

    addAtrule_(name, syntax) {
      if (!syntax) {
        return;
      }

      this.atrules[name] = {
        type: 'Atrule',
        name: name,
        prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
        descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((map, descName) => {
          map[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
          return map;
        }, Object.create(null)) : null
      };
    }

    addProperty_(name, syntax) {
      if (!syntax) {
        return;
      }

      this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    }

    addType_(name, syntax) {
      if (!syntax) {
        return;
      }

      this.types[name] = this.createDescriptor(syntax, 'Type', name);
    }

    checkAtruleName(atruleName) {
      if (!this.getAtrule(atruleName)) {
        return new error$2.SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
      }
    }

    checkAtrulePrelude(atruleName, prelude) {
      const error = this.checkAtruleName(atruleName);

      if (error) {
        return error;
      }

      const atrule = this.getAtrule(atruleName);

      if (!atrule.prelude && prelude) {
        return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
      }

      if (atrule.prelude && !prelude) {
        if (!matchSyntax(this, atrule.prelude, '', false).matched) {
          return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
        }
      }
    }

    checkAtruleDescriptorName(atruleName, descriptorName) {
      const error$1 = this.checkAtruleName(atruleName);

      if (error$1) {
        return error$1;
      }

      const atrule = this.getAtrule(atruleName);
      const descriptor = names.keyword(descriptorName);

      if (!atrule.descriptors) {
        return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
      }

      if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
        return new error$2.SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
      }
    }

    checkPropertyName(propertyName) {
      if (!this.getProperty(propertyName)) {
        return new error$2.SyntaxReferenceError('Unknown property', propertyName);
      }
    }

    matchAtrulePrelude(atruleName, prelude) {
      const error = this.checkAtrulePrelude(atruleName, prelude);

      if (error) {
        return buildMatchResult(null, error);
      }

      const atrule = this.getAtrule(atruleName);

      if (!atrule.prelude) {
        return buildMatchResult(null, null);
      }

      return matchSyntax(this, atrule.prelude, prelude || '', false);
    }

    matchAtruleDescriptor(atruleName, descriptorName, value) {
      const error = this.checkAtruleDescriptorName(atruleName, descriptorName);

      if (error) {
        return buildMatchResult(null, error);
      }

      const atrule = this.getAtrule(atruleName);
      const descriptor = names.keyword(descriptorName);
      return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    }

    matchDeclaration(node) {
      if (node.type !== 'Declaration') {
        return buildMatchResult(null, new Error('Not a Declaration node'));
      }

      return this.matchProperty(node.property, node.value);
    }

    matchProperty(propertyName, value) {
      // don't match syntax for a custom property at the moment
      if (names.property(propertyName).custom) {
        return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
      }

      const error = this.checkPropertyName(propertyName);

      if (error) {
        return buildMatchResult(null, error);
      }

      return matchSyntax(this, this.getProperty(propertyName), value, true);
    }

    matchType(typeName, value) {
      const typeSyntax = this.getType(typeName);

      if (!typeSyntax) {
        return buildMatchResult(null, new error$2.SyntaxReferenceError('Unknown type', typeName));
      }

      return matchSyntax(this, typeSyntax, value, false);
    }

    match(syntax, value) {
      if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
        return buildMatchResult(null, new error$2.SyntaxReferenceError('Bad syntax'));
      }

      if (typeof syntax === 'string' || !syntax.match) {
        syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
      }

      return matchSyntax(this, syntax, value, false);
    }

    findValueFragments(propertyName, value, type, name) {
      return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    }

    findDeclarationValueFragments(declaration, type, name) {
      return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    }

    findAllFragments(ast, type, name) {
      const result = [];
      this.syntax.walk(ast, {
        visit: 'Declaration',
        enter: declaration => {
          result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
        }
      });
      return result;
    }

    getAtrule(atruleName, fallbackBasename = true) {
      const atrule = names.keyword(atruleName);
      const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
      return atruleEntry || null;
    }

    getAtrulePrelude(atruleName, fallbackBasename = true) {
      const atrule = this.getAtrule(atruleName, fallbackBasename);
      return atrule && atrule.prelude || null;
    }

    getAtruleDescriptor(atruleName, name) {
      return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
    }

    getProperty(propertyName, fallbackBasename = true) {
      const property = names.property(propertyName);
      const propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
      return propertyEntry || null;
    }

    getType(name) {
      return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
    }

    validate() {
      function validate(syntax, name, broken, descriptor) {
        if (broken.has(name)) {
          return broken.get(name);
        }

        broken.set(name, false);

        if (descriptor.syntax !== null) {
          walk_1$2.walk(descriptor.syntax, function (node) {
            if (node.type !== 'Type' && node.type !== 'Property') {
              return;
            }

            const map = node.type === 'Type' ? syntax.types : syntax.properties;
            const brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

            if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
              broken.set(name, true);
            }
          }, this);
        }
      }

      let brokenTypes = new Map();
      let brokenProperties = new Map();

      for (const key in this.types) {
        validate(this, key, brokenTypes, this.types[key]);
      }

      for (const key in this.properties) {
        validate(this, key, brokenProperties, this.properties[key]);
      }

      brokenTypes = [...brokenTypes.keys()].filter(name => brokenTypes.get(name));
      brokenProperties = [...brokenProperties.keys()].filter(name => brokenProperties.get(name));

      if (brokenTypes.length || brokenProperties.length) {
        return {
          types: brokenTypes,
          properties: brokenProperties
        };
      }

      return null;
    }

    dump(syntaxAsAst, pretty) {
      return {
        generic: this.generic,
        units: this.units,
        types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
        properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
        atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
      };
    }

    toString() {
      return JSON.stringify(this.dump());
    }

  }

  var Lexer_2 = Lexer;

  var Lexer_1$1 = {
  	Lexer: Lexer_2
  };

  function appendOrSet(a, b) {
    if (typeof b === 'string' && /^\s*\|/.test(b)) {
      return typeof a === 'string' ? a + b : b.replace(/^\s*\|\s*/, '');
    }

    return b || null;
  }

  function sliceProps(obj, props) {
    const result = Object.create(null);

    for (const [key, value] of Object.entries(obj)) {
      if (value) {
        result[key] = {};

        for (const prop of Object.keys(value)) {
          if (props.includes(prop)) {
            result[key][prop] = value[prop];
          }
        }
      }
    }

    return result;
  }

  function mix(dest, src) {
    const result = { ...dest
    };

    for (const [prop, value] of Object.entries(src)) {
      switch (prop) {
        case 'generic':
          result[prop] = Boolean(value);
          break;

        case 'units':
          result[prop] = { ...dest[prop]
          };

          for (const [name, patch] of Object.entries(value)) {
            result[prop][name] = Array.isArray(patch) ? patch : [];
          }

          break;

        case 'atrules':
          result[prop] = { ...dest[prop]
          };

          for (const [name, atrule] of Object.entries(value)) {
            const exists = result[prop][name] || {};
            const current = result[prop][name] = {
              prelude: exists.prelude || null,
              descriptors: { ...exists.descriptors
              }
            };

            if (!atrule) {
              continue;
            }

            current.prelude = atrule.prelude ? appendOrSet(current.prelude, atrule.prelude) : current.prelude || null;

            for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
              current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;
            }

            if (!Object.keys(current.descriptors).length) {
              current.descriptors = null;
            }
          }

          break;

        case 'types':
        case 'properties':
          result[prop] = { ...dest[prop]
          };

          for (const [name, syntax] of Object.entries(value)) {
            result[prop][name] = appendOrSet(result[prop][name], syntax);
          }

          break;

        case 'scope':
          result[prop] = { ...dest[prop]
          };

          for (const [name, props] of Object.entries(value)) {
            result[prop][name] = { ...result[prop][name],
              ...props
            };
          }

          break;

        case 'parseContext':
          result[prop] = { ...dest[prop],
            ...value
          };
          break;

        case 'atrule':
        case 'pseudo':
          result[prop] = { ...dest[prop],
            ...sliceProps(value, ['parse'])
          };
          break;

        case 'node':
          result[prop] = { ...dest[prop],
            ...sliceProps(value, ['name', 'structure', 'parse', 'generate', 'walkContext'])
          };
          break;
      }
    }

    return result;
  }

  var mix_1 = mix;

  function createSyntax$1(config) {
    const parse = create$3.createParser(config);
    const walk = create.createWalker(config);
    const generate = create$2.createGenerator(config);
    const {
      fromPlainObject,
      toPlainObject
    } = create$1.createConvertor(walk);
    const syntax = {
      lexer: null,
      createLexer: config => new Lexer_1$1.Lexer(config, syntax, syntax.lexer.structure),
      tokenize: tokenizer$2.tokenize,
      parse,
      generate,
      walk,
      find: walk.find,
      findLast: walk.findLast,
      findAll: walk.findAll,
      fromPlainObject,
      toPlainObject,

      fork(extension) {
        const base = mix_1({}, config); // copy of config

        return createSyntax$1(typeof extension === 'function' ? extension(base, Object.assign) : mix_1(base, extension));
      }

    };
    syntax.lexer = new Lexer_1$1.Lexer({
      generic: true,
      units: config.units,
      types: config.types,
      atrules: config.atrules,
      properties: config.properties,
      node: config.node
    }, syntax);
    return syntax;
  }

  const createSyntax$1$1 = config => createSyntax$1(mix_1({}, config));

  var create_1 = createSyntax$1$1;

  var atrules = {
  	charset: {
  		prelude: "<string>"
  	},
  	"font-face": {
  		descriptors: {
  			"unicode-range": {
  				comment: "replaces <unicode-range>, an old production name",
  				syntax: "<urange>#"
  			}
  		}
  	},
  	nest: {
  		prelude: "<complex-selector-list>"
  	}
  };
  var properties$2 = {
  	"-moz-background-clip": {
  		comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
  		syntax: "padding | border"
  	},
  	"-moz-border-radius-bottomleft": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
  		syntax: "<'border-bottom-left-radius'>"
  	},
  	"-moz-border-radius-bottomright": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
  		syntax: "<'border-bottom-right-radius'>"
  	},
  	"-moz-border-radius-topleft": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
  		syntax: "<'border-top-left-radius'>"
  	},
  	"-moz-border-radius-topright": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
  		syntax: "<'border-bottom-right-radius'>"
  	},
  	"-moz-control-character-visibility": {
  		comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
  		syntax: "visible | hidden"
  	},
  	"-moz-osx-font-smoothing": {
  		comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
  		syntax: "auto | grayscale"
  	},
  	"-moz-user-select": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
  		syntax: "none | text | all | -moz-none"
  	},
  	"-ms-flex-align": {
  		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
  		syntax: "start | end | center | baseline | stretch"
  	},
  	"-ms-flex-item-align": {
  		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
  		syntax: "auto | start | end | center | baseline | stretch"
  	},
  	"-ms-flex-line-pack": {
  		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
  		syntax: "start | end | center | justify | distribute | stretch"
  	},
  	"-ms-flex-negative": {
  		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
  		syntax: "<'flex-shrink'>"
  	},
  	"-ms-flex-pack": {
  		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
  		syntax: "start | end | center | justify | distribute"
  	},
  	"-ms-flex-order": {
  		comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
  		syntax: "<integer>"
  	},
  	"-ms-flex-positive": {
  		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
  		syntax: "<'flex-grow'>"
  	},
  	"-ms-flex-preferred-size": {
  		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
  		syntax: "<'flex-basis'>"
  	},
  	"-ms-interpolation-mode": {
  		comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
  		syntax: "nearest-neighbor | bicubic"
  	},
  	"-ms-grid-column-align": {
  		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
  		syntax: "start | end | center | stretch"
  	},
  	"-ms-grid-row-align": {
  		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
  		syntax: "start | end | center | stretch"
  	},
  	"-ms-hyphenate-limit-last": {
  		comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
  		syntax: "none | always | column | page | spread"
  	},
  	"-webkit-appearance": {
  		comment: "webkit specific keywords",
  		references: [
  			"http://css-infos.net/property/-webkit-appearance"
  		],
  		syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
  	},
  	"-webkit-background-clip": {
  		comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
  		syntax: "[ <box> | border | padding | content | text ]#"
  	},
  	"-webkit-column-break-after": {
  		comment: "added, http://help.dottoro.com/lcrthhhv.php",
  		syntax: "always | auto | avoid"
  	},
  	"-webkit-column-break-before": {
  		comment: "added, http://help.dottoro.com/lcxquvkf.php",
  		syntax: "always | auto | avoid"
  	},
  	"-webkit-column-break-inside": {
  		comment: "added, http://help.dottoro.com/lclhnthl.php",
  		syntax: "always | auto | avoid"
  	},
  	"-webkit-font-smoothing": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
  		syntax: "auto | none | antialiased | subpixel-antialiased"
  	},
  	"-webkit-mask-box-image": {
  		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
  		syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
  	},
  	"-webkit-print-color-adjust": {
  		comment: "missed",
  		references: [
  			"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
  		],
  		syntax: "economy | exact"
  	},
  	"-webkit-text-security": {
  		comment: "missed; http://help.dottoro.com/lcbkewgt.php",
  		syntax: "none | circle | disc | square"
  	},
  	"-webkit-user-drag": {
  		comment: "missed; http://help.dottoro.com/lcbixvwm.php",
  		syntax: "none | element | auto"
  	},
  	"-webkit-user-select": {
  		comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
  		syntax: "auto | none | text | all"
  	},
  	"alignment-baseline": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
  		],
  		syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
  	},
  	"background-clip": {
  		comment: "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
  		references: [
  			"https://github.com/csstree/csstree/issues/190"
  		],
  		syntax: "<bg-clip>#"
  	},
  	"baseline-shift": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
  		],
  		syntax: "baseline | sub | super | <svg-length>"
  	},
  	behavior: {
  		comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
  		syntax: "<url>+"
  	},
  	"clip-rule": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
  		],
  		syntax: "nonzero | evenodd"
  	},
  	cue: {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<'cue-before'> <'cue-after'>?"
  	},
  	"cue-after": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<url> <decibel>? | none"
  	},
  	"cue-before": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<url> <decibel>? | none"
  	},
  	cursor: {
  		comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
  		references: [
  			"https://www.sitepoint.com/css3-cursor-styles/"
  		],
  		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
  	},
  	display: {
  		comment: "extended with -ms-flexbox",
  		syntax: "| <-non-standard-display>"
  	},
  	position: {
  		comment: "extended with -webkit-sticky",
  		syntax: "| -webkit-sticky"
  	},
  	"dominant-baseline": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
  		],
  		syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
  	},
  	"image-rendering": {
  		comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
  		references: [
  			"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
  			"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
  		],
  		syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
  	},
  	fill: {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
  		],
  		syntax: "<paint>"
  	},
  	"fill-opacity": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
  		],
  		syntax: "<number-zero-one>"
  	},
  	"fill-rule": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
  		],
  		syntax: "nonzero | evenodd"
  	},
  	filter: {
  		comment: "extend with IE legacy syntaxes",
  		syntax: "| <-ms-filter-function-list>"
  	},
  	"glyph-orientation-horizontal": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
  		],
  		syntax: "<angle>"
  	},
  	"glyph-orientation-vertical": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
  		],
  		syntax: "<angle>"
  	},
  	kerning: {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/text.html#KerningProperty"
  		],
  		syntax: "auto | <svg-length>"
  	},
  	"letter-spacing": {
  		comment: "fix syntax <length> -> <length-percentage>",
  		references: [
  			"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
  		],
  		syntax: "normal | <length-percentage>"
  	},
  	marker: {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
  		],
  		syntax: "none | <url>"
  	},
  	"marker-end": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
  		],
  		syntax: "none | <url>"
  	},
  	"marker-mid": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
  		],
  		syntax: "none | <url>"
  	},
  	"marker-start": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
  		],
  		syntax: "none | <url>"
  	},
  	"max-width": {
  		comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
  		syntax: "| <-non-standard-width>"
  	},
  	width: {
  		references: [
  			"https://developer.mozilla.org/en-US/docs/Web/CSS/width",
  			"https://github.com/csstree/stylelint-validator/issues/29"
  		],
  		syntax: "| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content"
  	},
  	"min-width": {
  		comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
  		syntax: "| <-non-standard-width>"
  	},
  	overflow: {
  		comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
  		syntax: "| <-non-standard-overflow>"
  	},
  	pause: {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<'pause-before'> <'pause-after'>?"
  	},
  	"pause-after": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
  	},
  	"pause-before": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
  	},
  	rest: {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<'rest-before'> <'rest-after'>?"
  	},
  	"rest-after": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
  	},
  	"rest-before": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
  	},
  	"shape-rendering": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
  		],
  		syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
  	},
  	src: {
  		comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
  		syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
  	},
  	speak: {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "auto | none | normal"
  	},
  	"speak-as": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
  	},
  	stroke: {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
  		],
  		syntax: "<paint>"
  	},
  	"stroke-dasharray": {
  		comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
  		],
  		syntax: "none | [ <svg-length>+ ]#"
  	},
  	"stroke-dashoffset": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
  		],
  		syntax: "<svg-length>"
  	},
  	"stroke-linecap": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
  		],
  		syntax: "butt | round | square"
  	},
  	"stroke-linejoin": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
  		],
  		syntax: "miter | round | bevel"
  	},
  	"stroke-miterlimit": {
  		comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
  		],
  		syntax: "<number-one-or-greater>"
  	},
  	"stroke-opacity": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
  		],
  		syntax: "<number-zero-one>"
  	},
  	"stroke-width": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
  		],
  		syntax: "<svg-length>"
  	},
  	"text-anchor": {
  		comment: "added SVG property",
  		references: [
  			"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
  		],
  		syntax: "start | middle | end"
  	},
  	"unicode-bidi": {
  		comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
  		syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
  	},
  	"unicode-range": {
  		comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
  		syntax: "<urange>#"
  	},
  	"voice-balance": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<number> | left | center | right | leftwards | rightwards"
  	},
  	"voice-duration": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "auto | <time>"
  	},
  	"voice-family": {
  		comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
  	},
  	"voice-pitch": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
  	},
  	"voice-range": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
  	},
  	"voice-rate": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
  	},
  	"voice-stress": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "normal | strong | moderate | none | reduced"
  	},
  	"voice-volume": {
  		comment: "https://www.w3.org/TR/css3-speech/#property-index",
  		syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
  	},
  	"writing-mode": {
  		comment: "extend with SVG keywords",
  		syntax: "| <svg-writing-mode>"
  	}
  };
  var types$3 = {
  	"-legacy-gradient": {
  		comment: "added collection of legacy gradient syntaxes",
  		syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
  	},
  	"-legacy-linear-gradient": {
  		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
  		syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
  	},
  	"-legacy-repeating-linear-gradient": {
  		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
  		syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
  	},
  	"-legacy-linear-gradient-arguments": {
  		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
  		syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
  	},
  	"-legacy-radial-gradient": {
  		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
  		syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
  	},
  	"-legacy-repeating-radial-gradient": {
  		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
  		syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
  	},
  	"-legacy-radial-gradient-arguments": {
  		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
  		syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
  	},
  	"-legacy-radial-gradient-size": {
  		comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
  		syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
  	},
  	"-legacy-radial-gradient-shape": {
  		comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
  		syntax: "circle | ellipse"
  	},
  	"-non-standard-font": {
  		comment: "non standard fonts",
  		references: [
  			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
  		],
  		syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
  	},
  	"-non-standard-color": {
  		comment: "non standard colors",
  		references: [
  			"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
  			"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
  		],
  		syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
  	},
  	"-non-standard-image-rendering": {
  		comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
  		syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
  	},
  	"-non-standard-overflow": {
  		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
  		syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
  	},
  	"-non-standard-width": {
  		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
  		syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
  	},
  	"-webkit-gradient()": {
  		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
  		syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
  	},
  	"-webkit-gradient-color-stop": {
  		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
  		syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
  	},
  	"-webkit-gradient-point": {
  		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
  		syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
  	},
  	"-webkit-gradient-radius": {
  		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
  		syntax: "<length> | <percentage>"
  	},
  	"-webkit-gradient-type": {
  		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
  		syntax: "linear | radial"
  	},
  	"-webkit-mask-box-repeat": {
  		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
  		syntax: "repeat | stretch | round"
  	},
  	"-webkit-mask-clip-style": {
  		comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
  		syntax: "border | border-box | padding | padding-box | content | content-box | text"
  	},
  	"-ms-filter-function-list": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
  		syntax: "<-ms-filter-function>+"
  	},
  	"-ms-filter-function": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
  		syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
  	},
  	"-ms-filter-function-progid": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
  		syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
  	},
  	"-ms-filter-function-legacy": {
  		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
  		syntax: "<ident-token> | <function-token> <any-value>? )"
  	},
  	"-ms-filter": {
  		syntax: "<string>"
  	},
  	age: {
  		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
  		syntax: "child | young | old"
  	},
  	"attr-name": {
  		syntax: "<wq-name>"
  	},
  	"attr-fallback": {
  		syntax: "<any-value>"
  	},
  	"bg-clip": {
  		comment: "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
  		syntax: "<box> | border | text"
  	},
  	bottom: {
  		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
  		syntax: "<length> | auto"
  	},
  	"content-list": {
  		comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
  		syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"
  	},
  	"element()": {
  		comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
  		syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
  	},
  	"generic-voice": {
  		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
  		syntax: "[ <age>? <gender> <integer>? ]"
  	},
  	gender: {
  		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
  		syntax: "male | female | neutral"
  	},
  	"generic-family": {
  		comment: "added -apple-system",
  		references: [
  			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
  		],
  		syntax: "| -apple-system"
  	},
  	gradient: {
  		comment: "added legacy syntaxes support",
  		syntax: "| <-legacy-gradient>"
  	},
  	left: {
  		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
  		syntax: "<length> | auto"
  	},
  	"mask-image": {
  		comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
  		syntax: "<mask-reference>#"
  	},
  	"named-color": {
  		comment: "added non standard color names",
  		syntax: "| <-non-standard-color>"
  	},
  	paint: {
  		comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
  		syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
  	},
  	right: {
  		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
  		syntax: "<length> | auto"
  	},
  	shape: {
  		comment: "missed spaces in function body and add backwards compatible syntax",
  		syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
  	},
  	"scroll-timeline-axis": {
  		comment: "missed definition",
  		syntax: "block | inline | vertical | horizontal"
  	},
  	"scroll-timeline-name": {
  		comment: "missed definition",
  		references: [
  			"https://w3c.github.io/csswg-drafts/scroll-animations/#propdef-scroll-timeline-name"
  		],
  		syntax: "none | <custom-ident>"
  	},
  	"single-animation-composition": {
  		comment: "missed definition",
  		references: [
  			"https://w3c.github.io/csswg-drafts/css-animations-2/#typedef-single-animation-composition"
  		],
  		syntax: "replace | add | accumulate"
  	},
  	"svg-length": {
  		comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
  		references: [
  			"https://www.w3.org/TR/SVG11/coords.html#Units"
  		],
  		syntax: "<percentage> | <length> | <number>"
  	},
  	"svg-writing-mode": {
  		comment: "SVG specific keywords (deprecated for CSS)",
  		references: [
  			"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
  			"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
  		],
  		syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
  	},
  	top: {
  		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
  		syntax: "<length> | auto"
  	},
  	x: {
  		comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
  		syntax: "<number>"
  	},
  	y: {
  		comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
  		syntax: "<number>"
  	},
  	declaration: {
  		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
  		syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
  	},
  	"declaration-list": {
  		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
  		syntax: "[ <declaration>? ';' ]* <declaration>?"
  	},
  	url: {
  		comment: "https://drafts.csswg.org/css-values-4/#urls",
  		syntax: "url( <string> <url-modifier>* ) | <url-token>"
  	},
  	"url-modifier": {
  		comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
  		syntax: "<ident> | <function-token> <any-value> )"
  	},
  	"number-zero-one": {
  		syntax: "<number [0,1]>"
  	},
  	"number-one-or-greater": {
  		syntax: "<number [1,∞]>"
  	},
  	"-non-standard-display": {
  		syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
  	}
  };
  var patch = {
  	atrules: atrules,
  	properties: properties$2,
  	types: types$3
  };

  const patch$1 = patch;
  var dataPatch = patch$1;

  var mdnAtrules = {
  	"@charset": {
  	syntax: "@charset \"<charset>\";",
  	groups: [
  		"CSS Charsets"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
  },
  	"@counter-style": {
  	syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
  	interfaces: [
  		"CSSCounterStyleRule"
  	],
  	groups: [
  		"CSS Counter Styles"
  	],
  	descriptors: {
  		"additive-symbols": {
  			syntax: "[ <integer> && <symbol> ]#",
  			media: "all",
  			initial: "n/a (required)",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		fallback: {
  			syntax: "<counter-style-name>",
  			media: "all",
  			initial: "decimal",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		negative: {
  			syntax: "<symbol> <symbol>?",
  			media: "all",
  			initial: "\"-\" hyphen-minus",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		pad: {
  			syntax: "<integer> && <symbol>",
  			media: "all",
  			initial: "0 \"\"",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		prefix: {
  			syntax: "<symbol>",
  			media: "all",
  			initial: "\"\"",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		range: {
  			syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
  			media: "all",
  			initial: "auto",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		"speak-as": {
  			syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
  			media: "all",
  			initial: "auto",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		suffix: {
  			syntax: "<symbol>",
  			media: "all",
  			initial: "\". \"",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		symbols: {
  			syntax: "<symbol>+",
  			media: "all",
  			initial: "n/a (required)",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		system: {
  			syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
  			media: "all",
  			initial: "symbolic",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		}
  	},
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
  },
  	"@document": {
  	syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
  	interfaces: [
  		"CSSGroupingRule",
  		"CSSConditionRule"
  	],
  	groups: [
  		"CSS Conditional Rules"
  	],
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
  },
  	"@font-face": {
  	syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ] ||\n  [ size-adjust: <size-adjust>; ] ||\n  [ ascent-override: <ascent-override>; ] ||\n  [ descent-override: <descent-override>; ] ||\n  [ line-gap-override: <line-gap-override>; ]\n}",
  	interfaces: [
  		"CSSFontFaceRule"
  	],
  	groups: [
  		"CSS Fonts"
  	],
  	descriptors: {
  		"ascent-override": {
  			syntax: "normal | <percentage>",
  			media: "all",
  			initial: "normal",
  			percentages: "asSpecified",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "experimental"
  		},
  		"descent-override": {
  			syntax: "normal | <percentage>",
  			media: "all",
  			initial: "normal",
  			percentages: "asSpecified",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "experimental"
  		},
  		"font-display": {
  			syntax: "[ auto | block | swap | fallback | optional ]",
  			media: "visual",
  			percentages: "no",
  			initial: "auto",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "experimental"
  		},
  		"font-family": {
  			syntax: "<family-name>",
  			media: "all",
  			initial: "n/a (required)",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"font-feature-settings": {
  			syntax: "normal | <feature-tag-value>#",
  			media: "all",
  			initial: "normal",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		"font-variation-settings": {
  			syntax: "normal | [ <string> <number> ]#",
  			media: "all",
  			initial: "normal",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		"font-stretch": {
  			syntax: "<font-stretch-absolute>{1,2}",
  			media: "all",
  			initial: "normal",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"font-style": {
  			syntax: "normal | italic | oblique <angle>{0,2}",
  			media: "all",
  			initial: "normal",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"font-weight": {
  			syntax: "<font-weight-absolute>{1,2}",
  			media: "all",
  			initial: "normal",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"font-variant": {
  			syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
  			media: "all",
  			initial: "normal",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		"line-gap-override": {
  			syntax: "normal | <percentage>",
  			media: "all",
  			initial: "normal",
  			percentages: "asSpecified",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "experimental"
  		},
  		"size-adjust": {
  			syntax: "<percentage>",
  			media: "all",
  			initial: "100%",
  			percentages: "asSpecified",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "experimental"
  		},
  		src: {
  			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
  			media: "all",
  			initial: "n/a (required)",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		"unicode-range": {
  			syntax: "<unicode-range>#",
  			media: "all",
  			initial: "U+0-10FFFF",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		}
  	},
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
  },
  	"@font-feature-values": {
  	syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
  	interfaces: [
  		"CSSFontFeatureValuesRule"
  	],
  	groups: [
  		"CSS Fonts"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
  },
  	"@import": {
  	syntax: "@import [ <string> | <url> ]\n        [ layer | layer(<layer-name>) ]?\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;",
  	groups: [
  		"CSS Conditional Rules",
  		"Media Queries"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
  },
  	"@keyframes": {
  	syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
  	interfaces: [
  		"CSSKeyframeRule",
  		"CSSKeyframesRule"
  	],
  	groups: [
  		"CSS Animations"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
  },
  	"@layer": {
  	syntax: "@layer [ <layer-name># | <layer-name>?  {\n  <stylesheet>\n} ]",
  	interfaces: [
  		"CSSLayerBlockRule",
  		"CSSLayerStatementRule"
  	],
  	groups: [
  		"CSS Cascading and Inheritance"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer"
  },
  	"@media": {
  	syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
  	interfaces: [
  		"CSSGroupingRule",
  		"CSSConditionRule",
  		"CSSMediaRule",
  		"CSSCustomMediaRule"
  	],
  	groups: [
  		"CSS Conditional Rules",
  		"Media Queries"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
  },
  	"@namespace": {
  	syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
  	groups: [
  		"CSS Namespaces"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
  },
  	"@page": {
  	syntax: "@page <page-selector-list> {\n  <page-body>\n}",
  	interfaces: [
  		"CSSPageRule"
  	],
  	groups: [
  		"CSS Pages"
  	],
  	descriptors: {
  		bleed: {
  			syntax: "auto | <length>",
  			media: [
  				"visual",
  				"paged"
  			],
  			initial: "auto",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		marks: {
  			syntax: "none | [ crop || cross ]",
  			media: [
  				"visual",
  				"paged"
  			],
  			initial: "none",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		size: {
  			syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
  			media: [
  				"visual",
  				"paged"
  			],
  			initial: "auto",
  			percentages: "no",
  			computed: "asSpecifiedRelativeToAbsoluteLengths",
  			order: "orderOfAppearance",
  			status: "standard"
  		}
  	},
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
  },
  	"@property": {
  	syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
  	interfaces: [
  		"CSS",
  		"CSSPropertyRule"
  	],
  	groups: [
  		"CSS Houdini"
  	],
  	descriptors: {
  		syntax: {
  			syntax: "<string>",
  			media: "all",
  			percentages: "no",
  			initial: "n/a (required)",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "experimental"
  		},
  		inherits: {
  			syntax: "true | false",
  			media: "all",
  			percentages: "no",
  			initial: "auto",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "experimental"
  		},
  		"initial-value": {
  			syntax: "<string>",
  			media: "all",
  			initial: "n/a (required)",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "experimental"
  		}
  	},
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
  },
  	"@scroll-timeline": {
  	syntax: "@scroll-timeline <timeline-name> { <declaration-list> }",
  	interfaces: [
  		"ScrollTimeline"
  	],
  	groups: [
  		"CSS Animations"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline"
  },
  	"@supports": {
  	syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
  	interfaces: [
  		"CSSGroupingRule",
  		"CSSConditionRule",
  		"CSSSupportsRule"
  	],
  	groups: [
  		"CSS Conditional Rules"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
  },
  	"@viewport": {
  	syntax: "@viewport {\n  <group-rule-body>\n}",
  	interfaces: [
  		"CSSViewportRule"
  	],
  	groups: [
  		"CSS Device Adaptation"
  	],
  	descriptors: {
  		height: {
  			syntax: "<viewport-length>{1,2}",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: [
  				"min-height",
  				"max-height"
  			],
  			percentages: [
  				"min-height",
  				"max-height"
  			],
  			computed: [
  				"min-height",
  				"max-height"
  			],
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		"max-height": {
  			syntax: "<viewport-length>",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "referToHeightOfInitialViewport",
  			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"max-width": {
  			syntax: "<viewport-length>",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "referToWidthOfInitialViewport",
  			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"max-zoom": {
  			syntax: "auto | <number> | <percentage>",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "the zoom factor itself",
  			computed: "autoNonNegativeOrPercentage",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"min-height": {
  			syntax: "<viewport-length>",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "referToHeightOfInitialViewport",
  			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"min-width": {
  			syntax: "<viewport-length>",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "referToWidthOfInitialViewport",
  			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"min-zoom": {
  			syntax: "auto | <number> | <percentage>",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "the zoom factor itself",
  			computed: "autoNonNegativeOrPercentage",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		orientation: {
  			syntax: "auto | portrait | landscape",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "referToSizeOfBoundingBox",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"user-zoom": {
  			syntax: "zoom | fixed",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "zoom",
  			percentages: "referToSizeOfBoundingBox",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		"viewport-fit": {
  			syntax: "auto | contain | cover",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "no",
  			computed: "asSpecified",
  			order: "uniqueOrder",
  			status: "standard"
  		},
  		width: {
  			syntax: "<viewport-length>{1,2}",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: [
  				"min-width",
  				"max-width"
  			],
  			percentages: [
  				"min-width",
  				"max-width"
  			],
  			computed: [
  				"min-width",
  				"max-width"
  			],
  			order: "orderOfAppearance",
  			status: "standard"
  		},
  		zoom: {
  			syntax: "auto | <number> | <percentage>",
  			media: [
  				"visual",
  				"continuous"
  			],
  			initial: "auto",
  			percentages: "the zoom factor itself",
  			computed: "autoNonNegativeOrPercentage",
  			order: "uniqueOrder",
  			status: "standard"
  		}
  	},
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
  }
  };

  var all$1 = {
  	syntax: "initial | inherit | unset | revert | revert-layer",
  	media: "noPracticalMedia",
  	inherited: false,
  	animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
  	percentages: "no",
  	groups: [
  		"CSS Miscellaneous"
  	],
  	initial: "noPracticalInitialValue",
  	appliesto: "allElements",
  	computed: "asSpecifiedAppliesToEachProperty",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
  };
  var animation = {
  	syntax: "<single-animation>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: [
  		"animation-name",
  		"animation-duration",
  		"animation-timing-function",
  		"animation-delay",
  		"animation-iteration-count",
  		"animation-direction",
  		"animation-fill-mode",
  		"animation-play-state",
  		"animation-timeline"
  	],
  	appliesto: "allElementsAndPseudos",
  	computed: [
  		"animation-name",
  		"animation-duration",
  		"animation-timing-function",
  		"animation-delay",
  		"animation-direction",
  		"animation-iteration-count",
  		"animation-fill-mode",
  		"animation-play-state",
  		"animation-timeline"
  	],
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
  };
  var appearance = {
  	syntax: "none | auto | textfield | menulist-button | <compat-auto>",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
  };
  var azimuth = {
  	syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
  	media: "aural",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Speech"
  	],
  	initial: "center",
  	appliesto: "allElements",
  	computed: "normalizedAngle",
  	order: "orderOfAppearance",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
  };
  var background = {
  	syntax: "[ <bg-layer> , ]* <final-bg-layer>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"background-color",
  		"background-image",
  		"background-clip",
  		"background-position",
  		"background-size",
  		"background-repeat",
  		"background-attachment"
  	],
  	percentages: [
  		"background-position",
  		"background-size"
  	],
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"background-image",
  		"background-position",
  		"background-size",
  		"background-repeat",
  		"background-origin",
  		"background-clip",
  		"background-attachment",
  		"background-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"background-image",
  		"background-position",
  		"background-size",
  		"background-repeat",
  		"background-origin",
  		"background-clip",
  		"background-attachment",
  		"background-color"
  	],
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
  };
  var border = {
  	syntax: "<line-width> || <line-style> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-color",
  		"border-style",
  		"border-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-width",
  		"border-style",
  		"border-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-width",
  		"border-style",
  		"border-color"
  	],
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
  };
  var bottom = {
  	syntax: "<length> | <percentage> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToContainingBlockHeight",
  	groups: [
  		"CSS Positioning"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
  };
  var caret = {
  	syntax: "<'caret-color'> || <'caret-shape'>",
  	media: "interactive",
  	inherited: true,
  	animationType: [
  		"caret-color",
  		"caret-shape"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: [
  		"caret-color",
  		"caret-shape"
  	],
  	appliesto: "elementsThatAcceptInput",
  	computed: [
  		"caret-color",
  		"caret-shape"
  	],
  	order: "perGrammar",
  	status: "standard"
  };
  var clear = {
  	syntax: "none | left | right | both | inline-start | inline-end",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Positioning"
  	],
  	initial: "none",
  	appliesto: "blockLevelElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
  };
  var clip = {
  	syntax: "<shape> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "rectangle",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "auto",
  	appliesto: "absolutelyPositionedElements",
  	computed: "autoOrRectangle",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
  };
  var color$1 = {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Color"
  	],
  	initial: "canvastext",
  	appliesto: "allElementsAndText",
  	computed: "computedColor",
  	order: "perGrammar",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
  };
  var columns = {
  	syntax: "<'column-width'> || <'column-count'>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"column-width",
  		"column-count"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: [
  		"column-width",
  		"column-count"
  	],
  	appliesto: "blockContainersExceptTableWrappers",
  	computed: [
  		"column-width",
  		"column-count"
  	],
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
  };
  var contain = {
  	syntax: "none | strict | content | [ [ size || inline-size ] || layout || style || paint ]",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Containment"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
  };
  var content = {
  	syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Generated Content"
  	],
  	initial: "normal",
  	appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
  	computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
  };
  var cursor = {
  	syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
  	media: [
  		"visual",
  		"interactive"
  	],
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecifiedURLsAbsolute",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
  };
  var direction = {
  	syntax: "ltr | rtl",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Writing Modes"
  	],
  	initial: "ltr",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
  };
  var display = {
  	syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
  	media: "all",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Display"
  	],
  	initial: "inline",
  	appliesto: "allElements",
  	computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
  };
  var filter$1 = {
  	syntax: "none | <filter-function-list>",
  	media: "visual",
  	inherited: false,
  	animationType: "filterList",
  	percentages: "no",
  	groups: [
  		"Filter Effects"
  	],
  	initial: "none",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
  };
  var flex = {
  	syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"flex-grow",
  		"flex-shrink",
  		"flex-basis"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Flexible Box Layout"
  	],
  	initial: [
  		"flex-grow",
  		"flex-shrink",
  		"flex-basis"
  	],
  	appliesto: "flexItemsAndInFlowPseudos",
  	computed: [
  		"flex-grow",
  		"flex-shrink",
  		"flex-basis"
  	],
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
  };
  var float$1 = {
  	syntax: "left | right | none | inline-start | inline-end",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Positioning"
  	],
  	initial: "none",
  	appliesto: "allElementsNoEffectIfDisplayNone",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
  };
  var font = {
  	syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
  	media: "visual",
  	inherited: true,
  	animationType: [
  		"font-style",
  		"font-variant",
  		"font-weight",
  		"font-stretch",
  		"font-size",
  		"line-height",
  		"font-family"
  	],
  	percentages: [
  		"font-size",
  		"line-height"
  	],
  	groups: [
  		"CSS Fonts"
  	],
  	initial: [
  		"font-style",
  		"font-variant",
  		"font-weight",
  		"font-stretch",
  		"font-size",
  		"line-height",
  		"font-family"
  	],
  	appliesto: "allElements",
  	computed: [
  		"font-style",
  		"font-variant",
  		"font-weight",
  		"font-stretch",
  		"font-size",
  		"line-height",
  		"font-family"
  	],
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
  };
  var gap = {
  	syntax: "<'row-gap'> <'column-gap'>?",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"row-gap",
  		"column-gap"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: [
  		"row-gap",
  		"column-gap"
  	],
  	appliesto: "multiColumnElementsFlexContainersGridContainers",
  	computed: [
  		"row-gap",
  		"column-gap"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
  };
  var grid = {
  	syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: [
  		"grid-template-rows",
  		"grid-template-columns",
  		"grid-auto-rows",
  		"grid-auto-columns"
  	],
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: [
  		"grid-template-rows",
  		"grid-template-columns",
  		"grid-template-areas",
  		"grid-auto-rows",
  		"grid-auto-columns",
  		"grid-auto-flow",
  		"grid-column-gap",
  		"grid-row-gap",
  		"column-gap",
  		"row-gap"
  	],
  	appliesto: "gridContainers",
  	computed: [
  		"grid-template-rows",
  		"grid-template-columns",
  		"grid-template-areas",
  		"grid-auto-rows",
  		"grid-auto-columns",
  		"grid-auto-flow",
  		"grid-column-gap",
  		"grid-row-gap",
  		"column-gap",
  		"row-gap"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
  };
  var height = {
  	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "allElementsButNonReplacedAndTableColumns",
  	computed: "percentageAutoOrAbsoluteLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
  };
  var hyphens = {
  	syntax: "none | manual | auto",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "manual",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
  };
  var inset = {
  	syntax: "<'top'>{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "logicalHeightOrWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"top",
  		"bottom",
  		"left",
  		"right"
  	],
  	appliesto: "positionedElements",
  	computed: [
  		"top",
  		"bottom",
  		"left",
  		"right"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
  };
  var isolation = {
  	syntax: "auto | isolate",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Compositing and Blending"
  	],
  	initial: "auto",
  	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
  };
  var left = {
  	syntax: "<length> | <percentage> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Positioning"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
  };
  var margin = {
  	syntax: "[ <length> | <percentage> | auto ]{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: [
  		"margin-bottom",
  		"margin-left",
  		"margin-right",
  		"margin-top"
  	],
  	appliesto: "allElementsExceptTableDisplayTypes",
  	computed: [
  		"margin-bottom",
  		"margin-left",
  		"margin-right",
  		"margin-top"
  	],
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
  };
  var mask = {
  	syntax: "<mask-layer>#",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"mask-image",
  		"mask-mode",
  		"mask-repeat",
  		"mask-position",
  		"mask-clip",
  		"mask-origin",
  		"mask-size",
  		"mask-composite"
  	],
  	percentages: [
  		"mask-position"
  	],
  	groups: [
  		"CSS Masking"
  	],
  	initial: [
  		"mask-image",
  		"mask-mode",
  		"mask-repeat",
  		"mask-position",
  		"mask-clip",
  		"mask-origin",
  		"mask-size",
  		"mask-composite"
  	],
  	appliesto: "allElementsSVGContainerElements",
  	computed: [
  		"mask-image",
  		"mask-mode",
  		"mask-repeat",
  		"mask-position",
  		"mask-clip",
  		"mask-origin",
  		"mask-size",
  		"mask-composite"
  	],
  	order: "perGrammar",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
  };
  var offset = {
  	syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"offset-position",
  		"offset-path",
  		"offset-distance",
  		"offset-anchor",
  		"offset-rotate"
  	],
  	percentages: [
  		"offset-position",
  		"offset-distance",
  		"offset-anchor"
  	],
  	groups: [
  		"CSS Motion Path"
  	],
  	initial: [
  		"offset-position",
  		"offset-path",
  		"offset-distance",
  		"offset-anchor",
  		"offset-rotate"
  	],
  	appliesto: "transformableElements",
  	computed: [
  		"offset-position",
  		"offset-path",
  		"offset-distance",
  		"offset-anchor",
  		"offset-rotate"
  	],
  	order: "perGrammar",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
  };
  var opacity = {
  	syntax: "<alpha-value>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "mapToRange0To1",
  	groups: [
  		"CSS Color"
  	],
  	initial: "1",
  	appliesto: "allElements",
  	computed: "specifiedValueNumberClipped0To1",
  	order: "perGrammar",
  	alsoAppliesTo: [
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
  };
  var order = {
  	syntax: "<integer>",
  	media: "visual",
  	inherited: false,
  	animationType: "integer",
  	percentages: "no",
  	groups: [
  		"CSS Flexible Box Layout"
  	],
  	initial: "0",
  	appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
  };
  var orphans = {
  	syntax: "<integer>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fragmentation"
  	],
  	initial: "2",
  	appliesto: "blockContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
  };
  var outline = {
  	syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
  	media: [
  		"visual",
  		"interactive"
  	],
  	inherited: false,
  	animationType: [
  		"outline-color",
  		"outline-width",
  		"outline-style"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: [
  		"outline-color",
  		"outline-style",
  		"outline-width"
  	],
  	appliesto: "allElements",
  	computed: [
  		"outline-color",
  		"outline-width",
  		"outline-style"
  	],
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
  };
  var overflow = {
  	syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "visible",
  	appliesto: "blockContainersFlexContainersGridContainers",
  	computed: [
  		"overflow-x",
  		"overflow-y"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
  };
  var padding = {
  	syntax: "[ <length> | <percentage> ]{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: [
  		"padding-bottom",
  		"padding-left",
  		"padding-right",
  		"padding-top"
  	],
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: [
  		"padding-bottom",
  		"padding-left",
  		"padding-right",
  		"padding-top"
  	],
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
  };
  var perspective = {
  	syntax: "none | <length>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "none",
  	appliesto: "transformableElements",
  	computed: "absoluteLengthOrNone",
  	order: "uniqueOrder",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
  };
  var position$1 = {
  	syntax: "static | relative | absolute | sticky | fixed",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Positioning"
  	],
  	initial: "static",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
  };
  var quotes = {
  	syntax: "none | auto | [ <string> <string> ]+",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Generated Content"
  	],
  	initial: "dependsOnUserAgent",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
  };
  var resize = {
  	syntax: "none | both | horizontal | vertical | block | inline",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "none",
  	appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
  };
  var right = {
  	syntax: "<length> | <percentage> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Positioning"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
  };
  var rotate = {
  	syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
  	media: "visual",
  	inherited: false,
  	animationType: "transform",
  	percentages: "no",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "none",
  	appliesto: "transformableElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
  };
  var scale = {
  	syntax: "none | <number>{1,3}",
  	media: "visual",
  	inherited: false,
  	animationType: "transform",
  	percentages: "no",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "none",
  	appliesto: "transformableElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
  };
  var top = {
  	syntax: "<length> | <percentage> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToContainingBlockHeight",
  	groups: [
  		"CSS Positioning"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
  };
  var transform$1 = {
  	syntax: "none | <transform-list>",
  	media: "visual",
  	inherited: false,
  	animationType: "transform",
  	percentages: "referToSizeOfBoundingBox",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "none",
  	appliesto: "transformableElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
  };
  var transition = {
  	syntax: "<single-transition>#",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Transitions"
  	],
  	initial: [
  		"transition-delay",
  		"transition-duration",
  		"transition-property",
  		"transition-timing-function"
  	],
  	appliesto: "allElementsAndPseudos",
  	computed: [
  		"transition-delay",
  		"transition-duration",
  		"transition-property",
  		"transition-timing-function"
  	],
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
  };
  var translate = {
  	syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
  	media: "visual",
  	inherited: false,
  	animationType: "transform",
  	percentages: "referToSizeOfBoundingBox",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "none",
  	appliesto: "transformableElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "perGrammar",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
  };
  var visibility = {
  	syntax: "visible | hidden | collapse",
  	media: "visual",
  	inherited: true,
  	animationType: "visibility",
  	percentages: "no",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "visible",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
  };
  var widows = {
  	syntax: "<integer>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fragmentation"
  	],
  	initial: "2",
  	appliesto: "blockContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
  };
  var width = {
  	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "allElementsButNonReplacedAndTableRows",
  	computed: "percentageAutoOrAbsoluteLength",
  	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
  };
  var zoom = {
  	syntax: "normal | reset | <number> | <percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "integer",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
  };
  var mdnProperties = {
  	"--*": {
  	syntax: "<declaration-value>",
  	media: "all",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Variables"
  	],
  	initial: "seeProse",
  	appliesto: "allElements",
  	computed: "asSpecifiedWithVarsSubstituted",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
  },
  	"-ms-accelerator": {
  	syntax: "false | true",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "false",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
  },
  	"-ms-block-progression": {
  	syntax: "tb | rl | bt | lr",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "tb",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
  },
  	"-ms-content-zoom-chaining": {
  	syntax: "none | chained",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "none",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
  },
  	"-ms-content-zooming": {
  	syntax: "none | zoom",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "zoomForTheTopLevelNoneForTheRest",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
  },
  	"-ms-content-zoom-limit": {
  	syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: [
  		"-ms-content-zoom-limit-max",
  		"-ms-content-zoom-limit-min"
  	],
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: [
  		"-ms-content-zoom-limit-max",
  		"-ms-content-zoom-limit-min"
  	],
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: [
  		"-ms-content-zoom-limit-max",
  		"-ms-content-zoom-limit-min"
  	],
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
  },
  	"-ms-content-zoom-limit-max": {
  	syntax: "<percentage>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "maxZoomFactor",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "400%",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
  },
  	"-ms-content-zoom-limit-min": {
  	syntax: "<percentage>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "minZoomFactor",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "100%",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
  },
  	"-ms-content-zoom-snap": {
  	syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: [
  		"-ms-content-zoom-snap-type",
  		"-ms-content-zoom-snap-points"
  	],
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: [
  		"-ms-content-zoom-snap-type",
  		"-ms-content-zoom-snap-points"
  	],
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
  },
  	"-ms-content-zoom-snap-points": {
  	syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "snapInterval(0%, 100%)",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
  },
  	"-ms-content-zoom-snap-type": {
  	syntax: "none | proximity | mandatory",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "none",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
  },
  	"-ms-filter": {
  	syntax: "<string>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "\"\"",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
  },
  	"-ms-flow-from": {
  	syntax: "[ none | <custom-ident> ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "none",
  	appliesto: "nonReplacedElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
  },
  	"-ms-flow-into": {
  	syntax: "[ none | <custom-ident> ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "none",
  	appliesto: "iframeElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
  },
  	"-ms-grid-columns": {
  	syntax: "none | <track-list> | <auto-track-list>",
  	media: "visual",
  	inherited: false,
  	animationType: "simpleListOfLpcDifferenceLpc",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "none",
  	appliesto: "gridContainers",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
  },
  	"-ms-grid-rows": {
  	syntax: "none | <track-list> | <auto-track-list>",
  	media: "visual",
  	inherited: false,
  	animationType: "simpleListOfLpcDifferenceLpc",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "none",
  	appliesto: "gridContainers",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
  },
  	"-ms-high-contrast-adjust": {
  	syntax: "auto | none",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
  },
  	"-ms-hyphenate-limit-chars": {
  	syntax: "auto | <integer>{1,3}",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
  },
  	"-ms-hyphenate-limit-lines": {
  	syntax: "no-limit | <integer>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "no-limit",
  	appliesto: "blockContainerElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
  },
  	"-ms-hyphenate-limit-zone": {
  	syntax: "<percentage> | <length>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "referToLineBoxWidth",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "0",
  	appliesto: "blockContainerElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
  },
  	"-ms-ime-align": {
  	syntax: "auto | after",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
  },
  	"-ms-overflow-style": {
  	syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
  	media: "interactive",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "auto",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
  },
  	"-ms-scrollbar-3dlight-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "dependsOnUserAgent",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
  },
  	"-ms-scrollbar-arrow-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "ButtonText",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
  },
  	"-ms-scrollbar-base-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "dependsOnUserAgent",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
  },
  	"-ms-scrollbar-darkshadow-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "ThreeDDarkShadow",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
  },
  	"-ms-scrollbar-face-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "ThreeDFace",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
  },
  	"-ms-scrollbar-highlight-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "ThreeDHighlight",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
  },
  	"-ms-scrollbar-shadow-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "ThreeDDarkShadow",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
  },
  	"-ms-scrollbar-track-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "Scrollbar",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
  },
  	"-ms-scroll-chaining": {
  	syntax: "chained | none",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "chained",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
  },
  	"-ms-scroll-limit": {
  	syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: [
  		"-ms-scroll-limit-x-min",
  		"-ms-scroll-limit-y-min",
  		"-ms-scroll-limit-x-max",
  		"-ms-scroll-limit-y-max"
  	],
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: [
  		"-ms-scroll-limit-x-min",
  		"-ms-scroll-limit-y-min",
  		"-ms-scroll-limit-x-max",
  		"-ms-scroll-limit-y-max"
  	],
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
  },
  	"-ms-scroll-limit-x-max": {
  	syntax: "auto | <length>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "auto",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
  },
  	"-ms-scroll-limit-x-min": {
  	syntax: "<length>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "0",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
  },
  	"-ms-scroll-limit-y-max": {
  	syntax: "auto | <length>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "auto",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
  },
  	"-ms-scroll-limit-y-min": {
  	syntax: "<length>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "0",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
  },
  	"-ms-scroll-rails": {
  	syntax: "none | railed",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "railed",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
  },
  	"-ms-scroll-snap-points-x": {
  	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "snapInterval(0px, 100%)",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
  },
  	"-ms-scroll-snap-points-y": {
  	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "snapInterval(0px, 100%)",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
  },
  	"-ms-scroll-snap-type": {
  	syntax: "none | proximity | mandatory",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "none",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
  },
  	"-ms-scroll-snap-x": {
  	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: [
  		"-ms-scroll-snap-type",
  		"-ms-scroll-snap-points-x"
  	],
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: [
  		"-ms-scroll-snap-type",
  		"-ms-scroll-snap-points-x"
  	],
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
  },
  	"-ms-scroll-snap-y": {
  	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: [
  		"-ms-scroll-snap-type",
  		"-ms-scroll-snap-points-y"
  	],
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: [
  		"-ms-scroll-snap-type",
  		"-ms-scroll-snap-points-y"
  	],
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
  },
  	"-ms-scroll-translation": {
  	syntax: "none | vertical-to-horizontal",
  	media: "interactive",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
  },
  	"-ms-text-autospace": {
  	syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
  },
  	"-ms-touch-select": {
  	syntax: "grippers | none",
  	media: "interactive",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "grippers",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
  },
  	"-ms-user-select": {
  	syntax: "none | element | text",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "text",
  	appliesto: "nonReplacedElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
  },
  	"-ms-wrap-flow": {
  	syntax: "auto | both | start | end | maximum | clear",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "auto",
  	appliesto: "blockLevelElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
  },
  	"-ms-wrap-margin": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "0",
  	appliesto: "exclusionElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
  },
  	"-ms-wrap-through": {
  	syntax: "wrap | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Microsoft Extensions"
  	],
  	initial: "wrap",
  	appliesto: "blockLevelElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
  },
  	"-moz-appearance": {
  	syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "noneButOverriddenInUserAgentCSS",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
  },
  	"-moz-binding": {
  	syntax: "<url> | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "none",
  	appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
  },
  	"-moz-border-bottom-colors": {
  	syntax: "<color>+ | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
  },
  	"-moz-border-left-colors": {
  	syntax: "<color>+ | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
  },
  	"-moz-border-right-colors": {
  	syntax: "<color>+ | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
  },
  	"-moz-border-top-colors": {
  	syntax: "<color>+ | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
  },
  	"-moz-context-properties": {
  	syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "none",
  	appliesto: "allElementsThatCanReferenceImages",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
  },
  	"-moz-float-edge": {
  	syntax: "border-box | content-box | margin-box | padding-box",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "content-box",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
  },
  	"-moz-force-broken-image-icon": {
  	syntax: "0 | 1",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "0",
  	appliesto: "images",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
  },
  	"-moz-image-region": {
  	syntax: "<shape> | auto",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "auto",
  	appliesto: "xulImageElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
  },
  	"-moz-orient": {
  	syntax: "inline | block | horizontal | vertical",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "inline",
  	appliesto: "anyElementEffectOnProgressAndMeter",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
  },
  	"-moz-outline-radius": {
  	syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"-moz-outline-radius-topleft",
  		"-moz-outline-radius-topright",
  		"-moz-outline-radius-bottomright",
  		"-moz-outline-radius-bottomleft"
  	],
  	percentages: [
  		"-moz-outline-radius-topleft",
  		"-moz-outline-radius-topright",
  		"-moz-outline-radius-bottomright",
  		"-moz-outline-radius-bottomleft"
  	],
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: [
  		"-moz-outline-radius-topleft",
  		"-moz-outline-radius-topright",
  		"-moz-outline-radius-bottomright",
  		"-moz-outline-radius-bottomleft"
  	],
  	appliesto: "allElements",
  	computed: [
  		"-moz-outline-radius-topleft",
  		"-moz-outline-radius-topright",
  		"-moz-outline-radius-bottomright",
  		"-moz-outline-radius-bottomleft"
  	],
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
  },
  	"-moz-outline-radius-bottomleft": {
  	syntax: "<outline-radius>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
  },
  	"-moz-outline-radius-bottomright": {
  	syntax: "<outline-radius>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
  },
  	"-moz-outline-radius-topleft": {
  	syntax: "<outline-radius>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
  },
  	"-moz-outline-radius-topright": {
  	syntax: "<outline-radius>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
  },
  	"-moz-stack-sizing": {
  	syntax: "ignore | stretch-to-fit",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "stretch-to-fit",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
  },
  	"-moz-text-blink": {
  	syntax: "none | blink",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
  },
  	"-moz-user-focus": {
  	syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
  },
  	"-moz-user-input": {
  	syntax: "auto | none | enabled | disabled",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
  },
  	"-moz-user-modify": {
  	syntax: "read-only | read-write | write-only",
  	media: "interactive",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "read-only",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
  },
  	"-moz-window-dragging": {
  	syntax: "drag | no-drag",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "drag",
  	appliesto: "allElementsCreatingNativeWindows",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
  },
  	"-moz-window-shadow": {
  	syntax: "default | menu | tooltip | sheet | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "default",
  	appliesto: "allElementsCreatingNativeWindows",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
  },
  	"-webkit-appearance": {
  	syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "noneButOverriddenInUserAgentCSS",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
  },
  	"-webkit-border-before": {
  	syntax: "<'border-width'> || <'border-style'> || <color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: [
  		"-webkit-border-before-width"
  	],
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: [
  		"border-width",
  		"border-style",
  		"color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-width",
  		"border-style",
  		"color"
  	],
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
  },
  	"-webkit-border-before-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "nonstandard"
  },
  	"-webkit-border-before-style": {
  	syntax: "<'border-style'>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard"
  },
  	"-webkit-border-before-width": {
  	syntax: "<'border-width'>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
  	order: "uniqueOrder",
  	status: "nonstandard"
  },
  	"-webkit-box-reflect": {
  	syntax: "[ above | below | right | left ]? <length>? <image>?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
  },
  	"-webkit-line-clamp": {
  	syntax: "none | <integer>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions",
  		"CSS Overflow"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
  },
  	"-webkit-mask": {
  	syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: [
  		"-webkit-mask-image",
  		"-webkit-mask-repeat",
  		"-webkit-mask-attachment",
  		"-webkit-mask-position",
  		"-webkit-mask-origin",
  		"-webkit-mask-clip"
  	],
  	appliesto: "allElements",
  	computed: [
  		"-webkit-mask-image",
  		"-webkit-mask-repeat",
  		"-webkit-mask-attachment",
  		"-webkit-mask-position",
  		"-webkit-mask-origin",
  		"-webkit-mask-clip"
  	],
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
  },
  	"-webkit-mask-attachment": {
  	syntax: "<attachment>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "scroll",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
  },
  	"-webkit-mask-clip": {
  	syntax: "[ <box> | border | padding | content | text ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "border",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
  },
  	"-webkit-mask-composite": {
  	syntax: "<composite-style>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "source-over",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
  },
  	"-webkit-mask-image": {
  	syntax: "<mask-reference>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "absoluteURIOrNone",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
  },
  	"-webkit-mask-origin": {
  	syntax: "[ <box> | border | padding | content ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "padding",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
  },
  	"-webkit-mask-position": {
  	syntax: "<position>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "referToSizeOfElement",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "0% 0%",
  	appliesto: "allElements",
  	computed: "absoluteLengthOrPercentage",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
  },
  	"-webkit-mask-position-x": {
  	syntax: "[ <length-percentage> | left | center | right ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "referToSizeOfElement",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "0%",
  	appliesto: "allElements",
  	computed: "absoluteLengthOrPercentage",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
  },
  	"-webkit-mask-position-y": {
  	syntax: "[ <length-percentage> | top | center | bottom ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "referToSizeOfElement",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "0%",
  	appliesto: "allElements",
  	computed: "absoluteLengthOrPercentage",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
  },
  	"-webkit-mask-repeat": {
  	syntax: "<repeat-style>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "repeat",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
  },
  	"-webkit-mask-repeat-x": {
  	syntax: "repeat | no-repeat | space | round",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "repeat",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
  },
  	"-webkit-mask-repeat-y": {
  	syntax: "repeat | no-repeat | space | round",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "repeat",
  	appliesto: "allElements",
  	computed: "absoluteLengthOrPercentage",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
  },
  	"-webkit-mask-size": {
  	syntax: "<bg-size>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "relativeToBackgroundPositioningArea",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "auto auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
  },
  	"-webkit-overflow-scrolling": {
  	syntax: "auto | touch",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "auto",
  	appliesto: "scrollingBoxes",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
  },
  	"-webkit-tap-highlight-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "black",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
  },
  	"-webkit-text-fill-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
  },
  	"-webkit-text-stroke": {
  	syntax: "<length> || <color>",
  	media: "visual",
  	inherited: true,
  	animationType: [
  		"-webkit-text-stroke-width",
  		"-webkit-text-stroke-color"
  	],
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: [
  		"-webkit-text-stroke-width",
  		"-webkit-text-stroke-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"-webkit-text-stroke-width",
  		"-webkit-text-stroke-color"
  	],
  	order: "canonicalOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
  },
  	"-webkit-text-stroke-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: true,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
  },
  	"-webkit-text-stroke-width": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "absoluteLength",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
  },
  	"-webkit-touch-callout": {
  	syntax: "default | none",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "default",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
  },
  	"-webkit-user-modify": {
  	syntax: "read-only | read-write | read-write-plaintext-only",
  	media: "interactive",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"WebKit Extensions"
  	],
  	initial: "read-only",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard"
  },
  	"accent-color": {
  	syntax: "auto | <color>",
  	media: "interactive",
  	inherited: true,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asAutoOrColor",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color"
  },
  	"align-content": {
  	syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: "normal",
  	appliesto: "multilineFlexContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
  },
  	"align-items": {
  	syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
  },
  	"align-self": {
  	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: "auto",
  	appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
  	computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
  },
  	"align-tracks": {
  	syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "normal",
  	appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
  },
  	all: all$1,
  	animation: animation,
  	"animation-composition": {
  	syntax: "<single-animation-composition>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "replace",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-composition"
  },
  	"animation-delay": {
  	syntax: "<time>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "0s",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
  },
  	"animation-direction": {
  	syntax: "<single-animation-direction>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "normal",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
  },
  	"animation-duration": {
  	syntax: "<time>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "0s",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
  },
  	"animation-fill-mode": {
  	syntax: "<single-animation-fill-mode>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "none",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
  },
  	"animation-iteration-count": {
  	syntax: "<single-animation-iteration-count>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "1",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
  },
  	"animation-name": {
  	syntax: "[ none | <keyframes-name> ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "none",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
  },
  	"animation-play-state": {
  	syntax: "<single-animation-play-state>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "running",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
  },
  	"animation-timing-function": {
  	syntax: "<easing-function>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "ease",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
  },
  	"animation-timeline": {
  	syntax: "<single-animation-timeline>#",
  	media: "visual",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "listEachItemIdentifyerOrNoneAuto",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline"
  },
  	appearance: appearance,
  	"aspect-ratio": {
  	syntax: "auto | <ratio>",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
  },
  	azimuth: azimuth,
  	"backdrop-filter": {
  	syntax: "none | <filter-function-list>",
  	media: "visual",
  	inherited: false,
  	animationType: "filterList",
  	percentages: "no",
  	groups: [
  		"Filter Effects"
  	],
  	initial: "none",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
  },
  	"backface-visibility": {
  	syntax: "visible | hidden",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "visible",
  	appliesto: "transformableElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
  },
  	background: background,
  	"background-attachment": {
  	syntax: "<attachment>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "scroll",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
  },
  	"background-blend-mode": {
  	syntax: "<blend-mode>#",
  	media: "none",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Compositing and Blending"
  	],
  	initial: "normal",
  	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
  },
  	"background-clip": {
  	syntax: "<box>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "border-box",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
  },
  	"background-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "transparent",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
  },
  	"background-image": {
  	syntax: "<bg-image>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecifiedURLsAbsolute",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
  },
  	"background-origin": {
  	syntax: "<box>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "padding-box",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
  },
  	"background-position": {
  	syntax: "<bg-position>#",
  	media: "visual",
  	inherited: false,
  	animationType: "repeatableListOfSimpleListOfLpc",
  	percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "0% 0%",
  	appliesto: "allElements",
  	computed: [
  		"background-position-x",
  		"background-position-y"
  	],
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
  },
  	"background-position-x": {
  	syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "0%",
  	appliesto: "allElements",
  	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
  },
  	"background-position-y": {
  	syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "0%",
  	appliesto: "allElements",
  	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
  },
  	"background-repeat": {
  	syntax: "<repeat-style>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "repeat",
  	appliesto: "allElements",
  	computed: "listEachItemHasTwoKeywordsOnePerDimension",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
  },
  	"background-size": {
  	syntax: "<bg-size>#",
  	media: "visual",
  	inherited: false,
  	animationType: "repeatableListOfSimpleListOfLpc",
  	percentages: "relativeToBackgroundPositioningArea",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "auto auto",
  	appliesto: "allElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
  },
  	"block-overflow": {
  	syntax: "clip | ellipsis | <string>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "clip",
  	appliesto: "blockContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "experimental"
  },
  	"block-size": {
  	syntax: "<'width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "blockSizeOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "auto",
  	appliesto: "sameAsWidthAndHeight",
  	computed: "sameAsWidthAndHeight",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
  },
  	border: border,
  	"border-block": {
  	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"border-top-width",
  		"border-top-style",
  		"border-top-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-top-width",
  		"border-top-style",
  		"border-top-color"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
  },
  	"border-block-color": {
  	syntax: "<'border-top-color'>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
  },
  	"border-block-style": {
  	syntax: "<'border-top-style'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
  },
  	"border-block-width": {
  	syntax: "<'border-top-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
  },
  	"border-block-end": {
  	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-block-end-color",
  		"border-block-end-style",
  		"border-block-end-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"border-top-width",
  		"border-top-style",
  		"border-top-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-top-width",
  		"border-top-style",
  		"border-top-color"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
  },
  	"border-block-end-color": {
  	syntax: "<'border-top-color'>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
  },
  	"border-block-end-style": {
  	syntax: "<'border-top-style'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
  },
  	"border-block-end-width": {
  	syntax: "<'border-top-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
  },
  	"border-block-start": {
  	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-block-start-color",
  		"border-block-start-style",
  		"border-block-start-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"border-width",
  		"border-style",
  		"color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-width",
  		"border-style",
  		"border-block-start-color"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
  },
  	"border-block-start-color": {
  	syntax: "<'border-top-color'>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
  },
  	"border-block-start-style": {
  	syntax: "<'border-top-style'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
  },
  	"border-block-start-width": {
  	syntax: "<'border-top-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
  },
  	"border-bottom": {
  	syntax: "<line-width> || <line-style> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-bottom-color",
  		"border-bottom-style",
  		"border-bottom-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-bottom-width",
  		"border-bottom-style",
  		"border-bottom-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-bottom-width",
  		"border-bottom-style",
  		"border-bottom-color"
  	],
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
  },
  	"border-bottom-color": {
  	syntax: "<'border-top-color'>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
  },
  	"border-bottom-left-radius": {
  	syntax: "<length-percentage>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "0",
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: "twoAbsoluteLengthOrPercentages",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
  },
  	"border-bottom-right-radius": {
  	syntax: "<length-percentage>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "0",
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: "twoAbsoluteLengthOrPercentages",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
  },
  	"border-bottom-style": {
  	syntax: "<line-style>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
  },
  	"border-bottom-width": {
  	syntax: "<line-width>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
  },
  	"border-collapse": {
  	syntax: "collapse | separate",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Table"
  	],
  	initial: "separate",
  	appliesto: "tableElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
  },
  	"border-color": {
  	syntax: "<color>{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-bottom-color",
  		"border-left-color",
  		"border-right-color",
  		"border-top-color"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-top-color",
  		"border-right-color",
  		"border-bottom-color",
  		"border-left-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-bottom-color",
  		"border-left-color",
  		"border-right-color",
  		"border-top-color"
  	],
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
  },
  	"border-end-end-radius": {
  	syntax: "<length-percentage>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: "twoAbsoluteLengthOrPercentages",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
  },
  	"border-end-start-radius": {
  	syntax: "<length-percentage>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: "twoAbsoluteLengthOrPercentages",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
  },
  	"border-image": {
  	syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: [
  		"border-image-slice",
  		"border-image-width"
  	],
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-image-source",
  		"border-image-slice",
  		"border-image-width",
  		"border-image-outset",
  		"border-image-repeat"
  	],
  	appliesto: "allElementsExceptTableElementsWhenCollapse",
  	computed: [
  		"border-image-outset",
  		"border-image-repeat",
  		"border-image-slice",
  		"border-image-source",
  		"border-image-width"
  	],
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
  },
  	"border-image-outset": {
  	syntax: "[ <length> | <number> ]{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptTableElementsWhenCollapse",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
  },
  	"border-image-repeat": {
  	syntax: "[ stretch | repeat | round | space ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "stretch",
  	appliesto: "allElementsExceptTableElementsWhenCollapse",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
  },
  	"border-image-slice": {
  	syntax: "<number-percentage>{1,4} && fill?",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "referToSizeOfBorderImage",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "100%",
  	appliesto: "allElementsExceptTableElementsWhenCollapse",
  	computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
  	order: "percentagesOrLengthsFollowedByFill",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
  },
  	"border-image-source": {
  	syntax: "none | <image>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "none",
  	appliesto: "allElementsExceptTableElementsWhenCollapse",
  	computed: "noneOrImageWithAbsoluteURI",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
  },
  	"border-image-width": {
  	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "referToWidthOrHeightOfBorderImageArea",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "1",
  	appliesto: "allElementsExceptTableElementsWhenCollapse",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
  },
  	"border-inline": {
  	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"border-top-width",
  		"border-top-style",
  		"border-top-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-top-width",
  		"border-top-style",
  		"border-top-color"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
  },
  	"border-inline-end": {
  	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-inline-end-color",
  		"border-inline-end-style",
  		"border-inline-end-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"border-width",
  		"border-style",
  		"color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-width",
  		"border-style",
  		"border-inline-end-color"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
  },
  	"border-inline-color": {
  	syntax: "<'border-top-color'>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
  },
  	"border-inline-style": {
  	syntax: "<'border-top-style'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
  },
  	"border-inline-width": {
  	syntax: "<'border-top-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
  },
  	"border-inline-end-color": {
  	syntax: "<'border-top-color'>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
  },
  	"border-inline-end-style": {
  	syntax: "<'border-top-style'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
  },
  	"border-inline-end-width": {
  	syntax: "<'border-top-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
  },
  	"border-inline-start": {
  	syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-inline-start-color",
  		"border-inline-start-style",
  		"border-inline-start-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"border-width",
  		"border-style",
  		"color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-width",
  		"border-style",
  		"border-inline-start-color"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
  },
  	"border-inline-start-color": {
  	syntax: "<'border-top-color'>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
  },
  	"border-inline-start-style": {
  	syntax: "<'border-top-style'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
  },
  	"border-inline-start-width": {
  	syntax: "<'border-top-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
  },
  	"border-left": {
  	syntax: "<line-width> || <line-style> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-left-color",
  		"border-left-style",
  		"border-left-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-left-width",
  		"border-left-style",
  		"border-left-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-left-width",
  		"border-left-style",
  		"border-left-color"
  	],
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
  },
  	"border-left-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
  },
  	"border-left-style": {
  	syntax: "<line-style>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
  },
  	"border-left-width": {
  	syntax: "<line-width>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
  },
  	"border-radius": {
  	syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-top-left-radius",
  		"border-top-right-radius",
  		"border-bottom-right-radius",
  		"border-bottom-left-radius"
  	],
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-top-left-radius",
  		"border-top-right-radius",
  		"border-bottom-right-radius",
  		"border-bottom-left-radius"
  	],
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: [
  		"border-bottom-left-radius",
  		"border-bottom-right-radius",
  		"border-top-left-radius",
  		"border-top-right-radius"
  	],
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
  },
  	"border-right": {
  	syntax: "<line-width> || <line-style> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-right-color",
  		"border-right-style",
  		"border-right-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-right-width",
  		"border-right-style",
  		"border-right-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-right-width",
  		"border-right-style",
  		"border-right-color"
  	],
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
  },
  	"border-right-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
  },
  	"border-right-style": {
  	syntax: "<line-style>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
  },
  	"border-right-width": {
  	syntax: "<line-width>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
  },
  	"border-spacing": {
  	syntax: "<length> <length>?",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Table"
  	],
  	initial: "0",
  	appliesto: "tableElements",
  	computed: "twoAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
  },
  	"border-start-end-radius": {
  	syntax: "<length-percentage>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: "twoAbsoluteLengthOrPercentages",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
  },
  	"border-start-start-radius": {
  	syntax: "<length-percentage>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: "twoAbsoluteLengthOrPercentages",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
  },
  	"border-style": {
  	syntax: "<line-style>{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-top-style",
  		"border-right-style",
  		"border-bottom-style",
  		"border-left-style"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-bottom-style",
  		"border-left-style",
  		"border-right-style",
  		"border-top-style"
  	],
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
  },
  	"border-top": {
  	syntax: "<line-width> || <line-style> || <color>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-top-color",
  		"border-top-style",
  		"border-top-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-top-width",
  		"border-top-style",
  		"border-top-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-top-width",
  		"border-top-style",
  		"border-top-color"
  	],
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
  },
  	"border-top-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
  },
  	"border-top-left-radius": {
  	syntax: "<length-percentage>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "0",
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: "twoAbsoluteLengthOrPercentages",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
  },
  	"border-top-right-radius": {
  	syntax: "<length-percentage>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfBorderBox",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "0",
  	appliesto: "allElementsUAsNotRequiredWhenCollapse",
  	computed: "twoAbsoluteLengthOrPercentages",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
  },
  	"border-top-style": {
  	syntax: "<line-style>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
  },
  	"border-top-width": {
  	syntax: "<line-width>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
  },
  	"border-width": {
  	syntax: "<line-width>{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"border-bottom-width",
  		"border-left-width",
  		"border-right-width",
  		"border-top-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: [
  		"border-top-width",
  		"border-right-width",
  		"border-bottom-width",
  		"border-left-width"
  	],
  	appliesto: "allElements",
  	computed: [
  		"border-bottom-width",
  		"border-left-width",
  		"border-right-width",
  		"border-top-width"
  	],
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
  },
  	bottom: bottom,
  	"box-align": {
  	syntax: "start | center | end | baseline | stretch",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "stretch",
  	appliesto: "elementsWithDisplayBoxOrInlineBox",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
  },
  	"box-decoration-break": {
  	syntax: "slice | clone",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fragmentation"
  	],
  	initial: "slice",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
  },
  	"box-direction": {
  	syntax: "normal | reverse | inherit",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "normal",
  	appliesto: "elementsWithDisplayBoxOrInlineBox",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
  },
  	"box-flex": {
  	syntax: "<number>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "0",
  	appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
  },
  	"box-flex-group": {
  	syntax: "<integer>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "1",
  	appliesto: "inFlowChildrenOfBoxElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
  },
  	"box-lines": {
  	syntax: "single | multiple",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "single",
  	appliesto: "boxElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
  },
  	"box-ordinal-group": {
  	syntax: "<integer>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "1",
  	appliesto: "childrenOfBoxElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
  },
  	"box-orient": {
  	syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "inlineAxisHorizontalInXUL",
  	appliesto: "elementsWithDisplayBoxOrInlineBox",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
  },
  	"box-pack": {
  	syntax: "start | center | end | justify",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions",
  		"WebKit Extensions"
  	],
  	initial: "start",
  	appliesto: "elementsWithDisplayMozBoxMozInlineBox",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
  },
  	"box-shadow": {
  	syntax: "none | <shadow>#",
  	media: "visual",
  	inherited: false,
  	animationType: "shadowList",
  	percentages: "no",
  	groups: [
  		"CSS Backgrounds and Borders"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "absoluteLengthsSpecifiedColorAsSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
  },
  	"box-sizing": {
  	syntax: "content-box | border-box",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "content-box",
  	appliesto: "allElementsAcceptingWidthOrHeight",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
  },
  	"break-after": {
  	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fragmentation"
  	],
  	initial: "auto",
  	appliesto: "blockLevelElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
  },
  	"break-before": {
  	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fragmentation"
  	],
  	initial: "auto",
  	appliesto: "blockLevelElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
  },
  	"break-inside": {
  	syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fragmentation"
  	],
  	initial: "auto",
  	appliesto: "blockLevelElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
  },
  	"caption-side": {
  	syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Table"
  	],
  	initial: "top",
  	appliesto: "tableCaptionElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
  },
  	caret: caret,
  	"caret-color": {
  	syntax: "auto | <color>",
  	media: "interactive",
  	inherited: true,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asAutoOrColor",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
  },
  	"caret-shape": {
  	syntax: "auto | bar | block | underscore",
  	media: "interactive",
  	inherited: true,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "elementsThatAcceptInput",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard"
  },
  	clear: clear,
  	clip: clip,
  	"clip-path": {
  	syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
  	media: "visual",
  	inherited: false,
  	animationType: "basicShapeOtherwiseNo",
  	percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "none",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecifiedURLsAbsolute",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
  },
  	color: color$1,
  	"print-color-adjust": {
  	syntax: "economy | exact",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Color"
  	],
  	initial: "economy",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"
  },
  	"color-scheme": {
  	syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Color"
  	],
  	initial: "normal",
  	appliesto: "allElementsAndText",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme"
  },
  	"column-count": {
  	syntax: "<integer> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "integer",
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: "auto",
  	appliesto: "blockContainersExceptTableWrappers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
  },
  	"column-fill": {
  	syntax: "auto | balance | balance-all",
  	media: "visualInContinuousMediaNoEffectInOverflowColumns",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: "balance",
  	appliesto: "multicolElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
  },
  	"column-gap": {
  	syntax: "normal | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: "normal",
  	appliesto: "multiColumnElementsFlexContainersGridContainers",
  	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
  },
  	"column-rule": {
  	syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"column-rule-color",
  		"column-rule-style",
  		"column-rule-width"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: [
  		"column-rule-width",
  		"column-rule-style",
  		"column-rule-color"
  	],
  	appliesto: "multicolElements",
  	computed: [
  		"column-rule-color",
  		"column-rule-style",
  		"column-rule-width"
  	],
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
  },
  	"column-rule-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: "currentcolor",
  	appliesto: "multicolElements",
  	computed: "computedColor",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
  },
  	"column-rule-style": {
  	syntax: "<'border-style'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: "none",
  	appliesto: "multicolElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
  },
  	"column-rule-width": {
  	syntax: "<'border-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: "medium",
  	appliesto: "multicolElements",
  	computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
  },
  	"column-span": {
  	syntax: "none | all",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: "none",
  	appliesto: "inFlowBlockLevelElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
  },
  	"column-width": {
  	syntax: "<length> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Columns"
  	],
  	initial: "auto",
  	appliesto: "blockContainersExceptTableWrappers",
  	computed: "absoluteLengthZeroOrLarger",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
  },
  	columns: columns,
  	contain: contain,
  	"contain-intrinsic-size": {
  	syntax: "[ none | <length> | auto <length> ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"contain-intrinsic-width",
  		"contain-intrinsic-height"
  	],
  	percentages: [
  		"contain-intrinsic-width",
  		"contain-intrinsic-height"
  	],
  	groups: [
  		"CSS Containment"
  	],
  	initial: [
  		"contain-intrinsic-width",
  		"contain-intrinsic-height"
  	],
  	appliesto: "elementsForWhichSizeContainmentCanApply",
  	computed: [
  		"contain-intrinsic-width",
  		"contain-intrinsic-height"
  	],
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-size"
  },
  	"contain-intrinsic-block-size": {
  	syntax: "none | <length> | auto <length>",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Containment"
  	],
  	initial: "none",
  	appliesto: "elementsForWhichSizeContainmentCanApply",
  	computed: "asSpecifiedWithLengthValuesComputed",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-block-size"
  },
  	"contain-intrinsic-height": {
  	syntax: "none | <length> | auto <length>",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Containment"
  	],
  	initial: "none",
  	appliesto: "elementsForWhichSizeContainmentCanApply",
  	computed: "asSpecifiedWithLengthValuesComputed",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-height"
  },
  	"contain-intrinsic-inline-size": {
  	syntax: "none | <length> | auto <length>",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Containment"
  	],
  	initial: "none",
  	appliesto: "elementsForWhichSizeContainmentCanApply",
  	computed: "asSpecifiedWithLengthValuesComputed",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-inline-size"
  },
  	"contain-intrinsic-width": {
  	syntax: "none | <length> | auto <length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Containment"
  	],
  	initial: "none",
  	appliesto: "elementsForWhichSizeContainmentCanApply",
  	computed: "asSpecifiedWithLengthValuesComputed",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-width"
  },
  	content: content,
  	"content-visibility": {
  	syntax: "visible | auto | hidden",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Containment"
  	],
  	initial: "visible",
  	appliesto: "elementsForWhichLayoutContainmentCanApply",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility"
  },
  	"counter-increment": {
  	syntax: "[ <counter-name> <integer>? ]+ | none",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Counter Styles"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
  },
  	"counter-reset": {
  	syntax: "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Counter Styles"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
  },
  	"counter-set": {
  	syntax: "[ <counter-name> <integer>? ]+ | none",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Counter Styles"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
  },
  	cursor: cursor,
  	direction: direction,
  	display: display,
  	"empty-cells": {
  	syntax: "show | hide",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Table"
  	],
  	initial: "show",
  	appliesto: "tableCellElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
  },
  	filter: filter$1,
  	flex: flex,
  	"flex-basis": {
  	syntax: "content | <'width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToFlexContainersInnerMainSize",
  	groups: [
  		"CSS Flexible Box Layout"
  	],
  	initial: "auto",
  	appliesto: "flexItemsAndInFlowPseudos",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
  },
  	"flex-direction": {
  	syntax: "row | row-reverse | column | column-reverse",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Flexible Box Layout"
  	],
  	initial: "row",
  	appliesto: "flexContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
  },
  	"flex-flow": {
  	syntax: "<'flex-direction'> || <'flex-wrap'>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Flexible Box Layout"
  	],
  	initial: [
  		"flex-direction",
  		"flex-wrap"
  	],
  	appliesto: "flexContainers",
  	computed: [
  		"flex-direction",
  		"flex-wrap"
  	],
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
  },
  	"flex-grow": {
  	syntax: "<number>",
  	media: "visual",
  	inherited: false,
  	animationType: "number",
  	percentages: "no",
  	groups: [
  		"CSS Flexible Box Layout"
  	],
  	initial: "0",
  	appliesto: "flexItemsAndInFlowPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
  },
  	"flex-shrink": {
  	syntax: "<number>",
  	media: "visual",
  	inherited: false,
  	animationType: "number",
  	percentages: "no",
  	groups: [
  		"CSS Flexible Box Layout"
  	],
  	initial: "1",
  	appliesto: "flexItemsAndInFlowPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
  },
  	"flex-wrap": {
  	syntax: "nowrap | wrap | wrap-reverse",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Flexible Box Layout"
  	],
  	initial: "nowrap",
  	appliesto: "flexContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
  },
  	float: float$1,
  	font: font,
  	"font-family": {
  	syntax: "[ <family-name> | <generic-family> ]#",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "dependsOnUserAgent",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
  },
  	"font-feature-settings": {
  	syntax: "normal | <feature-tag-value>#",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
  },
  	"font-kerning": {
  	syntax: "auto | normal | none",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
  },
  	"font-language-override": {
  	syntax: "normal | <string>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
  },
  	"font-optical-sizing": {
  	syntax: "auto | none",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
  },
  	"font-variation-settings": {
  	syntax: "normal | [ <string> <number> ]#",
  	media: "visual",
  	inherited: true,
  	animationType: "transform",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
  },
  	"font-size": {
  	syntax: "<absolute-size> | <relative-size> | <length-percentage>",
  	media: "visual",
  	inherited: true,
  	animationType: "length",
  	percentages: "referToParentElementsFontSize",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
  },
  	"font-size-adjust": {
  	syntax: "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
  	media: "visual",
  	inherited: true,
  	animationType: "number",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
  },
  	"font-smooth": {
  	syntax: "auto | never | always | <absolute-size> | <length>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
  },
  	"font-stretch": {
  	syntax: "<font-stretch-absolute>",
  	media: "visual",
  	inherited: true,
  	animationType: "fontStretch",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
  },
  	"font-style": {
  	syntax: "normal | italic | oblique <angle>?",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
  },
  	"font-synthesis": {
  	syntax: "none | [ weight || style || small-caps ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "weight style",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
  },
  	"font-variant": {
  	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
  },
  	"font-variant-alternates": {
  	syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
  },
  	"font-variant-caps": {
  	syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
  },
  	"font-variant-east-asian": {
  	syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
  },
  	"font-variant-ligatures": {
  	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
  },
  	"font-variant-numeric": {
  	syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
  },
  	"font-variant-position": {
  	syntax: "normal | sub | super",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
  },
  	"font-weight": {
  	syntax: "<font-weight-absolute> | bolder | lighter",
  	media: "visual",
  	inherited: true,
  	animationType: "fontWeight",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
  },
  	"forced-color-adjust": {
  	syntax: "auto | none",
  	media: "visual",
  	inherited: true,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Color"
  	],
  	initial: "auto",
  	appliesto: "allElementsAndText",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"
  },
  	gap: gap,
  	grid: grid,
  	"grid-area": {
  	syntax: "<grid-line> [ / <grid-line> ]{0,3}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: [
  		"grid-row-start",
  		"grid-column-start",
  		"grid-row-end",
  		"grid-column-end"
  	],
  	appliesto: "gridItemsAndBoxesWithinGridContainer",
  	computed: [
  		"grid-row-start",
  		"grid-column-start",
  		"grid-row-end",
  		"grid-column-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
  },
  	"grid-auto-columns": {
  	syntax: "<track-size>+",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "auto",
  	appliesto: "gridContainers",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
  },
  	"grid-auto-flow": {
  	syntax: "[ row | column ] || dense",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "row",
  	appliesto: "gridContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
  },
  	"grid-auto-rows": {
  	syntax: "<track-size>+",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "auto",
  	appliesto: "gridContainers",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
  },
  	"grid-column": {
  	syntax: "<grid-line> [ / <grid-line> ]?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: [
  		"grid-column-start",
  		"grid-column-end"
  	],
  	appliesto: "gridItemsAndBoxesWithinGridContainer",
  	computed: [
  		"grid-column-start",
  		"grid-column-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
  },
  	"grid-column-end": {
  	syntax: "<grid-line>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "auto",
  	appliesto: "gridItemsAndBoxesWithinGridContainer",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
  },
  	"grid-column-gap": {
  	syntax: "<length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "0",
  	appliesto: "gridContainers",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
  },
  	"grid-column-start": {
  	syntax: "<grid-line>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "auto",
  	appliesto: "gridItemsAndBoxesWithinGridContainer",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
  },
  	"grid-gap": {
  	syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"grid-row-gap",
  		"grid-column-gap"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: [
  		"grid-row-gap",
  		"grid-column-gap"
  	],
  	appliesto: "gridContainers",
  	computed: [
  		"grid-row-gap",
  		"grid-column-gap"
  	],
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
  },
  	"grid-row": {
  	syntax: "<grid-line> [ / <grid-line> ]?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: [
  		"grid-row-start",
  		"grid-row-end"
  	],
  	appliesto: "gridItemsAndBoxesWithinGridContainer",
  	computed: [
  		"grid-row-start",
  		"grid-row-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
  },
  	"grid-row-end": {
  	syntax: "<grid-line>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "auto",
  	appliesto: "gridItemsAndBoxesWithinGridContainer",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
  },
  	"grid-row-gap": {
  	syntax: "<length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "0",
  	appliesto: "gridContainers",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
  },
  	"grid-row-start": {
  	syntax: "<grid-line>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "auto",
  	appliesto: "gridItemsAndBoxesWithinGridContainer",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
  },
  	"grid-template": {
  	syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: [
  		"grid-template-columns",
  		"grid-template-rows"
  	],
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: [
  		"grid-template-columns",
  		"grid-template-rows",
  		"grid-template-areas"
  	],
  	appliesto: "gridContainers",
  	computed: [
  		"grid-template-columns",
  		"grid-template-rows",
  		"grid-template-areas"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
  },
  	"grid-template-areas": {
  	syntax: "none | <string>+",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "none",
  	appliesto: "gridContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
  },
  	"grid-template-columns": {
  	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
  	media: "visual",
  	inherited: false,
  	animationType: "simpleListOfLpcDifferenceLpc",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "none",
  	appliesto: "gridContainers",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
  },
  	"grid-template-rows": {
  	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
  	media: "visual",
  	inherited: false,
  	animationType: "simpleListOfLpcDifferenceLpc",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "none",
  	appliesto: "gridContainers",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
  },
  	"hanging-punctuation": {
  	syntax: "none | [ first || [ force-end | allow-end ] || last ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
  },
  	height: height,
  	"hyphenate-character": {
  	syntax: "auto | <string>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"
  },
  	hyphens: hyphens,
  	"image-orientation": {
  	syntax: "from-image | <angle> | [ <angle>? flip ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Images"
  	],
  	initial: "from-image",
  	appliesto: "allElements",
  	computed: "angleRoundedToNextQuarter",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
  },
  	"image-rendering": {
  	syntax: "auto | crisp-edges | pixelated",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Images"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
  },
  	"image-resolution": {
  	syntax: "[ from-image || <resolution> ] && snap?",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Images"
  	],
  	initial: "1dppx",
  	appliesto: "allElements",
  	computed: "asSpecifiedWithExceptionOfResolution",
  	order: "uniqueOrder",
  	status: "experimental"
  },
  	"ime-mode": {
  	syntax: "auto | normal | active | inactive | disabled",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "textFields",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
  },
  	"initial-letter": {
  	syntax: "normal | [ <number> <integer>? ]",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Inline"
  	],
  	initial: "normal",
  	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
  },
  	"initial-letter-align": {
  	syntax: "[ auto | alphabetic | hanging | ideographic ]",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Inline"
  	],
  	initial: "auto",
  	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
  },
  	"inline-size": {
  	syntax: "<'width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "inlineSizeOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "auto",
  	appliesto: "sameAsWidthAndHeight",
  	computed: "sameAsWidthAndHeight",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
  },
  	"input-security": {
  	syntax: "auto | none",
  	media: "interactive",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "sensitiveTextInputs",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard"
  },
  	inset: inset,
  	"inset-block": {
  	syntax: "<'top'>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "logicalHeightOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"inset-block-start",
  		"inset-block-end"
  	],
  	appliesto: "positionedElements",
  	computed: [
  		"inset-block-start",
  		"inset-block-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
  },
  	"inset-block-end": {
  	syntax: "<'top'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "logicalHeightOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "sameAsBoxOffsets",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
  },
  	"inset-block-start": {
  	syntax: "<'top'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "logicalHeightOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "sameAsBoxOffsets",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
  },
  	"inset-inline": {
  	syntax: "<'top'>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"inset-inline-start",
  		"inset-inline-end"
  	],
  	appliesto: "positionedElements",
  	computed: [
  		"inset-inline-start",
  		"inset-inline-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
  },
  	"inset-inline-end": {
  	syntax: "<'top'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "sameAsBoxOffsets",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
  },
  	"inset-inline-start": {
  	syntax: "<'top'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "sameAsBoxOffsets",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
  },
  	isolation: isolation,
  	"justify-content": {
  	syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: "normal",
  	appliesto: "flexContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
  },
  	"justify-items": {
  	syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: "legacy",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
  },
  	"justify-self": {
  	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: "auto",
  	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
  },
  	"justify-tracks": {
  	syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "normal",
  	appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
  },
  	left: left,
  	"letter-spacing": {
  	syntax: "normal | <length>",
  	media: "visual",
  	inherited: true,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "optimumValueOfAbsoluteLengthOrNormal",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
  },
  	"line-break": {
  	syntax: "auto | loose | normal | strict | anywhere",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
  },
  	"line-clamp": {
  	syntax: "none | <integer>",
  	media: "visual",
  	inherited: false,
  	animationType: "integer",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "none",
  	appliesto: "blockContainersExceptMultiColumnContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "experimental"
  },
  	"line-height": {
  	syntax: "normal | <number> | <length> | <percentage>",
  	media: "visual",
  	inherited: true,
  	animationType: "numberOrLength",
  	percentages: "referToElementFontSize",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "absoluteLengthOrAsSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
  },
  	"line-height-step": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Fonts"
  	],
  	initial: "0",
  	appliesto: "blockContainers",
  	computed: "absoluteLength",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
  },
  	"list-style": {
  	syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Lists and Counters"
  	],
  	initial: [
  		"list-style-type",
  		"list-style-position",
  		"list-style-image"
  	],
  	appliesto: "listItems",
  	computed: [
  		"list-style-image",
  		"list-style-position",
  		"list-style-type"
  	],
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
  },
  	"list-style-image": {
  	syntax: "<image> | none",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Lists and Counters"
  	],
  	initial: "none",
  	appliesto: "listItems",
  	computed: "theKeywordListStyleImageNoneOrComputedValue",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
  },
  	"list-style-position": {
  	syntax: "inside | outside",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Lists and Counters"
  	],
  	initial: "outside",
  	appliesto: "listItems",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
  },
  	"list-style-type": {
  	syntax: "<counter-style> | <string> | none",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Lists and Counters"
  	],
  	initial: "disc",
  	appliesto: "listItems",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
  },
  	margin: margin,
  	"margin-block": {
  	syntax: "<'margin-left'>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "dependsOnLayoutModel",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"margin-block-start",
  		"margin-block-end"
  	],
  	appliesto: "sameAsMargin",
  	computed: [
  		"margin-block-start",
  		"margin-block-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
  },
  	"margin-block-end": {
  	syntax: "<'margin-left'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "dependsOnLayoutModel",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "sameAsMargin",
  	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
  },
  	"margin-block-start": {
  	syntax: "<'margin-left'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "dependsOnLayoutModel",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "sameAsMargin",
  	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
  },
  	"margin-bottom": {
  	syntax: "<length> | <percentage> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptTableDisplayTypes",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
  },
  	"margin-inline": {
  	syntax: "<'margin-left'>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "dependsOnLayoutModel",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"margin-inline-start",
  		"margin-inline-end"
  	],
  	appliesto: "sameAsMargin",
  	computed: [
  		"margin-inline-start",
  		"margin-inline-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
  },
  	"margin-inline-end": {
  	syntax: "<'margin-left'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "dependsOnLayoutModel",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "sameAsMargin",
  	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
  },
  	"margin-inline-start": {
  	syntax: "<'margin-left'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "dependsOnLayoutModel",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "sameAsMargin",
  	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
  },
  	"margin-left": {
  	syntax: "<length> | <percentage> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptTableDisplayTypes",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
  },
  	"margin-right": {
  	syntax: "<length> | <percentage> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptTableDisplayTypes",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
  },
  	"margin-top": {
  	syntax: "<length> | <percentage> | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptTableDisplayTypes",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
  },
  	"margin-trim": {
  	syntax: "none | in-flow | all",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "none",
  	appliesto: "blockContainersAndMultiColumnContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
  },
  	mask: mask,
  	"mask-border": {
  	syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"mask-border-mode",
  		"mask-border-outset",
  		"mask-border-repeat",
  		"mask-border-slice",
  		"mask-border-source",
  		"mask-border-width"
  	],
  	percentages: [
  		"mask-border-slice",
  		"mask-border-width"
  	],
  	groups: [
  		"CSS Masking"
  	],
  	initial: [
  		"mask-border-mode",
  		"mask-border-outset",
  		"mask-border-repeat",
  		"mask-border-slice",
  		"mask-border-source",
  		"mask-border-width"
  	],
  	appliesto: "allElementsSVGContainerElements",
  	computed: [
  		"mask-border-mode",
  		"mask-border-outset",
  		"mask-border-repeat",
  		"mask-border-slice",
  		"mask-border-source",
  		"mask-border-width"
  	],
  	order: "perGrammar",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
  },
  	"mask-border-mode": {
  	syntax: "luminance | alpha",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "alpha",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
  },
  	"mask-border-outset": {
  	syntax: "[ <length> | <number> ]{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "0",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
  },
  	"mask-border-repeat": {
  	syntax: "[ stretch | repeat | round | space ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "stretch",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
  },
  	"mask-border-slice": {
  	syntax: "<number-percentage>{1,4} fill?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "referToSizeOfMaskBorderImage",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "0",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
  },
  	"mask-border-source": {
  	syntax: "none | <image>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "none",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecifiedURLsAbsolute",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
  },
  	"mask-border-width": {
  	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "relativeToMaskBorderImageArea",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "auto",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
  },
  	"mask-clip": {
  	syntax: "[ <geometry-box> | no-clip ]#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "border-box",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
  },
  	"mask-composite": {
  	syntax: "<compositing-operator>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "add",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
  },
  	"mask-image": {
  	syntax: "<mask-reference>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "none",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecifiedURLsAbsolute",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
  },
  	"mask-mode": {
  	syntax: "<masking-mode>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "match-source",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
  },
  	"mask-origin": {
  	syntax: "<geometry-box>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "border-box",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
  },
  	"mask-position": {
  	syntax: "<position>#",
  	media: "visual",
  	inherited: false,
  	animationType: "repeatableListOfSimpleListOfLpc",
  	percentages: "referToSizeOfMaskPaintingArea",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "center",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "consistsOfTwoKeywordsForOriginAndOffsets",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
  },
  	"mask-repeat": {
  	syntax: "<repeat-style>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "repeat",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "consistsOfTwoDimensionKeywords",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
  },
  	"mask-size": {
  	syntax: "<bg-size>#",
  	media: "visual",
  	inherited: false,
  	animationType: "repeatableListOfSimpleListOfLpc",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "auto",
  	appliesto: "allElementsSVGContainerElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
  },
  	"mask-type": {
  	syntax: "luminance | alpha",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Masking"
  	],
  	initial: "luminance",
  	appliesto: "maskElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
  },
  	"masonry-auto-flow": {
  	syntax: "[ pack | next ] || [ definite-first | ordered ]",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Grid Layout"
  	],
  	initial: "pack",
  	appliesto: "gridContainersWithMasonryLayout",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
  },
  	"math-depth": {
  	syntax: "auto-add | add(<integer>) | <integer>",
  	media: "visual",
  	inherited: true,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"MathML"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-depth"
  },
  	"math-shift": {
  	syntax: "normal | compact",
  	media: "visual",
  	inherited: true,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"MathML"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-shift"
  },
  	"math-style": {
  	syntax: "normal | compact",
  	media: "visual",
  	inherited: true,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"MathML"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
  },
  	"max-block-size": {
  	syntax: "<'max-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "blockSizeOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "none",
  	appliesto: "sameAsWidthAndHeight",
  	computed: "sameAsMaxWidthAndMaxHeight",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
  },
  	"max-height": {
  	syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "none",
  	appliesto: "allElementsButNonReplacedAndTableColumns",
  	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
  },
  	"max-inline-size": {
  	syntax: "<'max-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "inlineSizeOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "none",
  	appliesto: "sameAsWidthAndHeight",
  	computed: "sameAsMaxWidthAndMaxHeight",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
  },
  	"max-lines": {
  	syntax: "none | <integer>",
  	media: "visual",
  	inherited: false,
  	animationType: "integer",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "none",
  	appliesto: "blockContainersExceptMultiColumnContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "experimental"
  },
  	"max-width": {
  	syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "none",
  	appliesto: "allElementsButNonReplacedAndTableRows",
  	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
  },
  	"min-block-size": {
  	syntax: "<'min-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "blockSizeOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "sameAsWidthAndHeight",
  	computed: "sameAsMinWidthAndMinHeight",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
  },
  	"min-height": {
  	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "allElementsButNonReplacedAndTableColumns",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
  },
  	"min-inline-size": {
  	syntax: "<'min-width'>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "inlineSizeOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "sameAsWidthAndHeight",
  	computed: "sameAsMinWidthAndMinHeight",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
  },
  	"min-width": {
  	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "allElementsButNonReplacedAndTableRows",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
  },
  	"mix-blend-mode": {
  	syntax: "<blend-mode> | plus-lighter",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Compositing and Blending"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
  },
  	"object-fit": {
  	syntax: "fill | contain | cover | none | scale-down",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Images"
  	],
  	initial: "fill",
  	appliesto: "replacedElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
  },
  	"object-position": {
  	syntax: "<position>",
  	media: "visual",
  	inherited: true,
  	animationType: "repeatableListOfSimpleListOfLpc",
  	percentages: "referToWidthAndHeightOfElement",
  	groups: [
  		"CSS Images"
  	],
  	initial: "50% 50%",
  	appliesto: "replacedElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
  },
  	offset: offset,
  	"offset-anchor": {
  	syntax: "auto | <position>",
  	media: "visual",
  	inherited: false,
  	animationType: "position",
  	percentages: "relativeToWidthAndHeight",
  	groups: [
  		"CSS Motion Path"
  	],
  	initial: "auto",
  	appliesto: "transformableElements",
  	computed: "forLengthAbsoluteValueOtherwisePercentage",
  	order: "perGrammar",
  	status: "standard"
  },
  	"offset-distance": {
  	syntax: "<length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToTotalPathLength",
  	groups: [
  		"CSS Motion Path"
  	],
  	initial: "0",
  	appliesto: "transformableElements",
  	computed: "forLengthAbsoluteValueOtherwisePercentage",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
  },
  	"offset-path": {
  	syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
  	media: "visual",
  	inherited: false,
  	animationType: "angleOrBasicShapeOrPath",
  	percentages: "no",
  	groups: [
  		"CSS Motion Path"
  	],
  	initial: "none",
  	appliesto: "transformableElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
  },
  	"offset-position": {
  	syntax: "auto | <position>",
  	media: "visual",
  	inherited: false,
  	animationType: "position",
  	percentages: "referToSizeOfContainingBlock",
  	groups: [
  		"CSS Motion Path"
  	],
  	initial: "auto",
  	appliesto: "transformableElements",
  	computed: "forLengthAbsoluteValueOtherwisePercentage",
  	order: "perGrammar",
  	status: "experimental"
  },
  	"offset-rotate": {
  	syntax: "[ auto | reverse ] || <angle>",
  	media: "visual",
  	inherited: false,
  	animationType: "angleOrBasicShapeOrPath",
  	percentages: "no",
  	groups: [
  		"CSS Motion Path"
  	],
  	initial: "auto",
  	appliesto: "transformableElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
  },
  	opacity: opacity,
  	order: order,
  	orphans: orphans,
  	outline: outline,
  	"outline-color": {
  	syntax: "<color> | invert",
  	media: [
  		"visual",
  		"interactive"
  	],
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "invertOrCurrentColor",
  	appliesto: "allElements",
  	computed: "invertForTranslucentColorRGBAOtherwiseRGB",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
  },
  	"outline-offset": {
  	syntax: "<length>",
  	media: [
  		"visual",
  		"interactive"
  	],
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
  },
  	"outline-style": {
  	syntax: "auto | <'border-style'>",
  	media: [
  		"visual",
  		"interactive"
  	],
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
  },
  	"outline-width": {
  	syntax: "<line-width>",
  	media: [
  		"visual",
  		"interactive"
  	],
  	inherited: false,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "medium",
  	appliesto: "allElements",
  	computed: "absoluteLength0ForNone",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
  },
  	overflow: overflow,
  	"overflow-anchor": {
  	syntax: "auto | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Anchoring"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard"
  },
  	"overflow-block": {
  	syntax: "visible | hidden | clip | scroll | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "auto",
  	appliesto: "blockContainersFlexContainersGridContainers",
  	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
  	order: "perGrammar",
  	status: "standard"
  },
  	"overflow-clip-box": {
  	syntax: "padding-box | content-box",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Mozilla Extensions"
  	],
  	initial: "padding-box",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "nonstandard",
  	mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
  },
  	"overflow-clip-margin": {
  	syntax: "<visual-box> || <length [0,∞]>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "0px",
  	appliesto: "allElements",
  	computed: "theComputedLength",
  	order: "perGrammar",
  	status: "standard"
  },
  	"overflow-inline": {
  	syntax: "visible | hidden | clip | scroll | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "auto",
  	appliesto: "blockContainersFlexContainersGridContainers",
  	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
  	order: "perGrammar",
  	status: "standard"
  },
  	"overflow-wrap": {
  	syntax: "normal | break-word | anywhere",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "normal",
  	appliesto: "nonReplacedInlineElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
  },
  	"overflow-x": {
  	syntax: "visible | hidden | clip | scroll | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "visible",
  	appliesto: "blockContainersFlexContainersGridContainers",
  	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
  },
  	"overflow-y": {
  	syntax: "visible | hidden | clip | scroll | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "visible",
  	appliesto: "blockContainersFlexContainersGridContainers",
  	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
  },
  	"overscroll-behavior": {
  	syntax: "[ contain | none | auto ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: [
  		"overscroll-behavior-x",
  		"overscroll-behavior-y"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
  },
  	"overscroll-behavior-block": {
  	syntax: "contain | none | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
  },
  	"overscroll-behavior-inline": {
  	syntax: "contain | none | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
  },
  	"overscroll-behavior-x": {
  	syntax: "contain | none | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
  },
  	"overscroll-behavior-y": {
  	syntax: "contain | none | auto",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "auto",
  	appliesto: "nonReplacedBlockAndInlineBlockElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
  },
  	padding: padding,
  	"padding-block": {
  	syntax: "<'padding-left'>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"padding-block-start",
  		"padding-block-end"
  	],
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: [
  		"padding-block-start",
  		"padding-block-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
  },
  	"padding-block-end": {
  	syntax: "<'padding-left'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: "asLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
  },
  	"padding-block-start": {
  	syntax: "<'padding-left'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: "asLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
  },
  	"padding-bottom": {
  	syntax: "<length> | <percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
  },
  	"padding-inline": {
  	syntax: "<'padding-left'>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: [
  		"padding-inline-start",
  		"padding-inline-end"
  	],
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: [
  		"padding-inline-start",
  		"padding-inline-end"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
  },
  	"padding-inline-end": {
  	syntax: "<'padding-left'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: "asLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
  },
  	"padding-inline-start": {
  	syntax: "<'padding-left'>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "logicalWidthOfContainingBlock",
  	groups: [
  		"CSS Logical Properties"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: "asLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
  },
  	"padding-left": {
  	syntax: "<length> | <percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
  },
  	"padding-right": {
  	syntax: "<length> | <percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
  },
  	"padding-top": {
  	syntax: "<length> | <percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Box Model"
  	],
  	initial: "0",
  	appliesto: "allElementsExceptInternalTableDisplayTypes",
  	computed: "percentageAsSpecifiedOrAbsoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
  },
  	"page-break-after": {
  	syntax: "auto | always | avoid | left | right | recto | verso",
  	media: [
  		"visual",
  		"paged"
  	],
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Pages"
  	],
  	initial: "auto",
  	appliesto: "blockElementsInNormalFlow",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
  },
  	"page-break-before": {
  	syntax: "auto | always | avoid | left | right | recto | verso",
  	media: [
  		"visual",
  		"paged"
  	],
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Pages"
  	],
  	initial: "auto",
  	appliesto: "blockElementsInNormalFlow",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
  },
  	"page-break-inside": {
  	syntax: "auto | avoid",
  	media: [
  		"visual",
  		"paged"
  	],
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Pages"
  	],
  	initial: "auto",
  	appliesto: "blockElementsInNormalFlow",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
  },
  	"paint-order": {
  	syntax: "normal | [ fill || stroke || markers ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "normal",
  	appliesto: "textElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
  },
  	perspective: perspective,
  	"perspective-origin": {
  	syntax: "<position>",
  	media: "visual",
  	inherited: false,
  	animationType: "simpleListOfLpc",
  	percentages: "referToSizeOfBoundingBox",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "50% 50%",
  	appliesto: "transformableElements",
  	computed: "forLengthAbsoluteValueOtherwisePercentage",
  	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
  },
  	"place-content": {
  	syntax: "<'align-content'> <'justify-content'>?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: [
  		"align-content",
  		"justify-content"
  	],
  	appliesto: "multilineFlexContainers",
  	computed: [
  		"align-content",
  		"justify-content"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
  },
  	"place-items": {
  	syntax: "<'align-items'> <'justify-items'>?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: [
  		"align-items",
  		"justify-items"
  	],
  	appliesto: "allElements",
  	computed: [
  		"align-items",
  		"justify-items"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
  },
  	"place-self": {
  	syntax: "<'align-self'> <'justify-self'>?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: [
  		"align-self",
  		"justify-self"
  	],
  	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
  	computed: [
  		"align-self",
  		"justify-self"
  	],
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
  },
  	"pointer-events": {
  	syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
  },
  	position: position$1,
  	quotes: quotes,
  	resize: resize,
  	right: right,
  	rotate: rotate,
  	"row-gap": {
  	syntax: "normal | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToDimensionOfContentArea",
  	groups: [
  		"CSS Box Alignment"
  	],
  	initial: "normal",
  	appliesto: "multiColumnElementsFlexContainersGridContainers",
  	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
  },
  	"ruby-align": {
  	syntax: "start | center | space-between | space-around",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Ruby"
  	],
  	initial: "space-around",
  	appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
  },
  	"ruby-merge": {
  	syntax: "separate | collapse | auto",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Ruby"
  	],
  	initial: "separate",
  	appliesto: "rubyAnnotationsContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental"
  },
  	"ruby-position": {
  	syntax: "[ alternate || [ over | under ] ] | inter-character",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Ruby"
  	],
  	initial: "alternate",
  	appliesto: "rubyAnnotationsContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
  },
  	scale: scale,
  	"scrollbar-color": {
  	syntax: "auto | <color>{2}",
  	media: "visual",
  	inherited: true,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Scrollbars"
  	],
  	initial: "auto",
  	appliesto: "scrollingBoxes",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
  },
  	"scrollbar-gutter": {
  	syntax: "auto | stable && both-edges?",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Overflow"
  	],
  	initial: "auto",
  	appliesto: "scrollingBoxes",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
  },
  	"scrollbar-width": {
  	syntax: "auto | thin | none",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Scrollbars"
  	],
  	initial: "auto",
  	appliesto: "scrollingBoxes",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
  },
  	"scroll-behavior": {
  	syntax: "auto | smooth",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSSOM View"
  	],
  	initial: "auto",
  	appliesto: "scrollingBoxes",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
  },
  	"scroll-margin": {
  	syntax: "<length>{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: [
  		"scroll-margin-bottom",
  		"scroll-margin-left",
  		"scroll-margin-right",
  		"scroll-margin-top"
  	],
  	appliesto: "allElements",
  	computed: [
  		"scroll-margin-bottom",
  		"scroll-margin-left",
  		"scroll-margin-right",
  		"scroll-margin-top"
  	],
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
  },
  	"scroll-margin-block": {
  	syntax: "<length>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: [
  		"scroll-margin-block-start",
  		"scroll-margin-block-end"
  	],
  	appliesto: "allElements",
  	computed: [
  		"scroll-margin-block-start",
  		"scroll-margin-block-end"
  	],
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
  },
  	"scroll-margin-block-start": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
  },
  	"scroll-margin-block-end": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
  },
  	"scroll-margin-bottom": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
  },
  	"scroll-margin-inline": {
  	syntax: "<length>{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: [
  		"scroll-margin-inline-start",
  		"scroll-margin-inline-end"
  	],
  	appliesto: "allElements",
  	computed: [
  		"scroll-margin-inline-start",
  		"scroll-margin-inline-end"
  	],
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
  },
  	"scroll-margin-inline-start": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
  },
  	"scroll-margin-inline-end": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
  },
  	"scroll-margin-left": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
  },
  	"scroll-margin-right": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
  },
  	"scroll-margin-top": {
  	syntax: "<length>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
  },
  	"scroll-padding": {
  	syntax: "[ auto | <length-percentage> ]{1,4}",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: [
  		"scroll-padding-bottom",
  		"scroll-padding-left",
  		"scroll-padding-right",
  		"scroll-padding-top"
  	],
  	appliesto: "scrollContainers",
  	computed: [
  		"scroll-padding-bottom",
  		"scroll-padding-left",
  		"scroll-padding-right",
  		"scroll-padding-top"
  	],
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
  },
  	"scroll-padding-block": {
  	syntax: "[ auto | <length-percentage> ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: [
  		"scroll-padding-block-start",
  		"scroll-padding-block-end"
  	],
  	appliesto: "scrollContainers",
  	computed: [
  		"scroll-padding-block-start",
  		"scroll-padding-block-end"
  	],
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
  },
  	"scroll-padding-block-start": {
  	syntax: "auto | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "auto",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
  },
  	"scroll-padding-block-end": {
  	syntax: "auto | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "auto",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
  },
  	"scroll-padding-bottom": {
  	syntax: "auto | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "auto",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
  },
  	"scroll-padding-inline": {
  	syntax: "[ auto | <length-percentage> ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: [
  		"scroll-padding-inline-start",
  		"scroll-padding-inline-end"
  	],
  	appliesto: "scrollContainers",
  	computed: [
  		"scroll-padding-inline-start",
  		"scroll-padding-inline-end"
  	],
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
  },
  	"scroll-padding-inline-start": {
  	syntax: "auto | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "auto",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
  },
  	"scroll-padding-inline-end": {
  	syntax: "auto | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "auto",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
  },
  	"scroll-padding-left": {
  	syntax: "auto | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "auto",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
  },
  	"scroll-padding-right": {
  	syntax: "auto | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "auto",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
  },
  	"scroll-padding-top": {
  	syntax: "auto | <length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "relativeToTheScrollContainersScrollport",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "auto",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
  },
  	"scroll-snap-align": {
  	syntax: "[ none | start | end | center ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
  },
  	"scroll-snap-coordinate": {
  	syntax: "none | <position>#",
  	media: "interactive",
  	inherited: false,
  	animationType: "position",
  	percentages: "referToBorderBox",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
  },
  	"scroll-snap-destination": {
  	syntax: "<position>",
  	media: "interactive",
  	inherited: false,
  	animationType: "position",
  	percentages: "relativeToScrollContainerPaddingBoxAxis",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "0px 0px",
  	appliesto: "scrollContainers",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
  },
  	"scroll-snap-points-x": {
  	syntax: "none | repeat( <length-percentage> )",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "relativeToScrollContainerPaddingBoxAxis",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "none",
  	appliesto: "scrollContainers",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
  },
  	"scroll-snap-points-y": {
  	syntax: "none | repeat( <length-percentage> )",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "relativeToScrollContainerPaddingBoxAxis",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "none",
  	appliesto: "scrollContainers",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
  },
  	"scroll-snap-stop": {
  	syntax: "normal | always",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
  },
  	"scroll-snap-type": {
  	syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
  },
  	"scroll-snap-type-x": {
  	syntax: "none | mandatory | proximity",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "none",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
  },
  	"scroll-snap-type-y": {
  	syntax: "none | mandatory | proximity",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Scroll Snap"
  	],
  	initial: "none",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "obsolete",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
  },
  	"scroll-timeline": {
  	syntax: "<scroll-timeline-name> || <scroll-timeline-axis>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"scroll-timeline-name",
  		"scroll-timeline-axis"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: [
  		"scroll-timeline-name",
  		"scroll-timeline-axis"
  	],
  	appliesto: "scrollContainers",
  	computed: [
  		"scroll-timeline-name",
  		"scroll-timeline-axis"
  	],
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline"
  },
  	"scroll-timeline-axis": {
  	syntax: "block | inline | vertical | horizontal",
  	media: "interactive",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "block",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-axis"
  },
  	"scroll-timeline-name": {
  	syntax: "none | <custom-ident>",
  	media: "interactive",
  	inherited: false,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Animations"
  	],
  	initial: "none",
  	appliesto: "scrollContainers",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-name"
  },
  	"shape-image-threshold": {
  	syntax: "<alpha-value>",
  	media: "visual",
  	inherited: false,
  	animationType: "number",
  	percentages: "no",
  	groups: [
  		"CSS Shapes"
  	],
  	initial: "0.0",
  	appliesto: "floats",
  	computed: "specifiedValueNumberClipped0To1",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
  },
  	"shape-margin": {
  	syntax: "<length-percentage>",
  	media: "visual",
  	inherited: false,
  	animationType: "lpc",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Shapes"
  	],
  	initial: "0",
  	appliesto: "floats",
  	computed: "asSpecifiedRelativeToAbsoluteLengths",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
  },
  	"shape-outside": {
  	syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
  	media: "visual",
  	inherited: false,
  	animationType: "basicShapeOtherwiseNo",
  	percentages: "no",
  	groups: [
  		"CSS Shapes"
  	],
  	initial: "none",
  	appliesto: "floats",
  	computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
  },
  	"tab-size": {
  	syntax: "<integer> | <length>",
  	media: "visual",
  	inherited: true,
  	animationType: "length",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "8",
  	appliesto: "blockContainers",
  	computed: "specifiedIntegerOrAbsoluteLength",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
  },
  	"table-layout": {
  	syntax: "auto | fixed",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Table"
  	],
  	initial: "auto",
  	appliesto: "tableElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
  },
  	"text-align": {
  	syntax: "start | end | left | right | center | justify | match-parent",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "startOrNamelessValueIfLTRRightIfRTL",
  	appliesto: "blockContainers",
  	computed: "asSpecifiedExceptMatchParent",
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
  },
  	"text-align-last": {
  	syntax: "auto | start | end | left | right | center | justify",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "auto",
  	appliesto: "blockContainers",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
  },
  	"text-combine-upright": {
  	syntax: "none | all | [ digits <integer>? ]",
  	media: "visual",
  	inherited: true,
  	animationType: "notAnimatable",
  	percentages: "no",
  	groups: [
  		"CSS Writing Modes"
  	],
  	initial: "none",
  	appliesto: "nonReplacedInlineElements",
  	computed: "keywordPlusIntegerIfDigits",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
  },
  	"text-decoration": {
  	syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"text-decoration-color",
  		"text-decoration-style",
  		"text-decoration-line",
  		"text-decoration-thickness"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: [
  		"text-decoration-color",
  		"text-decoration-style",
  		"text-decoration-line"
  	],
  	appliesto: "allElements",
  	computed: [
  		"text-decoration-line",
  		"text-decoration-style",
  		"text-decoration-color",
  		"text-decoration-thickness"
  	],
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
  },
  	"text-decoration-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
  },
  	"text-decoration-line": {
  	syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
  },
  	"text-decoration-skip": {
  	syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "objects",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
  },
  	"text-decoration-skip-ink": {
  	syntax: "auto | all | none",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
  },
  	"text-decoration-style": {
  	syntax: "solid | double | dotted | dashed | wavy",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "solid",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
  },
  	"text-decoration-thickness": {
  	syntax: "auto | from-font | <length> | <percentage> ",
  	media: "visual",
  	inherited: false,
  	animationType: "byComputedValueType",
  	percentages: "referToElementFontSize",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
  },
  	"text-emphasis": {
  	syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
  	media: "visual",
  	inherited: false,
  	animationType: [
  		"text-emphasis-color",
  		"text-emphasis-style"
  	],
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: [
  		"text-emphasis-style",
  		"text-emphasis-color"
  	],
  	appliesto: "allElements",
  	computed: [
  		"text-emphasis-style",
  		"text-emphasis-color"
  	],
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
  },
  	"text-emphasis-color": {
  	syntax: "<color>",
  	media: "visual",
  	inherited: false,
  	animationType: "color",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "currentcolor",
  	appliesto: "allElements",
  	computed: "computedColor",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
  },
  	"text-emphasis-position": {
  	syntax: "[ over | under ] && [ right | left ]",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "over right",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
  },
  	"text-emphasis-style": {
  	syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
  },
  	"text-indent": {
  	syntax: "<length-percentage> && hanging? && each-line?",
  	media: "visual",
  	inherited: true,
  	animationType: "lpc",
  	percentages: "referToWidthOfContainingBlock",
  	groups: [
  		"CSS Text"
  	],
  	initial: "0",
  	appliesto: "blockContainers",
  	computed: "percentageOrAbsoluteLengthPlusKeywords",
  	order: "lengthOrPercentageBeforeKeywords",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
  },
  	"text-justify": {
  	syntax: "auto | inter-character | inter-word | none",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "auto",
  	appliesto: "inlineLevelAndTableCellElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
  },
  	"text-orientation": {
  	syntax: "mixed | upright | sideways",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Writing Modes"
  	],
  	initial: "mixed",
  	appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
  },
  	"text-overflow": {
  	syntax: "[ clip | ellipsis | <string> ]{1,2}",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "clip",
  	appliesto: "blockContainerElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
  },
  	"text-rendering": {
  	syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Miscellaneous"
  	],
  	initial: "auto",
  	appliesto: "textElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
  },
  	"text-shadow": {
  	syntax: "none | <shadow-t>#",
  	media: "visual",
  	inherited: true,
  	animationType: "shadowList",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "colorPlusThreeAbsoluteLengths",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
  },
  	"text-size-adjust": {
  	syntax: "none | auto | <percentage>",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "referToSizeOfFont",
  	groups: [
  		"CSS Text"
  	],
  	initial: "autoForSmartphoneBrowsersSupportingInflation",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "experimental",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
  },
  	"text-transform": {
  	syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "none",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
  },
  	"text-underline-offset": {
  	syntax: "auto | <length> | <percentage> ",
  	media: "visual",
  	inherited: true,
  	animationType: "byComputedValueType",
  	percentages: "referToElementFontSize",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
  },
  	"text-underline-position": {
  	syntax: "auto | from-font | [ under || [ left | right ] ]",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text Decoration"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "orderOfAppearance",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
  },
  	top: top,
  	"touch-action": {
  	syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"Pointer Events"
  	],
  	initial: "auto",
  	appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
  },
  	transform: transform$1,
  	"transform-box": {
  	syntax: "content-box | border-box | fill-box | stroke-box | view-box",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "view-box",
  	appliesto: "transformableElements",
  	computed: "asSpecified",
  	order: "perGrammar",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
  },
  	"transform-origin": {
  	syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
  	media: "visual",
  	inherited: false,
  	animationType: "simpleListOfLpc",
  	percentages: "referToSizeOfBoundingBox",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "50% 50% 0",
  	appliesto: "transformableElements",
  	computed: "forLengthAbsoluteValueOtherwisePercentage",
  	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
  },
  	"transform-style": {
  	syntax: "flat | preserve-3d",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Transforms"
  	],
  	initial: "flat",
  	appliesto: "transformableElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
  },
  	transition: transition,
  	"transition-delay": {
  	syntax: "<time>#",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Transitions"
  	],
  	initial: "0s",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
  },
  	"transition-duration": {
  	syntax: "<time>#",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Transitions"
  	],
  	initial: "0s",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
  },
  	"transition-property": {
  	syntax: "none | <single-transition-property>#",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Transitions"
  	],
  	initial: "all",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
  },
  	"transition-timing-function": {
  	syntax: "<easing-function>#",
  	media: "interactive",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Transitions"
  	],
  	initial: "ease",
  	appliesto: "allElementsAndPseudos",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
  },
  	translate: translate,
  	"unicode-bidi": {
  	syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Writing Modes"
  	],
  	initial: "normal",
  	appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
  },
  	"user-select": {
  	syntax: "auto | text | none | contain | all",
  	media: "visual",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Basic User Interface"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
  },
  	"vertical-align": {
  	syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
  	media: "visual",
  	inherited: false,
  	animationType: "length",
  	percentages: "referToLineHeight",
  	groups: [
  		"CSS Table"
  	],
  	initial: "baseline",
  	appliesto: "inlineLevelAndTableCellElements",
  	computed: "absoluteLengthOrKeyword",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
  },
  	visibility: visibility,
  	"white-space": {
  	syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
  },
  	widows: widows,
  	width: width,
  	"will-change": {
  	syntax: "auto | <animateable-feature>#",
  	media: "all",
  	inherited: false,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Will Change"
  	],
  	initial: "auto",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
  },
  	"word-break": {
  	syntax: "normal | break-all | keep-all | break-word",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
  },
  	"word-spacing": {
  	syntax: "normal | <length>",
  	media: "visual",
  	inherited: true,
  	animationType: "length",
  	percentages: "referToWidthOfAffectedGlyph",
  	groups: [
  		"CSS Text"
  	],
  	initial: "normal",
  	appliesto: "allElements",
  	computed: "absoluteLength",
  	order: "uniqueOrder",
  	alsoAppliesTo: [
  		"::first-letter",
  		"::first-line",
  		"::placeholder"
  	],
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
  },
  	"word-wrap": {
  	syntax: "normal | break-word",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Text"
  	],
  	initial: "normal",
  	appliesto: "nonReplacedInlineElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
  },
  	"writing-mode": {
  	syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
  	media: "visual",
  	inherited: true,
  	animationType: "discrete",
  	percentages: "no",
  	groups: [
  		"CSS Writing Modes"
  	],
  	initial: "horizontal-tb",
  	appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
  },
  	"z-index": {
  	syntax: "auto | <integer>",
  	media: "visual",
  	inherited: false,
  	animationType: "integer",
  	percentages: "no",
  	groups: [
  		"CSS Positioning"
  	],
  	initial: "auto",
  	appliesto: "positionedElements",
  	computed: "asSpecified",
  	order: "uniqueOrder",
  	stacking: true,
  	status: "standard",
  	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
  },
  	zoom: zoom
  };

  var attachment = {
  	syntax: "scroll | fixed | local"
  };
  var axis = {
  	syntax: "block | inline | vertical | horizontal"
  };
  var box = {
  	syntax: "border-box | padding-box | content-box"
  };
  var color = {
  	syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
  };
  var combinator$1 = {
  	syntax: "'>' | '+' | '~' | [ '||' ]"
  };
  var counter = {
  	syntax: "<counter()> | <counters()>"
  };
  var gradient = {
  	syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"
  };
  var hue = {
  	syntax: "<number> | <angle>"
  };
  var image = {
  	syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
  };
  var nth$1 = {
  	syntax: "<an-plus-b> | even | odd"
  };
  var position = {
  	syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
  };
  var quote = {
  	syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
  };
  var ratio = {
  	syntax: "<number [0,∞]> [ / <number [0,∞]> ]?"
  };
  var scroller = {
  	syntax: "root | nearest"
  };
  var shadow = {
  	syntax: "inset? && <length>{2,4} && <color>?"
  };
  var shape = {
  	syntax: "rect(<top>, <right>, <bottom>, <left>)"
  };
  var size = {
  	syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
  };
  var symbol = {
  	syntax: "<string> | <image> | <custom-ident>"
  };
  var target = {
  	syntax: "<target-counter()> | <target-counters()> | <target-text()>"
  };
  var mdnSyntaxes = {
  	"abs()": {
  	syntax: "abs( <calc-sum> )"
  },
  	"absolute-size": {
  	syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
  },
  	"acos()": {
  	syntax: "acos( <calc-sum> )"
  },
  	"alpha-value": {
  	syntax: "<number> | <percentage>"
  },
  	"angle-percentage": {
  	syntax: "<angle> | <percentage>"
  },
  	"angular-color-hint": {
  	syntax: "<angle-percentage>"
  },
  	"angular-color-stop": {
  	syntax: "<color> && <color-stop-angle>?"
  },
  	"angular-color-stop-list": {
  	syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
  },
  	"animateable-feature": {
  	syntax: "scroll-position | contents | <custom-ident>"
  },
  	"asin()": {
  	syntax: "asin( <calc-sum> )"
  },
  	"atan()": {
  	syntax: "atan( <calc-sum> )"
  },
  	"atan2()": {
  	syntax: "atan2( <calc-sum>, <calc-sum> )"
  },
  	attachment: attachment,
  	"attr()": {
  	syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
  },
  	"attr-matcher": {
  	syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
  },
  	"attr-modifier": {
  	syntax: "i | s"
  },
  	"attribute-selector": {
  	syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
  },
  	"auto-repeat": {
  	syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
  },
  	"auto-track-list": {
  	syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
  },
  	axis: axis,
  	"baseline-position": {
  	syntax: "[ first | last ]? baseline"
  },
  	"basic-shape": {
  	syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
  },
  	"bg-image": {
  	syntax: "none | <image>"
  },
  	"bg-layer": {
  	syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
  },
  	"bg-position": {
  	syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
  },
  	"bg-size": {
  	syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
  },
  	"blur()": {
  	syntax: "blur( <length> )"
  },
  	"blend-mode": {
  	syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
  },
  	box: box,
  	"brightness()": {
  	syntax: "brightness( <number-percentage> )"
  },
  	"calc()": {
  	syntax: "calc( <calc-sum> )"
  },
  	"calc-sum": {
  	syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
  },
  	"calc-product": {
  	syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
  },
  	"calc-value": {
  	syntax: "<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )"
  },
  	"calc-constant": {
  	syntax: "e | pi | infinity | -infinity | NaN"
  },
  	"cf-final-image": {
  	syntax: "<image> | <color>"
  },
  	"cf-mixing-image": {
  	syntax: "<percentage>? && <image>"
  },
  	"circle()": {
  	syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
  },
  	"clamp()": {
  	syntax: "clamp( <calc-sum>#{3} )"
  },
  	"class-selector": {
  	syntax: "'.' <ident-token>"
  },
  	"clip-source": {
  	syntax: "<url>"
  },
  	color: color,
  	"color-stop": {
  	syntax: "<color-stop-length> | <color-stop-angle>"
  },
  	"color-stop-angle": {
  	syntax: "<angle-percentage>{1,2}"
  },
  	"color-stop-length": {
  	syntax: "<length-percentage>{1,2}"
  },
  	"color-stop-list": {
  	syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
  },
  	combinator: combinator$1,
  	"common-lig-values": {
  	syntax: "[ common-ligatures | no-common-ligatures ]"
  },
  	"compat-auto": {
  	syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
  },
  	"composite-style": {
  	syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
  },
  	"compositing-operator": {
  	syntax: "add | subtract | intersect | exclude"
  },
  	"compound-selector": {
  	syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
  },
  	"compound-selector-list": {
  	syntax: "<compound-selector>#"
  },
  	"complex-selector": {
  	syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
  },
  	"complex-selector-list": {
  	syntax: "<complex-selector>#"
  },
  	"conic-gradient()": {
  	syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
  },
  	"contextual-alt-values": {
  	syntax: "[ contextual | no-contextual ]"
  },
  	"content-distribution": {
  	syntax: "space-between | space-around | space-evenly | stretch"
  },
  	"content-list": {
  	syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"
  },
  	"content-position": {
  	syntax: "center | start | end | flex-start | flex-end"
  },
  	"content-replacement": {
  	syntax: "<image>"
  },
  	"contrast()": {
  	syntax: "contrast( [ <number-percentage> ] )"
  },
  	"cos()": {
  	syntax: "cos( <calc-sum> )"
  },
  	counter: counter,
  	"counter()": {
  	syntax: "counter( <counter-name>, <counter-style>? )"
  },
  	"counter-name": {
  	syntax: "<custom-ident>"
  },
  	"counter-style": {
  	syntax: "<counter-style-name> | symbols()"
  },
  	"counter-style-name": {
  	syntax: "<custom-ident>"
  },
  	"counters()": {
  	syntax: "counters( <counter-name>, <string>, <counter-style>? )"
  },
  	"cross-fade()": {
  	syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
  },
  	"cubic-bezier-timing-function": {
  	syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
  },
  	"deprecated-system-color": {
  	syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
  },
  	"discretionary-lig-values": {
  	syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
  },
  	"display-box": {
  	syntax: "contents | none"
  },
  	"display-inside": {
  	syntax: "flow | flow-root | table | flex | grid | ruby"
  },
  	"display-internal": {
  	syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
  },
  	"display-legacy": {
  	syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
  },
  	"display-listitem": {
  	syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
  },
  	"display-outside": {
  	syntax: "block | inline | run-in"
  },
  	"drop-shadow()": {
  	syntax: "drop-shadow( <length>{2,3} <color>? )"
  },
  	"east-asian-variant-values": {
  	syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
  },
  	"east-asian-width-values": {
  	syntax: "[ full-width | proportional-width ]"
  },
  	"element()": {
  	syntax: "element( <id-selector> )"
  },
  	"ellipse()": {
  	syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
  },
  	"ending-shape": {
  	syntax: "circle | ellipse"
  },
  	"env()": {
  	syntax: "env( <custom-ident> , <declaration-value>? )"
  },
  	"exp()": {
  	syntax: "exp( <calc-sum> )"
  },
  	"explicit-track-list": {
  	syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
  },
  	"family-name": {
  	syntax: "<string> | <custom-ident>+"
  },
  	"feature-tag-value": {
  	syntax: "<string> [ <integer> | on | off ]?"
  },
  	"feature-type": {
  	syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
  },
  	"feature-value-block": {
  	syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
  },
  	"feature-value-block-list": {
  	syntax: "<feature-value-block>+"
  },
  	"feature-value-declaration": {
  	syntax: "<custom-ident>: <integer>+;"
  },
  	"feature-value-declaration-list": {
  	syntax: "<feature-value-declaration>"
  },
  	"feature-value-name": {
  	syntax: "<custom-ident>"
  },
  	"fill-rule": {
  	syntax: "nonzero | evenodd"
  },
  	"filter-function": {
  	syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
  },
  	"filter-function-list": {
  	syntax: "[ <filter-function> | <url> ]+"
  },
  	"final-bg-layer": {
  	syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
  },
  	"fixed-breadth": {
  	syntax: "<length-percentage>"
  },
  	"fixed-repeat": {
  	syntax: "repeat( [ <integer [1,∞]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
  },
  	"fixed-size": {
  	syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
  },
  	"font-stretch-absolute": {
  	syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
  },
  	"font-variant-css21": {
  	syntax: "[ normal | small-caps ]"
  },
  	"font-weight-absolute": {
  	syntax: "normal | bold | <number [1,1000]>"
  },
  	"frequency-percentage": {
  	syntax: "<frequency> | <percentage>"
  },
  	"general-enclosed": {
  	syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
  },
  	"generic-family": {
  	syntax: "serif | sans-serif | cursive | fantasy | monospace"
  },
  	"generic-name": {
  	syntax: "serif | sans-serif | cursive | fantasy | monospace"
  },
  	"geometry-box": {
  	syntax: "<shape-box> | fill-box | stroke-box | view-box"
  },
  	gradient: gradient,
  	"grayscale()": {
  	syntax: "grayscale( <number-percentage> )"
  },
  	"grid-line": {
  	syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
  },
  	"historical-lig-values": {
  	syntax: "[ historical-ligatures | no-historical-ligatures ]"
  },
  	"hsl()": {
  	syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
  },
  	"hsla()": {
  	syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
  },
  	hue: hue,
  	"hue-rotate()": {
  	syntax: "hue-rotate( <angle> )"
  },
  	"hwb()": {
  	syntax: "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"
  },
  	"hypot()": {
  	syntax: "hypot( <calc-sum># )"
  },
  	"id-selector": {
  	syntax: "<hash-token>"
  },
  	image: image,
  	"image()": {
  	syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
  },
  	"image-set()": {
  	syntax: "image-set( <image-set-option># )"
  },
  	"image-set-option": {
  	syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
  },
  	"image-src": {
  	syntax: "<url> | <string>"
  },
  	"image-tags": {
  	syntax: "ltr | rtl"
  },
  	"inflexible-breadth": {
  	syntax: "<length-percentage> | min-content | max-content | auto"
  },
  	"inset()": {
  	syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
  },
  	"invert()": {
  	syntax: "invert( <number-percentage> )"
  },
  	"keyframes-name": {
  	syntax: "<custom-ident> | <string>"
  },
  	"keyframe-block": {
  	syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
  },
  	"keyframe-block-list": {
  	syntax: "<keyframe-block>+"
  },
  	"keyframe-selector": {
  	syntax: "from | to | <percentage>"
  },
  	"lab()": {
  	syntax: "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
  },
  	"layer()": {
  	syntax: "layer( <layer-name> )"
  },
  	"layer-name": {
  	syntax: "<ident> [ '.' <ident> ]*"
  },
  	"lch()": {
  	syntax: "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
  },
  	"leader()": {
  	syntax: "leader( <leader-type> )"
  },
  	"leader-type": {
  	syntax: "dotted | solid | space | <string>"
  },
  	"length-percentage": {
  	syntax: "<length> | <percentage>"
  },
  	"line-names": {
  	syntax: "'[' <custom-ident>* ']'"
  },
  	"line-name-list": {
  	syntax: "[ <line-names> | <name-repeat> ]+"
  },
  	"line-style": {
  	syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
  },
  	"line-width": {
  	syntax: "<length> | thin | medium | thick"
  },
  	"linear-color-hint": {
  	syntax: "<length-percentage>"
  },
  	"linear-color-stop": {
  	syntax: "<color> <color-stop-length>?"
  },
  	"linear-gradient()": {
  	syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
  },
  	"log()": {
  	syntax: "log( <calc-sum>, <calc-sum>? )"
  },
  	"mask-layer": {
  	syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
  },
  	"mask-position": {
  	syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
  },
  	"mask-reference": {
  	syntax: "none | <image> | <mask-source>"
  },
  	"mask-source": {
  	syntax: "<url>"
  },
  	"masking-mode": {
  	syntax: "alpha | luminance | match-source"
  },
  	"matrix()": {
  	syntax: "matrix( <number>#{6} )"
  },
  	"matrix3d()": {
  	syntax: "matrix3d( <number>#{16} )"
  },
  	"max()": {
  	syntax: "max( <calc-sum># )"
  },
  	"media-and": {
  	syntax: "<media-in-parens> [ and <media-in-parens> ]+"
  },
  	"media-condition": {
  	syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
  },
  	"media-condition-without-or": {
  	syntax: "<media-not> | <media-and> | <media-in-parens>"
  },
  	"media-feature": {
  	syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
  },
  	"media-in-parens": {
  	syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
  },
  	"media-not": {
  	syntax: "not <media-in-parens>"
  },
  	"media-or": {
  	syntax: "<media-in-parens> [ or <media-in-parens> ]+"
  },
  	"media-query": {
  	syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
  },
  	"media-query-list": {
  	syntax: "<media-query>#"
  },
  	"media-type": {
  	syntax: "<ident>"
  },
  	"mf-boolean": {
  	syntax: "<mf-name>"
  },
  	"mf-name": {
  	syntax: "<ident>"
  },
  	"mf-plain": {
  	syntax: "<mf-name> : <mf-value>"
  },
  	"mf-range": {
  	syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
  },
  	"mf-value": {
  	syntax: "<number> | <dimension> | <ident> | <ratio>"
  },
  	"min()": {
  	syntax: "min( <calc-sum># )"
  },
  	"minmax()": {
  	syntax: "minmax( [ <length-percentage> | min-content | max-content | auto ] , [ <length-percentage> | <flex> | min-content | max-content | auto ] )"
  },
  	"mod()": {
  	syntax: "mod( <calc-sum>, <calc-sum> )"
  },
  	"name-repeat": {
  	syntax: "repeat( [ <integer [1,∞]> | auto-fill ], <line-names>+ )"
  },
  	"named-color": {
  	syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
  },
  	"namespace-prefix": {
  	syntax: "<ident>"
  },
  	"ns-prefix": {
  	syntax: "[ <ident-token> | '*' ]? '|'"
  },
  	"number-percentage": {
  	syntax: "<number> | <percentage>"
  },
  	"numeric-figure-values": {
  	syntax: "[ lining-nums | oldstyle-nums ]"
  },
  	"numeric-fraction-values": {
  	syntax: "[ diagonal-fractions | stacked-fractions ]"
  },
  	"numeric-spacing-values": {
  	syntax: "[ proportional-nums | tabular-nums ]"
  },
  	nth: nth$1,
  	"opacity()": {
  	syntax: "opacity( [ <number-percentage> ] )"
  },
  	"overflow-position": {
  	syntax: "unsafe | safe"
  },
  	"outline-radius": {
  	syntax: "<length> | <percentage>"
  },
  	"page-body": {
  	syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
  },
  	"page-margin-box": {
  	syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
  },
  	"page-margin-box-type": {
  	syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
  },
  	"page-selector-list": {
  	syntax: "[ <page-selector># ]?"
  },
  	"page-selector": {
  	syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
  },
  	"page-size": {
  	syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
  },
  	"path()": {
  	syntax: "path( [ <fill-rule>, ]? <string> )"
  },
  	"paint()": {
  	syntax: "paint( <ident>, <declaration-value>? )"
  },
  	"perspective()": {
  	syntax: "perspective( [ <length [0,∞]> | none ] )"
  },
  	"polygon()": {
  	syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
  },
  	position: position,
  	"pow()": {
  	syntax: "pow( <calc-sum>, <calc-sum> )"
  },
  	"pseudo-class-selector": {
  	syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
  },
  	"pseudo-element-selector": {
  	syntax: "':' <pseudo-class-selector>"
  },
  	"pseudo-page": {
  	syntax: ": [ left | right | first | blank ]"
  },
  	quote: quote,
  	"radial-gradient()": {
  	syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
  },
  	ratio: ratio,
  	"relative-selector": {
  	syntax: "<combinator>? <complex-selector>"
  },
  	"relative-selector-list": {
  	syntax: "<relative-selector>#"
  },
  	"relative-size": {
  	syntax: "larger | smaller"
  },
  	"rem()": {
  	syntax: "rem( <calc-sum>, <calc-sum> )"
  },
  	"repeat-style": {
  	syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
  },
  	"repeating-conic-gradient()": {
  	syntax: "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
  },
  	"repeating-linear-gradient()": {
  	syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
  },
  	"repeating-radial-gradient()": {
  	syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
  },
  	"reversed-counter-name": {
  	syntax: "reversed( <counter-name> )"
  },
  	"rgb()": {
  	syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
  },
  	"rgba()": {
  	syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
  },
  	"rotate()": {
  	syntax: "rotate( [ <angle> | <zero> ] )"
  },
  	"rotate3d()": {
  	syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
  },
  	"rotateX()": {
  	syntax: "rotateX( [ <angle> | <zero> ] )"
  },
  	"rotateY()": {
  	syntax: "rotateY( [ <angle> | <zero> ] )"
  },
  	"rotateZ()": {
  	syntax: "rotateZ( [ <angle> | <zero> ] )"
  },
  	"round()": {
  	syntax: "round( <rounding-strategy>?, <calc-sum>, <calc-sum> )"
  },
  	"rounding-strategy": {
  	syntax: "nearest | up | down | to-zero"
  },
  	"saturate()": {
  	syntax: "saturate( <number-percentage> )"
  },
  	"scale()": {
  	syntax: "scale( [ <number> | <percentage> ]#{1,2} )"
  },
  	"scale3d()": {
  	syntax: "scale3d( [ <number> | <percentage> ]#{3} )"
  },
  	"scaleX()": {
  	syntax: "scaleX( [ <number> | <percentage> ] )"
  },
  	"scaleY()": {
  	syntax: "scaleY( [ <number> | <percentage> ] )"
  },
  	"scaleZ()": {
  	syntax: "scaleZ( [ <number> | <percentage> ] )"
  },
  	scroller: scroller,
  	"self-position": {
  	syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
  },
  	"shape-radius": {
  	syntax: "<length-percentage> | closest-side | farthest-side"
  },
  	"sign()": {
  	syntax: "sign( <calc-sum> )"
  },
  	"skew()": {
  	syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
  },
  	"skewX()": {
  	syntax: "skewX( [ <angle> | <zero> ] )"
  },
  	"skewY()": {
  	syntax: "skewY( [ <angle> | <zero> ] )"
  },
  	"sepia()": {
  	syntax: "sepia( <number-percentage> )"
  },
  	shadow: shadow,
  	"shadow-t": {
  	syntax: "[ <length>{2,3} && <color>? ]"
  },
  	shape: shape,
  	"shape-box": {
  	syntax: "<box> | margin-box"
  },
  	"side-or-corner": {
  	syntax: "[ left | right ] || [ top | bottom ]"
  },
  	"sin()": {
  	syntax: "sin( <calc-sum> )"
  },
  	"single-animation": {
  	syntax: "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
  },
  	"single-animation-direction": {
  	syntax: "normal | reverse | alternate | alternate-reverse"
  },
  	"single-animation-fill-mode": {
  	syntax: "none | forwards | backwards | both"
  },
  	"single-animation-iteration-count": {
  	syntax: "infinite | <number>"
  },
  	"single-animation-play-state": {
  	syntax: "running | paused"
  },
  	"single-animation-timeline": {
  	syntax: "auto | none | <timeline-name> | scroll(<axis>? <scroller>?)"
  },
  	"single-transition": {
  	syntax: "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"
  },
  	"single-transition-property": {
  	syntax: "all | <custom-ident>"
  },
  	size: size,
  	"sqrt()": {
  	syntax: "sqrt( <calc-sum> )"
  },
  	"step-position": {
  	syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
  },
  	"step-timing-function": {
  	syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
  },
  	"subclass-selector": {
  	syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
  },
  	"supports-condition": {
  	syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
  },
  	"supports-in-parens": {
  	syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
  },
  	"supports-feature": {
  	syntax: "<supports-decl> | <supports-selector-fn>"
  },
  	"supports-decl": {
  	syntax: "( <declaration> )"
  },
  	"supports-selector-fn": {
  	syntax: "selector( <complex-selector> )"
  },
  	symbol: symbol,
  	"tan()": {
  	syntax: "tan( <calc-sum> )"
  },
  	target: target,
  	"target-counter()": {
  	syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
  },
  	"target-counters()": {
  	syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
  },
  	"target-text()": {
  	syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
  },
  	"time-percentage": {
  	syntax: "<time> | <percentage>"
  },
  	"timeline-name": {
  	syntax: "<custom-ident> | <string>"
  },
  	"easing-function": {
  	syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
  },
  	"track-breadth": {
  	syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
  },
  	"track-list": {
  	syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
  },
  	"track-repeat": {
  	syntax: "repeat( [ <integer [1,∞]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
  },
  	"track-size": {
  	syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage> )"
  },
  	"transform-function": {
  	syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
  },
  	"transform-list": {
  	syntax: "<transform-function>+"
  },
  	"translate()": {
  	syntax: "translate( <length-percentage> , <length-percentage>? )"
  },
  	"translate3d()": {
  	syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
  },
  	"translateX()": {
  	syntax: "translateX( <length-percentage> )"
  },
  	"translateY()": {
  	syntax: "translateY( <length-percentage> )"
  },
  	"translateZ()": {
  	syntax: "translateZ( <length> )"
  },
  	"type-or-unit": {
  	syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
  },
  	"type-selector": {
  	syntax: "<wq-name> | <ns-prefix>? '*'"
  },
  	"var()": {
  	syntax: "var( <custom-property-name> , <declaration-value>? )"
  },
  	"viewport-length": {
  	syntax: "auto | <length-percentage>"
  },
  	"visual-box": {
  	syntax: "content-box | padding-box | border-box"
  },
  	"wq-name": {
  	syntax: "<ns-prefix>? <ident-token>"
  }
  };

  const extendSyntax = /^\s*\|\s*/;

  function preprocessAtrules(dict) {
    const result = Object.create(null);

    for (const atruleName in dict) {
      const atrule = dict[atruleName];
      let descriptors = null;

      if (atrule.descriptors) {
        descriptors = Object.create(null);

        for (const descriptor in atrule.descriptors) {
          descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
        }
      }

      result[atruleName.substr(1)] = {
        prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, '').match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
        descriptors
      };
    }

    return result;
  }

  function patchDictionary(dict, patchDict) {
    const result = {}; // copy all syntaxes for an original dict

    for (const key in dict) {
      result[key] = dict[key].syntax || dict[key];
    } // apply a patch


    for (const key in patchDict) {
      if (key in dict) {
        if (patchDict[key].syntax) {
          result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + ' ' + patchDict[key].syntax.trim() : patchDict[key].syntax;
        } else {
          delete result[key];
        }
      } else {
        if (patchDict[key].syntax) {
          result[key] = patchDict[key].syntax.replace(extendSyntax, '');
        }
      }
    }

    return result;
  }

  function patchAtrules(dict, patchDict) {
    const result = {}; // copy all syntaxes for an original dict

    for (const key in dict) {
      const atrulePatch = patchDict[key] || {};
      result[key] = {
        prelude: key in patchDict && 'prelude' in atrulePatch ? atrulePatch.prelude : dict[key].prelude || null,
        descriptors: patchDictionary(dict[key].descriptors || {}, atrulePatch.descriptors || {})
      };
    } // apply a patch


    for (const key in patchDict) {
      if (!hasOwnProperty.call(dict, key)) {
        const atrulePatch = patchDict[key] || {};
        result[key] = {
          prelude: atrulePatch.prelude || null,
          descriptors: atrulePatch.descriptors && patchDictionary({}, atrulePatch.descriptors)
        };
      }
    }

    return result;
  }

  const definitions = {
    types: patchDictionary(mdnSyntaxes, dataPatch.types),
    atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
    properties: patchDictionary(mdnProperties, dataPatch.properties)
  };
  var data = definitions;

  const PLUSSIGN$5 = 0x002B; // U+002B PLUS SIGN (+)

  const HYPHENMINUS$2 = 0x002D; // U+002D HYPHEN-MINUS (-)

  const N$1 = 0x006E; // U+006E LATIN SMALL LETTER N (n)

  const DISALLOW_SIGN = true;
  const ALLOW_SIGN = false;

  function checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code = this.charCodeAt(pos);

    if (code === PLUSSIGN$5 || code === HYPHENMINUS$2) {
      if (disallowSign) {
        this.error('Number sign is not allowed');
      }

      pos++;
    }

    for (; pos < this.tokenEnd; pos++) {
      if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
        this.error('Integer is expected', pos);
      }
    }
  }

  function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
  }

  function expectCharCode(offset, code) {
    if (!this.cmpChar(this.tokenStart + offset, code)) {
      let msg = '';

      switch (code) {
        case N$1:
          msg = 'N is expected';
          break;

        case HYPHENMINUS$2:
          msg = 'HyphenMinus is expected';
          break;
      }

      this.error(msg, this.tokenStart + offset);
    }
  } // ... <signed-integer>
  // ... ['+' | '-'] <signless-integer>


  function consumeB() {
    let offset = 0;
    let sign = 0;
    let type = this.tokenType;

    while (type === types$4.WhiteSpace || type === types$4.Comment) {
      type = this.lookupType(++offset);
    }

    if (type !== types$4.Number) {
      if (this.isDelim(PLUSSIGN$5, offset) || this.isDelim(HYPHENMINUS$2, offset)) {
        sign = this.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;

        do {
          type = this.lookupType(++offset);
        } while (type === types$4.WhiteSpace || type === types$4.Comment);

        if (type !== types$4.Number) {
          this.skip(offset);
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
        }
      } else {
        return null;
      }
    }

    if (offset > 0) {
      this.skip(offset);
    }

    if (sign === 0) {
      type = this.charCodeAt(this.tokenStart);

      if (type !== PLUSSIGN$5 && type !== HYPHENMINUS$2) {
        this.error('Number sign is expected');
      }
    }

    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS$2 ? '-' + this.consume(types$4.Number) : this.consume(types$4.Number);
  } // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb


  const name$G = 'AnPlusB';
  const structure$E = {
    a: [String, null],
    b: [String, null]
  };

  function parse$S() {
    /* eslint-disable brace-style*/
    const start = this.tokenStart;
    let a = null;
    let b = null; // <integer>

    if (this.tokenType === types$4.Number) {
      checkTokenIsInteger.call(this, ALLOW_SIGN);
      b = this.consume(types$4.Number);
    } // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (this.tokenType === types$4.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$2)) {
        a = '-1';
        expectCharCode.call(this, 1, N$1);

        switch (this.tokenEnd - this.tokenStart) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            this.next();
            b = consumeB.call(this);
            break;
          // -n- <signless-integer>

          case 3:
            expectCharCode.call(this, 2, HYPHENMINUS$2);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = '-' + this.consume(types$4.Number);
            break;
          // <dashndashdigit-ident>

          default:
            expectCharCode.call(this, 2, HYPHENMINUS$2);
            checkInteger.call(this, 3, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + 2);
        }
      } // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      // '+'? n- <signless-integer>
      // '+'? <ndashdigit-ident>
      else if (this.tokenType === types$4.Ident || this.isDelim(PLUSSIGN$5) && this.lookupType(1) === types$4.Ident) {
          let sign = 0;
          a = '1'; // just ignore a plus

          if (this.isDelim(PLUSSIGN$5)) {
            sign = 1;
            this.next();
          }

          expectCharCode.call(this, 0, N$1);

          switch (this.tokenEnd - this.tokenStart) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
              this.next();
              b = consumeB.call(this);
              break;
            // '+'? n- <signless-integer>

            case 2:
              expectCharCode.call(this, 1, HYPHENMINUS$2);
              this.next();
              this.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = '-' + this.consume(types$4.Number);
              break;
            // '+'? <ndashdigit-ident>

            default:
              expectCharCode.call(this, 1, HYPHENMINUS$2);
              checkInteger.call(this, 2, DISALLOW_SIGN);
              this.next();
              b = this.substrToCursor(start + sign + 1);
          }
        } // <ndashdigit-dimension>
        // <ndash-dimension> <signless-integer>
        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        else if (this.tokenType === types$4.Dimension) {
            const code = this.charCodeAt(this.tokenStart);
            const sign = code === PLUSSIGN$5 || code === HYPHENMINUS$2;
            let i = this.tokenStart + sign;

            for (; i < this.tokenEnd; i++) {
              if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
                break;
              }
            }

            if (i === this.tokenStart + sign) {
              this.error('Integer is expected', this.tokenStart + sign);
            }

            expectCharCode.call(this, i - this.tokenStart, N$1);
            a = this.substring(start, i); // <n-dimension>
            // <n-dimension> <signed-integer>
            // <n-dimension> ['+' | '-'] <signless-integer>

            if (i + 1 === this.tokenEnd) {
              this.next();
              b = consumeB.call(this);
            } else {
              expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS$2); // <ndash-dimension> <signless-integer>

              if (i + 2 === this.tokenEnd) {
                this.next();
                this.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = '-' + this.consume(types$4.Number);
              } // <ndashdigit-dimension>
              else {
                  checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
                  this.next();
                  b = this.substrToCursor(i + 1);
                }
            }
          } else {
            this.error();
          }

    if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
      a = a.substr(1);
    }

    if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
      b = b.substr(1);
    }

    return {
      type: 'AnPlusB',
      loc: this.getLocation(start, this.tokenStart),
      a,
      b
    };
  }

  function generate$F(node) {
    if (node.a) {
      const a = node.a === '+1' && 'n' || node.a === '1' && 'n' || node.a === '-1' && '-n' || node.a + 'n';

      if (node.b) {
        const b = node.b[0] === '-' || node.b[0] === '+' ? node.b : '+' + node.b;
        this.tokenize(a + b);
      } else {
        this.tokenize(a);
      }
    } else {
      this.tokenize(node.b);
    }
  }

  var generate_1$G = generate$F;
  var name_1$E = name$G;
  var parse_1$M = parse$S;
  var structure_1$E = structure$E;

  var AnPlusB = {
  	generate: generate_1$G,
  	name: name_1$E,
  	parse: parse_1$M,
  	structure: structure_1$E
  };

  function consumeRaw$5(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
  }

  function isDeclarationBlockAtrule() {
    for (let offset = 1, type; type = this.lookupType(offset); offset++) {
      if (type === types$4.RightCurlyBracket) {
        return true;
      }

      if (type === types$4.LeftCurlyBracket || type === types$4.AtKeyword) {
        return false;
      }
    }

    return false;
  }

  const name$F = 'Atrule';
  const walkContext$9 = 'atrule';
  const structure$D = {
    name: String,
    prelude: ['AtrulePrelude', 'Raw', null],
    block: ['Block', null]
  };

  function parse$R(isDeclaration = false) {
    const start = this.tokenStart;
    let name;
    let nameLowerCase;
    let prelude = null;
    let block = null;
    this.eat(types$4.AtKeyword);
    name = this.substrToCursor(start + 1);
    nameLowerCase = name.toLowerCase();
    this.skipSC(); // parse prelude

    if (this.eof === false && this.tokenType !== types$4.LeftCurlyBracket && this.tokenType !== types$4.Semicolon) {
      if (this.parseAtrulePrelude) {
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name, isDeclaration), consumeRaw$5);
      } else {
        prelude = consumeRaw$5.call(this, this.tokenIndex);
      }

      this.skipSC();
    }

    switch (this.tokenType) {
      case types$4.Semicolon:
        this.next();
        break;

      case types$4.LeftCurlyBracket:
        if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === 'function') {
          block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
        } else {
          // TODO: should consume block content as Raw?
          block = this.Block(isDeclarationBlockAtrule.call(this));
        }

        break;
    }

    return {
      type: 'Atrule',
      loc: this.getLocation(start, this.tokenStart),
      name,
      prelude,
      block
    };
  }

  function generate$E(node) {
    this.token(types$4.AtKeyword, '@' + node.name);

    if (node.prelude !== null) {
      this.node(node.prelude);
    }

    if (node.block) {
      this.node(node.block);
    } else {
      this.token(types$4.Semicolon, ';');
    }
  }

  var generate_1$F = generate$E;
  var name_1$D = name$F;
  var parse_1$L = parse$R;
  var structure_1$D = structure$D;
  var walkContext_1$9 = walkContext$9;

  var Atrule = {
  	generate: generate_1$F,
  	name: name_1$D,
  	parse: parse_1$L,
  	structure: structure_1$D,
  	walkContext: walkContext_1$9
  };

  const name$E = 'AtrulePrelude';
  const walkContext$8 = 'atrulePrelude';
  const structure$C = {
    children: [[]]
  };

  function parse$Q(name) {
    let children = null;

    if (name !== null) {
      name = name.toLowerCase();
    }

    this.skipSC();

    if (hasOwnProperty.call(this.atrule, name) && typeof this.atrule[name].prelude === 'function') {
      // custom consumer
      children = this.atrule[name].prelude.call(this);
    } else {
      // default consumer
      children = this.readSequence(this.scope.AtrulePrelude);
    }

    this.skipSC();

    if (this.eof !== true && this.tokenType !== types$4.LeftCurlyBracket && this.tokenType !== types$4.Semicolon) {
      this.error('Semicolon or block is expected');
    }

    return {
      type: 'AtrulePrelude',
      loc: this.getLocationFromList(children),
      children
    };
  }

  function generate$D(node) {
    this.children(node);
  }

  var generate_1$E = generate$D;
  var name_1$C = name$E;
  var parse_1$K = parse$Q;
  var structure_1$C = structure$C;
  var walkContext_1$8 = walkContext$8;

  var AtrulePrelude$1 = {
  	generate: generate_1$E,
  	name: name_1$C,
  	parse: parse_1$K,
  	structure: structure_1$C,
  	walkContext: walkContext_1$8
  };

  const DOLLARSIGN$1 = 0x0024; // U+0024 DOLLAR SIGN ($)

  const ASTERISK$6 = 0x002A; // U+002A ASTERISK (*)

  const EQUALSSIGN = 0x003D; // U+003D EQUALS SIGN (=)

  const CIRCUMFLEXACCENT = 0x005E; // U+005E (^)

  const VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

  const TILDE$2 = 0x007E; // U+007E TILDE (~)

  function getAttributeName() {
    if (this.eof) {
      this.error('Unexpected end of input');
    }

    const start = this.tokenStart;
    let expectIdent = false;

    if (this.isDelim(ASTERISK$6)) {
      expectIdent = true;
      this.next();
    } else if (!this.isDelim(VERTICALLINE$2)) {
      this.eat(types$4.Ident);
    }

    if (this.isDelim(VERTICALLINE$2)) {
      if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
        this.next();
        this.eat(types$4.Ident);
      } else if (expectIdent) {
        this.error('Identifier is expected', this.tokenEnd);
      }
    } else if (expectIdent) {
      this.error('Vertical line is expected');
    }

    return {
      type: 'Identifier',
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }

  function getOperator() {
    const start = this.tokenStart;
    const code = this.charCodeAt(start);

    if (code !== EQUALSSIGN && // =
    code !== TILDE$2 && // ~=
    code !== CIRCUMFLEXACCENT && // ^=
    code !== DOLLARSIGN$1 && // $=
    code !== ASTERISK$6 && // *=
    code !== VERTICALLINE$2 // |=
    ) {
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
      }

    this.next();

    if (code !== EQUALSSIGN) {
      if (!this.isDelim(EQUALSSIGN)) {
        this.error('Equal sign is expected');
      }

      this.next();
    }

    return this.substrToCursor(start);
  } // '[' <wq-name> ']'
  // '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'


  const name$D = 'AttributeSelector';
  const structure$B = {
    name: 'Identifier',
    matcher: [String, null],
    value: ['String', 'Identifier', null],
    flags: [String, null]
  };

  function parse$P() {
    const start = this.tokenStart;
    let name;
    let matcher = null;
    let value = null;
    let flags = null;
    this.eat(types$4.LeftSquareBracket);
    this.skipSC();
    name = getAttributeName.call(this);
    this.skipSC();

    if (this.tokenType !== types$4.RightSquareBracket) {
      // avoid case `[name i]`
      if (this.tokenType !== types$4.Ident) {
        matcher = getOperator.call(this);
        this.skipSC();
        value = this.tokenType === types$4.String ? this.String() : this.Identifier();
        this.skipSC();
      } // attribute flags


      if (this.tokenType === types$4.Ident) {
        flags = this.consume(types$4.Ident);
        this.skipSC();
      }
    }

    this.eat(types$4.RightSquareBracket);
    return {
      type: 'AttributeSelector',
      loc: this.getLocation(start, this.tokenStart),
      name,
      matcher,
      value,
      flags
    };
  }

  function generate$C(node) {
    this.token(types$4.Delim, '[');
    this.node(node.name);

    if (node.matcher !== null) {
      this.tokenize(node.matcher);
      this.node(node.value);
    }

    if (node.flags !== null) {
      this.token(types$4.Ident, node.flags);
    }

    this.token(types$4.Delim, ']');
  }

  var generate_1$D = generate$C;
  var name_1$B = name$D;
  var parse_1$J = parse$P;
  var structure_1$B = structure$B;

  var AttributeSelector = {
  	generate: generate_1$D,
  	name: name_1$B,
  	parse: parse_1$J,
  	structure: structure_1$B
  };

  const AMPERSAND$4 = 0x0026; // U+0026 AMPERSAND (&)

  function consumeRaw$4(startToken) {
    return this.Raw(startToken, null, true);
  }

  function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw$4);
  }

  function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }

  function consumeDeclaration() {
    if (this.tokenType === types$4.Semicolon) {
      return consumeRawDeclaration.call(this, this.tokenIndex);
    }

    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.tokenType === types$4.Semicolon) {
      this.next();
    }

    return node;
  }

  const name$C = 'Block';
  const walkContext$7 = 'block';
  const structure$A = {
    children: [['Atrule', 'Rule', 'Declaration']]
  };

  function parse$O(isStyleBlock) {
    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();
    this.eat(types$4.LeftCurlyBracket);

    scan: while (!this.eof) {
      switch (this.tokenType) {
        case types$4.RightCurlyBracket:
          break scan;

        case types$4.WhiteSpace:
        case types$4.Comment:
          this.next();
          break;

        case types$4.AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw$4));
          break;

        default:
          if (isStyleBlock && this.isDelim(AMPERSAND$4)) {
            children.push(consumeRule.call(this));
          } else {
            children.push(consumer.call(this));
          }

      }
    }

    if (!this.eof) {
      this.eat(types$4.RightCurlyBracket);
    }

    return {
      type: 'Block',
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }

  function generate$B(node) {
    this.token(types$4.LeftCurlyBracket, '{');
    this.children(node, prev => {
      if (prev.type === 'Declaration') {
        this.token(types$4.Semicolon, ';');
      }
    });
    this.token(types$4.RightCurlyBracket, '}');
  }

  var generate_1$C = generate$B;
  var name_1$A = name$C;
  var parse_1$I = parse$O;
  var structure_1$A = structure$A;
  var walkContext_1$7 = walkContext$7;

  var Block = {
  	generate: generate_1$C,
  	name: name_1$A,
  	parse: parse_1$I,
  	structure: structure_1$A,
  	walkContext: walkContext_1$7
  };

  const name$B = 'Brackets';
  const structure$z = {
    children: [[]]
  };

  function parse$N(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(types$4.LeftSquareBracket);
    children = readSequence.call(this, recognizer);

    if (!this.eof) {
      this.eat(types$4.RightSquareBracket);
    }

    return {
      type: 'Brackets',
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }

  function generate$A(node) {
    this.token(types$4.Delim, '[');
    this.children(node);
    this.token(types$4.Delim, ']');
  }

  var generate_1$B = generate$A;
  var name_1$z = name$B;
  var parse_1$H = parse$N;
  var structure_1$z = structure$z;

  var Brackets = {
  	generate: generate_1$B,
  	name: name_1$z,
  	parse: parse_1$H,
  	structure: structure_1$z
  };

  const name$A = 'CDC';
  const structure$y = [];

  function parse$M() {
    const start = this.tokenStart;
    this.eat(types$4.CDC); // -->

    return {
      type: 'CDC',
      loc: this.getLocation(start, this.tokenStart)
    };
  }

  function generate$z() {
    this.token(types$4.CDC, '-->');
  }

  var generate_1$A = generate$z;
  var name_1$y = name$A;
  var parse_1$G = parse$M;
  var structure_1$y = structure$y;

  var CDC = {
  	generate: generate_1$A,
  	name: name_1$y,
  	parse: parse_1$G,
  	structure: structure_1$y
  };

  const name$z = 'CDO';
  const structure$x = [];

  function parse$L() {
    const start = this.tokenStart;
    this.eat(types$4.CDO); // <!--

    return {
      type: 'CDO',
      loc: this.getLocation(start, this.tokenStart)
    };
  }

  function generate$y() {
    this.token(types$4.CDO, '<!--');
  }

  var generate_1$z = generate$y;
  var name_1$x = name$z;
  var parse_1$F = parse$L;
  var structure_1$x = structure$x;

  var CDO = {
  	generate: generate_1$z,
  	name: name_1$x,
  	parse: parse_1$F,
  	structure: structure_1$x
  };

  const FULLSTOP$2 = 0x002E; // U+002E FULL STOP (.)
  // '.' ident

  const name$y = 'ClassSelector';
  const structure$w = {
    name: String
  };

  function parse$K() {
    this.eatDelim(FULLSTOP$2);
    return {
      type: 'ClassSelector',
      loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
      name: this.consume(types$4.Ident)
    };
  }

  function generate$x(node) {
    this.token(types$4.Delim, '.');
    this.token(types$4.Ident, node.name);
  }

  var generate_1$y = generate$x;
  var name_1$w = name$y;
  var parse_1$E = parse$K;
  var structure_1$w = structure$w;

  var ClassSelector = {
  	generate: generate_1$y,
  	name: name_1$w,
  	parse: parse_1$E,
  	structure: structure_1$w
  };

  const PLUSSIGN$4 = 0x002B; // U+002B PLUS SIGN (+)

  const SOLIDUS$5 = 0x002F; // U+002F SOLIDUS (/)

  const GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)

  const TILDE$1 = 0x007E; // U+007E TILDE (~)

  const name$x = 'Combinator';
  const structure$v = {
    name: String
  }; // + | > | ~ | /deep/

  function parse$J() {
    const start = this.tokenStart;
    let name;

    switch (this.tokenType) {
      case types$4.WhiteSpace:
        name = ' ';
        break;

      case types$4.Delim:
        switch (this.charCodeAt(this.tokenStart)) {
          case GREATERTHANSIGN$1:
          case PLUSSIGN$4:
          case TILDE$1:
            this.next();
            break;

          case SOLIDUS$5:
            this.next();
            this.eatIdent('deep');
            this.eatDelim(SOLIDUS$5);
            break;

          default:
            this.error('Combinator is expected');
        }

        name = this.substrToCursor(start);
        break;
    }

    return {
      type: 'Combinator',
      loc: this.getLocation(start, this.tokenStart),
      name
    };
  }

  function generate$w(node) {
    this.tokenize(node.name);
  }

  var generate_1$x = generate$w;
  var name_1$v = name$x;
  var parse_1$D = parse$J;
  var structure_1$v = structure$v;

  var Combinator = {
  	generate: generate_1$x,
  	name: name_1$v,
  	parse: parse_1$D,
  	structure: structure_1$v
  };

  const ASTERISK$5 = 0x002A; // U+002A ASTERISK (*)

  const SOLIDUS$4 = 0x002F; // U+002F SOLIDUS (/)

  const name$w = 'Comment';
  const structure$u = {
    value: String
  };

  function parse$I() {
    const start = this.tokenStart;
    let end = this.tokenEnd;
    this.eat(types$4.Comment);

    if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK$5 && this.charCodeAt(end - 1) === SOLIDUS$4) {
      end -= 2;
    }

    return {
      type: 'Comment',
      loc: this.getLocation(start, this.tokenStart),
      value: this.substring(start + 2, end)
    };
  }

  function generate$v(node) {
    this.token(types$4.Comment, '/*' + node.value + '*/');
  }

  var generate_1$w = generate$v;
  var name_1$u = name$w;
  var parse_1$C = parse$I;
  var structure_1$u = structure$u;

  var Comment$1 = {
  	generate: generate_1$w,
  	name: name_1$u,
  	parse: parse_1$C,
  	structure: structure_1$u
  };

  const EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

  const NUMBERSIGN$2 = 0x0023; // U+0023 NUMBER SIGN (#)

  const DOLLARSIGN = 0x0024; // U+0024 DOLLAR SIGN ($)

  const AMPERSAND$3 = 0x0026; // U+0026 AMPERSAND (&)

  const ASTERISK$4 = 0x002A; // U+002A ASTERISK (*)

  const PLUSSIGN$3 = 0x002B; // U+002B PLUS SIGN (+)

  const SOLIDUS$3 = 0x002F; // U+002F SOLIDUS (/)

  function consumeValueRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
  }

  function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
  }

  function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value = this.Value();

    if (value.type !== 'Raw' && this.eof === false && this.tokenType !== types$4.Semicolon && this.isDelim(EXCLAMATIONMARK$1) === false && this.isBalanceEdge(startValueToken) === false) {
      this.error();
    }

    return value;
  }

  const name$v = 'Declaration';
  const walkContext$6 = 'declaration';
  const structure$t = {
    important: [Boolean, String],
    property: String,
    value: ['Value', 'Raw']
  };

  function parse$H() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property = readProperty.call(this);
    const customProperty = names.isCustomProperty(property);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value;
    this.skipSC();
    this.eat(types$4.Colon);
    const valueStart = this.tokenIndex;

    if (!customProperty) {
      this.skipSC();
    }

    if (parseValue) {
      value = this.parseWithFallback(consumeValue, consumeRaw);
    } else {
      value = consumeRaw.call(this, this.tokenIndex);
    }

    if (customProperty && value.type === 'Value' && value.children.isEmpty) {
      for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === types$4.WhiteSpace) {
          value.children.appendData({
            type: 'WhiteSpace',
            loc: null,
            value: ' '
          });
          break;
        }
      }
    }

    if (this.isDelim(EXCLAMATIONMARK$1)) {
      important = getImportant.call(this);
      this.skipSC();
    } // Do not include semicolon to range per spec
    // https://drafts.csswg.org/css-syntax/#declaration-diagram


    if (this.eof === false && this.tokenType !== types$4.Semicolon && this.isBalanceEdge(startToken) === false) {
      this.error();
    }

    return {
      type: 'Declaration',
      loc: this.getLocation(start, this.tokenStart),
      important,
      property,
      value
    };
  }

  function generate$u(node) {
    this.token(types$4.Ident, node.property);
    this.token(types$4.Colon, ':');
    this.node(node.value);

    if (node.important) {
      this.token(types$4.Delim, '!');
      this.token(types$4.Ident, node.important === true ? 'important' : node.important);
    }
  }

  function readProperty() {
    const start = this.tokenStart; // hacks

    if (this.tokenType === types$4.Delim) {
      switch (this.charCodeAt(this.tokenStart)) {
        case ASTERISK$4:
        case DOLLARSIGN:
        case PLUSSIGN$3:
        case NUMBERSIGN$2:
        case AMPERSAND$3:
          this.next();
          break;
        // TODO: not sure we should support this hack

        case SOLIDUS$3:
          this.next();

          if (this.isDelim(SOLIDUS$3)) {
            this.next();
          }

          break;
      }
    }

    if (this.tokenType === types$4.Hash) {
      this.eat(types$4.Hash);
    } else {
      this.eat(types$4.Ident);
    }

    return this.substrToCursor(start);
  } // ! ws* important


  function getImportant() {
    this.eat(types$4.Delim);
    this.skipSC();
    const important = this.consume(types$4.Ident); // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support

    return important === 'important' ? true : important;
  }

  var generate_1$v = generate$u;
  var name_1$t = name$v;
  var parse_1$B = parse$H;
  var structure_1$t = structure$t;
  var walkContext_1$6 = walkContext$6;

  var Declaration$1 = {
  	generate: generate_1$v,
  	name: name_1$t,
  	parse: parse_1$B,
  	structure: structure_1$t,
  	walkContext: walkContext_1$6
  };

  const AMPERSAND$2 = 0x0026; // U+0026 AMPERSAND (&)

  function consumeRaw$3(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }

  const name$u = 'DeclarationList';
  const structure$s = {
    children: [['Declaration', 'Atrule', 'Rule']]
  };

  function parse$G() {
    const children = this.createList();

    while (!this.eof) {
      switch (this.tokenType) {
        case types$4.WhiteSpace:
        case types$4.Comment:
        case types$4.Semicolon:
          this.next();
          break;

        case types$4.AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw$3));
          break;

        default:
          if (this.isDelim(AMPERSAND$2)) {
            children.push(this.parseWithFallback(this.Rule, consumeRaw$3));
          } else {
            children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
          }

      }
    }

    return {
      type: 'DeclarationList',
      loc: this.getLocationFromList(children),
      children
    };
  }

  function generate$t(node) {
    this.children(node, prev => {
      if (prev.type === 'Declaration') {
        this.token(types$4.Semicolon, ';');
      }
    });
  }

  var generate_1$u = generate$t;
  var name_1$s = name$u;
  var parse_1$A = parse$G;
  var structure_1$s = structure$s;

  var DeclarationList = {
  	generate: generate_1$u,
  	name: name_1$s,
  	parse: parse_1$A,
  	structure: structure_1$s
  };

  const name$t = 'Dimension';
  const structure$r = {
    value: String,
    unit: String
  };

  function parse$F() {
    const start = this.tokenStart;
    const value = this.consumeNumber(types$4.Dimension);
    return {
      type: 'Dimension',
      loc: this.getLocation(start, this.tokenStart),
      value,
      unit: this.substring(start + value.length, this.tokenStart)
    };
  }

  function generate$s(node) {
    this.token(types$4.Dimension, node.value + node.unit);
  }

  var generate_1$t = generate$s;
  var name_1$r = name$t;
  var parse_1$z = parse$F;
  var structure_1$r = structure$r;

  var Dimension = {
  	generate: generate_1$t,
  	name: name_1$r,
  	parse: parse_1$z,
  	structure: structure_1$r
  };

  const name$s = 'Function';
  const walkContext$5 = 'function';
  const structure$q = {
    name: String,
    children: [[]]
  }; // <function-token> <sequence> )

  function parse$E(readSequence, recognizer) {
    const start = this.tokenStart;
    const name = this.consumeFunctionName();
    const nameLowerCase = name.toLowerCase();
    let children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);

    if (!this.eof) {
      this.eat(types$4.RightParenthesis);
    }

    return {
      type: 'Function',
      loc: this.getLocation(start, this.tokenStart),
      name,
      children
    };
  }

  function generate$r(node) {
    this.token(types$4.Function, node.name + '(');
    this.children(node);
    this.token(types$4.RightParenthesis, ')');
  }

  var generate_1$s = generate$r;
  var name_1$q = name$s;
  var parse_1$y = parse$E;
  var structure_1$q = structure$q;
  var walkContext_1$5 = walkContext$5;

  var _Function$2 = {
  	generate: generate_1$s,
  	name: name_1$q,
  	parse: parse_1$y,
  	structure: structure_1$q,
  	walkContext: walkContext_1$5
  };

  // '#' ident


  const xxx = 'XXX';
  const name$r = 'Hash';
  const structure$p = {
    value: String
  };

  function parse$D() {
    const start = this.tokenStart;
    this.eat(types$4.Hash);
    return {
      type: 'Hash',
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start + 1)
    };
  }

  function generate$q(node) {
    this.token(types$4.Hash, '#' + node.value);
  }

  var generate_1$r = generate$q;
  var name_1$p = name$r;
  var parse_1$x = parse$D;
  var structure_1$p = structure$p;
  var xxx_1 = xxx;

  var Hash = {
  	generate: generate_1$r,
  	name: name_1$p,
  	parse: parse_1$x,
  	structure: structure_1$p,
  	xxx: xxx_1
  };

  const name$q = 'Identifier';
  const structure$o = {
    name: String
  };

  function parse$C() {
    return {
      type: 'Identifier',
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      name: this.consume(types$4.Ident)
    };
  }

  function generate$p(node) {
    this.token(types$4.Ident, node.name);
  }

  var generate_1$q = generate$p;
  var name_1$o = name$q;
  var parse_1$w = parse$C;
  var structure_1$o = structure$o;

  var Identifier = {
  	generate: generate_1$q,
  	name: name_1$o,
  	parse: parse_1$w,
  	structure: structure_1$o
  };

  const name$p = 'IdSelector';
  const structure$n = {
    name: String
  };

  function parse$B() {
    const start = this.tokenStart; // TODO: check value is an ident

    this.eat(types$4.Hash);
    return {
      type: 'IdSelector',
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start + 1)
    };
  }

  function generate$o(node) {
    // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector
    // in safe mode (e.g. "a#id"), because IE11 doesn't allow a sequence <ident-token> <hash-token>
    // without a whitespace in values (e.g. "1px solid#000")
    this.token(types$4.Delim, '#' + node.name);
  }

  var generate_1$p = generate$o;
  var name_1$n = name$p;
  var parse_1$v = parse$B;
  var structure_1$n = structure$n;

  var IdSelector = {
  	generate: generate_1$p,
  	name: name_1$n,
  	parse: parse_1$v,
  	structure: structure_1$n
  };

  const name$o = 'MediaFeature';
  const structure$m = {
    name: String,
    value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
  };

  function parse$A() {
    const start = this.tokenStart;
    let name;
    let value = null;
    this.eat(types$4.LeftParenthesis);
    this.skipSC();
    name = this.consume(types$4.Ident);
    this.skipSC();

    if (this.tokenType !== types$4.RightParenthesis) {
      this.eat(types$4.Colon);
      this.skipSC();

      switch (this.tokenType) {
        case types$4.Number:
          if (this.lookupNonWSType(1) === types$4.Delim) {
            value = this.Ratio();
          } else {
            value = this.Number();
          }

          break;

        case types$4.Dimension:
          value = this.Dimension();
          break;

        case types$4.Ident:
          value = this.Identifier();
          break;

        default:
          this.error('Number, dimension, ratio or identifier is expected');
      }

      this.skipSC();
    }

    this.eat(types$4.RightParenthesis);
    return {
      type: 'MediaFeature',
      loc: this.getLocation(start, this.tokenStart),
      name,
      value
    };
  }

  function generate$n(node) {
    this.token(types$4.LeftParenthesis, '(');
    this.token(types$4.Ident, node.name);

    if (node.value !== null) {
      this.token(types$4.Colon, ':');
      this.node(node.value);
    }

    this.token(types$4.RightParenthesis, ')');
  }

  var generate_1$o = generate$n;
  var name_1$m = name$o;
  var parse_1$u = parse$A;
  var structure_1$m = structure$m;

  var MediaFeature$1 = {
  	generate: generate_1$o,
  	name: name_1$m,
  	parse: parse_1$u,
  	structure: structure_1$m
  };

  const name$n = 'MediaQuery';
  const structure$l = {
    children: [['Identifier', 'MediaFeature', 'WhiteSpace']]
  };

  function parse$z() {
    const children = this.createList();
    let child = null;
    this.skipSC();

    scan: while (!this.eof) {
      switch (this.tokenType) {
        case types$4.Comment:
        case types$4.WhiteSpace:
          this.next();
          continue;

        case types$4.Ident:
          child = this.Identifier();
          break;

        case types$4.LeftParenthesis:
          child = this.MediaFeature();
          break;

        default:
          break scan;
      }

      children.push(child);
    }

    if (child === null) {
      this.error('Identifier or parenthesis is expected');
    }

    return {
      type: 'MediaQuery',
      loc: this.getLocationFromList(children),
      children
    };
  }

  function generate$m(node) {
    this.children(node);
  }

  var generate_1$n = generate$m;
  var name_1$l = name$n;
  var parse_1$t = parse$z;
  var structure_1$l = structure$l;

  var MediaQuery = {
  	generate: generate_1$n,
  	name: name_1$l,
  	parse: parse_1$t,
  	structure: structure_1$l
  };

  const name$m = 'MediaQueryList';
  const structure$k = {
    children: [['MediaQuery']]
  };

  function parse$y() {
    const children = this.createList();
    this.skipSC();

    while (!this.eof) {
      children.push(this.MediaQuery());

      if (this.tokenType !== types$4.Comma) {
        break;
      }

      this.next();
    }

    return {
      type: 'MediaQueryList',
      loc: this.getLocationFromList(children),
      children
    };
  }

  function generate$l(node) {
    this.children(node, () => this.token(types$4.Comma, ','));
  }

  var generate_1$m = generate$l;
  var name_1$k = name$m;
  var parse_1$s = parse$y;
  var structure_1$k = structure$k;

  var MediaQueryList = {
  	generate: generate_1$m,
  	name: name_1$k,
  	parse: parse_1$s,
  	structure: structure_1$k
  };

  const AMPERSAND$1 = 0x0026; // U+0026 AMPERSAND (&)

  const name$l = 'NestingSelector';
  const structure$j = {};

  function parse$x() {
    const start = this.tokenStart;
    this.eatDelim(AMPERSAND$1);
    return {
      type: 'NestingSelector',
      loc: this.getLocation(start, this.tokenStart)
    };
  }

  function generate$k() {
    this.token(types$4.Delim, '&');
  }

  var generate_1$l = generate$k;
  var name_1$j = name$l;
  var parse_1$r = parse$x;
  var structure_1$j = structure$j;

  var NestingSelector = {
  	generate: generate_1$l,
  	name: name_1$j,
  	parse: parse_1$r,
  	structure: structure_1$j
  };

  const name$k = 'Nth';
  const structure$i = {
    nth: ['AnPlusB', 'Identifier'],
    selector: ['SelectorList', null]
  };

  function parse$w() {
    this.skipSC();
    const start = this.tokenStart;
    let end = start;
    let selector = null;
    let nth;

    if (this.lookupValue(0, 'odd') || this.lookupValue(0, 'even')) {
      nth = this.Identifier();
    } else {
      nth = this.AnPlusB();
    }

    end = this.tokenStart;
    this.skipSC();

    if (this.lookupValue(0, 'of')) {
      this.next();
      selector = this.SelectorList();
      end = this.tokenStart;
    }

    return {
      type: 'Nth',
      loc: this.getLocation(start, end),
      nth,
      selector
    };
  }

  function generate$j(node) {
    this.node(node.nth);

    if (node.selector !== null) {
      this.token(types$4.Ident, 'of');
      this.node(node.selector);
    }
  }

  var generate_1$k = generate$j;
  var name_1$i = name$k;
  var parse_1$q = parse$w;
  var structure_1$i = structure$i;

  var Nth = {
  	generate: generate_1$k,
  	name: name_1$i,
  	parse: parse_1$q,
  	structure: structure_1$i
  };

  const name$j = 'Number';
  const structure$h = {
    value: String
  };

  function parse$v() {
    return {
      type: 'Number',
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consume(types$4.Number)
    };
  }

  function generate$i(node) {
    this.token(types$4.Number, node.value);
  }

  var generate_1$j = generate$i;
  var name_1$h = name$j;
  var parse_1$p = parse$v;
  var structure_1$h = structure$h;

  var _Number$2 = {
  	generate: generate_1$j,
  	name: name_1$h,
  	parse: parse_1$p,
  	structure: structure_1$h
  };

  const name$i = 'Operator';
  const structure$g = {
    value: String
  };

  function parse$u() {
    const start = this.tokenStart;
    this.next();
    return {
      type: 'Operator',
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }

  function generate$h(node) {
    this.tokenize(node.value);
  }

  var generate_1$i = generate$h;
  var name_1$g = name$i;
  var parse_1$o = parse$u;
  var structure_1$g = structure$g;

  var Operator = {
  	generate: generate_1$i,
  	name: name_1$g,
  	parse: parse_1$o,
  	structure: structure_1$g
  };

  const name$h = 'Parentheses';
  const structure$f = {
    children: [[]]
  };

  function parse$t(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(types$4.LeftParenthesis);
    children = readSequence.call(this, recognizer);

    if (!this.eof) {
      this.eat(types$4.RightParenthesis);
    }

    return {
      type: 'Parentheses',
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }

  function generate$g(node) {
    this.token(types$4.LeftParenthesis, '(');
    this.children(node);
    this.token(types$4.RightParenthesis, ')');
  }

  var generate_1$h = generate$g;
  var name_1$f = name$h;
  var parse_1$n = parse$t;
  var structure_1$f = structure$f;

  var Parentheses = {
  	generate: generate_1$h,
  	name: name_1$f,
  	parse: parse_1$n,
  	structure: structure_1$f
  };

  const name$g = 'Percentage';
  const structure$e = {
    value: String
  };

  function parse$s() {
    return {
      type: 'Percentage',
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consumeNumber(types$4.Percentage)
    };
  }

  function generate$f(node) {
    this.token(types$4.Percentage, node.value + '%');
  }

  var generate_1$g = generate$f;
  var name_1$e = name$g;
  var parse_1$m = parse$s;
  var structure_1$e = structure$e;

  var Percentage = {
  	generate: generate_1$g,
  	name: name_1$e,
  	parse: parse_1$m,
  	structure: structure_1$e
  };

  const name$f = 'PseudoClassSelector';
  const walkContext$4 = 'function';
  const structure$d = {
    name: String,
    children: [['Raw'], null]
  }; // : [ <ident> | <function-token> <any-value>? ) ]

  function parse$r() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;
    this.eat(types$4.Colon);

    if (this.tokenType === types$4.Function) {
      name = this.consumeFunctionName();
      nameLowerCase = name.toLowerCase();

      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.tokenIndex, null, false));
      }

      this.eat(types$4.RightParenthesis);
    } else {
      name = this.consume(types$4.Ident);
    }

    return {
      type: 'PseudoClassSelector',
      loc: this.getLocation(start, this.tokenStart),
      name,
      children
    };
  }

  function generate$e(node) {
    this.token(types$4.Colon, ':');

    if (node.children === null) {
      this.token(types$4.Ident, node.name);
    } else {
      this.token(types$4.Function, node.name + '(');
      this.children(node);
      this.token(types$4.RightParenthesis, ')');
    }
  }

  var generate_1$f = generate$e;
  var name_1$d = name$f;
  var parse_1$l = parse$r;
  var structure_1$d = structure$d;
  var walkContext_1$4 = walkContext$4;

  var PseudoClassSelector = {
  	generate: generate_1$f,
  	name: name_1$d,
  	parse: parse_1$l,
  	structure: structure_1$d,
  	walkContext: walkContext_1$4
  };

  const name$e = 'PseudoElementSelector';
  const walkContext$3 = 'function';
  const structure$c = {
    name: String,
    children: [['Raw'], null]
  }; // :: [ <ident> | <function-token> <any-value>? ) ]

  function parse$q() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;
    this.eat(types$4.Colon);
    this.eat(types$4.Colon);

    if (this.tokenType === types$4.Function) {
      name = this.consumeFunctionName();
      nameLowerCase = name.toLowerCase();

      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.tokenIndex, null, false));
      }

      this.eat(types$4.RightParenthesis);
    } else {
      name = this.consume(types$4.Ident);
    }

    return {
      type: 'PseudoElementSelector',
      loc: this.getLocation(start, this.tokenStart),
      name,
      children
    };
  }

  function generate$d(node) {
    this.token(types$4.Colon, ':');
    this.token(types$4.Colon, ':');

    if (node.children === null) {
      this.token(types$4.Ident, node.name);
    } else {
      this.token(types$4.Function, node.name + '(');
      this.children(node);
      this.token(types$4.RightParenthesis, ')');
    }
  }

  var generate_1$e = generate$d;
  var name_1$c = name$e;
  var parse_1$k = parse$q;
  var structure_1$c = structure$c;
  var walkContext_1$3 = walkContext$3;

  var PseudoElementSelector = {
  	generate: generate_1$e,
  	name: name_1$c,
  	parse: parse_1$k,
  	structure: structure_1$c,
  	walkContext: walkContext_1$3
  };

  const SOLIDUS$2 = 0x002F; // U+002F SOLIDUS (/)

  const FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)
  // Terms of <ratio> should be a positive numbers (not zero or negative)
  // (see https://drafts.csswg.org/mediaqueries-3/#values)
  // However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
  // and this is using by various sites. Therefore we relax checking on parse
  // to test a term is unsigned number without an exponent part.
  // Additional checking may be applied on lexer validation.

  function consumeNumber$1() {
    this.skipSC();
    const value = this.consume(types$4.Number);

    for (let i = 0; i < value.length; i++) {
      const code = value.charCodeAt(i);

      if (!charCodeDefinitions.isDigit(code) && code !== FULLSTOP$1) {
        this.error('Unsigned number is expected', this.tokenStart - value.length + i);
      }
    }

    if (Number(value) === 0) {
      this.error('Zero number is not allowed', this.tokenStart - value.length);
    }

    return value;
  }

  const name$d = 'Ratio';
  const structure$b = {
    left: String,
    right: String
  }; // <positive-integer> S* '/' S* <positive-integer>

  function parse$p() {
    const start = this.tokenStart;
    const left = consumeNumber$1.call(this);
    let right;
    this.skipSC();
    this.eatDelim(SOLIDUS$2);
    right = consumeNumber$1.call(this);
    return {
      type: 'Ratio',
      loc: this.getLocation(start, this.tokenStart),
      left,
      right
    };
  }

  function generate$c(node) {
    this.token(types$4.Number, node.left);
    this.token(types$4.Delim, '/');
    this.token(types$4.Number, node.right);
  }

  var generate_1$d = generate$c;
  var name_1$b = name$d;
  var parse_1$j = parse$p;
  var structure_1$b = structure$b;

  var Ratio = {
  	generate: generate_1$d,
  	name: name_1$b,
  	parse: parse_1$j,
  	structure: structure_1$b
  };

  function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
      if (this.lookupType(-1) === types$4.WhiteSpace) {
        return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
      }
    }

    return this.tokenStart;
  }

  const name$c = 'Raw';
  const structure$a = {
    value: String
  };

  function parse$o(startToken, consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(startToken);
    let endOffset;
    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);

    if (excludeWhiteSpace && this.tokenStart > startOffset) {
      endOffset = getOffsetExcludeWS.call(this);
    } else {
      endOffset = this.tokenStart;
    }

    return {
      type: 'Raw',
      loc: this.getLocation(startOffset, endOffset),
      value: this.substring(startOffset, endOffset)
    };
  }

  function generate$b(node) {
    this.tokenize(node.value);
  }

  var generate_1$c = generate$b;
  var name_1$a = name$c;
  var parse_1$i = parse$o;
  var structure_1$a = structure$a;

  var Raw = {
  	generate: generate_1$c,
  	name: name_1$a,
  	parse: parse_1$i,
  	structure: structure_1$a
  };

  function consumeRaw$2(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
  }

  function consumePrelude() {
    const prelude = this.SelectorList();

    if (prelude.type !== 'Raw' && this.eof === false && this.tokenType !== types$4.LeftCurlyBracket) {
      this.error();
    }

    return prelude;
  }

  const name$b = 'Rule';
  const walkContext$2 = 'rule';
  const structure$9 = {
    prelude: ['SelectorList', 'Raw'],
    block: ['Block']
  };

  function parse$n() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;

    if (this.parseRulePrelude) {
      prelude = this.parseWithFallback(consumePrelude, consumeRaw$2);
    } else {
      prelude = consumeRaw$2.call(this, startToken);
    }

    block = this.Block(true);
    return {
      type: 'Rule',
      loc: this.getLocation(startOffset, this.tokenStart),
      prelude,
      block
    };
  }

  function generate$a(node) {
    this.node(node.prelude);
    this.node(node.block);
  }

  var generate_1$b = generate$a;
  var name_1$9 = name$b;
  var parse_1$h = parse$n;
  var structure_1$9 = structure$9;
  var walkContext_1$2 = walkContext$2;

  var Rule$2 = {
  	generate: generate_1$b,
  	name: name_1$9,
  	parse: parse_1$h,
  	structure: structure_1$9,
  	walkContext: walkContext_1$2
  };

  const name$a = 'Selector';
  const structure$8 = {
    children: [['TypeSelector', 'IdSelector', 'ClassSelector', 'AttributeSelector', 'PseudoClassSelector', 'PseudoElementSelector', 'Combinator', 'WhiteSpace']]
  };

  function parse$m() {
    const children = this.readSequence(this.scope.Selector); // nothing were consumed

    if (this.getFirstListNode(children) === null) {
      this.error('Selector is expected');
    }

    return {
      type: 'Selector',
      loc: this.getLocationFromList(children),
      children
    };
  }

  function generate$9(node) {
    this.children(node);
  }

  var generate_1$a = generate$9;
  var name_1$8 = name$a;
  var parse_1$g = parse$m;
  var structure_1$8 = structure$8;

  var Selector$2 = {
  	generate: generate_1$a,
  	name: name_1$8,
  	parse: parse_1$g,
  	structure: structure_1$8
  };

  const name$9 = 'SelectorList';
  const walkContext$1 = 'selector';
  const structure$7 = {
    children: [['Selector', 'Raw']]
  };

  function parse$l() {
    const children = this.createList();

    while (!this.eof) {
      children.push(this.Selector());

      if (this.tokenType === types$4.Comma) {
        this.next();
        continue;
      }

      break;
    }

    return {
      type: 'SelectorList',
      loc: this.getLocationFromList(children),
      children
    };
  }

  function generate$8(node) {
    this.children(node, () => this.token(types$4.Comma, ','));
  }

  var generate_1$9 = generate$8;
  var name_1$7 = name$9;
  var parse_1$f = parse$l;
  var structure_1$7 = structure$7;
  var walkContext_1$1 = walkContext$1;

  var SelectorList = {
  	generate: generate_1$9,
  	name: name_1$7,
  	parse: parse_1$f,
  	structure: structure_1$7,
  	walkContext: walkContext_1$1
  };

  const REVERSE_SOLIDUS$2 = 0x005c; // U+005C REVERSE SOLIDUS (\)

  const QUOTATION_MARK$1 = 0x0022; // "

  const APOSTROPHE$1 = 0x0027; // '

  function decode$2(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK$1 || firstChar === APOSTROPHE$1 ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = '';

    for (let i = start; i <= end; i++) {
      let code = str.charCodeAt(i);

      if (code === REVERSE_SOLIDUS$2) {
        // special case at the ending
        if (i === end) {
          // if the next input code point is EOF, do nothing
          // otherwise include last quote as escaped
          if (i !== len - 1) {
            decoded = str.substr(i + 1);
          }

          break;
        }

        code = str.charCodeAt(++i); // consume escaped

        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS$2, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils$9.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils$9.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          // \r\n
          if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }

    return decoded;
  } // https://drafts.csswg.org/cssom/#serialize-a-string
  // § 2.1. Common Serializing Idioms


  function encode$2(str, apostrophe) {
    const quote = apostrophe ? '\'' : '"';
    const quoteCode = apostrophe ? APOSTROPHE$1 : QUOTATION_MARK$1;
    let encoded = '';
    let wsBeforeHexIsNeeded = false;

    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i); // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).

      if (code === 0x0000) {
        encoded += '\uFFFD';
        continue;
      } // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
      // the character escaped as code point.
      // Note: Do not compare with 0x0001 since 0x0000 is precessed before


      if (code <= 0x001f || code === 0x007F) {
        encoded += '\\' + code.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      } // If the character is '"' (U+0022) or "\" (U+005C), the escaped character.


      if (code === quoteCode || code === REVERSE_SOLIDUS$2) {
        encoded += '\\' + str.charAt(i);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && (charCodeDefinitions.isHexDigit(code) || charCodeDefinitions.isWhiteSpace(code))) {
          encoded += ' ';
        } // Otherwise, the character itself.


        encoded += str.charAt(i);
        wsBeforeHexIsNeeded = false;
      }
    }

    return quote + encoded + quote;
  }

  var decode_1$2 = decode$2;
  var encode_1$2 = encode$2;

  var string$3 = {
  	decode: decode_1$2,
  	encode: encode_1$2
  };

  const name$8 = 'String';
  const structure$6 = {
    value: String
  };

  function parse$k() {
    return {
      type: 'String',
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: string$3.decode(this.consume(types$4.String))
    };
  }

  function generate$7(node) {
    this.token(types$4.String, string$3.encode(node.value));
  }

  var generate_1$8 = generate$7;
  var name_1$6 = name$8;
  var parse_1$e = parse$k;
  var structure_1$6 = structure$6;

  var _String$2 = {
  	generate: generate_1$8,
  	name: name_1$6,
  	parse: parse_1$e,
  	structure: structure_1$6
  };

  const EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

  function consumeRaw$1(startToken) {
    return this.Raw(startToken, null, false);
  }

  const name$7 = 'StyleSheet';
  const walkContext = 'stylesheet';
  const structure$5 = {
    children: [['Comment', 'CDO', 'CDC', 'Atrule', 'Rule', 'Raw']]
  };

  function parse$j() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;

    while (!this.eof) {
      switch (this.tokenType) {
        case types$4.WhiteSpace:
          this.next();
          continue;

        case types$4.Comment:
          // ignore comments except exclamation comments (i.e. /*! .. */) on top level
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
            this.next();
            continue;
          }

          child = this.Comment();
          break;

        case types$4.CDO:
          // <!--
          child = this.CDO();
          break;

        case types$4.CDC:
          // -->
          child = this.CDC();
          break;
        // CSS Syntax Module Level 3
        // §2.2 Error handling
        // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.

        case types$4.AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw$1);
          break;
        // Anything else starts a qualified rule ...

        default:
          child = this.parseWithFallback(this.Rule, consumeRaw$1);
      }

      children.push(child);
    }

    return {
      type: 'StyleSheet',
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }

  function generate$6(node) {
    this.children(node);
  }

  var generate_1$7 = generate$6;
  var name_1$5 = name$7;
  var parse_1$d = parse$j;
  var structure_1$5 = structure$5;
  var walkContext_1 = walkContext;

  var StyleSheet = {
  	generate: generate_1$7,
  	name: name_1$5,
  	parse: parse_1$d,
  	structure: structure_1$5,
  	walkContext: walkContext_1
  };

  const ASTERISK$3 = 0x002A; // U+002A ASTERISK (*)

  const VERTICALLINE$1 = 0x007C; // U+007C VERTICAL LINE (|)

  function eatIdentifierOrAsterisk() {
    if (this.tokenType !== types$4.Ident && this.isDelim(ASTERISK$3) === false) {
      this.error('Identifier or asterisk is expected');
    }

    this.next();
  }

  const name$6 = 'TypeSelector';
  const structure$4 = {
    name: String
  }; // ident
  // ident|ident
  // ident|*
  // *
  // *|ident
  // *|*
  // |ident
  // |*

  function parse$i() {
    const start = this.tokenStart;

    if (this.isDelim(VERTICALLINE$1)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);

      if (this.isDelim(VERTICALLINE$1)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }

    return {
      type: 'TypeSelector',
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }

  function generate$5(node) {
    this.tokenize(node.name);
  }

  var generate_1$6 = generate$5;
  var name_1$4 = name$6;
  var parse_1$c = parse$i;
  var structure_1$4 = structure$4;

  var TypeSelector = {
  	generate: generate_1$6,
  	name: name_1$4,
  	parse: parse_1$c,
  	structure: structure_1$4
  };

  const PLUSSIGN$2 = 0x002B; // U+002B PLUS SIGN (+)

  const HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)

  const QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)

  function eatHexSequence(offset, allowDash) {
    let len = 0;

    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
      const code = this.charCodeAt(pos);

      if (code === HYPHENMINUS$1 && allowDash && len !== 0) {
        eatHexSequence.call(this, offset + len + 1, false);
        return -1;
      }

      if (!charCodeDefinitions.isHexDigit(code)) {
        this.error(allowDash && len !== 0 ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected' : len < 6 ? 'Hex digit is expected' : 'Unexpected input', pos);
      }

      if (++len > 6) {
        this.error('Too many hex digits', pos);
      }
    }

    this.next();
    return len;
  }

  function eatQuestionMarkSequence(max) {
    let count = 0;

    while (this.isDelim(QUESTIONMARK)) {
      if (++count > max) {
        this.error('Too many question marks');
      }

      this.next();
    }
  }

  function startsWith(code) {
    if (this.charCodeAt(this.tokenStart) !== code) {
      this.error((code === PLUSSIGN$2 ? 'Plus sign' : 'Hyphen minus') + ' is expected');
    }
  } // https://drafts.csswg.org/css-syntax/#urange
  // Informally, the <urange> production has three forms:
  // U+0001
  //      Defines a range consisting of a single code point, in this case the code point "1".
  // U+0001-00ff
  //      Defines a range of codepoints between the first and the second value, in this case
  //      the range between "1" and "ff" (255 in decimal) inclusive.
  // U+00??
  //      Defines a range of codepoints where the "?" characters range over all hex digits,
  //      in this case defining the same as the value U+0000-00ff.
  // In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
  //
  // <urange> =
  //   u '+' <ident-token> '?'* |
  //   u <dimension-token> '?'* |
  //   u <number-token> '?'* |
  //   u <number-token> <dimension-token> |
  //   u <number-token> <number-token> |
  //   u '+' '?'+


  function scanUnicodeRange() {
    let hexLength = 0;

    switch (this.tokenType) {
      case types$4.Number:
        // u <number-token> '?'*
        // u <number-token> <dimension-token>
        // u <number-token> <number-token>
        hexLength = eatHexSequence.call(this, 1, true);

        if (this.isDelim(QUESTIONMARK)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          break;
        }

        if (this.tokenType === types$4.Dimension || this.tokenType === types$4.Number) {
          startsWith.call(this, HYPHENMINUS$1);
          eatHexSequence.call(this, 1, false);
          break;
        }

        break;

      case types$4.Dimension:
        // u <dimension-token> '?'*
        hexLength = eatHexSequence.call(this, 1, true);

        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }

        break;

      default:
        // u '+' <ident-token> '?'*
        // u '+' '?'+
        this.eatDelim(PLUSSIGN$2);

        if (this.tokenType === types$4.Ident) {
          hexLength = eatHexSequence.call(this, 0, true);

          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }

          break;
        }

        if (this.isDelim(QUESTIONMARK)) {
          this.next();
          eatQuestionMarkSequence.call(this, 5);
          break;
        }

        this.error('Hex digit or question mark is expected');
    }
  }

  const name$5 = 'UnicodeRange';
  const structure$3 = {
    value: String
  };

  function parse$h() {
    const start = this.tokenStart; // U or u

    this.eatIdent('u');
    scanUnicodeRange.call(this);
    return {
      type: 'UnicodeRange',
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }

  function generate$4(node) {
    this.tokenize(node.value);
  }

  var generate_1$5 = generate$4;
  var name_1$3 = name$5;
  var parse_1$b = parse$h;
  var structure_1$3 = structure$3;

  var UnicodeRange = {
  	generate: generate_1$5,
  	name: name_1$3,
  	parse: parse_1$b,
  	structure: structure_1$3
  };

  const SPACE$4 = 0x0020; // U+0020 SPACE

  const REVERSE_SOLIDUS$1 = 0x005c; // U+005C REVERSE SOLIDUS (\)

  const QUOTATION_MARK = 0x0022; // "

  const APOSTROPHE = 0x0027; // '

  const LEFTPARENTHESIS = 0x0028; // U+0028 LEFT PARENTHESIS (()

  const RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())

  function decode$1(str) {
    const len = str.length;
    let start = 4; // length of "url("

    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = '';

    while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))) {
      start++;
    }

    while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))) {
      end--;
    }

    for (let i = start; i <= end; i++) {
      let code = str.charCodeAt(i);

      if (code === REVERSE_SOLIDUS$1) {
        // special case at the ending
        if (i === end) {
          // if the next input code point is EOF, do nothing
          // otherwise include last left parenthesis as escaped
          if (i !== len - 1) {
            decoded = str.substr(i + 1);
          }

          break;
        }

        code = str.charCodeAt(++i); // consume escaped

        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS$1, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils$9.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils$9.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          // \r\n
          if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }

    return decoded;
  }

  function encode$1(str) {
    let encoded = '';
    let wsBeforeHexIsNeeded = false;

    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i); // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).

      if (code === 0x0000) {
        encoded += '\uFFFD';
        continue;
      } // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
      // the character escaped as code point.
      // Note: Do not compare with 0x0001 since 0x0000 is precessed before


      if (code <= 0x001f || code === 0x007F) {
        encoded += '\\' + code.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }

      if (code === SPACE$4 || code === REVERSE_SOLIDUS$1 || code === QUOTATION_MARK || code === APOSTROPHE || code === LEFTPARENTHESIS || code === RIGHTPARENTHESIS) {
        encoded += '\\' + str.charAt(i);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {
          encoded += ' ';
        }

        encoded += str.charAt(i);
        wsBeforeHexIsNeeded = false;
      }
    }

    return 'url(' + encoded + ')';
  }

  var decode_1$1 = decode$1;
  var encode_1$1 = encode$1;

  var url = {
  	decode: decode_1$1,
  	encode: encode_1$1
  };

  const name$4 = 'Url';
  const structure$2 = {
    value: String
  }; // <url-token> | <function-token> <string> )

  function parse$g() {
    const start = this.tokenStart;
    let value;

    switch (this.tokenType) {
      case types$4.Url:
        value = url.decode(this.consume(types$4.Url));
        break;

      case types$4.Function:
        if (!this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')) {
          this.error('Function name must be `url`');
        }

        this.eat(types$4.Function);
        this.skipSC();
        value = string$3.decode(this.consume(types$4.String));
        this.skipSC();

        if (!this.eof) {
          this.eat(types$4.RightParenthesis);
        }

        break;

      default:
        this.error('Url or Function is expected');
    }

    return {
      type: 'Url',
      loc: this.getLocation(start, this.tokenStart),
      value
    };
  }

  function generate$3(node) {
    this.token(types$4.Url, url.encode(node.value));
  }

  var generate_1$4 = generate$3;
  var name_1$2 = name$4;
  var parse_1$a = parse$g;
  var structure_1$2 = structure$2;

  var Url = {
  	generate: generate_1$4,
  	name: name_1$2,
  	parse: parse_1$a,
  	structure: structure_1$2
  };

  const name$3 = 'Value';
  const structure$1 = {
    children: [[]]
  };

  function parse$f() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);
    return {
      type: 'Value',
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }

  function generate$2(node) {
    this.children(node);
  }

  var generate_1$3 = generate$2;
  var name_1$1 = name$3;
  var parse_1$9 = parse$f;
  var structure_1$1 = structure$1;

  var Value$1 = {
  	generate: generate_1$3,
  	name: name_1$1,
  	parse: parse_1$9,
  	structure: structure_1$1
  };

  const SPACE$3 = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
  });
  const name$2 = 'WhiteSpace';
  const structure = {
    value: String
  };

  function parse$e() {
    this.eat(types$4.WhiteSpace);
    return SPACE$3; // return {
    //     type: 'WhiteSpace',
    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),
    //     value: this.consume(WHITESPACE)
    // };
  }

  function generate$1(node) {
    this.token(types$4.WhiteSpace, node.value);
  }

  var generate_1$2 = generate$1;
  var name_1 = name$2;
  var parse_1$8 = parse$e;
  var structure_1 = structure;

  var WhiteSpace = {
  	generate: generate_1$2,
  	name: name_1,
  	parse: parse_1$8,
  	structure: structure_1
  };

  var AnPlusB_1$1 = AnPlusB;
  var Atrule_1$1 = Atrule;
  var AtrulePrelude_1$1 = AtrulePrelude$1;
  var AttributeSelector_1$1 = AttributeSelector;
  var Block_1$1 = Block;
  var Brackets_1$1 = Brackets;
  var CDC_1$1 = CDC;
  var CDO_1$1 = CDO;
  var ClassSelector_1$1 = ClassSelector;
  var Combinator_1$1 = Combinator;
  var Comment_1$1 = Comment$1;
  var Declaration_1$1 = Declaration$1;
  var DeclarationList_1$1 = DeclarationList;
  var Dimension_1$1 = Dimension;
  var _Function$1 = _Function$2;
  var Hash_1$1 = Hash;
  var Identifier_1$1 = Identifier;
  var IdSelector_1$1 = IdSelector;
  var MediaFeature_1$1 = MediaFeature$1;
  var MediaQuery_1$1 = MediaQuery;
  var MediaQueryList_1$1 = MediaQueryList;
  var NestingSelector_1$1 = NestingSelector;
  var Nth_1$1 = Nth;
  var _Number$1 = _Number$2;
  var Operator_1$1 = Operator;
  var Parentheses_1$1 = Parentheses;
  var Percentage_1$1 = Percentage;
  var PseudoClassSelector_1$1 = PseudoClassSelector;
  var PseudoElementSelector_1$1 = PseudoElementSelector;
  var Ratio_1$1 = Ratio;
  var Raw_1$1 = Raw;
  var Rule_1$1 = Rule$2;
  var Selector_1$1 = Selector$2;
  var SelectorList_1$1 = SelectorList;
  var _String$1 = _String$2;
  var StyleSheet_1$1 = StyleSheet;
  var TypeSelector_1$1 = TypeSelector;
  var UnicodeRange_1$1 = UnicodeRange;
  var Url_1$1 = Url;
  var Value_1$1 = Value$1;
  var WhiteSpace_1$1 = WhiteSpace;

  var node$3 = {
  	AnPlusB: AnPlusB_1$1,
  	Atrule: Atrule_1$1,
  	AtrulePrelude: AtrulePrelude_1$1,
  	AttributeSelector: AttributeSelector_1$1,
  	Block: Block_1$1,
  	Brackets: Brackets_1$1,
  	CDC: CDC_1$1,
  	CDO: CDO_1$1,
  	ClassSelector: ClassSelector_1$1,
  	Combinator: Combinator_1$1,
  	Comment: Comment_1$1,
  	Declaration: Declaration_1$1,
  	DeclarationList: DeclarationList_1$1,
  	Dimension: Dimension_1$1,
  	Function: _Function$1,
  	Hash: Hash_1$1,
  	Identifier: Identifier_1$1,
  	IdSelector: IdSelector_1$1,
  	MediaFeature: MediaFeature_1$1,
  	MediaQuery: MediaQuery_1$1,
  	MediaQueryList: MediaQueryList_1$1,
  	NestingSelector: NestingSelector_1$1,
  	Nth: Nth_1$1,
  	Number: _Number$1,
  	Operator: Operator_1$1,
  	Parentheses: Parentheses_1$1,
  	Percentage: Percentage_1$1,
  	PseudoClassSelector: PseudoClassSelector_1$1,
  	PseudoElementSelector: PseudoElementSelector_1$1,
  	Ratio: Ratio_1$1,
  	Raw: Raw_1$1,
  	Rule: Rule_1$1,
  	Selector: Selector_1$1,
  	SelectorList: SelectorList_1$1,
  	String: _String$1,
  	StyleSheet: StyleSheet_1$1,
  	TypeSelector: TypeSelector_1$1,
  	UnicodeRange: UnicodeRange_1$1,
  	Url: Url_1$1,
  	Value: Value_1$1,
  	WhiteSpace: WhiteSpace_1$1
  };

  const lexerConfig = {
    generic: true,
    ...data,
    node: node$3
  };
  var lexer$1 = lexerConfig;

  const NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)

  const ASTERISK$2 = 0x002A; // U+002A ASTERISK (*)

  const PLUSSIGN$1 = 0x002B; // U+002B PLUS SIGN (+)

  const HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)

  const SOLIDUS$1 = 0x002F; // U+002F SOLIDUS (/)

  const U$1 = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

  function defaultRecognizer(context) {
    switch (this.tokenType) {
      case types$4.Hash:
        return this.Hash();

      case types$4.Comma:
        return this.Operator();

      case types$4.LeftParenthesis:
        return this.Parentheses(this.readSequence, context.recognizer);

      case types$4.LeftSquareBracket:
        return this.Brackets(this.readSequence, context.recognizer);

      case types$4.String:
        return this.String();

      case types$4.Dimension:
        return this.Dimension();

      case types$4.Percentage:
        return this.Percentage();

      case types$4.Number:
        return this.Number();

      case types$4.Function:
        return this.cmpStr(this.tokenStart, this.tokenEnd, 'url(') ? this.Url() : this.Function(this.readSequence, context.recognizer);

      case types$4.Url:
        return this.Url();

      case types$4.Ident:
        // check for unicode range, it should start with u+ or U+
        if (this.cmpChar(this.tokenStart, U$1) && this.cmpChar(this.tokenStart + 1, PLUSSIGN$1)) {
          return this.UnicodeRange();
        } else {
          return this.Identifier();
        }

      case types$4.Delim:
        {
          const code = this.charCodeAt(this.tokenStart);

          if (code === SOLIDUS$1 || code === ASTERISK$2 || code === PLUSSIGN$1 || code === HYPHENMINUS) {
            return this.Operator(); // TODO: replace with Delim
          } // TODO: produce a node with Delim node type


          if (code === NUMBERSIGN$1) {
            this.error('Hex or identifier is expected', this.tokenStart + 1);
          }

          break;
        }
    }
  }

  var _default$K = defaultRecognizer;

  const atrulePrelude = {
    getNode: _default$K
  };
  var atrulePrelude_1 = atrulePrelude;

  const NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)

  const AMPERSAND = 0x0026; // U+0026 AMPERSAND (&)

  const ASTERISK$1 = 0x002A; // U+002A ASTERISK (*)

  const PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

  const SOLIDUS = 0x002F; // U+002F SOLIDUS (/)

  const FULLSTOP = 0x002E; // U+002E FULL STOP (.)

  const GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)

  const VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

  const TILDE = 0x007E; // U+007E TILDE (~)

  function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== 'Combinator' && next !== null && next.type !== 'Combinator') {
      children.push({
        // FIXME: this.Combinator() should be used instead
        type: 'Combinator',
        loc: null,
        name: ' '
      });
    }
  }

  function getNode() {
    switch (this.tokenType) {
      case types$4.LeftSquareBracket:
        return this.AttributeSelector();

      case types$4.Hash:
        return this.IdSelector();

      case types$4.Colon:
        if (this.lookupType(1) === types$4.Colon) {
          return this.PseudoElementSelector();
        } else {
          return this.PseudoClassSelector();
        }

      case types$4.Ident:
        return this.TypeSelector();

      case types$4.Number:
      case types$4.Percentage:
        return this.Percentage();

      case types$4.Dimension:
        // throws when .123ident
        if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
          this.error('Identifier is expected', this.tokenStart + 1);
        }

        break;

      case types$4.Delim:
        {
          const code = this.charCodeAt(this.tokenStart);

          switch (code) {
            case PLUSSIGN:
            case GREATERTHANSIGN:
            case TILDE:
            case SOLIDUS:
              // /deep/
              return this.Combinator();

            case FULLSTOP:
              return this.ClassSelector();

            case ASTERISK$1:
            case VERTICALLINE:
              return this.TypeSelector();

            case NUMBERSIGN:
              return this.IdSelector();

            case AMPERSAND:
              return this.NestingSelector();
          }

          break;
        }
    }
  }

  const Selector$1 = {
    onWhiteSpace,
    getNode
  };
  var selector$2 = Selector$1;

  // expression( <any-value> )

  function expressionFn() {
    return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
  }

  var expression = expressionFn;

  // var( <ident> , <value>? )


  function varFn() {
    const children = this.createList();
    this.skipSC(); // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer

    children.push(this.Identifier());
    this.skipSC();

    if (this.tokenType === types$4.Comma) {
      children.push(this.Operator());
      const startIndex = this.tokenIndex;
      const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);

      if (value.type === 'Value' && value.children.isEmpty) {
        for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
          if (this.lookupType(offset) === types$4.WhiteSpace) {
            value.children.appendData({
              type: 'WhiteSpace',
              loc: null,
              value: ' '
            });
            break;
          }
        }
      }

      children.push(value);
    }

    return children;
  }

  var _var = varFn;

  function isPlusMinusOperator(node) {
    return node !== null && node.type === 'Operator' && (node.value[node.value.length - 1] === '-' || node.value[node.value.length - 1] === '+');
  }

  const value = {
    getNode: _default$K,

    onWhiteSpace(next, children) {
      if (isPlusMinusOperator(next)) {
        next.value = ' ' + next.value;
      }

      if (isPlusMinusOperator(children.last)) {
        children.last.value += ' ';
      }
    },

    'expression': expression,
    'var': _var
  };
  var value_1 = value;

  var AtrulePrelude = atrulePrelude_1;
  var Selector = selector$2;
  var Value = value_1;

  var scope = {
  	AtrulePrelude: AtrulePrelude,
  	Selector: Selector,
  	Value: Value
  };

  const fontFace = {
    parse: {
      prelude: null,

      block() {
        return this.Block(true);
      }

    }
  };
  var fontFace_1 = fontFace;

  const importAtrule = {
    parse: {
      prelude() {
        const children = this.createList();
        this.skipSC();

        switch (this.tokenType) {
          case types$4.String:
            children.push(this.String());
            break;

          case types$4.Url:
          case types$4.Function:
            children.push(this.Url());
            break;

          default:
            this.error('String or url() is expected');
        }

        if (this.lookupNonWSType(0) === types$4.Ident || this.lookupNonWSType(0) === types$4.LeftParenthesis) {
          children.push(this.MediaQueryList());
        }

        return children;
      },

      block: null
    }
  };
  var _import = importAtrule;

  const media = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.MediaQueryList());
      },

      block(isStyleBlock = false) {
        return this.Block(isStyleBlock);
      }

    }
  };
  var media_1 = media;

  const nest = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },

      block() {
        return this.Block(true);
      }

    }
  };
  var nest_1 = nest;

  const page = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },

      block() {
        return this.Block(true);
      }

    }
  };
  var page_1 = page;

  function consumeRaw() {
    return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
  }

  function parentheses() {
    this.skipSC();

    if (this.tokenType === types$4.Ident && this.lookupNonWSType(1) === types$4.Colon) {
      return this.createSingleNodeList(this.Declaration());
    }

    return readSequence.call(this);
  }

  function readSequence() {
    const children = this.createList();
    let child;
    this.skipSC();

    scan: while (!this.eof) {
      switch (this.tokenType) {
        case types$4.Comment:
        case types$4.WhiteSpace:
          this.next();
          continue;

        case types$4.Function:
          child = this.Function(consumeRaw, this.scope.AtrulePrelude);
          break;

        case types$4.Ident:
          child = this.Identifier();
          break;

        case types$4.LeftParenthesis:
          child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
          break;

        default:
          break scan;
      }

      children.push(child);
    }

    return children;
  }

  const supports = {
    parse: {
      prelude() {
        const children = readSequence.call(this);

        if (this.getFirstListNode(children) === null) {
          this.error('Condition is expected');
        }

        return children;
      },

      block(isStyleBlock = false) {
        return this.Block(isStyleBlock);
      }

    }
  };
  var supports_1 = supports;

  const atrule = {
    'font-face': fontFace_1,
    'import': _import,
    media: media_1,
    nest: nest_1,
    page: page_1,
    supports: supports_1
  };
  var atrule_1 = atrule;

  const selectorList = {
    parse() {
      return this.createSingleNodeList(this.SelectorList());
    }

  };
  const selector$1 = {
    parse() {
      return this.createSingleNodeList(this.Selector());
    }

  };
  const identList = {
    parse() {
      return this.createSingleNodeList(this.Identifier());
    }

  };
  const nth = {
    parse() {
      return this.createSingleNodeList(this.Nth());
    }

  };
  const pseudo$1 = {
    'dir': identList,
    'has': selectorList,
    'lang': identList,
    'matches': selectorList,
    'is': selectorList,
    '-moz-any': selectorList,
    '-webkit-any': selectorList,
    'where': selectorList,
    'not': selectorList,
    'nth-child': nth,
    'nth-last-child': nth,
    'nth-last-of-type': nth,
    'nth-of-type': nth,
    'slotted': selector$1,
    'host': selector$1,
    'host-context': selector$1
  };
  var pseudo_1 = pseudo$1;

  var AnPlusB_1 = AnPlusB.parse;
  var Atrule_1 = Atrule.parse;
  var AtrulePrelude_1 = AtrulePrelude$1.parse;
  var AttributeSelector_1 = AttributeSelector.parse;
  var Block_1 = Block.parse;
  var Brackets_1 = Brackets.parse;
  var CDC_1 = CDC.parse;
  var CDO_1 = CDO.parse;
  var ClassSelector_1 = ClassSelector.parse;
  var Combinator_1 = Combinator.parse;
  var Comment_1 = Comment$1.parse;
  var Declaration_1 = Declaration$1.parse;
  var DeclarationList_1 = DeclarationList.parse;
  var Dimension_1 = Dimension.parse;
  var _Function = _Function$2.parse;
  var Hash_1 = Hash.parse;
  var Identifier_1 = Identifier.parse;
  var IdSelector_1 = IdSelector.parse;
  var MediaFeature_1 = MediaFeature$1.parse;
  var MediaQuery_1 = MediaQuery.parse;
  var MediaQueryList_1 = MediaQueryList.parse;
  var NestingSelector_1 = NestingSelector.parse;
  var Nth_1 = Nth.parse;
  var _Number = _Number$2.parse;
  var Operator_1 = Operator.parse;
  var Parentheses_1 = Parentheses.parse;
  var Percentage_1 = Percentage.parse;
  var PseudoClassSelector_1 = PseudoClassSelector.parse;
  var PseudoElementSelector_1 = PseudoElementSelector.parse;
  var Ratio_1 = Ratio.parse;
  var Raw_1 = Raw.parse;
  var Rule_1 = Rule$2.parse;
  var Selector_1 = Selector$2.parse;
  var SelectorList_1 = SelectorList.parse;
  var _String = _String$2.parse;
  var StyleSheet_1 = StyleSheet.parse;
  var TypeSelector_1 = TypeSelector.parse;
  var UnicodeRange_1 = UnicodeRange.parse;
  var Url_1 = Url.parse;
  var Value_1 = Value$1.parse;
  var WhiteSpace_1 = WhiteSpace.parse;

  var indexParse = {
  	AnPlusB: AnPlusB_1,
  	Atrule: Atrule_1,
  	AtrulePrelude: AtrulePrelude_1,
  	AttributeSelector: AttributeSelector_1,
  	Block: Block_1,
  	Brackets: Brackets_1,
  	CDC: CDC_1,
  	CDO: CDO_1,
  	ClassSelector: ClassSelector_1,
  	Combinator: Combinator_1,
  	Comment: Comment_1,
  	Declaration: Declaration_1,
  	DeclarationList: DeclarationList_1,
  	Dimension: Dimension_1,
  	Function: _Function,
  	Hash: Hash_1,
  	Identifier: Identifier_1,
  	IdSelector: IdSelector_1,
  	MediaFeature: MediaFeature_1,
  	MediaQuery: MediaQuery_1,
  	MediaQueryList: MediaQueryList_1,
  	NestingSelector: NestingSelector_1,
  	Nth: Nth_1,
  	Number: _Number,
  	Operator: Operator_1,
  	Parentheses: Parentheses_1,
  	Percentage: Percentage_1,
  	PseudoClassSelector: PseudoClassSelector_1,
  	PseudoElementSelector: PseudoElementSelector_1,
  	Ratio: Ratio_1,
  	Raw: Raw_1,
  	Rule: Rule_1,
  	Selector: Selector_1,
  	SelectorList: SelectorList_1,
  	String: _String,
  	StyleSheet: StyleSheet_1,
  	TypeSelector: TypeSelector_1,
  	UnicodeRange: UnicodeRange_1,
  	Url: Url_1,
  	Value: Value_1,
  	WhiteSpace: WhiteSpace_1
  };

  const config$1 = {
    parseContext: {
      default: 'StyleSheet',
      stylesheet: 'StyleSheet',
      atrule: 'Atrule',

      atrulePrelude(options) {
        return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
      },

      mediaQueryList: 'MediaQueryList',
      mediaQuery: 'MediaQuery',
      rule: 'Rule',
      selectorList: 'SelectorList',
      selector: 'Selector',

      block() {
        return this.Block(true);
      },

      declarationList: 'DeclarationList',
      declaration: 'Declaration',
      value: 'Value'
    },
    scope: scope,
    atrule: atrule_1,
    pseudo: pseudo_1,
    node: indexParse
  };
  var parser$2 = config$1;

  const config = {
    node: node$3
  };
  var walker = config;

  const syntax = create_1({ ...lexer$1,
    ...parser$2,
    ...walker
  });
  var syntax_1 = syntax;

  var name$1 = "css-tree";
  var version$3 = "2.3.1";
  var description$1 = "A tool set for CSS: fast detailed parser (CSS → AST), walker (AST traversal), generator (AST → CSS) and lexer (validation and matching) based on specs and browser implementations";
  var author$1 = "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)";
  var license$1 = "MIT";
  var repository$1 = "csstree/csstree";
  var keywords$2 = [
  	"css",
  	"ast",
  	"tokenizer",
  	"parser",
  	"walker",
  	"lexer",
  	"generator",
  	"utils",
  	"syntax",
  	"validation"
  ];
  var type$1 = "module";
  var module$1 = "./lib/index.js";
  var main$1 = "./cjs/index.cjs";
  var exports$1 = {
  	".": {
  		"import": "./lib/index.js",
  		require: "./cjs/index.cjs"
  	},
  	"./dist/*": "./dist/*.js",
  	"./package.json": "./package.json",
  	"./tokenizer": {
  		"import": "./lib/tokenizer/index.js",
  		require: "./cjs/tokenizer/index.cjs"
  	},
  	"./parser": {
  		"import": "./lib/parser/index.js",
  		require: "./cjs/parser/index.cjs"
  	},
  	"./selector-parser": {
  		"import": "./lib/parser/parse-selector.js",
  		require: "./cjs/parser/parse-selector.cjs"
  	},
  	"./generator": {
  		"import": "./lib/generator/index.js",
  		require: "./cjs/generator/index.cjs"
  	},
  	"./walker": {
  		"import": "./lib/walker/index.js",
  		require: "./cjs/walker/index.cjs"
  	},
  	"./convertor": {
  		"import": "./lib/convertor/index.js",
  		require: "./cjs/convertor/index.cjs"
  	},
  	"./lexer": {
  		"import": "./lib/lexer/index.js",
  		require: "./cjs/lexer/index.cjs"
  	},
  	"./definition-syntax": {
  		"import": "./lib/definition-syntax/index.js",
  		require: "./cjs/definition-syntax/index.cjs"
  	},
  	"./definition-syntax-data": {
  		"import": "./lib/data.js",
  		require: "./cjs/data.cjs"
  	},
  	"./definition-syntax-data-patch": {
  		"import": "./lib/data-patch.js",
  		require: "./cjs/data-patch.cjs"
  	},
  	"./utils": {
  		"import": "./lib/utils/index.js",
  		require: "./cjs/utils/index.cjs"
  	}
  };
  var browser$1 = {
  	"./cjs/data.cjs": "./dist/data.cjs",
  	"./cjs/version.cjs": "./dist/version.cjs",
  	"./lib/data.js": "./dist/data.js",
  	"./lib/version.js": "./dist/version.js"
  };
  var unpkg = "dist/csstree.esm.js";
  var jsdelivr = "dist/csstree.esm.js";
  var scripts$1 = {
  	watch: "npm run build -- --watch",
  	build: "npm run bundle && npm run esm-to-cjs --",
  	"build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
  	bundle: "node scripts/bundle",
  	"bundle-and-test": "npm run bundle && npm run test:dist",
  	"esm-to-cjs": "node scripts/esm-to-cjs.cjs",
  	"esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
  	lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
  	"lint-and-test": "npm run lint && npm test",
  	"update:docs": "node scripts/update-docs",
  	"review:syntax-patch": "node scripts/review-syntax-patch",
  	test: "mocha lib/__tests --reporter ${REPORTER:-progress}",
  	"test:cjs": "mocha cjs/__tests --reporter ${REPORTER:-progress}",
  	"test:dist": "mocha dist/__tests --reporter ${REPORTER:-progress}",
  	coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
  	prepublishOnly: "npm run lint-and-test && npm run build-and-test",
  	hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
  };
  var dependencies$1 = {
  	"mdn-data": "2.0.30",
  	"source-map-js": "^1.0.1"
  };
  var devDependencies$1 = {
  	c8: "^7.12.0",
  	clap: "^2.0.1",
  	esbuild: "^0.14.53",
  	eslint: "^8.4.1",
  	"json-to-ast": "^2.1.0",
  	mocha: "^9.2.2",
  	rollup: "^2.68.0"
  };
  var engines$1 = {
  	node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
  };
  var files$1 = [
  	"data",
  	"dist",
  	"cjs",
  	"!cjs/__tests",
  	"lib",
  	"!lib/__tests"
  ];
  var require$$0$6 = {
  	name: name$1,
  	version: version$3,
  	description: description$1,
  	author: author$1,
  	license: license$1,
  	repository: repository$1,
  	keywords: keywords$2,
  	type: type$1,
  	module: module$1,
  	main: main$1,
  	exports: exports$1,
  	browser: browser$1,
  	unpkg: unpkg,
  	jsdelivr: jsdelivr,
  	scripts: scripts$1,
  	dependencies: dependencies$1,
  	devDependencies: devDependencies$1,
  	engines: engines$1,
  	files: files$1
  };

  const {
    version: version$2
  } = require$$0$6;

  var version_2 = version$2;

  var version_1$1 = {
  	version: version_2
  };

  var _SyntaxError = _SyntaxError$1.SyntaxError;
  var generate_1$1 = generate_1$H.generate;
  var parse_1$7 = parse_1$N.parse;
  var walk_1$1 = walk_1$2.walk;

  var definitionSyntax$1 = {
  	SyntaxError: _SyntaxError,
  	generate: generate_1$1,
  	parse: parse_1$7,
  	walk: walk_1$1
  };

  function clone(node) {
    const result = {};

    for (const key in node) {
      let value = node[key];

      if (value) {
        if (Array.isArray(value) || value instanceof List_1$1.List) {
          value = value.map(clone);
        } else if (value.constructor === Object) {
          value = clone(value);
        }
      }

      result[key] = value;
    }

    return result;
  }

  var clone_2 = clone;

  var clone_1$1 = {
  	clone: clone_2
  };

  const REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

  function decode(str) {
    const end = str.length - 1;
    let decoded = '';

    for (let i = 0; i < str.length; i++) {
      let code = str.charCodeAt(i);

      if (code === REVERSE_SOLIDUS) {
        // special case at the ending
        if (i === end) {
          // if the next input code point is EOF, do nothing
          break;
        }

        code = str.charCodeAt(++i); // consume escaped

        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils$9.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils$9.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          // \r\n
          if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }

    return decoded;
  } // https://drafts.csswg.org/cssom/#serialize-an-identifier
  // § 2.1. Common Serializing Idioms


  function encode(str) {
    let encoded = ''; // If the character is the first character and is a "-" (U+002D),
    // and there is no second character, then the escaped character.
    // Note: That's means a single dash string "-" return as escaped dash,
    // so move the condition out of the main loop

    if (str.length === 1 && str.charCodeAt(0) === 0x002D) {
      return '\\-';
    } // To serialize an identifier means to create a string represented
    // by the concatenation of, for each character of the identifier:


    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i); // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).

      if (code === 0x0000) {
        encoded += '\uFFFD';
        continue;
      }

      if ( // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
      // Note: Do not compare with 0x0001 since 0x0000 is precessed before
      code <= 0x001F || code === 0x007F || // [or] ... is in the range [0-9] (U+0030 to U+0039),
      code >= 0x0030 && code <= 0x0039 && ( // If the character is the first character ...
      i === 0 || // If the character is the second character ... and the first character is a "-" (U+002D)
      i === 1 && str.charCodeAt(0) === 0x002D)) {
        // ... then the character escaped as code point.
        encoded += '\\' + code.toString(16) + ' ';
        continue;
      } // If the character is not handled by one of the above rules and is greater
      // than or equal to U+0080, is "-" (U+002D) or "_" (U+005F), or is in one
      // of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A),
      // or \[a-z] (U+0061 to U+007A), then the character itself.


      if (charCodeDefinitions.isName(code)) {
        encoded += str.charAt(i);
      } else {
        // Otherwise, the escaped character.
        encoded += '\\' + str.charAt(i);
      }
    }

    return encoded;
  }

  var decode_1 = decode;
  var encode_1 = encode;

  var ident = {
  	decode: decode_1,
  	encode: encode_1
  };

  const {
    tokenize: tokenize$7,
    parse: parse$d,
    generate,
    lexer,
    createLexer,
    walk,
    find: find$1,
    findLast,
    findAll,
    toPlainObject,
    fromPlainObject,
    fork: fork$1
  } = syntax_1;
  var version_1 = version_1$1.version;
  var createSyntax = create_1;
  var List_1 = List_1$1.List;
  var Lexer_1 = Lexer_1$1.Lexer;
  var definitionSyntax = definitionSyntax$1;
  var clone_1 = clone_1$1.clone;
  var isCustomProperty = names.isCustomProperty;
  var keyword$1 = names.keyword;
  var property = names.property;
  var vendorPrefix = names.vendorPrefix;
  var ident_1 = ident;
  var string_1 = string$3;
  var url_1 = url;
  var tokenTypes$1 = types$4;
  var tokenNames = names$1;
  var TokenStream_1 = TokenStream_1$2.TokenStream;
  var createLexer_1 = createLexer;
  var find_1 = find$1;
  var findAll_1 = findAll;
  var findLast_1 = findLast;
  var fork_1 = fork$1;
  var fromPlainObject_1 = fromPlainObject;
  var generate_1 = generate;
  var lexer_1 = lexer;
  var parse_1$6 = parse$d;
  var toPlainObject_1 = toPlainObject;
  var tokenize_1$1 = tokenize$7;
  var walk_1 = walk;

  var cjs$3 = {
  	version: version_1,
  	createSyntax: createSyntax,
  	List: List_1,
  	Lexer: Lexer_1,
  	definitionSyntax: definitionSyntax,
  	clone: clone_1,
  	isCustomProperty: isCustomProperty,
  	keyword: keyword$1,
  	property: property,
  	vendorPrefix: vendorPrefix,
  	ident: ident_1,
  	string: string_1,
  	url: url_1,
  	tokenTypes: tokenTypes$1,
  	tokenNames: tokenNames,
  	TokenStream: TokenStream_1,
  	createLexer: createLexer_1,
  	find: find_1,
  	findAll: findAll_1,
  	findLast: findLast_1,
  	fork: fork_1,
  	fromPlainObject: fromPlainObject_1,
  	generate: generate_1,
  	lexer: lexer_1,
  	parse: parse_1$6,
  	toPlainObject: toPlainObject_1,
  	tokenize: tokenize_1$1,
  	walk: walk_1
  };

  const {
    parse: parse$c,
    List
  } = cjs$3;

















  const {
    isRegExp: isRegExp$Q,
    isString: isString$10
  } = validateTypes;



  const ruleName$2v = 'declaration-block-no-duplicate-properties';
  const messages$2v = ruleMessages$1(ruleName$2v, {
    rejected: property => `Unexpected duplicate "${property}"`
  });
  const meta$2v = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-no-duplicate-properties',
    fixable: true
  };
  /** @typedef {import('css-tree').CssNode} CssNode */

  /** @type {(node: CssNode) => node is CssNode & { children: List<CssNode> }} */

  const hasChildren = node => 'children' in node && node.children instanceof List;
  /** @type {(node1: CssNode[], node2: CssNode[]) => boolean} */


  const isEqualValueNodes = (nodes1, nodes2) => {
    // Different lengths indicate different syntaxes.
    if (nodes1.length !== nodes2.length) {
      return false;
    }

    for (let i = 0; i < nodes1.length; i++) {
      const node1 = nodes1[i];
      const node2 = nodes2[i]; // Different types indicate different syntaxes.

      if (typeof node1 === 'undefined' || typeof node2 === 'undefined' || node1.type !== node2.type) {
        return false;
      }

      const node1Name = 'name' in node1 ? String(node1.name) : '';
      const node2Name = 'name' in node2 ? String(node2.name) : ''; // Custom properties have unknown value syntaxes but are equal for CSS parsers.

      if (node1.type === 'Identifier' && isCustomProperty$2(node1Name) && node2.type === 'Identifier' && isCustomProperty$2(node2Name)) {
        continue;
      } // Different ident or function names indicate different syntaxes.


      if (node1Name.toLowerCase() !== node2Name.toLowerCase()) {
        return false;
      }

      const node1Unit = 'unit' in node1 ? node1.unit : '';
      const node2Unit = 'unit' in node2 ? node2.unit : ''; // Different units indicate different syntaxes.

      if (node1Unit !== node2Unit) {
        return false;
      }

      const node1Children = hasChildren(node1) ? node1.children.toArray() : null;
      const node2Children = hasChildren(node2) ? node2.children.toArray() : null;

      if (Array.isArray(node1Children) && Array.isArray(node2Children)) {
        if (isEqualValueNodes(node1Children, node2Children)) {
          continue;
        } else {
          return false;
        }
      }
    }

    return true;
  };
  /** @type {(value1: string, value2: string) => boolean} */


  const isEqualValueSyntaxes = (value1, value2) => {
    if (value1 === value2) {
      return true;
    }

    if (!(isStandardSyntaxValue(value1) && isStandardSyntaxValue(value2))) {
      return false;
    }

    let value1Node;
    let value2Node;

    try {
      value1Node = parse$c(value1, {
        context: 'value'
      });
      value2Node = parse$c(value2, {
        context: 'value'
      });
    } catch (error) {
      return false;
    }

    const node1Children = hasChildren(value1Node) ? value1Node.children.toArray() : [];
    const node2Children = hasChildren(value2Node) ? value2Node.children.toArray() : [];
    return isEqualValueNodes(node1Children, node2Children);
  };
  /** @type {import('stylelint').Rule} */


  const rule$2v = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2v, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['consecutive-duplicates', 'consecutive-duplicates-with-different-values', 'consecutive-duplicates-with-different-syntaxes', 'consecutive-duplicates-with-same-prefixless-values'],
          ignoreProperties: [isString$10, isRegExp$Q]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const ignoreDuplicates = optionsMatches(secondaryOptions, 'ignore', 'consecutive-duplicates');
      const ignoreDiffValues = optionsMatches(secondaryOptions, 'ignore', 'consecutive-duplicates-with-different-values');
      const ignoreDiffSyntaxes = optionsMatches(secondaryOptions, 'ignore', 'consecutive-duplicates-with-different-syntaxes');
      const ignorePrefixlessSameValues = optionsMatches(secondaryOptions, 'ignore', 'consecutive-duplicates-with-same-prefixless-values');
      eachDeclarationBlock(root, eachDecl => {
        /** @type {import('postcss').Declaration[]} */
        const decls = [];
        eachDecl(decl => {
          const prop = decl.prop;
          const lowerProp = decl.prop.toLowerCase();
          const value = decl.value;
          const important = decl.important;

          if (!isStandardSyntaxProperty(prop)) {
            return;
          }

          if (isCustomProperty$2(prop)) {
            return;
          } // Return early if the property is to be ignored


          if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
            return;
          } // Ignore the src property as commonly duplicated in at-fontface


          if (lowerProp === 'src') {
            return;
          }

          const indexDuplicate = decls.findIndex(d => d.prop.toLowerCase() === lowerProp);

          if (indexDuplicate === -1) {
            decls.push(decl);
          }

          const duplicateDecl = decls[indexDuplicate];

          if (!duplicateDecl) {
            return;
          }

          const duplicateValue = duplicateDecl.value || '';
          const duplicateImportant = duplicateDecl.important || false;
          const duplicateIsMoreImportant = !important && duplicateImportant;
          const duplicatesAreConsecutive = indexDuplicate === decls.length - 1;
          const unprefixedDuplicatesAreEqual = vendor.unprefixed(value) === vendor.unprefixed(duplicateValue);

          const fixOrReport = () => {
            if (!context.fix) {
              return report$1({
                message: messages$2v.rejected,
                messageArgs: [prop],
                node: decl,
                result,
                ruleName: ruleName$2v,
                word: prop
              });
            }

            if (duplicateIsMoreImportant) {
              return decl.remove();
            } // replace previous "active" decl with current one


            decls[indexDuplicate] = decl;
            return duplicateDecl.remove();
          };

          if (ignoreDiffValues || ignoreDiffSyntaxes || ignorePrefixlessSameValues) {
            if (!duplicatesAreConsecutive || ignorePrefixlessSameValues && !unprefixedDuplicatesAreEqual) {
              fixOrReport();
              return;
            }

            if (ignoreDiffSyntaxes) {
              const duplicateValueSyntaxesAreEqual = isEqualValueSyntaxes(value, duplicateValue);

              if (duplicateValueSyntaxesAreEqual) {
                fixOrReport();
                return;
              }
            }

            if (value !== duplicateValue) {
              return;
            }

            if (context.fix) {
              return duplicateDecl.remove();
            }

            return report$1({
              message: messages$2v.rejected,
              messageArgs: [prop],
              node: decl,
              result,
              ruleName: ruleName$2v,
              word: prop
            });
          }

          if (ignoreDuplicates && duplicatesAreConsecutive) {
            return;
          }

          fixOrReport();
        });
      });
    };
  };

  rule$2v.ruleName = ruleName$2v;
  rule$2v.messages = messages$2v;
  rule$2v.meta = meta$2v;
  var declarationBlockNoDuplicateProperties = rule$2v;

  const {
    basicKeywords: basicKeywords$2
  } = keywords$4;









  const {
    longhandSubPropertiesOfShorthandProperties: longhandSubPropertiesOfShorthandProperties$2
  } = properties$4;





  const {
    isRegExp: isRegExp$P,
    isString: isString$$
  } = validateTypes;

  const ruleName$2u = 'declaration-block-no-redundant-longhand-properties';
  const messages$2u = ruleMessages$1(ruleName$2u, {
    expected: props => `Expected shorthand property "${props}"`
  });
  const meta$2u = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-no-redundant-longhand-properties',
    fixable: true
  };
  /** @typedef {import('postcss').Declaration} Declaration */

  /** @type {Map<string, (decls: Map<string, Declaration>) => (string | undefined)>} */

  const customResolvers = new Map([['grid-column', decls => {
    const start = decls.get('grid-column-start')?.value.trim();
    const end = decls.get('grid-column-end')?.value.trim();
    if (!start || !end) return;
    return `${start} / ${end}`;
  }], ['grid-row', decls => {
    const start = decls.get('grid-row-start')?.value.trim();
    const end = decls.get('grid-row-end')?.value.trim();
    if (!start || !end) return;
    return `${start} / ${end}`;
  }], ['grid-template', decls => {
    const areas = decls.get('grid-template-areas')?.value.trim();
    const columns = decls.get('grid-template-columns')?.value.trim();
    const rows = decls.get('grid-template-rows')?.value.trim();
    if (!(areas && columns && rows)) return;
    const splitAreas = [...areas.matchAll(/"[^"]+"/g)].map(x => x[0]);
    const splitRows = rows.split(' ');
    if (splitAreas.length === 0 || splitRows.length === 0) return;
    if (splitAreas.length !== splitRows.length) return;
    const zipped = splitAreas.map((area, i) => `${area} ${splitRows[i]}`).join(' ');
    return `${zipped} / ${columns}`;
  }], ['transition', decls => {
    /** @type {(input: string | undefined) => string[]} */
    const commaSeparated = (input = '') => {
      let trimmedInput = input.trim();
      if (!trimmedInput) return [];
      if (trimmedInput.indexOf(',') === -1) return [trimmedInput];
      /** @type {import('postcss-value-parser').ParsedValue} */

      let parsedValue = lib$6(trimmedInput);
      /** @type {Array<Array<import('postcss-value-parser').Node>>} */

      let valueParts = [];
      {
        /** @type {Array<import('postcss-value-parser').Node>} */
        let currentListItem = [];
        parsedValue.nodes.forEach(node => {
          if (node.type === 'div' && node.value === ',') {
            valueParts.push(currentListItem);
            currentListItem = [];
            return;
          }

          currentListItem.push(node);
        });
        valueParts.push(currentListItem);
      }
      return valueParts.map(s => lib$6.stringify(s).trim()).filter(s => s.length > 0);
    };

    const delays = commaSeparated(decls.get('transition-delay')?.value);
    const durations = commaSeparated(decls.get('transition-duration')?.value);
    const timingFunctions = commaSeparated(decls.get('transition-timing-function')?.value);
    const properties = commaSeparated(decls.get('transition-property')?.value);

    if (!(delays.length && durations.length && timingFunctions.length && properties.length)) {
      return;
    } // transition-property is the canonical list of the number of properties;
    // see spec: https://w3c.github.io/csswg-drafts/css-transitions/#transition-property-property
    // if there are more transition-properties than duration/delay/timings,
    // the other properties are computed cyclically -- ex with %
    // see spec example #3: https://w3c.github.io/csswg-drafts/css-transitions/#example-d94cbd75


    return properties.map((property, i) => {
      return [property, durations[i % durations.length], timingFunctions[i % timingFunctions.length], delays[i % delays.length]].filter(isString$$).join(' ');
    }).join(', ');
  }]]);
  /**
   * @param {string} prefixedShorthandProperty
   * @param {string[]} prefixedShorthandData
   * @param {Map<string, Declaration>} transformedDeclarationNodes
   * @returns {string | undefined}
   */

  const resolveShorthandValue = (prefixedShorthandProperty, prefixedShorthandData, transformedDeclarationNodes) => {
    const resolver = customResolvers.get(prefixedShorthandProperty);

    if (resolver === undefined) {
      // the "default" resolver: sort the longhand values in the order
      // of their properties
      const values = prefixedShorthandData.map(p => transformedDeclarationNodes.get(p)?.value.trim()).filter(Boolean);
      return values.length > 0 ? values.join(' ') : undefined;
    }

    return resolver(transformedDeclarationNodes);
  };
  /** @type {import('stylelint').Rule} */


  const rule$2u = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2u, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreShorthands: [isString$$, isRegExp$P]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<string, import('stylelint').ShorthandProperties[]>} */


      const longhandToShorthands = new Map();

      for (const [shorthand, longhandProps] of longhandSubPropertiesOfShorthandProperties$2.entries()) {
        if (optionsMatches(secondaryOptions, 'ignoreShorthands', shorthand)) {
          continue;
        }

        for (const longhand of longhandProps) {
          const shorthands = longhandToShorthands.get(longhand) || [];
          shorthands.push(shorthand);
          longhandToShorthands.set(longhand, shorthands);
        }
      }

      eachDeclarationBlock(root, eachDecl => {
        /** @type {Map<string, string[]>} */
        const longhandDeclarations = new Map();
        /** @type {Map<string, Declaration[]>} */

        const longhandDeclarationNodes = new Map();
        eachDecl(decl => {
          // basic keywords are not allowed in shorthand properties
          if (basicKeywords$2.has(decl.value)) {
            return;
          }

          const prop = decl.prop.toLowerCase();
          const unprefixedProp = vendor.unprefixed(prop);
          const prefix = vendor.prefix(prop);
          const shorthandProperties = longhandToShorthands.get(unprefixedProp);

          if (!shorthandProperties) {
            return;
          }

          for (const shorthandProperty of shorthandProperties) {
            const prefixedShorthandProperty = prefix + shorthandProperty;
            const longhandDeclaration = longhandDeclarations.get(prefixedShorthandProperty) || [];
            const longhandDeclarationNode = longhandDeclarationNodes.get(prefixedShorthandProperty) || [];
            longhandDeclaration.push(prop);
            longhandDeclarations.set(prefixedShorthandProperty, longhandDeclaration);
            longhandDeclarationNode.push(decl);
            longhandDeclarationNodes.set(prefixedShorthandProperty, longhandDeclarationNode);
            const shorthandProps = longhandSubPropertiesOfShorthandProperties$2.get(shorthandProperty);
            const prefixedShorthandData = Array.from(shorthandProps || []).map(item => prefix + item);
            const copiedPrefixedShorthandData = [...prefixedShorthandData];

            if (!arrayEqual(copiedPrefixedShorthandData.sort(), longhandDeclaration.sort())) {
              continue;
            }

            if (context.fix) {
              const declNodes = longhandDeclarationNodes.get(prefixedShorthandProperty) || [];
              const [firstDeclNode] = declNodes;

              if (firstDeclNode) {
                const transformedDeclarationNodes = new Map(declNodes.map(d => [d.prop.toLowerCase(), d]));
                const resolvedShorthandValue = resolveShorthandValue(prefixedShorthandProperty, prefixedShorthandData, transformedDeclarationNodes);

                if (resolvedShorthandValue) {
                  const newShorthandDeclarationNode = firstDeclNode.clone({
                    prop: prefixedShorthandProperty,
                    value: resolvedShorthandValue
                  });
                  firstDeclNode.replaceWith(newShorthandDeclarationNode);
                  declNodes.forEach(node => node.remove());
                  return;
                }
              }
            }

            report$1({
              ruleName: ruleName$2u,
              result,
              node: decl,
              word: decl.prop,
              message: messages$2u.expected,
              messageArgs: [prefixedShorthandProperty]
            });
          }
        });
      });
    };
  };

  rule$2u.ruleName = ruleName$2u;
  rule$2u.messages = messages$2u;
  rule$2u.meta = meta$2u;
  var declarationBlockNoRedundantLonghandProperties = rule$2u;

  const {
    longhandSubPropertiesOfShorthandProperties: longhandSubPropertiesOfShorthandProperties$1
  } = properties$4;





  const ruleName$2t = 'declaration-block-no-shorthand-property-overrides';
  const messages$2t = ruleMessages$1(ruleName$2t, {
    rejected: (shorthand, original) => `Unexpected shorthand "${shorthand}" after "${original}"`
  });
  const meta$2t = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-no-shorthand-property-overrides'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2t = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2t, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      eachDeclarationBlock(root, eachDecl => {
        /** @type {Map<string, string>} */
        const declarations = new Map();
        eachDecl(decl => {
          const prop = decl.prop;
          const unprefixedProp = vendor.unprefixed(prop).toLowerCase();
          const prefix = vendor.prefix(prop).toLowerCase();
          const overrideables =
          /** @type {Map<string, Set<string>>} */
          longhandSubPropertiesOfShorthandProperties$1.get(unprefixedProp);

          if (!overrideables) {
            declarations.set(prop.toLowerCase(), prop);
            return;
          }

          for (const longhandProp of overrideables) {
            const declaration = declarations.get(prefix + longhandProp);

            if (!declaration) {
              continue;
            }

            report$1({
              ruleName: ruleName$2t,
              result,
              node: decl,
              message: messages$2t.rejected,
              messageArgs: [prop, declaration || ''],
              word: prop
            });
          }
        });
      });
    };
  };

  rule$2t.ruleName = ruleName$2t;
  rule$2t.messages = messages$2t;
  rule$2t.meta = meta$2t;
  var declarationBlockNoShorthandPropertyOverrides = rule$2t;

  const {
    isAtRule: isAtRule$k,
    isRule: isRule$a
  } = typeGuards;

  const ruleName$2s = 'declaration-block-semicolon-newline-after';
  const messages$2s = ruleMessages$1(ruleName$2s, {
    expectedAfter: () => 'Expected newline after ";"',
    expectedAfterMultiLine: () => 'Expected newline after ";" in a multi-line declaration block',
    rejectedAfterMultiLine: () => 'Unexpected newline after ";" in a multi-line declaration block'
  });
  const meta$2s = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-semicolon-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2s = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$2s);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2s, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        // Ignore last declaration if there's no trailing semicolon
        const parentRule = decl.parent;
        if (!parentRule) throw new Error('A parent node must be present');

        if (!isAtRule$k(parentRule) && !isRule$a(parentRule)) {
          return;
        }

        if (!parentRule.raws.semicolon && parentRule.last === decl) {
          return;
        }

        const nextNode = decl.next();

        if (!nextNode) {
          return;
        } // Allow end-of-line comment


        const nodeToCheck = nextNonCommentNode(nextNode);

        if (!nodeToCheck) {
          return;
        }

        checker.afterOneOnly({
          source: rawNodeString(nodeToCheck),
          index: -1,
          lineCheckStr: blockString(parentRule),
          err: m => {
            if (context.fix) {
              if (primary.startsWith('always')) {
                const index = nodeToCheck.raws.before.search(/\r?\n/);
                nodeToCheck.raws.before = index >= 0 ? nodeToCheck.raws.before.slice(index) : context.newline + nodeToCheck.raws.before;
                return;
              }

              if (primary === 'never-multi-line') {
                nodeToCheck.raws.before = '';
                return;
              }
            }

            report$1({
              message: m,
              node: decl,
              index: decl.toString().length + 1,
              result,
              ruleName: ruleName$2s
            });
          }
        });
      });
    };
  };

  rule$2s.ruleName = ruleName$2s;
  rule$2s.messages = messages$2s;
  rule$2s.meta = meta$2s;
  var declarationBlockSemicolonNewlineAfter = rule$2s;

  const {
    isAtRule: isAtRule$j,
    isRule: isRule$9
  } = typeGuards;

  const ruleName$2r = 'declaration-block-semicolon-newline-before';
  const messages$2r = ruleMessages$1(ruleName$2r, {
    expectedBefore: () => 'Expected newline before ";"',
    expectedBeforeMultiLine: () => 'Expected newline before ";" in a multi-line declaration block',
    rejectedBeforeMultiLine: () => 'Unexpected whitespace before ";" in a multi-line declaration block'
  });
  const meta$2r = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-semicolon-newline-before',
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2r = primary => {
    const checker = whitespaceChecker('newline', primary, messages$2r);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2r, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const parentRule = decl.parent;
        if (!parentRule) throw new Error('A parent node must be present');

        if (!isAtRule$j(parentRule) && !isRule$9(parentRule)) {
          return;
        }

        if (!parentRule.raws.semicolon && parentRule.last === decl) {
          return;
        }

        const declString = decl.toString();
        checker.beforeAllowingIndentation({
          source: declString,
          index: declString.length,
          lineCheckStr: blockString(parentRule),
          err: m => {
            report$1({
              message: m,
              node: decl,
              index: decl.toString().length - 1,
              result,
              ruleName: ruleName$2r
            });
          }
        });
      });
    };
  };

  rule$2r.ruleName = ruleName$2r;
  rule$2r.messages = messages$2r;
  rule$2r.meta = meta$2r;
  var declarationBlockSemicolonNewlineBefore = rule$2r;

  const {
    isAtRule: isAtRule$i,
    isRule: isRule$8
  } = typeGuards;

  const ruleName$2q = 'declaration-block-semicolon-space-after';
  const messages$2q = ruleMessages$1(ruleName$2q, {
    expectedAfter: () => 'Expected single space after ";"',
    rejectedAfter: () => 'Unexpected whitespace after ";"',
    expectedAfterSingleLine: () => 'Expected single space after ";" in a single-line declaration block',
    rejectedAfterSingleLine: () => 'Unexpected whitespace after ";" in a single-line declaration block'
  });
  const meta$2q = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-semicolon-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2q = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2q);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2q, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        // Ignore last declaration if there's no trailing semicolon
        const parentRule = decl.parent;
        if (!parentRule) throw new Error('A parent node must be present');

        if (!isAtRule$i(parentRule) && !isRule$8(parentRule)) {
          return;
        }

        if (!parentRule.raws.semicolon && parentRule.last === decl) {
          return;
        }

        const nextDecl = decl.next();

        if (!nextDecl) {
          return;
        }

        checker.after({
          source: rawNodeString(nextDecl),
          index: -1,
          lineCheckStr: blockString(parentRule),
          err: m => {
            if (context.fix) {
              if (primary.startsWith('always')) {
                nextDecl.raws.before = ' ';
                return;
              }

              if (primary.startsWith('never')) {
                nextDecl.raws.before = '';
                return;
              }
            }

            report$1({
              message: m,
              node: decl,
              index: decl.toString().length + 1,
              result,
              ruleName: ruleName$2q
            });
          }
        });
      });
    };
  };

  rule$2q.ruleName = ruleName$2q;
  rule$2q.messages = messages$2q;
  rule$2q.meta = meta$2q;
  var declarationBlockSemicolonSpaceAfter = rule$2q;

  const {
    isAtRule: isAtRule$h,
    isRule: isRule$7
  } = typeGuards;

  const ruleName$2p = 'declaration-block-semicolon-space-before';
  const messages$2p = ruleMessages$1(ruleName$2p, {
    expectedBefore: () => 'Expected single space before ";"',
    rejectedBefore: () => 'Unexpected whitespace before ";"',
    expectedBeforeSingleLine: () => 'Expected single space before ";" in a single-line declaration block',
    rejectedBeforeSingleLine: () => 'Unexpected whitespace before ";" in a single-line declaration block'
  });
  const meta$2p = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-semicolon-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2p = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2p);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2p, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        // Ignore last declaration if there's no trailing semicolon
        const parentRule = decl.parent;
        if (!parentRule) throw new Error('A parent node must be present');

        if (!isAtRule$h(parentRule) && !isRule$7(parentRule)) {
          return;
        }

        if (!parentRule.raws.semicolon && parentRule.last === decl) {
          return;
        }

        const declString = decl.toString();
        checker.before({
          source: declString,
          index: declString.length,
          lineCheckStr: blockString(parentRule),
          err: m => {
            if (context.fix) {
              const value = getDeclarationValue(decl);

              if (primary.startsWith('always')) {
                if (decl.important) {
                  decl.raws.important = ' !important ';
                } else {
                  setDeclarationValue(decl, value.replace(/\s*$/, ' '));
                }

                return;
              }

              if (primary.startsWith('never')) {
                if (decl.raws.important) {
                  decl.raws.important = decl.raws.important.replace(/\s*$/, '');
                } else {
                  setDeclarationValue(decl, value.replace(/\s*$/, ''));
                }

                return;
              }
            }

            report$1({
              message: m,
              node: decl,
              index: decl.toString().length - 1,
              result,
              ruleName: ruleName$2p
            });
          }
        });
      });
    };
  };

  rule$2p.ruleName = ruleName$2p;
  rule$2p.messages = messages$2p;
  rule$2p.meta = meta$2p;
  var declarationBlockSemicolonSpaceBefore = rule$2p;

  const {
    isNumber: isNumber$e
  } = validateTypes;

  const ruleName$2o = 'declaration-block-single-line-max-declarations';
  const messages$2o = ruleMessages$1(ruleName$2o, {
    expected: max => `Expected no more than ${max} ${max === 1 ? 'declaration' : 'declarations'}`
  });
  const meta$2o = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-single-line-max-declarations'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2o = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2o, {
        actual: primary,
        possible: [isNumber$e]
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        const block = blockString(ruleNode);

        if (!isSingleLineString(block)) {
          return;
        }

        if (!ruleNode.nodes) {
          return;
        }

        const decls = ruleNode.nodes.filter(node => node.type === 'decl');

        if (decls.length <= primary) {
          return;
        }

        report$1({
          message: messages$2o.expected,
          messageArgs: [primary],
          node: ruleNode,
          word: block,
          result,
          ruleName: ruleName$2o
        });
      });
    };
  };

  rule$2o.ruleName = ruleName$2o;
  rule$2o.messages = messages$2o;
  rule$2o.meta = meta$2o;
  var declarationBlockSingleLineMaxDeclarations = rule$2o;

  const {
    isAtRule: isAtRule$g
  } = typeGuards;



  const ruleName$2n = 'declaration-block-trailing-semicolon';
  const messages$2n = ruleMessages$1(ruleName$2n, {
    expected: 'Expected a trailing semicolon',
    rejected: 'Unexpected trailing semicolon'
  });
  const meta$2n = {
    url: 'https://stylelint.io/user-guide/rules/declaration-block-trailing-semicolon',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2n = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2n, {
        actual: primary,
        possible: ['always', 'never']
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['single-declaration']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(atRule => {
        if (!atRule.parent) throw new Error('A parent node must be present');

        if (atRule.parent === root) {
          return;
        }

        if (atRule !== atRule.parent.last) {
          return;
        }

        if (hasBlock(atRule)) {
          return;
        }

        checkLastNode(atRule);
      });
      root.walkDecls(decl => {
        if (!decl.parent) throw new Error('A parent node must be present');

        if (decl.parent.type === 'object') {
          return;
        }

        if (decl !== decl.parent.last) {
          return;
        }

        checkLastNode(decl);
      });
      /**
       * @param {import('postcss').Node} node
       */

      function checkLastNode(node) {
        if (!node.parent) throw new Error('A parent node must be present');
        const hasSemicolon = node.parent.raws.semicolon;
        const ignoreSingleDeclaration = optionsMatches(secondaryOptions, 'ignore', 'single-declaration');

        if (ignoreSingleDeclaration && node.parent.first === node) {
          return;
        }

        let message;

        if (primary === 'always') {
          if (hasSemicolon) {
            return;
          } // auto-fix


          if (context.fix) {
            node.parent.raws.semicolon = true;

            if (isAtRule$g(node)) {
              node.raws.between = '';
              node.parent.raws.after = ' ';
            }

            return;
          }

          message = messages$2n.expected;
        } else if (primary === 'never') {
          if (!hasSemicolon) {
            return;
          } // auto-fix


          if (context.fix) {
            node.parent.raws.semicolon = false;
            return;
          }

          message = messages$2n.rejected;
        } else {
          throw new Error(`Unexpected primary option: "${primary}"`);
        }

        report$1({
          message,
          node,
          index: node.toString().trim().length - 1,
          result,
          ruleName: ruleName$2n
        });
      }
    };
  };

  rule$2n.ruleName = ruleName$2n;
  rule$2n.messages = messages$2n;
  rule$2n.meta = meta$2n;
  var declarationBlockTrailingSemicolon = rule$2n;

  const ruleName$2m = 'declaration-colon-newline-after';
  const messages$2m = ruleMessages$1(ruleName$2m, {
    expectedAfter: () => 'Expected newline after ":"',
    expectedAfterMultiLine: () => 'Expected newline after ":" with a multi-line declaration'
  });
  const meta$2m = {
    url: 'https://stylelint.io/user-guide/rules/declaration-colon-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2m = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$2m);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2m, {
        actual: primary,
        possible: ['always', 'always-multi-line']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!isStandardSyntaxDeclaration(decl)) {
          return;
        } // Get the raw prop, and only the prop


        const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1; // The extra characters tacked onto the end ensure that there is a character to check
        // after the colon. Otherwise, with `background:pink` the character after the

        const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;

        for (let i = 0, l = propPlusColon.length; i < l; i++) {
          if (propPlusColon[i] !== ':') {
            continue;
          }

          const indexToCheck = /^[^\S\r\n]*\/\*/.test(propPlusColon.slice(i + 1)) ? propPlusColon.indexOf('*/', i) + 1 : i;
          checker.afterOneOnly({
            source: propPlusColon,
            index: indexToCheck,
            lineCheckStr: decl.value,
            err: m => {
              if (context.fix) {
                const between = decl.raws.between;
                if (between == null) throw new Error('`between` must be present');
                const betweenStart = declarationValueIndex(decl) - between.length;
                const sliceIndex = indexToCheck - betweenStart + 1;
                const betweenBefore = between.slice(0, sliceIndex);
                const betweenAfter = between.slice(sliceIndex);
                decl.raws.between = /^\s*\n/.test(betweenAfter) ? betweenBefore + betweenAfter.replace(/^[^\S\r\n]*/, '') : betweenBefore + context.newline + betweenAfter;
                return;
              }

              report$1({
                message: m,
                node: decl,
                index: indexToCheck,
                result,
                ruleName: ruleName$2m
              });
            }
          });
        }
      });
    };
  };

  rule$2m.ruleName = ruleName$2m;
  rule$2m.messages = messages$2m;
  rule$2m.meta = meta$2m;
  var declarationColonNewlineAfter = rule$2m;

  /** @typedef {(args: { source: string, index: number, lineCheckStr: string, err: (message: string) => void }) => void} LocationChecker */

  /**
   * @param {{
   *   root: import('postcss').Root,
   *   locationChecker: LocationChecker,
   *   fix: ((decl: import('postcss').Declaration, index: number) => boolean) | null,
   *   result: import('stylelint').PostcssResult,
   *   checkedRuleName: string,
   * }} opts
   */


  var declarationColonSpaceChecker = function declarationColonSpaceChecker(opts) {
    opts.root.walkDecls(decl => {
      if (!isStandardSyntaxDeclaration(decl)) {
        return;
      } // Get the raw prop, and only the prop


      const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1; // The extra characters tacked onto the end ensure that there is a character to check
      // after the colon. Otherwise, with `background:pink` the character after the

      const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;

      for (let i = 0, l = propPlusColon.length; i < l; i++) {
        if (propPlusColon[i] !== ':') {
          continue;
        }

        opts.locationChecker({
          source: propPlusColon,
          index: i,
          lineCheckStr: decl.value,
          err: message => {
            if (opts.fix && opts.fix(decl, i)) {
              return;
            }

            report$1({
              message,
              node: decl,
              index: decl.prop.toString().length + 1,
              result: opts.result,
              ruleName: opts.checkedRuleName
            });
          }
        });
        break;
      }
    });
  };

  const ruleName$2l = 'declaration-colon-space-after';
  const messages$2l = ruleMessages$1(ruleName$2l, {
    expectedAfter: () => 'Expected single space after ":"',
    rejectedAfter: () => 'Unexpected whitespace after ":"',
    expectedAfterSingleLine: () => 'Expected single space after ":" with a single-line declaration'
  });
  const meta$2l = {
    url: 'https://stylelint.io/user-guide/rules/declaration-colon-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2l = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2l);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2l, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line']
      });

      if (!validOptions) {
        return;
      }

      declarationColonSpaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$2l,
        fix: context.fix ? (decl, index) => {
          const colonIndex = index - declarationValueIndex(decl);
          const between = decl.raws.between;
          if (between == null) throw new Error('`between` must be present');

          if (primary.startsWith('always')) {
            decl.raws.between = between.slice(0, colonIndex) + between.slice(colonIndex).replace(/^:\s*/, ': ');
            return true;
          }

          if (primary === 'never') {
            decl.raws.between = between.slice(0, colonIndex) + between.slice(colonIndex).replace(/^:\s*/, ':');
            return true;
          }

          return false;
        } : null
      });
    };
  };

  rule$2l.ruleName = ruleName$2l;
  rule$2l.messages = messages$2l;
  rule$2l.meta = meta$2l;
  var declarationColonSpaceAfter = rule$2l;

  const ruleName$2k = 'declaration-colon-space-before';
  const messages$2k = ruleMessages$1(ruleName$2k, {
    expectedBefore: () => 'Expected single space before ":"',
    rejectedBefore: () => 'Unexpected whitespace before ":"'
  });
  const meta$2k = {
    url: 'https://stylelint.io/user-guide/rules/declaration-colon-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2k = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$2k);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2k, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      declarationColonSpaceChecker({
        root,
        result,
        locationChecker: checker.before,
        checkedRuleName: ruleName$2k,
        fix: context.fix ? (decl, index) => {
          const colonIndex = index - declarationValueIndex(decl);
          const between = decl.raws.between;
          if (between == null) throw new Error('`between` must be present');

          if (primary === 'always') {
            decl.raws.between = between.slice(0, colonIndex).replace(/\s*$/, ' ') + between.slice(colonIndex);
            return true;
          }

          if (primary === 'never') {
            decl.raws.between = between.slice(0, colonIndex).replace(/\s*$/, '') + between.slice(colonIndex);
            return true;
          }

          return false;
        } : null
      });
    };
  };

  rule$2k.ruleName = ruleName$2k;
  rule$2k.messages = messages$2k;
  rule$2k.meta = meta$2k;
  var declarationColonSpaceBefore = rule$2k;

  const {
    isDeclaration: isDeclaration$3
  } = typeGuards;
  /**
   * @param {import('postcss').Node} node
   */


  var isAfterStandardPropertyDeclaration = function isAfterStandardPropertyDeclaration(node) {
    const prevNode = getPreviousNonSharedLineCommentNode(node);
    return prevNode !== undefined && isDeclaration$3(prevNode) && isStandardSyntaxDeclaration(prevNode) && !isCustomProperty$2(prevNode.prop || '');
  };

  const {
    isAtRule: isAtRule$f,
    isRule: isRule$6,
    isRoot: isRoot$2
  } = typeGuards;

  const ruleName$2j = 'declaration-empty-line-before';
  const messages$2j = ruleMessages$1(ruleName$2j, {
    expected: 'Expected empty line before declaration',
    rejected: 'Unexpected empty line before declaration'
  });
  const meta$2j = {
    url: 'https://stylelint.io/user-guide/rules/declaration-empty-line-before',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2j = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2j, {
        actual: primary,
        possible: ['always', 'never']
      }, {
        actual: secondaryOptions,
        possible: {
          except: ['first-nested', 'after-comment', 'after-declaration'],
          ignore: ['after-comment', 'after-declaration', 'first-nested', 'inside-single-line-block']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;
        const parent = decl.parent;

        if (parent == null) {
          return;
        } // Ignore the first node


        if (isFirstNodeOfRoot(decl)) {
          return;
        }

        if (!isAtRule$f(parent) && !isRule$6(parent) && !isRoot$2(parent)) {
          return;
        }

        if (!isStandardSyntaxDeclaration(decl)) {
          return;
        }

        if (isCustomProperty$2(prop)) {
          return;
        } // Optionally ignore the node if a comment precedes it


        if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(decl)) {
          return;
        } // Optionally ignore the node if a declaration precedes it


        if (optionsMatches(secondaryOptions, 'ignore', 'after-declaration') && isAfterStandardPropertyDeclaration(decl)) {
          return;
        } // Optionally ignore the node if it is the first nested


        if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(decl)) {
          return;
        } // Optionally ignore nodes inside single-line blocks


        if (optionsMatches(secondaryOptions, 'ignore', 'inside-single-line-block') && isSingleLineString(blockString(parent))) {
          return;
        }

        let expectEmptyLineBefore = primary === 'always'; // Optionally reverse the expectation if any exceptions apply

        if (optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(decl) || optionsMatches(secondaryOptions, 'except', 'after-comment') && isAfterComment(decl) || optionsMatches(secondaryOptions, 'except', 'after-declaration') && isAfterStandardPropertyDeclaration(decl)) {
          expectEmptyLineBefore = !expectEmptyLineBefore;
        } // Check for at least one empty line


        const hasEmptyLineBefore = hasEmptyLine(decl.raws.before); // Return if the expectation is met

        if (expectEmptyLineBefore === hasEmptyLineBefore) {
          return;
        } // Fix


        if (context.fix) {
          if (context.newline == null) return;

          if (expectEmptyLineBefore) {
            addEmptyLineBefore(decl, context.newline);
          } else {
            removeEmptyLinesBefore(decl, context.newline);
          }

          return;
        }

        const message = expectEmptyLineBefore ? messages$2j.expected : messages$2j.rejected;
        report$1({
          message,
          node: decl,
          result,
          ruleName: ruleName$2j
        });
      });
    };
  };

  rule$2j.ruleName = ruleName$2j;
  rule$2j.messages = messages$2j;
  rule$2j.meta = meta$2j;
  var declarationEmptyLineBefore = rule$2j;

  /**
   * Returns a position of `!important` (or `! important` including whitespaces)
   * from the specified CSS source code. If not found, returns `undefined`.
   *
   * @param {string} source
   * @returns {{ index: number, endIndex: number } | undefined}
   */

  var getImportantPosition = function getImportantPosition(source) {
    const pattern = /!\s*important\b/gi;
    const match = pattern.exec(source);
    if (!match) return;
    return {
      index: match.index,
      endIndex: pattern.lastIndex
    };
  };

  const {
    assert: assert$a
  } = validateTypes;

  const ruleName$2i = 'declaration-no-important';
  const messages$2i = ruleMessages$1(ruleName$2i, {
    rejected: 'Unexpected !important'
  });
  const meta$2i = {
    url: 'https://stylelint.io/user-guide/rules/declaration-no-important'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2i = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2i, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!decl.important) {
          return;
        }

        const pos = getImportantPosition(decl.toString());
        assert$a(pos);
        report$1({
          message: messages$2i.rejected,
          node: decl,
          index: pos.index,
          endIndex: pos.endIndex,
          result,
          ruleName: ruleName$2i
        });
      });
    };
  };

  rule$2i.ruleName = ruleName$2i;
  rule$2i.messages = messages$2i;
  rule$2i.meta = meta$2i;
  var declarationNoImportant = rule$2i;

  const {
    isPlainObject: isPlainObject$2
  } = validateTypes;
  /**
   * Check whether the variable is an object and all its properties agree with the provided validator.
   *
   * @example
   * config = {
   *   value1: 1,
   *   value2: 2,
   *   value3: 3,
   * };
   * validateObjectWithProps(isNumber)(config);
   * //=> true
   *
   * @param {(value: unknown) => boolean} validator
   * @returns {(value: unknown) => boolean}
   */


  var validateObjectWithProps = validator => value => {
    if (!isPlainObject$2(value)) {
      return false;
    }

    return Object.values(value).every(item => {
      return validator(item);
    });
  };

  const {
    isNumber: isNumber$d,
    assertNumber: assertNumber$3
  } = validateTypes;



  const ruleName$2h = 'declaration-property-max-values';
  const messages$2h = ruleMessages$1(ruleName$2h, {
    rejected: (property, max) => `Expected "${property}" to have no more than ${max} ${max === 1 ? 'value' : 'values'}`
  });
  const meta$2h = {
    url: 'https://stylelint.io/user-guide/rules/declaration-property-max-values'
  };
  /**
   * @param {valueParser.Node} node
   */

  const isValueNode = node => {
    return node.type === 'word' || node.type === 'function' || node.type === 'string';
  };
  /** @type {import('stylelint').Rule<Record<string, number>>} */


  const rule$2h = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2h, {
        actual: primary,
        possible: [validateObjectWithProps(isNumber$d)]
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const {
          prop,
          value
        } = decl;
        const propLength = lib$6(value).nodes.filter(isValueNode).length;
        const unprefixedProp = vendor.unprefixed(prop);
        const propKey = Object.keys(primary).find(propIdentifier => matchesStringOrRegExp(unprefixedProp, propIdentifier));

        if (!propKey) {
          return;
        }

        const max = primary[propKey];
        assertNumber$3(max);

        if (propLength <= max) {
          return;
        }

        report$1({
          message: messages$2h.rejected,
          messageArgs: [prop, max],
          node: decl,
          result,
          ruleName: ruleName$2h
        });
      });
    };
  };

  rule$2h.ruleName = ruleName$2h;
  rule$2h.messages = messages$2h;
  rule$2h.meta = meta$2h;
  var declarationPropertyMaxValues = rule$2h;

  /**
   * @param {string} source
   *
   * @returns {string}
   */

  var blurInterpolation = function blurInterpolation(source, blurChar = ' ') {
    return source.replace(/[#@{}]+/g, blurChar);
  };

  /**
   * Get Dimension from value node;
   * `unit` and `number` return null if neither is found
   *
   * @param {import('postcss-value-parser').Node} node
   *
   * @returns {{unit: null, number: null} | valueParser.Dimension}
   */


  var getDimension = function getDimension(node) {
    if (!node || !node.value) {
      return {
        unit: null,
        number: null
      };
    } // Ignore non-word nodes


    if (node.type !== 'word') {
      return {
        unit: null,
        number: null
      };
    } // Ignore non standard syntax


    if (!isStandardSyntaxValue(node.value)) {
      return {
        unit: null,
        number: null
      };
    } // Ignore HEX


    if (node.value.startsWith('#')) {
      return {
        unit: null,
        number: null
      };
    } // Remove non standard stuff


    const value = blurInterpolation(node.value, '') // ignore hack unit
    .replace('\\0', '').replace('\\9', '');
    const parsedUnit = lib$6.unit(value);

    if (!parsedUnit) {
      return {
        unit: null,
        number: null
      };
    }

    return parsedUnit;
  };

  const {
    isString: isString$_
  } = validateTypes;



  const ruleName$2g = 'declaration-property-unit-allowed-list';
  const messages$2g = ruleMessages$1(ruleName$2g, {
    rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"`
  });
  const meta$2g = {
    url: 'https://stylelint.io/user-guide/rules/declaration-property-unit-allowed-list'
  };
  /** @type {import('stylelint').Rule<Record<string, string | string[]>>} */

  const rule$2g = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2g, {
        actual: primary,
        possible: [validateObjectWithArrayProps(isString$_)]
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['inside-function']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;
        const value = decl.value;
        const unprefixedProp = vendor.unprefixed(prop);
        const propKey = Object.keys(primary).find(propIdentifier => matchesStringOrRegExp(unprefixedProp, propIdentifier));

        if (!propKey) {
          return;
        }

        const propValue = primary[propKey];

        if (!propValue) {
          return;
        }

        const propList = new Set([propValue].flat());
        lib$6(value).walk(node => {
          // Ignore wrong units within `url` function
          if (node.type === 'function') {
            if (node.value.toLowerCase() === 'url') {
              return false;
            }

            if (optionsMatches(secondaryOptions, 'ignore', 'inside-function')) {
              return false;
            }
          }

          if (node.type === 'string') {
            return;
          }

          const {
            unit
          } = getDimension(node);

          if (!unit || propList.has(unit.toLowerCase())) {
            return;
          }

          const index = declarationValueIndex(decl) + node.sourceIndex;
          const endIndex = index + node.value.length;
          report$1({
            message: messages$2g.rejected,
            messageArgs: [prop, unit],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2g
          });
        });
      });
    };
  };

  rule$2g.ruleName = ruleName$2g;
  rule$2g.messages = messages$2g;
  rule$2g.meta = meta$2g;
  var declarationPropertyUnitAllowedList = rule$2g;

  const {
    isString: isString$Z
  } = validateTypes;



  const ruleName$2f = 'declaration-property-unit-disallowed-list';
  const messages$2f = ruleMessages$1(ruleName$2f, {
    rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"`
  });
  const meta$2f = {
    url: 'https://stylelint.io/user-guide/rules/declaration-property-unit-disallowed-list'
  };
  /** @type {import('stylelint').Rule<Record<string, string | string[]>>} */

  const rule$2f = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2f, {
        actual: primary,
        possible: [validateObjectWithArrayProps(isString$Z)]
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;
        const value = decl.value;
        const unprefixedProp = vendor.unprefixed(prop);
        const propKey = Object.keys(primary).find(propIdentifier => matchesStringOrRegExp(unprefixedProp, propIdentifier));

        if (!propKey) {
          return;
        }

        const propValue = primary[propKey];

        if (!propValue) {
          return;
        }

        const propList = new Set([propValue].flat());
        lib$6(value).walk(node => {
          // Ignore wrong units within `url` function
          if (node.type === 'function' && node.value.toLowerCase() === 'url') {
            return false;
          }

          if (node.type === 'string') {
            return;
          }

          const {
            unit
          } = getDimension(node);

          if (!unit || !propList.has(unit.toLowerCase())) {
            return;
          }

          const index = declarationValueIndex(decl) + node.sourceIndex;
          const endIndex = index + node.value.length;
          report$1({
            message: messages$2f.rejected,
            messageArgs: [prop, unit],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2f
          });
        });
      });
    };
  };

  rule$2f.ruleName = ruleName$2f;
  rule$2f.messages = messages$2f;
  rule$2f.meta = meta$2f;
  var declarationPropertyUnitDisallowedList = rule$2f;

  const {
    isString: isString$Y,
    isRegExp: isRegExp$O
  } = validateTypes;



  const ruleName$2e = 'declaration-property-value-allowed-list';
  const messages$2e = ruleMessages$1(ruleName$2e, {
    rejected: (property, value) => `Unexpected value "${value}" for property "${property}"`
  });
  const meta$2e = {
    url: 'https://stylelint.io/user-guide/rules/declaration-property-value-allowed-list'
  };
  /** @type {import('stylelint').Rule<Record<string, string | RegExp | Array<string | RegExp>>>} */

  const rule$2e = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2e, {
        actual: primary,
        possible: [validateObjectWithArrayProps(isString$Y, isRegExp$O)]
      });

      if (!validOptions) {
        return;
      }

      const propKeys = Object.keys(primary);
      root.walkDecls(decl => {
        const {
          prop,
          value
        } = decl;
        const unprefixedProp = vendor.unprefixed(prop);
        const propPatterns = propKeys.filter(key => matchesStringOrRegExp(unprefixedProp, key));

        if (propPatterns.length === 0) {
          return;
        }

        if (propPatterns.some(pattern => optionsMatches(primary, pattern, value))) {
          return;
        }

        const index = declarationValueIndex(decl);
        const endIndex = index + decl.value.length;
        report$1({
          message: messages$2e.rejected,
          messageArgs: [prop, value],
          node: decl,
          index,
          endIndex,
          result,
          ruleName: ruleName$2e
        });
      });
    };
  };

  rule$2e.ruleName = ruleName$2e;
  rule$2e.messages = messages$2e;
  rule$2e.meta = meta$2e;
  var declarationPropertyValueAllowedList = rule$2e;

  const {
    isString: isString$X,
    isRegExp: isRegExp$N
  } = validateTypes;



  const ruleName$2d = 'declaration-property-value-disallowed-list';
  const messages$2d = ruleMessages$1(ruleName$2d, {
    rejected: (property, value) => `Unexpected value "${value}" for property "${property}"`
  });
  const meta$2d = {
    url: 'https://stylelint.io/user-guide/rules/declaration-property-value-disallowed-list'
  };
  /** @type {import('stylelint').Rule<Record<string, string | RegExp | Array<string | RegExp>>>} */

  const rule$2d = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2d, {
        actual: primary,
        possible: [validateObjectWithArrayProps(isString$X, isRegExp$N)]
      });

      if (!validOptions) {
        return;
      }

      const propKeys = Object.keys(primary);
      root.walkDecls(decl => {
        const {
          prop,
          value
        } = decl;
        const unprefixedProp = vendor.unprefixed(prop);
        const propPatterns = propKeys.filter(key => matchesStringOrRegExp(unprefixedProp, key));

        if (propPatterns.length === 0) {
          return;
        }

        if (propPatterns.every(pattern => !optionsMatches(primary, pattern, value))) {
          return;
        }

        const index = declarationValueIndex(decl);
        const endIndex = index + decl.value.length;
        report$1({
          message: messages$2d.rejected,
          messageArgs: [prop, value],
          node: decl,
          index,
          endIndex,
          result,
          ruleName: ruleName$2d
        });
      });
    };
  };

  rule$2d.ruleName = ruleName$2d;
  rule$2d.messages = messages$2d;
  rule$2d.meta = meta$2d;
  var declarationPropertyValueDisallowedList = rule$2d;

  const {
    isPlainObject: isPlainObject$1
  } = isPlainObject_1;

  const {
    fork,
    parse: parse$b,
    find
  } = cjs$3;





















  const {
    isAtRule: isAtRule$e
  } = typeGuards;

  const {
    isRegExp: isRegExp$M,
    isString: isString$W
  } = validateTypes;

  const ruleName$2c = 'declaration-property-value-no-unknown';
  const messages$2c = ruleMessages$1(ruleName$2c, {
    rejected: (property, value) => `Unexpected unknown value "${value}" for property "${property}"`,
    rejectedParseError: (property, value) => `Cannot parse property value "${value}" for property "${property}"`
  });
  const meta$2c = {
    url: 'https://stylelint.io/user-guide/rules/declaration-property-value-no-unknown'
  };
  /** @type {import('stylelint').Rule} */

  const rule$2c = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2c, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreProperties: [validateObjectWithArrayProps(isString$W, isRegExp$M)],
          propertiesSyntax: [isPlainObject$1],
          typesSyntax: [isPlainObject$1]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const ignoreProperties = Array.from(Object.entries(secondaryOptions && secondaryOptions.ignoreProperties || {}));
      /** @type {(name: string, propValue: string) => boolean} */

      const isPropIgnored = (name, value) => {
        const [, valuePattern] = ignoreProperties.find(([namePattern]) => matchesStringOrRegExp(name, namePattern)) || [];
        return valuePattern && matchesStringOrRegExp(value, valuePattern);
      };

      const propertiesSyntax = secondaryOptions && secondaryOptions.propertiesSyntax || {};
      const typesSyntax = secondaryOptions && secondaryOptions.typesSyntax || {};
      const forkedLexer = fork({
        properties: propertiesSyntax,
        types: typesSyntax
      }).lexer;
      root.walkDecls(decl => {
        const {
          prop,
          value,
          parent
        } = decl; // NOTE: CSSTree's `fork()` doesn't support `-moz-initial`, but it may be possible in the future.
        // See https://github.com/stylelint/stylelint/pull/6511#issuecomment-1412921062

        if (/^-moz-initial$/i.test(value)) return;
        if (!isStandardSyntaxDeclaration(decl)) return;
        if (!isStandardSyntaxProperty(prop)) return;
        if (!isStandardSyntaxValue(value)) return;
        if (isCustomProperty$2(prop)) return;
        if (isPropIgnored(prop, value)) return;
        /** @type {import('css-tree').CssNode} */

        let cssTreeValueNode;

        try {
          cssTreeValueNode = parse$b(value, {
            context: 'value'
          });
          if (containsUnsupportedFunction(cssTreeValueNode)) return;
        } catch (e) {
          const index = declarationValueIndex(decl);
          const endIndex = index + value.length;
          report$1({
            message: messages$2c.rejectedParseError(prop, value),
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$2c
          });
          return;
        }

        const {
          error
        } = parent && isAtRule$e(parent) ? forkedLexer.matchAtruleDescriptor(parent.name, prop, cssTreeValueNode) : forkedLexer.matchProperty(prop, cssTreeValueNode);
        if (!error) return;
        if (!('mismatchLength' in error)) return;
        const {
          mismatchLength,
          mismatchOffset,
          name,
          rawMessage
        } = error;
        if (name !== 'SyntaxMatchError') return;
        if (rawMessage !== 'Mismatch') return;
        const mismatchValue = value.slice(mismatchOffset, mismatchOffset + mismatchLength);
        const index = declarationValueIndex(decl) + mismatchOffset;
        const endIndex = index + mismatchLength;
        report$1({
          message: messages$2c.rejected(prop, mismatchValue),
          node: decl,
          index,
          endIndex,
          result,
          ruleName: ruleName$2c
        });
      });
    };
  };
  /**
   * TODO: This function avoids false positives because CSSTree doesn't fully support
   * some math functions like `clamp()` via `fork()`. In the future, it may be unnecessary.
   *
   * @see https://github.com/stylelint/stylelint/pull/6511#issuecomment-1412921062
   * @see https://github.com/stylelint/stylelint/issues/6635#issuecomment-1425787649
   *
   * @param {import('css-tree').CssNode} cssTreeNode
   * @returns {boolean}
   */


  function containsUnsupportedFunction(cssTreeNode) {
    return Boolean(find(cssTreeNode, node => node.type === 'Function' && ['clamp', 'min', 'max', 'env'].includes(node.name)));
  }

  rule$2c.ruleName = ruleName$2c;
  rule$2c.messages = messages$2c;
  rule$2c.meta = meta$2c;
  var declarationPropertyValueNoUnknown = rule$2c;

  /**
   * Check whether it's a number or a number-like string:
   * i.e. when coerced to a number it == itself.
   *
   * @param {string | number} value
   */

  var isNumbery = function isNumbery(value) {
    return value.toString().trim().length !== 0 && Number(value) == value; // eslint-disable-line eqeqeq
  };

  const lengthUnits$3 = new Set([// Font-relative length units
  'cap', 'ch', 'em', 'ex', 'ic', 'lh', 'rcap', 'rch', 'rem', 'rex', 'ric', 'rlh', // Viewport-percentage lengths
  'dvb', 'dvh', 'dvi', 'dvmax', 'dvmin', 'dvw', 'lvb', 'lvh', 'lvi', 'lvmax', 'lvmin', 'lvw', 'svb', 'svh', 'svi', 'svmax', 'svmin', 'svw', 'vb', 'vh', 'vi', 'vw', 'vmin', 'vmax', 'vm', // Absolute length units
  'px', 'mm', 'cm', 'in', 'pt', 'pc', 'q', 'mozmm', // Flexible length units
  'fr', // Container query units
  'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax']);
  const resolutionUnits$1 = new Set(['dpi', 'dpcm', 'dppx', 'x']);
  const units$1 = uniteSets(lengthUnits$3, resolutionUnits$1, [// Relative length units
  '%', // Time length units
  's', 'ms', // Angle
  'deg', 'grad', 'turn', 'rad', // Frequency
  'Hz', 'kHz']);
  var units_1 = {
    lengthUnits: lengthUnits$3,
    resolutionUnits: resolutionUnits$1,
    units: units$1
  };

  const {
    fontSizeKeywords
  } = keywords$4;

  const {
    lengthUnits: lengthUnits$2
  } = units_1;


  /**
   * Check if a word is a font-size value.
   *
   * @param {string} word
   * @returns {boolean}
   */


  var isValidFontSize = function isValidFontSize(word) {
    if (!word) {
      return false;
    }

    if (fontSizeKeywords.has(word)) {
      return true;
    }

    const numberUnit = lib$6.unit(word);

    if (!numberUnit) {
      return false;
    }

    const unit = numberUnit.unit;

    if (unit === '%') {
      return true;
    }

    if (lengthUnits$2.has(unit.toLowerCase())) {
      return true;
    }

    return false;
  };

  /**
   * Check whether a word is a variable i.e var(--custom-property).
   *
   * @param {string} word
   * @returns {boolean}
   */

  var isVariable = function isVariable(word) {
    return word.toLowerCase().startsWith('var(');
  };

  const {
    assert: assert$9
  } = validateTypes;

  const {
    basicKeywords: basicKeywords$1,
    fontFamilyKeywords: fontFamilyKeywords$4,
    fontShorthandKeywords: fontShorthandKeywords$1
  } = keywords$4;

  const nodeTypesToCheck = new Set(['word', 'string', 'space', 'div']);
  /** @typedef {import('postcss-value-parser').Node} Node */

  /**
   *
   * @param {Node} firstNode
   * @param {Node} secondNode
   * @param {string | null} charactersBetween
   *
   * @returns {Node}
   */

  function joinValueNodes(firstNode, secondNode, charactersBetween) {
    firstNode.value = firstNode.value + charactersBetween + secondNode.value;
    return firstNode;
  }
  /**
   * Get the font-families within a `font` shorthand property value.
   *
   * @param {string} value
   * @returns {Node[]} Collection font-family nodes
   */


  var findFontFamily = function findFontFamily(value) {
    /** @type {Node[]} */
    const fontFamilies = [];
    const valueNodes = lib$6(value);
    const {
      nodes: children
    } = valueNodes; // Handle `inherit`, `initial` and etc

    if (children.length === 1 && children[0] && basicKeywords$1.has(children[0].value.toLowerCase())) {
      return [children[0]];
    }

    let needMergeNodesByValue = false;
    /** @type {string | null} */

    let mergeCharacters = null;
    valueNodes.walk((valueNode, index, nodes) => {
      if (valueNode.type === 'function') {
        return false;
      }

      if (!nodeTypesToCheck.has(valueNode.type)) {
        return;
      }

      const valueLowerCase = valueNode.value.toLowerCase(); // Ignore non standard syntax

      if (!isStandardSyntaxValue(valueLowerCase)) {
        return;
      } // Ignore variables


      if (isVariable(valueLowerCase)) {
        return;
      } // Ignore keywords for other font parts


      if (fontShorthandKeywords$1.has(valueLowerCase) && !fontFamilyKeywords$4.has(valueLowerCase)) {
        return;
      } // Ignore font-sizes


      if (isValidFontSize(valueNode.value)) {
        return;
      }

      const prevNode = nodes[index - 1];
      const prevPrevNode = nodes[index - 2]; // Ignore anything come after a <font-size>/, because it's a line-height

      if (prevNode && prevNode.value === '/' && prevPrevNode && isValidFontSize(prevPrevNode.value)) {
        return;
      } // Ignore number values


      if (isNumbery(valueLowerCase)) {
        return;
      } // Detect when a space or comma is dividing a list of font-families, and save the joining character.


      if ((valueNode.type === 'space' || valueNode.type === 'div' && valueNode.value !== ',') && fontFamilies.length !== 0) {
        needMergeNodesByValue = true;
        mergeCharacters = valueNode.value;
        return;
      }

      if (valueNode.type === 'space' || valueNode.type === 'div') {
        return;
      }

      const fontFamily = valueNode;

      if (needMergeNodesByValue) {
        const lastFontFamily = fontFamilies[fontFamilies.length - 1];
        assert$9(lastFontFamily);
        joinValueNodes(lastFontFamily, fontFamily, mergeCharacters);
        needMergeNodesByValue = false;
        mergeCharacters = null;
      } else {
        fontFamilies.push(fontFamily);
      }
    });
    return fontFamilies;
  };

  let isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty__default['default'].isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);

  let formatter$1 = (open, close, replace = open) => input => {
    let string = "" + input;
    let index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
  };

  let replaceClose = (string, close, replace, index) => {
    let start = string.substring(0, index) + replace;
    let end = string.substring(index + close.length);
    let nextIndex = end.indexOf(close);
    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
  };

  let createColors = (enabled = isColorSupported) => ({
    isColorSupported: enabled,
    reset: enabled ? s => `\x1b[0m${s}\x1b[0m` : String,
    bold: enabled ? formatter$1("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
    dim: enabled ? formatter$1("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
    italic: enabled ? formatter$1("\x1b[3m", "\x1b[23m") : String,
    underline: enabled ? formatter$1("\x1b[4m", "\x1b[24m") : String,
    inverse: enabled ? formatter$1("\x1b[7m", "\x1b[27m") : String,
    hidden: enabled ? formatter$1("\x1b[8m", "\x1b[28m") : String,
    strikethrough: enabled ? formatter$1("\x1b[9m", "\x1b[29m") : String,
    black: enabled ? formatter$1("\x1b[30m", "\x1b[39m") : String,
    red: enabled ? formatter$1("\x1b[31m", "\x1b[39m") : String,
    green: enabled ? formatter$1("\x1b[32m", "\x1b[39m") : String,
    yellow: enabled ? formatter$1("\x1b[33m", "\x1b[39m") : String,
    blue: enabled ? formatter$1("\x1b[34m", "\x1b[39m") : String,
    magenta: enabled ? formatter$1("\x1b[35m", "\x1b[39m") : String,
    cyan: enabled ? formatter$1("\x1b[36m", "\x1b[39m") : String,
    white: enabled ? formatter$1("\x1b[37m", "\x1b[39m") : String,
    gray: enabled ? formatter$1("\x1b[90m", "\x1b[39m") : String,
    bgBlack: enabled ? formatter$1("\x1b[40m", "\x1b[49m") : String,
    bgRed: enabled ? formatter$1("\x1b[41m", "\x1b[49m") : String,
    bgGreen: enabled ? formatter$1("\x1b[42m", "\x1b[49m") : String,
    bgYellow: enabled ? formatter$1("\x1b[43m", "\x1b[49m") : String,
    bgBlue: enabled ? formatter$1("\x1b[44m", "\x1b[49m") : String,
    bgMagenta: enabled ? formatter$1("\x1b[45m", "\x1b[49m") : String,
    bgCyan: enabled ? formatter$1("\x1b[46m", "\x1b[49m") : String,
    bgWhite: enabled ? formatter$1("\x1b[47m", "\x1b[49m") : String
  });

  var picocolors = createColors();
  var createColors_1 = createColors;
  picocolors.createColors = createColors_1;

  const SINGLE_QUOTE = "'".charCodeAt(0);
  const DOUBLE_QUOTE = '"'.charCodeAt(0);
  const BACKSLASH = '\\'.charCodeAt(0);
  const SLASH$2 = '/'.charCodeAt(0);
  const NEWLINE$2 = '\n'.charCodeAt(0);
  const SPACE$2 = ' '.charCodeAt(0);
  const FEED = '\f'.charCodeAt(0);
  const TAB = '\t'.charCodeAt(0);
  const CR$1 = '\r'.charCodeAt(0);
  const OPEN_SQUARE = '['.charCodeAt(0);
  const CLOSE_SQUARE = ']'.charCodeAt(0);
  const OPEN_PARENTHESES = '('.charCodeAt(0);
  const CLOSE_PARENTHESES = ')'.charCodeAt(0);
  const OPEN_CURLY = '{'.charCodeAt(0);
  const CLOSE_CURLY = '}'.charCodeAt(0);
  const SEMICOLON = ';'.charCodeAt(0);
  const ASTERISK = '*'.charCodeAt(0);
  const COLON$1 = ':'.charCodeAt(0);
  const AT = '@'.charCodeAt(0);
  const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
  const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
  const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
  const RE_HEX_ESCAPE = /[\da-f]/i;

  var tokenize$6 = function tokenizer(input, options = {}) {
    let css = input.css.valueOf();
    let ignore = options.ignoreErrors;
    let code, next, quote, content, escape;
    let escaped, escapePos, prev, n, currentToken;
    let length = css.length;
    let pos = 0;
    let buffer = [];
    let returned = [];

    function position() {
      return pos;
    }

    function unclosed(what) {
      throw input.error('Unclosed ' + what, pos);
    }

    function endOfFile() {
      return returned.length === 0 && pos >= length;
    }

    function nextToken(opts) {
      if (returned.length) return returned.pop();
      if (pos >= length) return;
      let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
      code = css.charCodeAt(pos);

      switch (code) {
        case NEWLINE$2:
        case SPACE$2:
        case TAB:
        case CR$1:
        case FEED:
          {
            next = pos;

            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === SPACE$2 || code === NEWLINE$2 || code === TAB || code === CR$1 || code === FEED);

            currentToken = ['space', css.slice(pos, next)];
            pos = next - 1;
            break;
          }

        case OPEN_SQUARE:
        case CLOSE_SQUARE:
        case OPEN_CURLY:
        case CLOSE_CURLY:
        case COLON$1:
        case SEMICOLON:
        case CLOSE_PARENTHESES:
          {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }

        case OPEN_PARENTHESES:
          {
            prev = buffer.length ? buffer.pop()[1] : '';
            n = css.charCodeAt(pos + 1);

            if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE$2 && n !== NEWLINE$2 && n !== TAB && n !== FEED && n !== CR$1) {
              next = pos;

              do {
                escaped = false;
                next = css.indexOf(')', next + 1);

                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed('bracket');
                  }
                }

                escapePos = next;

                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);

              currentToken = ['brackets', css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css.indexOf(')', pos + 1);
              content = css.slice(pos, next + 1);

              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ['(', '(', pos];
              } else {
                currentToken = ['brackets', content, pos, next];
                pos = next;
              }
            }

            break;
          }

        case SINGLE_QUOTE:
        case DOUBLE_QUOTE:
          {
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next = pos;

            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);

              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed('string');
                }
              }

              escapePos = next;

              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);

            currentToken = ['string', css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }

        case AT:
          {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);

            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }

            currentToken = ['at-word', css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }

        case BACKSLASH:
          {
            next = pos;
            escape = true;

            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape = !escape;
            }

            code = css.charCodeAt(next + 1);

            if (escape && code !== SLASH$2 && code !== SPACE$2 && code !== NEWLINE$2 && code !== TAB && code !== CR$1 && code !== FEED) {
              next += 1;

              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }

                if (css.charCodeAt(next + 1) === SPACE$2) {
                  next += 1;
                }
              }
            }

            currentToken = ['word', css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }

        default:
          {
            if (code === SLASH$2 && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf('*/', pos + 2) + 1;

              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed('comment');
                }
              }

              currentToken = ['comment', css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);

              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }

              currentToken = ['word', css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }

            break;
          }
      }

      pos++;
      return currentToken;
    }

    function back(token) {
      returned.push(token);
    }

    return {
      back,
      endOfFile,
      nextToken,
      position
    };
  };

  let Input$2;

  function registerInput(dependant) {
    Input$2 = dependant;
  }

  const HIGHLIGHT_THEME = {
    ';': picocolors.yellow,
    ':': picocolors.yellow,
    '(': picocolors.cyan,
    ')': picocolors.cyan,
    '[': picocolors.yellow,
    ']': picocolors.yellow,
    '{': picocolors.yellow,
    '}': picocolors.yellow,
    'at-word': picocolors.cyan,
    'brackets': picocolors.cyan,
    'call': picocolors.cyan,
    'class': picocolors.yellow,
    'comment': picocolors.gray,
    'hash': picocolors.magenta,
    'string': picocolors.green
  };

  function getTokenType([type, value], processor) {
    if (type === 'word') {
      if (value[0] === '.') {
        return 'class';
      }

      if (value[0] === '#') {
        return 'hash';
      }
    }

    if (!processor.endOfFile()) {
      let next = processor.nextToken();
      processor.back(next);
      if (next[0] === 'brackets' || next[0] === '(') return 'call';
    }

    return type;
  }

  function terminalHighlight(css) {
    let processor = tokenize$6(new Input$2(css), {
      ignoreErrors: true
    });
    let result = '';

    while (!processor.endOfFile()) {
      let token = processor.nextToken();
      let color = HIGHLIGHT_THEME[getTokenType(token, processor)];

      if (color) {
        result += token[1].split(/\r?\n/).map(i => color(i)).join('\n');
      } else {
        result += token[1];
      }
    }

    return result;
  }

  terminalHighlight.registerInput = registerInput;
  var terminalHighlight_1 = terminalHighlight;

  class CssSyntaxError extends Error {
    constructor(message, line, column, source, file, plugin) {
      super(message);
      this.name = 'CssSyntaxError';
      this.reason = message;

      if (file) {
        this.file = file;
      }

      if (source) {
        this.source = source;
      }

      if (plugin) {
        this.plugin = plugin;
      }

      if (typeof line !== 'undefined' && typeof column !== 'undefined') {
        if (typeof line === 'number') {
          this.line = line;
          this.column = column;
        } else {
          this.line = line.line;
          this.column = line.column;
          this.endLine = column.line;
          this.endColumn = column.column;
        }
      }

      this.setMessage();

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, CssSyntaxError);
      }
    }

    setMessage() {
      this.message = this.plugin ? this.plugin + ': ' : '';
      this.message += this.file ? this.file : '<css input>';

      if (typeof this.line !== 'undefined') {
        this.message += ':' + this.line + ':' + this.column;
      }

      this.message += ': ' + this.reason;
    }

    showSourceCode(color) {
      if (!this.source) return '';
      let css = this.source;
      if (color == null) color = picocolors.isColorSupported;

      if (terminalHighlight_1) {
        if (color) css = terminalHighlight_1(css);
      }

      let lines = css.split(/\r?\n/);
      let start = Math.max(this.line - 3, 0);
      let end = Math.min(this.line + 2, lines.length);
      let maxWidth = String(end).length;
      let mark, aside;

      if (color) {
        let {
          bold,
          gray,
          red
        } = picocolors.createColors(true);

        mark = text => bold(red(text));

        aside = text => gray(text);
      } else {
        mark = aside = str => str;
      }

      return lines.slice(start, end).map((line, index) => {
        let number = start + 1 + index;
        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';

        if (number === this.line) {
          let spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
          return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
        }

        return ' ' + aside(gutter) + line;
      }).join('\n');
    }

    toString() {
      let code = this.showSourceCode();

      if (code) {
        code = '\n\n' + code + '\n';
      }

      return this.name + ': ' + this.message + code;
    }

  }

  var cssSyntaxError = CssSyntaxError;
  CssSyntaxError.default = CssSyntaxError;

  var isClean$3 = Symbol('isClean');
  var my$3 = Symbol('my');

  var symbols$1 = {
  	isClean: isClean$3,
  	my: my$3
  };

  const DEFAULT_RAW = {
    after: '\n',
    beforeClose: '\n',
    beforeComment: '\n',
    beforeDecl: '\n',
    beforeOpen: ' ',
    beforeRule: '\n',
    colon: ': ',
    commentLeft: ' ',
    commentRight: ' ',
    emptyBody: '',
    indent: '    ',
    semicolon: false
  };

  function capitalize(str) {
    return str[0].toUpperCase() + str.slice(1);
  }

  class Stringifier {
    constructor(builder) {
      this.builder = builder;
    }

    atrule(node, semicolon) {
      let name = '@' + node.name;
      let params = node.params ? this.rawValue(node, 'params') : '';

      if (typeof node.raws.afterName !== 'undefined') {
        name += node.raws.afterName;
      } else if (params) {
        name += ' ';
      }

      if (node.nodes) {
        this.block(node, name + params);
      } else {
        let end = (node.raws.between || '') + (semicolon ? ';' : '');
        this.builder(name + params + end, node);
      }
    }

    beforeAfter(node, detect) {
      let value;

      if (node.type === 'decl') {
        value = this.raw(node, null, 'beforeDecl');
      } else if (node.type === 'comment') {
        value = this.raw(node, null, 'beforeComment');
      } else if (detect === 'before') {
        value = this.raw(node, null, 'beforeRule');
      } else {
        value = this.raw(node, null, 'beforeClose');
      }

      let buf = node.parent;
      let depth = 0;

      while (buf && buf.type !== 'root') {
        depth += 1;
        buf = buf.parent;
      }

      if (value.includes('\n')) {
        let indent = this.raw(node, null, 'indent');

        if (indent.length) {
          for (let step = 0; step < depth; step++) value += indent;
        }
      }

      return value;
    }

    block(node, start) {
      let between = this.raw(node, 'between', 'beforeOpen');
      this.builder(start + between + '{', node, 'start');
      let after;

      if (node.nodes && node.nodes.length) {
        this.body(node);
        after = this.raw(node, 'after');
      } else {
        after = this.raw(node, 'after', 'emptyBody');
      }

      if (after) this.builder(after);
      this.builder('}', node, 'end');
    }

    body(node) {
      let last = node.nodes.length - 1;

      while (last > 0) {
        if (node.nodes[last].type !== 'comment') break;
        last -= 1;
      }

      let semicolon = this.raw(node, 'semicolon');

      for (let i = 0; i < node.nodes.length; i++) {
        let child = node.nodes[i];
        let before = this.raw(child, 'before');
        if (before) this.builder(before);
        this.stringify(child, last !== i || semicolon);
      }
    }

    comment(node) {
      let left = this.raw(node, 'left', 'commentLeft');
      let right = this.raw(node, 'right', 'commentRight');
      this.builder('/*' + left + node.text + right + '*/', node);
    }

    decl(node, semicolon) {
      let between = this.raw(node, 'between', 'colon');
      let string = node.prop + between + this.rawValue(node, 'value');

      if (node.important) {
        string += node.raws.important || ' !important';
      }

      if (semicolon) string += ';';
      this.builder(string, node);
    }

    document(node) {
      this.body(node);
    }

    raw(node, own, detect) {
      let value;
      if (!detect) detect = own; // Already had

      if (own) {
        value = node.raws[own];
        if (typeof value !== 'undefined') return value;
      }

      let parent = node.parent;

      if (detect === 'before') {
        // Hack for first rule in CSS
        if (!parent || parent.type === 'root' && parent.first === node) {
          return '';
        } // `root` nodes in `document` should use only their own raws


        if (parent && parent.type === 'document') {
          return '';
        }
      } // Floating child without parent


      if (!parent) return DEFAULT_RAW[detect]; // Detect style by other nodes

      let root = node.root();
      if (!root.rawCache) root.rawCache = {};

      if (typeof root.rawCache[detect] !== 'undefined') {
        return root.rawCache[detect];
      }

      if (detect === 'before' || detect === 'after') {
        return this.beforeAfter(node, detect);
      } else {
        let method = 'raw' + capitalize(detect);

        if (this[method]) {
          value = this[method](root, node);
        } else {
          root.walk(i => {
            value = i.raws[own];
            if (typeof value !== 'undefined') return false;
          });
        }
      }

      if (typeof value === 'undefined') value = DEFAULT_RAW[detect];
      root.rawCache[detect] = value;
      return value;
    }

    rawBeforeClose(root) {
      let value;
      root.walk(i => {
        if (i.nodes && i.nodes.length > 0) {
          if (typeof i.raws.after !== 'undefined') {
            value = i.raws.after;

            if (value.includes('\n')) {
              value = value.replace(/[^\n]+$/, '');
            }

            return false;
          }
        }
      });
      if (value) value = value.replace(/\S/g, '');
      return value;
    }

    rawBeforeComment(root, node) {
      let value;
      root.walkComments(i => {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before;

          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      });

      if (typeof value === 'undefined') {
        value = this.raw(node, null, 'beforeDecl');
      } else if (value) {
        value = value.replace(/\S/g, '');
      }

      return value;
    }

    rawBeforeDecl(root, node) {
      let value;
      root.walkDecls(i => {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before;

          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      });

      if (typeof value === 'undefined') {
        value = this.raw(node, null, 'beforeRule');
      } else if (value) {
        value = value.replace(/\S/g, '');
      }

      return value;
    }

    rawBeforeOpen(root) {
      let value;
      root.walk(i => {
        if (i.type !== 'decl') {
          value = i.raws.between;
          if (typeof value !== 'undefined') return false;
        }
      });
      return value;
    }

    rawBeforeRule(root) {
      let value;
      root.walk(i => {
        if (i.nodes && (i.parent !== root || root.first !== i)) {
          if (typeof i.raws.before !== 'undefined') {
            value = i.raws.before;

            if (value.includes('\n')) {
              value = value.replace(/[^\n]+$/, '');
            }

            return false;
          }
        }
      });
      if (value) value = value.replace(/\S/g, '');
      return value;
    }

    rawColon(root) {
      let value;
      root.walkDecls(i => {
        if (typeof i.raws.between !== 'undefined') {
          value = i.raws.between.replace(/[^\s:]/g, '');
          return false;
        }
      });
      return value;
    }

    rawEmptyBody(root) {
      let value;
      root.walk(i => {
        if (i.nodes && i.nodes.length === 0) {
          value = i.raws.after;
          if (typeof value !== 'undefined') return false;
        }
      });
      return value;
    }

    rawIndent(root) {
      if (root.raws.indent) return root.raws.indent;
      let value;
      root.walk(i => {
        let p = i.parent;

        if (p && p !== root && p.parent && p.parent === root) {
          if (typeof i.raws.before !== 'undefined') {
            let parts = i.raws.before.split('\n');
            value = parts[parts.length - 1];
            value = value.replace(/\S/g, '');
            return false;
          }
        }
      });
      return value;
    }

    rawSemicolon(root) {
      let value;
      root.walk(i => {
        if (i.nodes && i.nodes.length && i.last.type === 'decl') {
          value = i.raws.semicolon;
          if (typeof value !== 'undefined') return false;
        }
      });
      return value;
    }

    rawValue(node, prop) {
      let value = node[prop];
      let raw = node.raws[prop];

      if (raw && raw.value === value) {
        return raw.raw;
      }

      return value;
    }

    root(node) {
      this.body(node);
      if (node.raws.after) this.builder(node.raws.after);
    }

    rule(node) {
      this.block(node, this.rawValue(node, 'selector'));

      if (node.raws.ownSemicolon) {
        this.builder(node.raws.ownSemicolon, node, 'end');
      }
    }

    stringify(node, semicolon) {
      /* c8 ignore start */
      if (!this[node.type]) {
        throw new Error('Unknown AST node type ' + node.type + '. ' + 'Maybe you need to change PostCSS stringifier.');
      }
      /* c8 ignore stop */


      this[node.type](node, semicolon);
    }

  }

  var stringifier = Stringifier;
  Stringifier.default = Stringifier;

  function stringify$4(node, builder) {
    let str = new stringifier(builder);
    str.stringify(node);
  }

  var stringify_1$1 = stringify$4;
  stringify$4.default = stringify$4;

  let {
    isClean: isClean$2,
    my: my$2
  } = symbols$1;







  function cloneNode(obj, parent) {
    let cloned = new obj.constructor();

    for (let i in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, i)) {
        /* c8 ignore next 2 */
        continue;
      }

      if (i === 'proxyCache') continue;
      let value = obj[i];
      let type = typeof value;

      if (i === 'parent' && type === 'object') {
        if (parent) cloned[i] = parent;
      } else if (i === 'source') {
        cloned[i] = value;
      } else if (Array.isArray(value)) {
        cloned[i] = value.map(j => cloneNode(j, cloned));
      } else {
        if (type === 'object' && value !== null) value = cloneNode(value);
        cloned[i] = value;
      }
    }

    return cloned;
  }

  class Node {
    constructor(defaults = {}) {
      this.raws = {};
      this[isClean$2] = false;
      this[my$2] = true;

      for (let name in defaults) {
        if (name === 'nodes') {
          this.nodes = [];

          for (let node of defaults[name]) {
            if (typeof node.clone === 'function') {
              this.append(node.clone());
            } else {
              this.append(node);
            }
          }
        } else {
          this[name] = defaults[name];
        }
      }
    }

    addToError(error) {
      error.postcssNode = this;

      if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
        let s = this.source;
        error.stack = error.stack.replace(/\n\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);
      }

      return error;
    }

    after(add) {
      this.parent.insertAfter(this, add);
      return this;
    }

    assign(overrides = {}) {
      for (let name in overrides) {
        this[name] = overrides[name];
      }

      return this;
    }

    before(add) {
      this.parent.insertBefore(this, add);
      return this;
    }

    cleanRaws(keepBetween) {
      delete this.raws.before;
      delete this.raws.after;
      if (!keepBetween) delete this.raws.between;
    }

    clone(overrides = {}) {
      let cloned = cloneNode(this);

      for (let name in overrides) {
        cloned[name] = overrides[name];
      }

      return cloned;
    }

    cloneAfter(overrides = {}) {
      let cloned = this.clone(overrides);
      this.parent.insertAfter(this, cloned);
      return cloned;
    }

    cloneBefore(overrides = {}) {
      let cloned = this.clone(overrides);
      this.parent.insertBefore(this, cloned);
      return cloned;
    }

    error(message, opts = {}) {
      if (this.source) {
        let {
          end,
          start
        } = this.rangeBy(opts);
        return this.source.input.error(message, {
          column: start.column,
          line: start.line
        }, {
          column: end.column,
          line: end.line
        }, opts);
      }

      return new cssSyntaxError(message);
    }

    getProxyProcessor() {
      return {
        get(node, prop) {
          if (prop === 'proxyOf') {
            return node;
          } else if (prop === 'root') {
            return () => node.root().toProxy();
          } else {
            return node[prop];
          }
        },

        set(node, prop, value) {
          if (node[prop] === value) return true;
          node[prop] = value;

          if (prop === 'prop' || prop === 'value' || prop === 'name' || prop === 'params' || prop === 'important' ||
          /* c8 ignore next */
          prop === 'text') {
            node.markDirty();
          }

          return true;
        }

      };
    }

    markDirty() {
      if (this[isClean$2]) {
        this[isClean$2] = false;
        let next = this;

        while (next = next.parent) {
          next[isClean$2] = false;
        }
      }
    }

    next() {
      if (!this.parent) return undefined;
      let index = this.parent.index(this);
      return this.parent.nodes[index + 1];
    }

    positionBy(opts, stringRepresentation) {
      let pos = this.source.start;

      if (opts.index) {
        pos = this.positionInside(opts.index, stringRepresentation);
      } else if (opts.word) {
        stringRepresentation = this.toString();
        let index = stringRepresentation.indexOf(opts.word);
        if (index !== -1) pos = this.positionInside(index, stringRepresentation);
      }

      return pos;
    }

    positionInside(index, stringRepresentation) {
      let string = stringRepresentation || this.toString();
      let column = this.source.start.column;
      let line = this.source.start.line;

      for (let i = 0; i < index; i++) {
        if (string[i] === '\n') {
          column = 1;
          line += 1;
        } else {
          column += 1;
        }
      }

      return {
        column,
        line
      };
    }

    prev() {
      if (!this.parent) return undefined;
      let index = this.parent.index(this);
      return this.parent.nodes[index - 1];
    }

    rangeBy(opts) {
      let start = {
        column: this.source.start.column,
        line: this.source.start.line
      };
      let end = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line
      } : {
        column: start.column + 1,
        line: start.line
      };

      if (opts.word) {
        let stringRepresentation = this.toString();
        let index = stringRepresentation.indexOf(opts.word);

        if (index !== -1) {
          start = this.positionInside(index, stringRepresentation);
          end = this.positionInside(index + opts.word.length, stringRepresentation);
        }
      } else {
        if (opts.start) {
          start = {
            column: opts.start.column,
            line: opts.start.line
          };
        } else if (opts.index) {
          start = this.positionInside(opts.index);
        }

        if (opts.end) {
          end = {
            column: opts.end.column,
            line: opts.end.line
          };
        } else if (opts.endIndex) {
          end = this.positionInside(opts.endIndex);
        } else if (opts.index) {
          end = this.positionInside(opts.index + 1);
        }
      }

      if (end.line < start.line || end.line === start.line && end.column <= start.column) {
        end = {
          column: start.column + 1,
          line: start.line
        };
      }

      return {
        end,
        start
      };
    }

    raw(prop, defaultType) {
      let str = new stringifier();
      return str.raw(this, prop, defaultType);
    }

    remove() {
      if (this.parent) {
        this.parent.removeChild(this);
      }

      this.parent = undefined;
      return this;
    }

    replaceWith(...nodes) {
      if (this.parent) {
        let bookmark = this;
        let foundSelf = false;

        for (let node of nodes) {
          if (node === this) {
            foundSelf = true;
          } else if (foundSelf) {
            this.parent.insertAfter(bookmark, node);
            bookmark = node;
          } else {
            this.parent.insertBefore(bookmark, node);
          }
        }

        if (!foundSelf) {
          this.remove();
        }
      }

      return this;
    }

    root() {
      let result = this;

      while (result.parent && result.parent.type !== 'document') {
        result = result.parent;
      }

      return result;
    }

    toJSON(_, inputs) {
      let fixed = {};
      let emitInputs = inputs == null;
      inputs = inputs || new Map();
      let inputsNextIndex = 0;

      for (let name in this) {
        if (!Object.prototype.hasOwnProperty.call(this, name)) {
          /* c8 ignore next 2 */
          continue;
        }

        if (name === 'parent' || name === 'proxyCache') continue;
        let value = this[name];

        if (Array.isArray(value)) {
          fixed[name] = value.map(i => {
            if (typeof i === 'object' && i.toJSON) {
              return i.toJSON(null, inputs);
            } else {
              return i;
            }
          });
        } else if (typeof value === 'object' && value.toJSON) {
          fixed[name] = value.toJSON(null, inputs);
        } else if (name === 'source') {
          let inputId = inputs.get(value.input);

          if (inputId == null) {
            inputId = inputsNextIndex;
            inputs.set(value.input, inputsNextIndex);
            inputsNextIndex++;
          }

          fixed[name] = {
            end: value.end,
            inputId,
            start: value.start
          };
        } else {
          fixed[name] = value;
        }
      }

      if (emitInputs) {
        fixed.inputs = [...inputs.keys()].map(input => input.toJSON());
      }

      return fixed;
    }

    toProxy() {
      if (!this.proxyCache) {
        this.proxyCache = new Proxy(this, this.getProxyProcessor());
      }

      return this.proxyCache;
    }

    toString(stringifier = stringify_1$1) {
      if (stringifier.stringify) stringifier = stringifier.stringify;
      let result = '';
      stringifier(this, i => {
        result += i;
      });
      return result;
    }

    warn(result, text, opts) {
      let data = {
        node: this
      };

      for (let i in opts) data[i] = opts[i];

      return result.warn(text, data);
    }

    get proxyOf() {
      return this;
    }

  }

  var node_1 = Node;
  Node.default = Node;

  class Declaration extends node_1 {
    constructor(defaults) {
      if (defaults && typeof defaults.value !== 'undefined' && typeof defaults.value !== 'string') {
        defaults = { ...defaults,
          value: String(defaults.value)
        };
      }

      super(defaults);
      this.type = 'decl';
    }

    get variable() {
      return this.prop.startsWith('--') || this.prop[0] === '$';
    }

  }

  var declaration = Declaration;
  Declaration.default = Declaration;

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var binarySearch = createCommonjsModule(function (module, exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */

  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);

    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    } else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      } // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.


      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      } // we are in termination case (3) or (2) and return the appropriate thing.


      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */


  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

    if (index < 0) {
      return -1;
    } // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.


    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }

      --index;
    }

    return index;
  };
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.
  function SortTemplate(comparator) {
    /**
     * Swap the elements indexed by `x` and `y` in the array `ary`.
     *
     * @param {Array} ary
     *        The array.
     * @param {Number} x
     *        The index of the first item.
     * @param {Number} y
     *        The index of the second item.
     */
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    /**
     * Returns a random integer within the range `low .. high` inclusive.
     *
     * @param {Number} low
     *        The lower bound on the range.
     * @param {Number} high
     *        The upper bound on the range.
     */


    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    /**
     * The Quick Sort algorithm.
     *
     * @param {Array} ary
     *        An array to sort.
     * @param {function} comparator
     *        Function to use to compare two items.
     * @param {Number} p
     *        Start index of the array
     * @param {Number} r
     *        End index of the array
     */


    function doQuickSort(ary, comparator, p, r) {
      // If our lower bound is less than our upper bound, we (1) partition the
      // array into two pieces and (2) recurse on each half. If it is not, this is
      // the empty array and our base case.
      if (p < r) {
        // (1) Partitioning.
        //
        // The partitioning chooses a pivot between `p` and `r` and moves all
        // elements that are less than or equal to the pivot to the before it, and
        // all the elements that are greater than it after it. The effect is that
        // once partition is done, the pivot is in the exact place it will be when
        // the array is put in sorted order, and it will not need to be moved
        // again. This runs in O(n) time.
        // Always choose a random pivot so that an input array which is reverse
        // sorted does not cause O(n^2) running time.
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
        // true:
        //
        //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
        //
        //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot, false) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }

        swap(ary, i + 1, j);
        var q = i + 1; // (2) Recurse on each half.

        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }

    return doQuickSort;
  }

  function cloneSort(comparator) {
    let template = SortTemplate.toString();
    let templateFn = new Function(`return ${template}`)();
    return templateFn(comparator);
  }
  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */


  let sortCache = new WeakMap();

  var quickSort_1 = function (ary, comparator, start = 0) {
    let doQuickSort = sortCache.get(comparator);

    if (doQuickSort === void 0) {
      doQuickSort = cloneSort(comparator);
      sortCache.set(comparator, doQuickSort);
    }

    doQuickSort(ary, comparator, start, ary.length - 1);
  };

  var quickSort$1 = {
  	quickSort: quickSort_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */




  var ArraySet = arraySet.ArraySet;



  var quickSort = quickSort$1.quickSort;

  function SourceMapConsumer$4(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = util$1.parseSourceMapInput(aSourceMap);
    }

    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }

  SourceMapConsumer$4.fromSourceMap = function (aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  /**
   * The version of the source mapping spec that we are consuming.
   */


  SourceMapConsumer$4.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer$4.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer$4.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });
  SourceMapConsumer$4.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer$4.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer$4.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */


  SourceMapConsumer$4.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

  SourceMapConsumer$4.GENERATED_ORDER = 1;
  SourceMapConsumer$4.ORIGINAL_ORDER = 2;
  SourceMapConsumer$4.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer$4.LEAST_UPPER_BOUND = 2;
  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */

  SourceMapConsumer$4.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer$4.GENERATED_ORDER;
    var mappings;

    switch (order) {
      case SourceMapConsumer$4.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;

      case SourceMapConsumer$4.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;

      default:
        throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    var boundCallback = aCallback.bind(context);
    var names = this._names;
    var sources = this._sources;
    var sourceMapURL = this._sourceMapURL;

    for (var i = 0, n = mappings.length; i < n; i++) {
      var mapping = mappings[i];
      var source = mapping.source === null ? null : sources.at(mapping.source);
      source = util$1.computeSourceURL(sourceRoot, source, sourceMapURL);
      boundCallback({
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : names.at(mapping.name)
      });
    }
  };
  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */


  SourceMapConsumer$4.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util$1.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.

    var needle = {
      source: util$1.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util$1.getArg(aArgs, 'column', 0)
    };
    needle.source = this._findSourceIndex(needle.source);

    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.

        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util$1.getArg(mapping, 'generatedLine', null),
            column: util$1.getArg(mapping, 'generatedColumn', null),
            lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.

        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util$1.getArg(mapping, 'generatedLine', null),
            column: util$1.getArg(mapping, 'generatedColumn', null),
            lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

  var SourceMapConsumer_1 = SourceMapConsumer$4;
  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The first parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */

  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = util$1.parseSourceMapInput(aSourceMap);
    }

    var version = util$1.getArg(sourceMap, 'version');
    var sources = util$1.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.

    var names = util$1.getArg(sourceMap, 'names', []);
    var sourceRoot = util$1.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util$1.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util$1.getArg(sourceMap, 'mappings');
    var file = util$1.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    if (sourceRoot) {
      sourceRoot = util$1.normalize(sourceRoot);
    }

    sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util$1.normalize) // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source) ? util$1.relative(sourceRoot, source) : source;
    }); // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.

    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function (s) {
      return util$1.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$4.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$4;
  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */

  BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
    var relativeSource = aSource;

    if (this.sourceRoot != null) {
      relativeSource = util$1.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    } // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.


    var i;

    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }

    return -1;
  };
  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */


  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util$1.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    }); // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();

    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util$1.compareByOriginalPositions);
    return smc;
  };
  /**
   * The version of the source mapping spec that we are consuming.
   */


  BasicSourceMapConsumer.prototype._version = 3;
  /**
   * The list of original sources.
   */

  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._absoluteSources.slice();
    }
  });
  /**
   * Provide the JIT with a nice shape / hidden class.
   */

  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */


  const compareGenerated = util$1.compareByGeneratedPositionsDeflatedNoLine;

  function sortGenerated(array, start) {
    let l = array.length;
    let n = array.length - start;

    if (n <= 1) {
      return;
    } else if (n == 2) {
      let a = array[start];
      let b = array[start + 1];

      if (compareGenerated(a, b) > 0) {
        array[start] = b;
        array[start + 1] = a;
      }
    } else if (n < 20) {
      for (let i = start; i < l; i++) {
        for (let j = i; j > start; j--) {
          let a = array[j - 1];
          let b = array[j];

          if (compareGenerated(a, b) <= 0) {
            break;
          }

          array[j - 1] = b;
          array[j] = a;
        }
      }
    } else {
      quickSort(array, compareGenerated, start);
    }
  }

  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, segment, end, value;
    let subarrayStart = 0;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
        sortGenerated(generatedMappings, subarrayStart);
        subarrayStart = generatedMappings.length;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }

        aStr.slice(index, end);
        segment = [];

        while (index < end) {
          base64Vlq.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        } // Generated column.


        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1]; // Original line.

          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

          mapping.originalLine += 1; // Original column.

          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);

        if (typeof mapping.originalLine === 'number') {
          let currentSource = mapping.source;

          while (originalMappings.length <= currentSource) {
            originalMappings.push(null);
          }

          if (originalMappings[currentSource] === null) {
            originalMappings[currentSource] = [];
          }

          originalMappings[currentSource].push(mapping);
        }
      }
    }

    sortGenerated(generatedMappings, subarrayStart);
    this.__generatedMappings = generatedMappings;

    for (var i = 0; i < originalMappings.length; i++) {
      if (originalMappings[i] != null) {
        quickSort(originalMappings[i], util$1.compareByOriginalPositionsNoSource);
      }
    }

    this.__originalMappings = [].concat(...originalMappings);
  };
  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */


  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }

    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */


  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).

      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      } // The last mapping for each line spans the entire line.


      mapping.lastGeneratedColumn = Infinity;
    }
  };
  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */


  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util$1.getArg(aArgs, 'line'),
      generatedColumn: util$1.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(aArgs, 'bias', SourceMapConsumer$4.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util$1.getArg(mapping, 'source', null);

        if (source !== null) {
          source = this._sources.at(source);
          source = util$1.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }

        var name = util$1.getArg(mapping, 'name', null);

        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source: source,
          line: util$1.getArg(mapping, 'originalLine', null),
          column: util$1.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */


  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }

    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };
  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */


  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);

    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;

    if (this.sourceRoot != null) {
      relativeSource = util$1.relative(this.sourceRoot, relativeSource);
    }

    var url;

    if (this.sourceRoot != null && (url = util$1.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    } // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.


    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */


  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util$1.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);

    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util$1.getArg(aArgs, 'line'),
      originalColumn: util$1.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(aArgs, 'bias', SourceMapConsumer$4.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util$1.getArg(mapping, 'generatedLine', null),
          column: util$1.getArg(mapping, 'generatedColumn', null),
          lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

  var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;
  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The first parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */

  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = util$1.parseSourceMapInput(aSourceMap);
    }

    var version = util$1.getArg(sourceMap, 'version');
    var sections = util$1.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }

      var offset = util$1.getArg(s, 'offset');
      var offsetLine = util$1.getArg(offset, 'line');
      var offsetColumn = util$1.getArg(offset, 'column');

      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }

      lastOffset = offset;
      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer$4(util$1.getArg(s, 'map'), aSourceMapURL)
      };
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$4.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$4;
  /**
   * The version of the source mapping spec that we are consuming.
   */

  IndexedSourceMapConsumer.prototype._version = 3;
  /**
   * The list of original sources.
   */

  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];

      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }

      return sources;
    }
  });
  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */

  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util$1.getArg(aArgs, 'line'),
      generatedColumn: util$1.getArg(aArgs, 'column')
    }; // Find the section containing the generated position we're trying to map
    // to an original position.

    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

      if (cmp) {
        return cmp;
      }

      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */


  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */


  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);

      if (content) {
        return content;
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */


  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i]; // Only consider this section if the requested source is in the list of
      // sources of the consumer.

      if (section.consumer._findSourceIndex(util$1.getArg(aArgs, 'source')) === -1) {
        continue;
      }

      var generatedPosition = section.consumer.generatedPositionFor(aArgs);

      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */


  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];

    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;

      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);

        source = util$1.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);

        this._sources.add(source);

        source = this._sources.indexOf(source);
        var name = null;

        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);

          this._names.add(name);

          name = this._names.indexOf(name);
        } // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.


        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);

        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
  };

  var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

  var sourceMapConsumer = {
  	SourceMapConsumer: SourceMapConsumer_1,
  	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
  	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var SourceMapGenerator$4 = sourceMapGenerator.SourceMapGenerator;

   // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).


  var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

  var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!

  var isSourceNode = "$$$isSourceNode$$$";
  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */

  function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }
  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */


  SourceNode$1.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode$1(); // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.

    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;

    var shiftNextLine = function () {
      var lineContents = getNextLine(); // The last line of a file might not have a newline.

      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    }; // We need to remember the position of "remainingLines"


    var lastGeneratedLine = 1,
        lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.

    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0; // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code); // No more remaining code, continue

          lastMapping = mapping;
          return;
        }
      } // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.


      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }

      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }

      lastMapping = mapping;
    }, this); // We have processed all mappings.

    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      } // and add the remaining lines without any mapping


      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    } // Copy sourcesContent into SourceNode


    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util$1.join(aRelativePath, sourceFile);
        }

        node.setSourceContent(sourceFile, content);
      }
    });
    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util$1.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode$1(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */


  SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };
  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */


  SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };
  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */


  SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;

    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];

      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */


  SourceNode$1.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;

    if (len > 0) {
      newChildren = [];

      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }

      newChildren.push(this.children[i]);
      this.children = newChildren;
    }

    return this;
  };
  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */


  SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];

    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }

    return this;
  };
  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */


  SourceNode$1.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util$1.toSetString(aSourceFile)] = aSourceContent;
  };
  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */


  SourceNode$1.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);

    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util$1.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */


  SourceNode$1.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };
  /**
   * Returns the string representation of this source node along with a source
   * map.
   */


  SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator$4(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;

      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }

        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }

      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0; // Mappings end at eol

          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };

  var SourceNode_1 = SourceNode$1;

  var sourceNode = {
  	SourceNode: SourceNode_1
  };

  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator$3 = sourceMapGenerator.SourceMapGenerator;
  var SourceMapConsumer$3 = sourceMapConsumer.SourceMapConsumer;
  var SourceNode = sourceNode.SourceNode;

  var sourceMap = {
  	SourceMapGenerator: SourceMapGenerator$3,
  	SourceMapConsumer: SourceMapConsumer$3,
  	SourceNode: SourceNode
  };

  let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';

  let customAlphabet = (alphabet, defaultSize = 21) => {
    return (size = defaultSize) => {
      let id = '';
      let i = size;

      while (i--) {
        id += alphabet[Math.random() * alphabet.length | 0];
      }

      return id;
    };
  };

  let nanoid$1 = (size = 21) => {
    let id = '';
    let i = size;

    while (i--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }

    return id;
  };

  var nonSecure = {
    nanoid: nanoid$1,
    customAlphabet
  };

  let {
    SourceMapConsumer: SourceMapConsumer$2,
    SourceMapGenerator: SourceMapGenerator$2
  } = sourceMap;

  let {
    existsSync,
    readFileSync: readFileSync$1
  } = fs__default['default'];

  let {
    dirname: dirname$1,
    join: join$1
  } = path__default['default'];

  function fromBase64(str) {
    if (Buffer) {
      return Buffer.from(str, 'base64').toString();
    } else {
      /* c8 ignore next 2 */
      return window.atob(str);
    }
  }

  class PreviousMap {
    constructor(css, opts) {
      if (opts.map === false) return;
      this.loadAnnotation(css);
      this.inline = this.startWith(this.annotation, 'data:');
      let prev = opts.map ? opts.map.prev : undefined;
      let text = this.loadMap(opts.from, prev);

      if (!this.mapFile && opts.from) {
        this.mapFile = opts.from;
      }

      if (this.mapFile) this.root = dirname$1(this.mapFile);
      if (text) this.text = text;
    }

    consumer() {
      if (!this.consumerCache) {
        this.consumerCache = new SourceMapConsumer$2(this.text);
      }

      return this.consumerCache;
    }

    decodeInline(text) {
      let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
      let baseUri = /^data:application\/json;base64,/;
      let charsetUri = /^data:application\/json;charset=utf-?8,/;
      let uri = /^data:application\/json,/;

      if (charsetUri.test(text) || uri.test(text)) {
        return decodeURIComponent(text.substr(RegExp.lastMatch.length));
      }

      if (baseCharsetUri.test(text) || baseUri.test(text)) {
        return fromBase64(text.substr(RegExp.lastMatch.length));
      }

      let encoding = text.match(/data:application\/json;([^,]+),/)[1];
      throw new Error('Unsupported source map encoding ' + encoding);
    }

    getAnnotationURL(sourceMapString) {
      return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim();
    }

    isMap(map) {
      if (typeof map !== 'object') return false;
      return typeof map.mappings === 'string' || typeof map._mappings === 'string' || Array.isArray(map.sections);
    }

    loadAnnotation(css) {
      let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!comments) return; // sourceMappingURLs from comments, strings, etc.

      let start = css.lastIndexOf(comments.pop());
      let end = css.indexOf('*/', start);

      if (start > -1 && end > -1) {
        // Locate the last sourceMappingURL to avoid pickin
        this.annotation = this.getAnnotationURL(css.substring(start, end));
      }
    }

    loadFile(path) {
      this.root = dirname$1(path);

      if (existsSync(path)) {
        this.mapFile = path;
        return readFileSync$1(path, 'utf-8').toString().trim();
      }
    }

    loadMap(file, prev) {
      if (prev === false) return false;

      if (prev) {
        if (typeof prev === 'string') {
          return prev;
        } else if (typeof prev === 'function') {
          let prevPath = prev(file);

          if (prevPath) {
            let map = this.loadFile(prevPath);

            if (!map) {
              throw new Error('Unable to load previous source map: ' + prevPath.toString());
            }

            return map;
          }
        } else if (prev instanceof SourceMapConsumer$2) {
          return SourceMapGenerator$2.fromSourceMap(prev).toString();
        } else if (prev instanceof SourceMapGenerator$2) {
          return prev.toString();
        } else if (this.isMap(prev)) {
          return JSON.stringify(prev);
        } else {
          throw new Error('Unsupported previous source map format: ' + prev.toString());
        }
      } else if (this.inline) {
        return this.decodeInline(this.annotation);
      } else if (this.annotation) {
        let map = this.annotation;
        if (file) map = join$1(dirname$1(file), map);
        return this.loadFile(map);
      }
    }

    startWith(string, start) {
      if (!string) return false;
      return string.substr(0, start.length) === start;
    }

    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }

  }

  var previousMap = PreviousMap;
  PreviousMap.default = PreviousMap;

  let {
    SourceMapConsumer: SourceMapConsumer$1,
    SourceMapGenerator: SourceMapGenerator$1
  } = sourceMap;

  let {
    fileURLToPath,
    pathToFileURL: pathToFileURL$1
  } = url__default['default'];

  let {
    isAbsolute,
    resolve: resolve$1
  } = path__default['default'];

  let {
    nanoid
  } = nonSecure;







  let fromOffsetCache = Symbol('fromOffsetCache');
  let sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);
  let pathAvailable$1 = Boolean(resolve$1 && isAbsolute);

  class Input$1 {
    constructor(css, opts = {}) {
      if (css === null || typeof css === 'undefined' || typeof css === 'object' && !css.toString) {
        throw new Error(`PostCSS received ${css} instead of CSS string`);
      }

      this.css = css.toString();

      if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
        this.hasBOM = true;
        this.css = this.css.slice(1);
      } else {
        this.hasBOM = false;
      }

      if (opts.from) {
        if (!pathAvailable$1 || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
          this.file = opts.from;
        } else {
          this.file = resolve$1(opts.from);
        }
      }

      if (pathAvailable$1 && sourceMapAvailable$1) {
        let map = new previousMap(this.css, opts);

        if (map.text) {
          this.map = map;
          let file = map.consumer().file;
          if (!this.file && file) this.file = this.mapResolve(file);
        }
      }

      if (!this.file) {
        this.id = '<input css ' + nanoid(6) + '>';
      }

      if (this.map) this.map.file = this.from;
    }

    error(message, line, column, opts = {}) {
      let result, endLine, endColumn;

      if (line && typeof line === 'object') {
        let start = line;
        let end = column;

        if (typeof start.offset === 'number') {
          let pos = this.fromOffset(start.offset);
          line = pos.line;
          column = pos.col;
        } else {
          line = start.line;
          column = start.column;
        }

        if (typeof end.offset === 'number') {
          let pos = this.fromOffset(end.offset);
          endLine = pos.line;
          endColumn = pos.col;
        } else {
          endLine = end.line;
          endColumn = end.column;
        }
      } else if (!column) {
        let pos = this.fromOffset(line);
        line = pos.line;
        column = pos.col;
      }

      let origin = this.origin(line, column, endLine, endColumn);

      if (origin) {
        result = new cssSyntaxError(message, origin.endLine === undefined ? origin.line : {
          column: origin.column,
          line: origin.line
        }, origin.endLine === undefined ? origin.column : {
          column: origin.endColumn,
          line: origin.endLine
        }, origin.source, origin.file, opts.plugin);
      } else {
        result = new cssSyntaxError(message, endLine === undefined ? line : {
          column,
          line
        }, endLine === undefined ? column : {
          column: endColumn,
          line: endLine
        }, this.css, this.file, opts.plugin);
      }

      result.input = {
        column,
        endColumn,
        endLine,
        line,
        source: this.css
      };

      if (this.file) {
        if (pathToFileURL$1) {
          result.input.url = pathToFileURL$1(this.file).toString();
        }

        result.input.file = this.file;
      }

      return result;
    }

    fromOffset(offset) {
      let lastLine, lineToIndex;

      if (!this[fromOffsetCache]) {
        let lines = this.css.split('\n');
        lineToIndex = new Array(lines.length);
        let prevIndex = 0;

        for (let i = 0, l = lines.length; i < l; i++) {
          lineToIndex[i] = prevIndex;
          prevIndex += lines[i].length + 1;
        }

        this[fromOffsetCache] = lineToIndex;
      } else {
        lineToIndex = this[fromOffsetCache];
      }

      lastLine = lineToIndex[lineToIndex.length - 1];
      let min = 0;

      if (offset >= lastLine) {
        min = lineToIndex.length - 1;
      } else {
        let max = lineToIndex.length - 2;
        let mid;

        while (min < max) {
          mid = min + (max - min >> 1);

          if (offset < lineToIndex[mid]) {
            max = mid - 1;
          } else if (offset >= lineToIndex[mid + 1]) {
            min = mid + 1;
          } else {
            min = mid;
            break;
          }
        }
      }

      return {
        col: offset - lineToIndex[min] + 1,
        line: min + 1
      };
    }

    mapResolve(file) {
      if (/^\w+:\/\//.test(file)) {
        return file;
      }

      return resolve$1(this.map.consumer().sourceRoot || this.map.root || '.', file);
    }

    origin(line, column, endLine, endColumn) {
      if (!this.map) return false;
      let consumer = this.map.consumer();
      let from = consumer.originalPositionFor({
        column,
        line
      });
      if (!from.source) return false;
      let to;

      if (typeof endLine === 'number') {
        to = consumer.originalPositionFor({
          column: endColumn,
          line: endLine
        });
      }

      let fromUrl;

      if (isAbsolute(from.source)) {
        fromUrl = pathToFileURL$1(from.source);
      } else {
        fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile));
      }

      let result = {
        column: from.column,
        endColumn: to && to.column,
        endLine: to && to.line,
        line: from.line,
        url: fromUrl.toString()
      };

      if (fromUrl.protocol === 'file:') {
        if (fileURLToPath) {
          result.file = fileURLToPath(fromUrl);
        } else {
          /* c8 ignore next 2 */
          throw new Error(`file: protocol is not available in this PostCSS build`);
        }
      }

      let source = consumer.sourceContentFor(from.source);
      if (source) result.source = source;
      return result;
    }

    toJSON() {
      let json = {};

      for (let name of ['hasBOM', 'css', 'file', 'id']) {
        if (this[name] != null) {
          json[name] = this[name];
        }
      }

      if (this.map) {
        json.map = { ...this.map
        };

        if (json.map.consumerCache) {
          json.map.consumerCache = undefined;
        }
      }

      return json;
    }

    get from() {
      return this.file || this.id;
    }

  }

  var input = Input$1;
  Input$1.default = Input$1;

  if (terminalHighlight_1 && terminalHighlight_1.registerInput) {
    terminalHighlight_1.registerInput(Input$1);
  }

  let {
    SourceMapConsumer,
    SourceMapGenerator
  } = sourceMap;

  let {
    dirname,
    relative,
    resolve,
    sep
  } = path__default['default'];

  let {
    pathToFileURL
  } = url__default['default'];



  let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
  let pathAvailable = Boolean(dirname && resolve && relative && sep);

  class MapGenerator {
    constructor(stringify, root, opts, cssString) {
      this.stringify = stringify;
      this.mapOpts = opts.map || {};
      this.root = root;
      this.opts = opts;
      this.css = cssString;
      this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
      this.memoizedFileURLs = new Map();
      this.memoizedPaths = new Map();
      this.memoizedURLs = new Map();
    }

    addAnnotation() {
      let content;

      if (this.isInline()) {
        content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
      } else if (typeof this.mapOpts.annotation === 'string') {
        content = this.mapOpts.annotation;
      } else if (typeof this.mapOpts.annotation === 'function') {
        content = this.mapOpts.annotation(this.opts.to, this.root);
      } else {
        content = this.outputFile() + '.map';
      }

      let eol = '\n';
      if (this.css.includes('\r\n')) eol = '\r\n';
      this.css += eol + '/*# sourceMappingURL=' + content + ' */';
    }

    applyPrevMaps() {
      for (let prev of this.previous()) {
        let from = this.toUrl(this.path(prev.file));
        let root = prev.root || dirname(prev.file);
        let map;

        if (this.mapOpts.sourcesContent === false) {
          map = new SourceMapConsumer(prev.text);

          if (map.sourcesContent) {
            map.sourcesContent = map.sourcesContent.map(() => null);
          }
        } else {
          map = prev.consumer();
        }

        this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
      }
    }

    clearAnnotation() {
      if (this.mapOpts.annotation === false) return;

      if (this.root) {
        let node;

        for (let i = this.root.nodes.length - 1; i >= 0; i--) {
          node = this.root.nodes[i];
          if (node.type !== 'comment') continue;

          if (node.text.indexOf('# sourceMappingURL=') === 0) {
            this.root.removeChild(i);
          }
        }
      } else if (this.css) {
        this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, '');
      }
    }

    generate() {
      this.clearAnnotation();

      if (pathAvailable && sourceMapAvailable && this.isMap()) {
        return this.generateMap();
      } else {
        let result = '';
        this.stringify(this.root, i => {
          result += i;
        });
        return [result];
      }
    }

    generateMap() {
      if (this.root) {
        this.generateString();
      } else if (this.previous().length === 1) {
        let prev = this.previous()[0].consumer();
        prev.file = this.outputFile();
        this.map = SourceMapGenerator.fromSourceMap(prev);
      } else {
        this.map = new SourceMapGenerator({
          file: this.outputFile()
        });
        this.map.addMapping({
          generated: {
            column: 0,
            line: 1
          },
          original: {
            column: 0,
            line: 1
          },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>'
        });
      }

      if (this.isSourcesContent()) this.setSourcesContent();
      if (this.root && this.previous().length > 0) this.applyPrevMaps();
      if (this.isAnnotation()) this.addAnnotation();

      if (this.isInline()) {
        return [this.css];
      } else {
        return [this.css, this.map];
      }
    }

    generateString() {
      this.css = '';
      this.map = new SourceMapGenerator({
        file: this.outputFile()
      });
      let line = 1;
      let column = 1;
      let noSource = '<no source>';
      let mapping = {
        generated: {
          column: 0,
          line: 0
        },
        original: {
          column: 0,
          line: 0
        },
        source: ''
      };
      let lines, last;
      this.stringify(this.root, (str, node, type) => {
        this.css += str;

        if (node && type !== 'end') {
          mapping.generated.line = line;
          mapping.generated.column = column - 1;

          if (node.source && node.source.start) {
            mapping.source = this.sourcePath(node);
            mapping.original.line = node.source.start.line;
            mapping.original.column = node.source.start.column - 1;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            this.map.addMapping(mapping);
          }
        }

        lines = str.match(/\n/g);

        if (lines) {
          line += lines.length;
          last = str.lastIndexOf('\n');
          column = str.length - last;
        } else {
          column += str.length;
        }

        if (node && type !== 'start') {
          let p = node.parent || {
            raws: {}
          };
          let childless = node.type === 'decl' || node.type === 'atrule' && !node.nodes;

          if (!childless || node !== p.last || p.raws.semicolon) {
            if (node.source && node.source.end) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.end.line;
              mapping.original.column = node.source.end.column - 1;
              mapping.generated.line = line;
              mapping.generated.column = column - 2;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              this.map.addMapping(mapping);
            }
          }
        }
      });
    }

    isAnnotation() {
      if (this.isInline()) {
        return true;
      }

      if (typeof this.mapOpts.annotation !== 'undefined') {
        return this.mapOpts.annotation;
      }

      if (this.previous().length) {
        return this.previous().some(i => i.annotation);
      }

      return true;
    }

    isInline() {
      if (typeof this.mapOpts.inline !== 'undefined') {
        return this.mapOpts.inline;
      }

      let annotation = this.mapOpts.annotation;

      if (typeof annotation !== 'undefined' && annotation !== true) {
        return false;
      }

      if (this.previous().length) {
        return this.previous().some(i => i.inline);
      }

      return true;
    }

    isMap() {
      if (typeof this.opts.map !== 'undefined') {
        return !!this.opts.map;
      }

      return this.previous().length > 0;
    }

    isSourcesContent() {
      if (typeof this.mapOpts.sourcesContent !== 'undefined') {
        return this.mapOpts.sourcesContent;
      }

      if (this.previous().length) {
        return this.previous().some(i => i.withContent());
      }

      return true;
    }

    outputFile() {
      if (this.opts.to) {
        return this.path(this.opts.to);
      } else if (this.opts.from) {
        return this.path(this.opts.from);
      } else {
        return 'to.css';
      }
    }

    path(file) {
      if (this.mapOpts.absolute) return file;
      if (file.charCodeAt(0) === 60
      /* `<` */
      ) return file;
      if (/^\w+:\/\//.test(file)) return file;
      let cached = this.memoizedPaths.get(file);
      if (cached) return cached;
      let from = this.opts.to ? dirname(this.opts.to) : '.';

      if (typeof this.mapOpts.annotation === 'string') {
        from = dirname(resolve(from, this.mapOpts.annotation));
      }

      let path = relative(from, file);
      this.memoizedPaths.set(file, path);
      return path;
    }

    previous() {
      if (!this.previousMaps) {
        this.previousMaps = [];

        if (this.root) {
          this.root.walk(node => {
            if (node.source && node.source.input.map) {
              let map = node.source.input.map;

              if (!this.previousMaps.includes(map)) {
                this.previousMaps.push(map);
              }
            }
          });
        } else {
          let input$1 = new input(this.css, this.opts);
          if (input$1.map) this.previousMaps.push(input$1.map);
        }
      }

      return this.previousMaps;
    }

    setSourcesContent() {
      let already = {};

      if (this.root) {
        this.root.walk(node => {
          if (node.source) {
            let from = node.source.input.from;

            if (from && !already[from]) {
              already[from] = true;
              let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
              this.map.setSourceContent(fromUrl, node.source.input.css);
            }
          }
        });
      } else if (this.css) {
        let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>';
        this.map.setSourceContent(from, this.css);
      }
    }

    sourcePath(node) {
      if (this.mapOpts.from) {
        return this.toUrl(this.mapOpts.from);
      } else if (this.usesFileUrls) {
        return this.toFileUrl(node.source.input.from);
      } else {
        return this.toUrl(this.path(node.source.input.from));
      }
    }

    toBase64(str) {
      if (Buffer) {
        return Buffer.from(str).toString('base64');
      } else {
        return window.btoa(unescape(encodeURIComponent(str)));
      }
    }

    toFileUrl(path) {
      let cached = this.memoizedFileURLs.get(path);
      if (cached) return cached;

      if (pathToFileURL) {
        let fileURL = pathToFileURL(path).toString();
        this.memoizedFileURLs.set(path, fileURL);
        return fileURL;
      } else {
        throw new Error('`map.absolute` option is not available in this PostCSS build');
      }
    }

    toUrl(path) {
      let cached = this.memoizedURLs.get(path);
      if (cached) return cached;

      if (sep === '\\') {
        path = path.replace(/\\/g, '/');
      }

      let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
      this.memoizedURLs.set(path, url);
      return url;
    }

  }

  var mapGenerator = MapGenerator;

  class Comment extends node_1 {
    constructor(defaults) {
      super(defaults);
      this.type = 'comment';
    }

  }

  var comment$1 = Comment;
  Comment.default = Comment;

  let {
    isClean: isClean$1,
    my: my$1
  } = symbols$1;







  let parse$a, Rule$1, AtRule$1, Root$1;

  function cleanSource(nodes) {
    return nodes.map(i => {
      if (i.nodes) i.nodes = cleanSource(i.nodes);
      delete i.source;
      return i;
    });
  }

  function markDirtyUp(node) {
    node[isClean$1] = false;

    if (node.proxyOf.nodes) {
      for (let i of node.proxyOf.nodes) {
        markDirtyUp(i);
      }
    }
  }

  class Container extends node_1 {
    append(...children) {
      for (let child of children) {
        let nodes = this.normalize(child, this.last);

        for (let node of nodes) this.proxyOf.nodes.push(node);
      }

      this.markDirty();
      return this;
    }

    cleanRaws(keepBetween) {
      super.cleanRaws(keepBetween);

      if (this.nodes) {
        for (let node of this.nodes) node.cleanRaws(keepBetween);
      }
    }

    each(callback) {
      if (!this.proxyOf.nodes) return undefined;
      let iterator = this.getIterator();
      let index, result;

      while (this.indexes[iterator] < this.proxyOf.nodes.length) {
        index = this.indexes[iterator];
        result = callback(this.proxyOf.nodes[index], index);
        if (result === false) break;
        this.indexes[iterator] += 1;
      }

      delete this.indexes[iterator];
      return result;
    }

    every(condition) {
      return this.nodes.every(condition);
    }

    getIterator() {
      if (!this.lastEach) this.lastEach = 0;
      if (!this.indexes) this.indexes = {};
      this.lastEach += 1;
      let iterator = this.lastEach;
      this.indexes[iterator] = 0;
      return iterator;
    }

    getProxyProcessor() {
      return {
        get(node, prop) {
          if (prop === 'proxyOf') {
            return node;
          } else if (!node[prop]) {
            return node[prop];
          } else if (prop === 'each' || typeof prop === 'string' && prop.startsWith('walk')) {
            return (...args) => {
              return node[prop](...args.map(i => {
                if (typeof i === 'function') {
                  return (child, index) => i(child.toProxy(), index);
                } else {
                  return i;
                }
              }));
            };
          } else if (prop === 'every' || prop === 'some') {
            return cb => {
              return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
            };
          } else if (prop === 'root') {
            return () => node.root().toProxy();
          } else if (prop === 'nodes') {
            return node.nodes.map(i => i.toProxy());
          } else if (prop === 'first' || prop === 'last') {
            return node[prop].toProxy();
          } else {
            return node[prop];
          }
        },

        set(node, prop, value) {
          if (node[prop] === value) return true;
          node[prop] = value;

          if (prop === 'name' || prop === 'params' || prop === 'selector') {
            node.markDirty();
          }

          return true;
        }

      };
    }

    index(child) {
      if (typeof child === 'number') return child;
      if (child.proxyOf) child = child.proxyOf;
      return this.proxyOf.nodes.indexOf(child);
    }

    insertAfter(exist, add) {
      let existIndex = this.index(exist);
      let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
      existIndex = this.index(exist);

      for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);

      let index;

      for (let id in this.indexes) {
        index = this.indexes[id];

        if (existIndex < index) {
          this.indexes[id] = index + nodes.length;
        }
      }

      this.markDirty();
      return this;
    }

    insertBefore(exist, add) {
      let existIndex = this.index(exist);
      let type = existIndex === 0 ? 'prepend' : false;
      let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
      existIndex = this.index(exist);

      for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);

      let index;

      for (let id in this.indexes) {
        index = this.indexes[id];

        if (existIndex <= index) {
          this.indexes[id] = index + nodes.length;
        }
      }

      this.markDirty();
      return this;
    }

    normalize(nodes, sample) {
      if (typeof nodes === 'string') {
        nodes = cleanSource(parse$a(nodes).nodes);
      } else if (Array.isArray(nodes)) {
        nodes = nodes.slice(0);

        for (let i of nodes) {
          if (i.parent) i.parent.removeChild(i, 'ignore');
        }
      } else if (nodes.type === 'root' && this.type !== 'document') {
        nodes = nodes.nodes.slice(0);

        for (let i of nodes) {
          if (i.parent) i.parent.removeChild(i, 'ignore');
        }
      } else if (nodes.type) {
        nodes = [nodes];
      } else if (nodes.prop) {
        if (typeof nodes.value === 'undefined') {
          throw new Error('Value field is missed in node creation');
        } else if (typeof nodes.value !== 'string') {
          nodes.value = String(nodes.value);
        }

        nodes = [new declaration(nodes)];
      } else if (nodes.selector) {
        nodes = [new Rule$1(nodes)];
      } else if (nodes.name) {
        nodes = [new AtRule$1(nodes)];
      } else if (nodes.text) {
        nodes = [new comment$1(nodes)];
      } else {
        throw new Error('Unknown node type in node creation');
      }

      let processed = nodes.map(i => {
        /* c8 ignore next */
        if (!i[my$1]) Container.rebuild(i);
        i = i.proxyOf;
        if (i.parent) i.parent.removeChild(i);
        if (i[isClean$1]) markDirtyUp(i);

        if (typeof i.raws.before === 'undefined') {
          if (sample && typeof sample.raws.before !== 'undefined') {
            i.raws.before = sample.raws.before.replace(/\S/g, '');
          }
        }

        i.parent = this.proxyOf;
        return i;
      });
      return processed;
    }

    prepend(...children) {
      children = children.reverse();

      for (let child of children) {
        let nodes = this.normalize(child, this.first, 'prepend').reverse();

        for (let node of nodes) this.proxyOf.nodes.unshift(node);

        for (let id in this.indexes) {
          this.indexes[id] = this.indexes[id] + nodes.length;
        }
      }

      this.markDirty();
      return this;
    }

    push(child) {
      child.parent = this;
      this.proxyOf.nodes.push(child);
      return this;
    }

    removeAll() {
      for (let node of this.proxyOf.nodes) node.parent = undefined;

      this.proxyOf.nodes = [];
      this.markDirty();
      return this;
    }

    removeChild(child) {
      child = this.index(child);
      this.proxyOf.nodes[child].parent = undefined;
      this.proxyOf.nodes.splice(child, 1);
      let index;

      for (let id in this.indexes) {
        index = this.indexes[id];

        if (index >= child) {
          this.indexes[id] = index - 1;
        }
      }

      this.markDirty();
      return this;
    }

    replaceValues(pattern, opts, callback) {
      if (!callback) {
        callback = opts;
        opts = {};
      }

      this.walkDecls(decl => {
        if (opts.props && !opts.props.includes(decl.prop)) return;
        if (opts.fast && !decl.value.includes(opts.fast)) return;
        decl.value = decl.value.replace(pattern, callback);
      });
      this.markDirty();
      return this;
    }

    some(condition) {
      return this.nodes.some(condition);
    }

    walk(callback) {
      return this.each((child, i) => {
        let result;

        try {
          result = callback(child, i);
        } catch (e) {
          throw child.addToError(e);
        }

        if (result !== false && child.walk) {
          result = child.walk(callback);
        }

        return result;
      });
    }

    walkAtRules(name, callback) {
      if (!callback) {
        callback = name;
        return this.walk((child, i) => {
          if (child.type === 'atrule') {
            return callback(child, i);
          }
        });
      }

      if (name instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === 'atrule' && name.test(child.name)) {
            return callback(child, i);
          }
        });
      }

      return this.walk((child, i) => {
        if (child.type === 'atrule' && child.name === name) {
          return callback(child, i);
        }
      });
    }

    walkComments(callback) {
      return this.walk((child, i) => {
        if (child.type === 'comment') {
          return callback(child, i);
        }
      });
    }

    walkDecls(prop, callback) {
      if (!callback) {
        callback = prop;
        return this.walk((child, i) => {
          if (child.type === 'decl') {
            return callback(child, i);
          }
        });
      }

      if (prop instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === 'decl' && prop.test(child.prop)) {
            return callback(child, i);
          }
        });
      }

      return this.walk((child, i) => {
        if (child.type === 'decl' && child.prop === prop) {
          return callback(child, i);
        }
      });
    }

    walkRules(selector, callback) {
      if (!callback) {
        callback = selector;
        return this.walk((child, i) => {
          if (child.type === 'rule') {
            return callback(child, i);
          }
        });
      }

      if (selector instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === 'rule' && selector.test(child.selector)) {
            return callback(child, i);
          }
        });
      }

      return this.walk((child, i) => {
        if (child.type === 'rule' && child.selector === selector) {
          return callback(child, i);
        }
      });
    }

    get first() {
      if (!this.proxyOf.nodes) return undefined;
      return this.proxyOf.nodes[0];
    }

    get last() {
      if (!this.proxyOf.nodes) return undefined;
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }

  }

  Container.registerParse = dependant => {
    parse$a = dependant;
  };

  Container.registerRule = dependant => {
    Rule$1 = dependant;
  };

  Container.registerAtRule = dependant => {
    AtRule$1 = dependant;
  };

  Container.registerRoot = dependant => {
    Root$1 = dependant;
  };

  var container$1 = Container;
  Container.default = Container;
  /* c8 ignore start */

  Container.rebuild = node => {
    if (node.type === 'atrule') {
      Object.setPrototypeOf(node, AtRule$1.prototype);
    } else if (node.type === 'rule') {
      Object.setPrototypeOf(node, Rule$1.prototype);
    } else if (node.type === 'decl') {
      Object.setPrototypeOf(node, declaration.prototype);
    } else if (node.type === 'comment') {
      Object.setPrototypeOf(node, comment$1.prototype);
    } else if (node.type === 'root') {
      Object.setPrototypeOf(node, Root$1.prototype);
    }

    node[my$1] = true;

    if (node.nodes) {
      node.nodes.forEach(child => {
        Container.rebuild(child);
      });
    }
  };

  let LazyResult$3, Processor$2;

  class Document extends container$1 {
    constructor(defaults) {
      // type needs to be passed to super, otherwise child roots won't be normalized correctly
      super({
        type: 'document',
        ...defaults
      });

      if (!this.nodes) {
        this.nodes = [];
      }
    }

    toResult(opts = {}) {
      let lazy = new LazyResult$3(new Processor$2(), this, opts);
      return lazy.stringify();
    }

  }

  Document.registerLazyResult = dependant => {
    LazyResult$3 = dependant;
  };

  Document.registerProcessor = dependant => {
    Processor$2 = dependant;
  };

  var document$1 = Document;
  Document.default = Document;

  /* eslint-disable no-console */

  let printed = {};

  var warnOnce = function warnOnce(message) {
    if (printed[message]) return;
    printed[message] = true;

    if (typeof console !== 'undefined' && console.warn) {
      console.warn(message);
    }
  };

  class AtRule extends container$1 {
    constructor(defaults) {
      super(defaults);
      this.type = 'atrule';
    }

    append(...children) {
      if (!this.proxyOf.nodes) this.nodes = [];
      return super.append(...children);
    }

    prepend(...children) {
      if (!this.proxyOf.nodes) this.nodes = [];
      return super.prepend(...children);
    }

  }

  var atRule = AtRule;
  AtRule.default = AtRule;
  container$1.registerAtRule(AtRule);

  let LazyResult$2, Processor$1;

  class Root extends container$1 {
    constructor(defaults) {
      super(defaults);
      this.type = 'root';
      if (!this.nodes) this.nodes = [];
    }

    normalize(child, sample, type) {
      let nodes = super.normalize(child);

      if (sample) {
        if (type === 'prepend') {
          if (this.nodes.length > 1) {
            sample.raws.before = this.nodes[1].raws.before;
          } else {
            delete sample.raws.before;
          }
        } else if (this.first !== sample) {
          for (let node of nodes) {
            node.raws.before = sample.raws.before;
          }
        }
      }

      return nodes;
    }

    removeChild(child, ignore) {
      let index = this.index(child);

      if (!ignore && index === 0 && this.nodes.length > 1) {
        this.nodes[1].raws.before = this.nodes[index].raws.before;
      }

      return super.removeChild(child);
    }

    toResult(opts = {}) {
      let lazy = new LazyResult$2(new Processor$1(), this, opts);
      return lazy.stringify();
    }

  }

  Root.registerLazyResult = dependant => {
    LazyResult$2 = dependant;
  };

  Root.registerProcessor = dependant => {
    Processor$1 = dependant;
  };

  var root$1 = Root;
  Root.default = Root;
  container$1.registerRoot(Root);

  let list = {
    comma(string) {
      return list.split(string, [','], true);
    },

    space(string) {
      let spaces = [' ', '\n', '\t'];
      return list.split(string, spaces);
    },

    split(string, separators, last) {
      let array = [];
      let current = '';
      let split = false;
      let func = 0;
      let inQuote = false;
      let prevQuote = '';
      let escape = false;

      for (let letter of string) {
        if (escape) {
          escape = false;
        } else if (letter === '\\') {
          escape = true;
        } else if (inQuote) {
          if (letter === prevQuote) {
            inQuote = false;
          }
        } else if (letter === '"' || letter === "'") {
          inQuote = true;
          prevQuote = letter;
        } else if (letter === '(') {
          func += 1;
        } else if (letter === ')') {
          if (func > 0) func -= 1;
        } else if (func === 0) {
          if (separators.includes(letter)) split = true;
        }

        if (split) {
          if (current !== '') array.push(current.trim());
          current = '';
          split = false;
        } else {
          current += letter;
        }
      }

      if (last || current !== '') array.push(current.trim());
      return array;
    }

  };
  var list_1 = list;
  list.default = list;

  class Rule extends container$1 {
    constructor(defaults) {
      super(defaults);
      this.type = 'rule';
      if (!this.nodes) this.nodes = [];
    }

    get selectors() {
      return list_1.comma(this.selector);
    }

    set selectors(values) {
      let match = this.selector ? this.selector.match(/,\s*/) : null;
      let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
      this.selector = values.join(sep);
    }

  }

  var rule$2b = Rule;
  Rule.default = Rule;
  container$1.registerRule(Rule);

  const SAFE_COMMENT_NEIGHBOR = {
    empty: true,
    space: true
  };

  function findLastWithPosition(tokens) {
    for (let i = tokens.length - 1; i >= 0; i--) {
      let token = tokens[i];
      let pos = token[3] || token[2];
      if (pos) return pos;
    }
  }

  class Parser {
    constructor(input) {
      this.input = input;
      this.root = new root$1();
      this.current = this.root;
      this.spaces = '';
      this.semicolon = false;
      this.customProperty = false;
      this.createTokenizer();
      this.root.source = {
        input,
        start: {
          column: 1,
          line: 1,
          offset: 0
        }
      };
    }

    atrule(token) {
      let node = new atRule();
      node.name = token[1].slice(1);

      if (node.name === '') {
        this.unnamedAtrule(node, token);
      }

      this.init(node, token[2]);
      let type;
      let prev;
      let shift;
      let last = false;
      let open = false;
      let params = [];
      let brackets = [];

      while (!this.tokenizer.endOfFile()) {
        token = this.tokenizer.nextToken();
        type = token[0];

        if (type === '(' || type === '[') {
          brackets.push(type === '(' ? ')' : ']');
        } else if (type === '{' && brackets.length > 0) {
          brackets.push('}');
        } else if (type === brackets[brackets.length - 1]) {
          brackets.pop();
        }

        if (brackets.length === 0) {
          if (type === ';') {
            node.source.end = this.getPosition(token[2]);
            node.source.end.offset++;
            this.semicolon = true;
            break;
          } else if (type === '{') {
            open = true;
            break;
          } else if (type === '}') {
            if (params.length > 0) {
              shift = params.length - 1;
              prev = params[shift];

              while (prev && prev[0] === 'space') {
                prev = params[--shift];
              }

              if (prev) {
                node.source.end = this.getPosition(prev[3] || prev[2]);
                node.source.end.offset++;
              }
            }

            this.end(token);
            break;
          } else {
            params.push(token);
          }
        } else {
          params.push(token);
        }

        if (this.tokenizer.endOfFile()) {
          last = true;
          break;
        }
      }

      node.raws.between = this.spacesAndCommentsFromEnd(params);

      if (params.length) {
        node.raws.afterName = this.spacesAndCommentsFromStart(params);
        this.raw(node, 'params', params);

        if (last) {
          token = params[params.length - 1];
          node.source.end = this.getPosition(token[3] || token[2]);
          node.source.end.offset++;
          this.spaces = node.raws.between;
          node.raws.between = '';
        }
      } else {
        node.raws.afterName = '';
        node.params = '';
      }

      if (open) {
        node.nodes = [];
        this.current = node;
      }
    }

    checkMissedSemicolon(tokens) {
      let colon = this.colon(tokens);
      if (colon === false) return;
      let founded = 0;
      let token;

      for (let j = colon - 1; j >= 0; j--) {
        token = tokens[j];

        if (token[0] !== 'space') {
          founded += 1;
          if (founded === 2) break;
        }
      } // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
      // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
      // And because we need it after that one we do +1 to get the next one.


      throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);
    }

    colon(tokens) {
      let brackets = 0;
      let token, type, prev;

      for (let [i, element] of tokens.entries()) {
        token = element;
        type = token[0];

        if (type === '(') {
          brackets += 1;
        }

        if (type === ')') {
          brackets -= 1;
        }

        if (brackets === 0 && type === ':') {
          if (!prev) {
            this.doubleColon(token);
          } else if (prev[0] === 'word' && prev[1] === 'progid') {
            continue;
          } else {
            return i;
          }
        }

        prev = token;
      }

      return false;
    }

    comment(token) {
      let node = new comment$1();
      this.init(node, token[2]);
      node.source.end = this.getPosition(token[3] || token[2]);
      node.source.end.offset++;
      let text = token[1].slice(2, -2);

      if (/^\s*$/.test(text)) {
        node.text = '';
        node.raws.left = text;
        node.raws.right = '';
      } else {
        let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
        node.text = match[2];
        node.raws.left = match[1];
        node.raws.right = match[3];
      }
    }

    createTokenizer() {
      this.tokenizer = tokenize$6(this.input);
    }

    decl(tokens, customProperty) {
      let node = new declaration();
      this.init(node, tokens[0][2]);
      let last = tokens[tokens.length - 1];

      if (last[0] === ';') {
        this.semicolon = true;
        tokens.pop();
      }

      node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
      node.source.end.offset++;

      while (tokens[0][0] !== 'word') {
        if (tokens.length === 1) this.unknownWord(tokens);
        node.raws.before += tokens.shift()[1];
      }

      node.source.start = this.getPosition(tokens[0][2]);
      node.prop = '';

      while (tokens.length) {
        let type = tokens[0][0];

        if (type === ':' || type === 'space' || type === 'comment') {
          break;
        }

        node.prop += tokens.shift()[1];
      }

      node.raws.between = '';
      let token;

      while (tokens.length) {
        token = tokens.shift();

        if (token[0] === ':') {
          node.raws.between += token[1];
          break;
        } else {
          if (token[0] === 'word' && /\w/.test(token[1])) {
            this.unknownWord([token]);
          }

          node.raws.between += token[1];
        }
      }

      if (node.prop[0] === '_' || node.prop[0] === '*') {
        node.raws.before += node.prop[0];
        node.prop = node.prop.slice(1);
      }

      let firstSpaces = [];
      let next;

      while (tokens.length) {
        next = tokens[0][0];
        if (next !== 'space' && next !== 'comment') break;
        firstSpaces.push(tokens.shift());
      }

      this.precheckMissedSemicolon(tokens);

      for (let i = tokens.length - 1; i >= 0; i--) {
        token = tokens[i];

        if (token[1].toLowerCase() === '!important') {
          node.important = true;
          let string = this.stringFrom(tokens, i);
          string = this.spacesFromEnd(tokens) + string;
          if (string !== ' !important') node.raws.important = string;
          break;
        } else if (token[1].toLowerCase() === 'important') {
          let cache = tokens.slice(0);
          let str = '';

          for (let j = i; j > 0; j--) {
            let type = cache[j][0];

            if (str.trim().indexOf('!') === 0 && type !== 'space') {
              break;
            }

            str = cache.pop()[1] + str;
          }

          if (str.trim().indexOf('!') === 0) {
            node.important = true;
            node.raws.important = str;
            tokens = cache;
          }
        }

        if (token[0] !== 'space' && token[0] !== 'comment') {
          break;
        }
      }

      let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');

      if (hasWord) {
        node.raws.between += firstSpaces.map(i => i[1]).join('');
        firstSpaces = [];
      }

      this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);

      if (node.value.includes(':') && !customProperty) {
        this.checkMissedSemicolon(tokens);
      }
    }

    doubleColon(token) {
      throw this.input.error('Double colon', {
        offset: token[2]
      }, {
        offset: token[2] + token[1].length
      });
    }

    emptyRule(token) {
      let node = new rule$2b();
      this.init(node, token[2]);
      node.selector = '';
      node.raws.between = '';
      this.current = node;
    }

    end(token) {
      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }

      this.semicolon = false;
      this.current.raws.after = (this.current.raws.after || '') + this.spaces;
      this.spaces = '';

      if (this.current.parent) {
        this.current.source.end = this.getPosition(token[2]);
        this.current.source.end.offset++;
        this.current = this.current.parent;
      } else {
        this.unexpectedClose(token);
      }
    }

    endFile() {
      if (this.current.parent) this.unclosedBlock();

      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }

      this.current.raws.after = (this.current.raws.after || '') + this.spaces;
      this.root.source.end = this.getPosition(this.tokenizer.position());
    }

    freeSemicolon(token) {
      this.spaces += token[1];

      if (this.current.nodes) {
        let prev = this.current.nodes[this.current.nodes.length - 1];

        if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
          prev.raws.ownSemicolon = this.spaces;
          this.spaces = '';
        }
      }
    } // Helpers


    getPosition(offset) {
      let pos = this.input.fromOffset(offset);
      return {
        column: pos.col,
        line: pos.line,
        offset
      };
    }

    init(node, offset) {
      this.current.push(node);
      node.source = {
        input: this.input,
        start: this.getPosition(offset)
      };
      node.raws.before = this.spaces;
      this.spaces = '';
      if (node.type !== 'comment') this.semicolon = false;
    }

    other(start) {
      let end = false;
      let type = null;
      let colon = false;
      let bracket = null;
      let brackets = [];
      let customProperty = start[1].startsWith('--');
      let tokens = [];
      let token = start;

      while (token) {
        type = token[0];
        tokens.push(token);

        if (type === '(' || type === '[') {
          if (!bracket) bracket = token;
          brackets.push(type === '(' ? ')' : ']');
        } else if (customProperty && colon && type === '{') {
          if (!bracket) bracket = token;
          brackets.push('}');
        } else if (brackets.length === 0) {
          if (type === ';') {
            if (colon) {
              this.decl(tokens, customProperty);
              return;
            } else {
              break;
            }
          } else if (type === '{') {
            this.rule(tokens);
            return;
          } else if (type === '}') {
            this.tokenizer.back(tokens.pop());
            end = true;
            break;
          } else if (type === ':') {
            colon = true;
          }
        } else if (type === brackets[brackets.length - 1]) {
          brackets.pop();
          if (brackets.length === 0) bracket = null;
        }

        token = this.tokenizer.nextToken();
      }

      if (this.tokenizer.endOfFile()) end = true;
      if (brackets.length > 0) this.unclosedBracket(bracket);

      if (end && colon) {
        if (!customProperty) {
          while (tokens.length) {
            token = tokens[tokens.length - 1][0];
            if (token !== 'space' && token !== 'comment') break;
            this.tokenizer.back(tokens.pop());
          }
        }

        this.decl(tokens, customProperty);
      } else {
        this.unknownWord(tokens);
      }
    }

    parse() {
      let token;

      while (!this.tokenizer.endOfFile()) {
        token = this.tokenizer.nextToken();

        switch (token[0]) {
          case 'space':
            this.spaces += token[1];
            break;

          case ';':
            this.freeSemicolon(token);
            break;

          case '}':
            this.end(token);
            break;

          case 'comment':
            this.comment(token);
            break;

          case 'at-word':
            this.atrule(token);
            break;

          case '{':
            this.emptyRule(token);
            break;

          default:
            this.other(token);
            break;
        }
      }

      this.endFile();
    }

    precheckMissedSemicolon()
    /* tokens */
    {// Hook for Safe Parser
    }

    raw(node, prop, tokens, customProperty) {
      let token, type;
      let length = tokens.length;
      let value = '';
      let clean = true;
      let next, prev;

      for (let i = 0; i < length; i += 1) {
        token = tokens[i];
        type = token[0];

        if (type === 'space' && i === length - 1 && !customProperty) {
          clean = false;
        } else if (type === 'comment') {
          prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';
          next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';

          if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
            if (value.slice(-1) === ',') {
              clean = false;
            } else {
              value += token[1];
            }
          } else {
            clean = false;
          }
        } else {
          value += token[1];
        }
      }

      if (!clean) {
        let raw = tokens.reduce((all, i) => all + i[1], '');
        node.raws[prop] = {
          raw,
          value
        };
      }

      node[prop] = value;
    }

    rule(tokens) {
      tokens.pop();
      let node = new rule$2b();
      this.init(node, tokens[0][2]);
      node.raws.between = this.spacesAndCommentsFromEnd(tokens);
      this.raw(node, 'selector', tokens);
      this.current = node;
    }

    spacesAndCommentsFromEnd(tokens) {
      let lastTokenType;
      let spaces = '';

      while (tokens.length) {
        lastTokenType = tokens[tokens.length - 1][0];
        if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
        spaces = tokens.pop()[1] + spaces;
      }

      return spaces;
    } // Errors


    spacesAndCommentsFromStart(tokens) {
      let next;
      let spaces = '';

      while (tokens.length) {
        next = tokens[0][0];
        if (next !== 'space' && next !== 'comment') break;
        spaces += tokens.shift()[1];
      }

      return spaces;
    }

    spacesFromEnd(tokens) {
      let lastTokenType;
      let spaces = '';

      while (tokens.length) {
        lastTokenType = tokens[tokens.length - 1][0];
        if (lastTokenType !== 'space') break;
        spaces = tokens.pop()[1] + spaces;
      }

      return spaces;
    }

    stringFrom(tokens, from) {
      let result = '';

      for (let i = from; i < tokens.length; i++) {
        result += tokens[i][1];
      }

      tokens.splice(from, tokens.length - from);
      return result;
    }

    unclosedBlock() {
      let pos = this.current.source.start;
      throw this.input.error('Unclosed block', pos.line, pos.column);
    }

    unclosedBracket(bracket) {
      throw this.input.error('Unclosed bracket', {
        offset: bracket[2]
      }, {
        offset: bracket[2] + 1
      });
    }

    unexpectedClose(token) {
      throw this.input.error('Unexpected }', {
        offset: token[2]
      }, {
        offset: token[2] + 1
      });
    }

    unknownWord(tokens) {
      throw this.input.error('Unknown word', {
        offset: tokens[0][2]
      }, {
        offset: tokens[0][2] + tokens[0][1].length
      });
    }

    unnamedAtrule(node, token) {
      throw this.input.error('At-rule without name', {
        offset: token[2]
      }, {
        offset: token[2] + token[1].length
      });
    }

  }

  var parser$1 = Parser;

  function parse$9(css, opts) {
    let input$1 = new input(css, opts);
    let parser = new parser$1(input$1);

    try {
      parser.parse();
    } catch (e) {
      {
        if (e.name === 'CssSyntaxError' && opts && opts.from) {
          if (/\.scss$/i.test(opts.from)) {
            e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
          } else if (/\.sass/i.test(opts.from)) {
            e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
          } else if (/\.less$/i.test(opts.from)) {
            e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
          }
        }
      }

      throw e;
    }

    return parser.root;
  }

  var parse_1$5 = parse$9;
  parse$9.default = parse$9;
  container$1.registerParse(parse$9);

  let {
    isClean,
    my
  } = symbols$1;

















  const TYPE_TO_CLASS_NAME = {
    atrule: 'AtRule',
    comment: 'Comment',
    decl: 'Declaration',
    document: 'Document',
    root: 'Root',
    rule: 'Rule'
  };
  const PLUGIN_PROPS = {
    AtRule: true,
    AtRuleExit: true,
    Comment: true,
    CommentExit: true,
    Declaration: true,
    DeclarationExit: true,
    Document: true,
    DocumentExit: true,
    Once: true,
    OnceExit: true,
    postcssPlugin: true,
    prepare: true,
    Root: true,
    RootExit: true,
    Rule: true,
    RuleExit: true
  };
  const NOT_VISITORS = {
    Once: true,
    postcssPlugin: true,
    prepare: true
  };
  const CHILDREN = 0;

  function isPromise(obj) {
    return typeof obj === 'object' && typeof obj.then === 'function';
  }

  function getEvents(node) {
    let key = false;
    let type = TYPE_TO_CLASS_NAME[node.type];

    if (node.type === 'decl') {
      key = node.prop.toLowerCase();
    } else if (node.type === 'atrule') {
      key = node.name.toLowerCase();
    }

    if (key && node.append) {
      return [type, type + '-' + key, CHILDREN, type + 'Exit', type + 'Exit-' + key];
    } else if (key) {
      return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key];
    } else if (node.append) {
      return [type, CHILDREN, type + 'Exit'];
    } else {
      return [type, type + 'Exit'];
    }
  }

  function toStack(node) {
    let events;

    if (node.type === 'document') {
      events = ['Document', CHILDREN, 'DocumentExit'];
    } else if (node.type === 'root') {
      events = ['Root', CHILDREN, 'RootExit'];
    } else {
      events = getEvents(node);
    }

    return {
      eventIndex: 0,
      events,
      iterator: 0,
      node,
      visitorIndex: 0,
      visitors: []
    };
  }

  function cleanMarks(node) {
    node[isClean] = false;
    if (node.nodes) node.nodes.forEach(i => cleanMarks(i));
    return node;
  }

  let postcss$3 = {};

  class LazyResult$1 {
    constructor(processor, css, opts) {
      this.stringified = false;
      this.processed = false;
      let root;

      if (typeof css === 'object' && css !== null && (css.type === 'root' || css.type === 'document')) {
        root = cleanMarks(css);
      } else if (css instanceof LazyResult$1 || css instanceof result) {
        root = cleanMarks(css.root);

        if (css.map) {
          if (typeof opts.map === 'undefined') opts.map = {};
          if (!opts.map.inline) opts.map.inline = false;
          opts.map.prev = css.map;
        }
      } else {
        let parser = parse_1$5;
        if (opts.syntax) parser = opts.syntax.parse;
        if (opts.parser) parser = opts.parser;
        if (parser.parse) parser = parser.parse;

        try {
          root = parser(css, opts);
        } catch (error) {
          this.processed = true;
          this.error = error;
        }

        if (root && !root[my]) {
          /* c8 ignore next 2 */
          container$1.rebuild(root);
        }
      }

      this.result = new result(processor, root, opts);
      this.helpers = { ...postcss$3,
        postcss: postcss$3,
        result: this.result
      };
      this.plugins = this.processor.plugins.map(plugin => {
        if (typeof plugin === 'object' && plugin.prepare) {
          return { ...plugin,
            ...plugin.prepare(this.result)
          };
        } else {
          return plugin;
        }
      });
    }

    async() {
      if (this.error) return Promise.reject(this.error);
      if (this.processed) return Promise.resolve(this.result);

      if (!this.processing) {
        this.processing = this.runAsync();
      }

      return this.processing;
    }

    catch(onRejected) {
      return this.async().catch(onRejected);
    }

    finally(onFinally) {
      return this.async().then(onFinally, onFinally);
    }

    getAsyncError() {
      throw new Error('Use process(css).then(cb) to work with async plugins');
    }

    handleError(error, node) {
      let plugin = this.result.lastPlugin;

      try {
        if (node) node.addToError(error);
        this.error = error;

        if (error.name === 'CssSyntaxError' && !error.plugin) {
          error.plugin = plugin.postcssPlugin;
          error.setMessage();
        } else if (plugin.postcssVersion) {
          if ("development" !== 'production') {
            let pluginName = plugin.postcssPlugin;
            let pluginVer = plugin.postcssVersion;
            let runtimeVer = this.result.processor.version;
            let a = pluginVer.split('.');
            let b = runtimeVer.split('.');

            if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
              // eslint-disable-next-line no-console
              console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');
            }
          }
        }
      } catch (err) {
        /* c8 ignore next 3 */
        // eslint-disable-next-line no-console
        if (console && console.error) console.error(err);
      }

      return error;
    }

    prepareVisitors() {
      this.listeners = {};

      let add = (plugin, type, cb) => {
        if (!this.listeners[type]) this.listeners[type] = [];
        this.listeners[type].push([plugin, cb]);
      };

      for (let plugin of this.plugins) {
        if (typeof plugin === 'object') {
          for (let event in plugin) {
            if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
              throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. ` + `Try to update PostCSS (${this.processor.version} now).`);
            }

            if (!NOT_VISITORS[event]) {
              if (typeof plugin[event] === 'object') {
                for (let filter in plugin[event]) {
                  if (filter === '*') {
                    add(plugin, event, plugin[event][filter]);
                  } else {
                    add(plugin, event + '-' + filter.toLowerCase(), plugin[event][filter]);
                  }
                }
              } else if (typeof plugin[event] === 'function') {
                add(plugin, event, plugin[event]);
              }
            }
          }
        }
      }

      this.hasListener = Object.keys(this.listeners).length > 0;
    }

    async runAsync() {
      this.plugin = 0;

      for (let i = 0; i < this.plugins.length; i++) {
        let plugin = this.plugins[i];
        let promise = this.runOnRoot(plugin);

        if (isPromise(promise)) {
          try {
            await promise;
          } catch (error) {
            throw this.handleError(error);
          }
        }
      }

      this.prepareVisitors();

      if (this.hasListener) {
        let root = this.result.root;

        while (!root[isClean]) {
          root[isClean] = true;
          let stack = [toStack(root)];

          while (stack.length > 0) {
            let promise = this.visitTick(stack);

            if (isPromise(promise)) {
              try {
                await promise;
              } catch (e) {
                let node = stack[stack.length - 1].node;
                throw this.handleError(e, node);
              }
            }
          }
        }

        if (this.listeners.OnceExit) {
          for (let [plugin, visitor] of this.listeners.OnceExit) {
            this.result.lastPlugin = plugin;

            try {
              if (root.type === 'document') {
                let roots = root.nodes.map(subRoot => visitor(subRoot, this.helpers));
                await Promise.all(roots);
              } else {
                await visitor(root, this.helpers);
              }
            } catch (e) {
              throw this.handleError(e);
            }
          }
        }
      }

      this.processed = true;
      return this.stringify();
    }

    runOnRoot(plugin) {
      this.result.lastPlugin = plugin;

      try {
        if (typeof plugin === 'object' && plugin.Once) {
          if (this.result.root.type === 'document') {
            let roots = this.result.root.nodes.map(root => plugin.Once(root, this.helpers));

            if (isPromise(roots[0])) {
              return Promise.all(roots);
            }

            return roots;
          }

          return plugin.Once(this.result.root, this.helpers);
        } else if (typeof plugin === 'function') {
          return plugin(this.result.root, this.result);
        }
      } catch (error) {
        throw this.handleError(error);
      }
    }

    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = true;
      this.sync();
      let opts = this.result.opts;
      let str = stringify_1$1;
      if (opts.syntax) str = opts.syntax.stringify;
      if (opts.stringifier) str = opts.stringifier;
      if (str.stringify) str = str.stringify;
      let map = new mapGenerator(str, this.result.root, this.result.opts);
      let data = map.generate();
      this.result.css = data[0];
      this.result.map = data[1];
      return this.result;
    }

    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      this.processed = true;

      if (this.processing) {
        throw this.getAsyncError();
      }

      for (let plugin of this.plugins) {
        let promise = this.runOnRoot(plugin);

        if (isPromise(promise)) {
          throw this.getAsyncError();
        }
      }

      this.prepareVisitors();

      if (this.hasListener) {
        let root = this.result.root;

        while (!root[isClean]) {
          root[isClean] = true;
          this.walkSync(root);
        }

        if (this.listeners.OnceExit) {
          if (root.type === 'document') {
            for (let subRoot of root.nodes) {
              this.visitSync(this.listeners.OnceExit, subRoot);
            }
          } else {
            this.visitSync(this.listeners.OnceExit, root);
          }
        }
      }

      return this.result;
    }

    then(onFulfilled, onRejected) {
      {
        if (!('from' in this.opts)) {
          warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');
        }
      }

      return this.async().then(onFulfilled, onRejected);
    }

    toString() {
      return this.css;
    }

    visitSync(visitors, node) {
      for (let [plugin, visitor] of visitors) {
        this.result.lastPlugin = plugin;
        let promise;

        try {
          promise = visitor(node, this.helpers);
        } catch (e) {
          throw this.handleError(e, node.proxyOf);
        }

        if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
          return true;
        }

        if (isPromise(promise)) {
          throw this.getAsyncError();
        }
      }
    }

    visitTick(stack) {
      let visit = stack[stack.length - 1];
      let {
        node,
        visitors
      } = visit;

      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
        stack.pop();
        return;
      }

      if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
        let [plugin, visitor] = visitors[visit.visitorIndex];
        visit.visitorIndex += 1;

        if (visit.visitorIndex === visitors.length) {
          visit.visitors = [];
          visit.visitorIndex = 0;
        }

        this.result.lastPlugin = plugin;

        try {
          return visitor(node.toProxy(), this.helpers);
        } catch (e) {
          throw this.handleError(e, node);
        }
      }

      if (visit.iterator !== 0) {
        let iterator = visit.iterator;
        let child;

        while (child = node.nodes[node.indexes[iterator]]) {
          node.indexes[iterator] += 1;

          if (!child[isClean]) {
            child[isClean] = true;
            stack.push(toStack(child));
            return;
          }
        }

        visit.iterator = 0;
        delete node.indexes[iterator];
      }

      let events = visit.events;

      while (visit.eventIndex < events.length) {
        let event = events[visit.eventIndex];
        visit.eventIndex += 1;

        if (event === CHILDREN) {
          if (node.nodes && node.nodes.length) {
            node[isClean] = true;
            visit.iterator = node.getIterator();
          }

          return;
        } else if (this.listeners[event]) {
          visit.visitors = this.listeners[event];
          return;
        }
      }

      stack.pop();
    }

    walkSync(node) {
      node[isClean] = true;
      let events = getEvents(node);

      for (let event of events) {
        if (event === CHILDREN) {
          if (node.nodes) {
            node.each(child => {
              if (!child[isClean]) this.walkSync(child);
            });
          }
        } else {
          let visitors = this.listeners[event];

          if (visitors) {
            if (this.visitSync(visitors, node.toProxy())) return;
          }
        }
      }
    }

    warnings() {
      return this.sync().warnings();
    }

    get content() {
      return this.stringify().content;
    }

    get css() {
      return this.stringify().css;
    }

    get map() {
      return this.stringify().map;
    }

    get messages() {
      return this.sync().messages;
    }

    get opts() {
      return this.result.opts;
    }

    get processor() {
      return this.result.processor;
    }

    get root() {
      return this.sync().root;
    }

    get [Symbol.toStringTag]() {
      return 'LazyResult';
    }

  }

  LazyResult$1.registerPostcss = dependant => {
    postcss$3 = dependant;
  };

  var lazyResult = LazyResult$1;
  LazyResult$1.default = LazyResult$1;
  root$1.registerLazyResult(LazyResult$1);
  document$1.registerLazyResult(LazyResult$1);

  class NoWorkResult {
    constructor(processor, css, opts) {
      css = css.toString();
      this.stringified = false;
      this._processor = processor;
      this._css = css;
      this._opts = opts;
      this._map = undefined;
      let root;
      let str = stringify_1$1;
      this.result = new result(this._processor, root, this._opts);
      this.result.css = css;
      let self = this;
      Object.defineProperty(this.result, 'root', {
        get() {
          return self.root;
        }

      });
      let map = new mapGenerator(str, root, this._opts, css);

      if (map.isMap()) {
        let [generatedCSS, generatedMap] = map.generate();

        if (generatedCSS) {
          this.result.css = generatedCSS;
        }

        if (generatedMap) {
          this.result.map = generatedMap;
        }
      }
    }

    async() {
      if (this.error) return Promise.reject(this.error);
      return Promise.resolve(this.result);
    }

    catch(onRejected) {
      return this.async().catch(onRejected);
    }

    finally(onFinally) {
      return this.async().then(onFinally, onFinally);
    }

    sync() {
      if (this.error) throw this.error;
      return this.result;
    }

    then(onFulfilled, onRejected) {
      {
        if (!('from' in this._opts)) {
          warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');
        }
      }

      return this.async().then(onFulfilled, onRejected);
    }

    toString() {
      return this._css;
    }

    warnings() {
      return [];
    }

    get content() {
      return this.result.css;
    }

    get css() {
      return this.result.css;
    }

    get map() {
      return this.result.map;
    }

    get messages() {
      return [];
    }

    get opts() {
      return this.result.opts;
    }

    get processor() {
      return this.result.processor;
    }

    get root() {
      if (this._root) {
        return this._root;
      }

      let root;
      let parser = parse_1$5;

      try {
        root = parser(this._css, this._opts);
      } catch (error) {
        this.error = error;
      }

      if (this.error) {
        throw this.error;
      } else {
        this._root = root;
        return root;
      }
    }

    get [Symbol.toStringTag]() {
      return 'NoWorkResult';
    }

  }

  var noWorkResult = NoWorkResult;
  NoWorkResult.default = NoWorkResult;

  class Processor {
    constructor(plugins = []) {
      this.version = '8.4.31';
      this.plugins = this.normalize(plugins);
    }

    normalize(plugins) {
      let normalized = [];

      for (let i of plugins) {
        if (i.postcss === true) {
          i = i();
        } else if (i.postcss) {
          i = i.postcss;
        }

        if (typeof i === 'object' && Array.isArray(i.plugins)) {
          normalized = normalized.concat(i.plugins);
        } else if (typeof i === 'object' && i.postcssPlugin) {
          normalized.push(i);
        } else if (typeof i === 'function') {
          normalized.push(i);
        } else if (typeof i === 'object' && (i.parse || i.stringify)) {
          {
            throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.');
          }
        } else {
          throw new Error(i + ' is not a PostCSS plugin');
        }
      }

      return normalized;
    }

    process(css, opts = {}) {
      if (this.plugins.length === 0 && typeof opts.parser === 'undefined' && typeof opts.stringifier === 'undefined' && typeof opts.syntax === 'undefined') {
        return new noWorkResult(this, css, opts);
      } else {
        return new lazyResult(this, css, opts);
      }
    }

    use(plugin) {
      this.plugins = this.plugins.concat(this.normalize([plugin]));
      return this;
    }

  }

  var processor$1 = Processor;
  Processor.default = Processor;
  root$1.registerProcessor(Processor);
  document$1.registerProcessor(Processor);

  function fromJSON(json, inputs) {
    if (Array.isArray(json)) return json.map(n => fromJSON(n));
    let {
      inputs: ownInputs,
      ...defaults
    } = json;

    if (ownInputs) {
      inputs = [];

      for (let input$1 of ownInputs) {
        let inputHydrated = { ...input$1,
          __proto__: input.prototype
        };

        if (inputHydrated.map) {
          inputHydrated.map = { ...inputHydrated.map,
            __proto__: previousMap.prototype
          };
        }

        inputs.push(inputHydrated);
      }
    }

    if (defaults.nodes) {
      defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));
    }

    if (defaults.source) {
      let {
        inputId,
        ...source
      } = defaults.source;
      defaults.source = source;

      if (inputId != null) {
        defaults.source.input = inputs[inputId];
      }
    }

    if (defaults.type === 'root') {
      return new root$1(defaults);
    } else if (defaults.type === 'decl') {
      return new declaration(defaults);
    } else if (defaults.type === 'rule') {
      return new rule$2b(defaults);
    } else if (defaults.type === 'comment') {
      return new comment$1(defaults);
    } else if (defaults.type === 'atrule') {
      return new atRule(defaults);
    } else {
      throw new Error('Unknown node type: ' + json.type);
    }
  }

  var fromJSON_1 = fromJSON;
  fromJSON.default = fromJSON;

  function postcss$2(...plugins) {
    if (plugins.length === 1 && Array.isArray(plugins[0])) {
      plugins = plugins[0];
    }

    return new processor$1(plugins);
  }

  postcss$2.plugin = function plugin(name, initializer) {
    let warningPrinted = false;

    function creator(...args) {
      // eslint-disable-next-line no-console
      if (console && console.warn && !warningPrinted) {
        warningPrinted = true; // eslint-disable-next-line no-console

        console.warn(name + ': postcss.plugin was deprecated. Migration guide:\n' + 'https://evilmartians.com/chronicles/postcss-8-plugin-migration');

        if (process.env.LANG && process.env.LANG.startsWith('cn')) {
          /* c8 ignore next 7 */
          // eslint-disable-next-line no-console
          console.warn(name + ': 里面 postcss.plugin 被弃用. 迁移指南:\n' + 'https://www.w3ctech.com/topic/2226');
        }
      }

      let transformer = initializer(...args);
      transformer.postcssPlugin = name;
      transformer.postcssVersion = new processor$1().version;
      return transformer;
    }

    let cache;
    Object.defineProperty(creator, 'postcss', {
      get() {
        if (!cache) cache = creator();
        return cache;
      }

    });

    creator.process = function (css, processOpts, pluginOpts) {
      return postcss$2([creator(pluginOpts)]).process(css, processOpts);
    };

    return creator;
  };

  postcss$2.stringify = stringify_1$1;
  postcss$2.parse = parse_1$5;
  postcss$2.fromJSON = fromJSON_1;
  postcss$2.list = list_1;

  postcss$2.comment = defaults => new comment$1(defaults);

  postcss$2.atRule = defaults => new atRule(defaults);

  postcss$2.decl = defaults => new declaration(defaults);

  postcss$2.rule = defaults => new rule$2b(defaults);

  postcss$2.root = defaults => new root$1(defaults);

  postcss$2.document = defaults => new document$1(defaults);

  postcss$2.CssSyntaxError = cssSyntaxError;
  postcss$2.Declaration = declaration;
  postcss$2.Container = container$1;
  postcss$2.Processor = processor$1;
  postcss$2.Document = document$1;
  postcss$2.Comment = comment$1;
  postcss$2.Warning = warning;
  postcss$2.AtRule = atRule;
  postcss$2.Result = result;
  postcss$2.Input = input;
  postcss$2.Rule = rule$2b;
  postcss$2.Root = root$1;
  postcss$2.Node = node_1;
  lazyResult.registerPostcss(postcss$2);
  var postcss_1 = postcss$2;
  postcss$2.default = postcss$2;

  const {
    systemFontKeywords,
    fontFamilyKeywords: fontFamilyKeywords$3
  } = keywords$4;











  const {
    isAtRule: isAtRule$d
  } = typeGuards;

  const {
    isRegExp: isRegExp$L,
    isString: isString$V,
    assert: assert$8
  } = validateTypes;

  const ruleName$2b = 'font-family-no-missing-generic-family-keyword';
  const messages$2b = ruleMessages$1(ruleName$2b, {
    rejected: 'Unexpected missing generic font family'
  });
  const meta$2b = {
    url: 'https://stylelint.io/user-guide/rules/font-family-no-missing-generic-family-keyword'
  };
  /**
   * @param {import('postcss-value-parser').Node} node
   * @returns {boolean}
   */

  const isFamilyNameKeyword$1 = node => !('quote' in node) && fontFamilyKeywords$3.has(node.value.toLowerCase());
  /**
   * @param {string} value
   * @returns {boolean}
   */


  const isLastFontFamilyVariable = value => {
    const lastValue = postcss_1.list.comma(value).pop();
    return lastValue != null && (isVariable(lastValue) || !isStandardSyntaxValue(lastValue));
  };
  /** @type {import('stylelint').Rule} */


  const rule$2a = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2b, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreFontFamilies: [isString$V, isRegExp$L]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(/^font(-family)?$/i, decl => {
        // Ignore @font-face
        const parent = decl.parent;

        if (parent && isAtRule$d(parent) && parent.name.toLowerCase() === 'font-face') {
          return;
        }

        if (decl.prop === 'font' && systemFontKeywords.has(decl.value.toLowerCase())) {
          return;
        }

        if (isLastFontFamilyVariable(decl.value)) {
          return;
        }

        const fontFamilies = findFontFamily(decl.value);

        if (fontFamilies.length === 0) {
          return;
        }

        if (fontFamilies.some(node => isFamilyNameKeyword$1(node))) {
          return;
        }

        if (fontFamilies.some(node => optionsMatches(secondaryOptions, 'ignoreFontFamilies', node.value))) {
          return;
        }

        const lastFontFamily = fontFamilies[fontFamilies.length - 1];
        assert$8(lastFontFamily);
        const valueIndex = declarationValueIndex(decl);
        const index = valueIndex + lastFontFamily.sourceIndex;
        const endIndex = valueIndex + lastFontFamily.sourceEndIndex;
        report$1({
          result,
          ruleName: ruleName$2b,
          message: messages$2b.rejected,
          node: decl,
          index,
          endIndex
        });
      });
    };
  };

  rule$2a.ruleName = ruleName$2b;
  rule$2a.messages = messages$2b;
  rule$2a.meta = meta$2b;
  var fontFamilyNoMissingGenericFamilyKeyword = rule$2a;

  const {
    fontFamilyKeywords: fontFamilyKeywords$2
  } = keywords$4;







  const ruleName$2a = 'font-family-name-quotes';
  const messages$2a = ruleMessages$1(ruleName$2a, {
    expected: family => `Expected quotes around "${family}"`,
    rejected: family => `Unexpected quotes around "${family}"`
  });
  const meta$2a = {
    url: 'https://stylelint.io/user-guide/rules/font-family-name-quotes',
    fixable: true
  };
  /**
   * @param {string} font
   * @returns {boolean}
   */

  function isSystemFontKeyword(font) {
    if (font.startsWith('-apple-')) {
      return true;
    }

    if (font === 'BlinkMacSystemFont') {
      return true;
    }

    return false;
  }
  /**
   * "To avoid mistakes in escaping, it is recommended to quote font family names
   * that contain white space, digits, or punctuation characters other than hyphens"
   * (https://www.w3.org/TR/CSS2/fonts.html#font-family-prop)
   *
   * @param {string} family
   * @returns {boolean}
   */


  function quotesRecommended(family) {
    return !/^[-a-zA-Z]+$/.test(family);
  }
  /**
   * Quotes are required if the family is not a valid CSS identifier
   * (regexes from https://mathiasbynens.be/notes/unquoted-font-family)
   *
   * @param {string} family
   * @returns {boolean}
   */


  function quotesRequired(family) {
    return family.split(/\s+/).some(word => /^(?:-?\d|--)/.test(word) || !/^[-\w\u{00A0}-\u{10FFFF}]+$/u.test(word));
  }
  /**
   * @typedef {{
   *   name: string,
   *   rawName: string,
   *   hasQuotes: boolean,
   *   sourceIndex: number,
   *   resetIndexes: (offset: number) => void,
   *   removeQuotes: () => void,
   *   addQuotes: () => void,
   * }} MutableNode
   */

  /**
   *
   * @param {import('postcss-value-parser').Node[]} fontFamilies
   * @param {import('postcss').Declaration} decl
   * @returns {MutableNode[]}
   */


  const makeMutableFontFamilies = (fontFamilies, decl) => {
    /**
     * @type {MutableNode[]}
     */
    const mutableNodes = [];
    fontFamilies.forEach((fontFamily, idx) => {
      const quote = 'quote' in fontFamily && fontFamily.quote;
      const name = fontFamily.value;
      /** @type {MutableNode} */

      const newNode = {
        name,
        rawName: quote ? `${quote}${name}${quote}` : name,
        sourceIndex: fontFamily.sourceIndex,
        hasQuotes: Boolean(quote),

        resetIndexes(offset) {
          mutableNodes.slice(idx + 1).forEach(n => n.sourceIndex += offset);
        },

        removeQuotes() {
          if (this.hasQuotes === false) return;
          const openIndex = this.sourceIndex;
          const closeIndex = openIndex + this.name.length + 2;
          this.hasQuotes = false;
          decl.value = decl.value.slice(0, openIndex) + this.name + decl.value.substring(closeIndex);
          this.resetIndexes(-2);
        },

        addQuotes() {
          if (this.hasQuotes === true) return;
          const openIndex = this.sourceIndex;
          const closeIndex = openIndex + this.name.length;
          this.hasQuotes = true;
          const fixedName = `"${this.name}"`;
          decl.value = decl.value.slice(0, openIndex) + fixedName + decl.value.substring(closeIndex);
          this.resetIndexes(2);
        }

      };
      mutableNodes.push(newNode);
    });
    return mutableNodes;
  };
  /** @type {import('stylelint').Rule} */


  const rule$29 = (primary, _secondary, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2a, {
        actual: primary,
        possible: ['always-where-required', 'always-where-recommended', 'always-unless-keyword']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(/^font(-family)?$/i, decl => {
        if (!isStandardSyntaxValue(decl.value)) {
          return;
        }

        let fontFamilyNodes = makeMutableFontFamilies(findFontFamily(decl.value), decl);

        if (fontFamilyNodes.length === 0) {
          return;
        }

        for (const fontFamilyNode of fontFamilyNodes) {
          checkFamilyName(fontFamilyNode, decl);
        }
      });
      /**
       * @param {MutableNode} fontFamilyNode
       * @param {import('postcss').Declaration} decl
       */

      function checkFamilyName(fontFamilyNode, decl) {
        const {
          name: family,
          rawName: rawFamily,
          hasQuotes
        } = fontFamilyNode;

        if (isVariable(rawFamily)) {
          return;
        } // Disallow quotes around (case-insensitive) keywords
        // and system font keywords in all cases


        if (fontFamilyKeywords$2.has(family.toLowerCase()) || isSystemFontKeyword(family)) {
          if (hasQuotes) {
            if (context.fix) {
              fontFamilyNode.removeQuotes();
              return;
            }

            return complain(messages$2a.rejected(family), rawFamily, decl);
          }

          return;
        }

        const required = quotesRequired(family);
        const recommended = quotesRecommended(family);

        switch (primary) {
          case 'always-unless-keyword':
            if (!hasQuotes) {
              if (context.fix) {
                fontFamilyNode.addQuotes();
                return;
              }

              return complain(messages$2a.expected(family), rawFamily, decl);
            }

            return;

          case 'always-where-recommended':
            if (!recommended && hasQuotes) {
              if (context.fix) {
                fontFamilyNode.removeQuotes();
                return;
              }

              return complain(messages$2a.rejected(family), rawFamily, decl);
            }

            if (recommended && !hasQuotes) {
              if (context.fix) {
                fontFamilyNode.addQuotes();
                return;
              }

              return complain(messages$2a.expected(family), rawFamily, decl);
            }

            return;

          case 'always-where-required':
            if (!required && hasQuotes) {
              if (context.fix) {
                fontFamilyNode.removeQuotes();
                return;
              }

              return complain(messages$2a.rejected(family), rawFamily, decl);
            }

            if (required && !hasQuotes) {
              if (context.fix) {
                fontFamilyNode.addQuotes();
                return;
              }

              return complain(messages$2a.expected(family), rawFamily, decl);
            }

        }
      }
      /**
       * @param {string} message
       * @param {string} family
       * @param {import('postcss').Declaration} decl
       */


      function complain(message, family, decl) {
        report$1({
          result,
          ruleName: ruleName$2a,
          message,
          node: decl,
          word: family
        });
      }
    };
  };

  rule$29.ruleName = ruleName$2a;
  rule$29.messages = messages$2a;
  rule$29.meta = meta$2a;
  var fontFamilyNameQuotes = rule$29;

  const {
    fontFamilyKeywords: fontFamilyKeywords$1
  } = keywords$4;









  const {
    isRegExp: isRegExp$K,
    isString: isString$U
  } = validateTypes;

  const ruleName$29 = 'font-family-no-duplicate-names';
  const messages$29 = ruleMessages$1(ruleName$29, {
    rejected: name => `Unexpected duplicate name ${name}`
  });
  const meta$29 = {
    url: 'https://stylelint.io/user-guide/rules/font-family-no-duplicate-names'
  };
  /**
   * @param {import('postcss-value-parser').Node} node
   */

  const isFamilyNameKeyword = node => !('quote' in node) && fontFamilyKeywords$1.has(node.value.toLowerCase());
  /** @type {import('stylelint').Rule} */


  const rule$28 = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$29, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreFontFamilyNames: [isString$U, isRegExp$K]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(/^font(-family)?$/i, decl => {
        const keywords = new Set();
        const familyNames = new Set();
        const fontFamilies = findFontFamily(decl.value);

        if (fontFamilies.length === 0) {
          return;
        }

        for (const fontFamilyNode of fontFamilies) {
          const family = fontFamilyNode.value.trim();

          if (optionsMatches(secondaryOptions, 'ignoreFontFamilyNames', family)) {
            continue;
          }

          const rawFamily = 'quote' in fontFamilyNode ? fontFamilyNode.quote + family + fontFamilyNode.quote : family;

          if (isFamilyNameKeyword(fontFamilyNode)) {
            if (keywords.has(family.toLowerCase())) {
              complain(messages$29.rejected(family), declarationValueIndex(decl) + fontFamilyNode.sourceIndex, rawFamily.length, decl);
              continue;
            }

            keywords.add(family);
            continue;
          }

          if (familyNames.has(family)) {
            complain(messages$29.rejected(family), declarationValueIndex(decl) + fontFamilyNode.sourceIndex, rawFamily.length, decl);
            continue;
          }

          familyNames.add(family);
        }
      });
      /**
       * @param {string} message
       * @param {number} index
       * @param {number} length
       * @param {import('postcss').Declaration} decl
       */

      function complain(message, index, length, decl) {
        report$1({
          result,
          ruleName: ruleName$29,
          message,
          node: decl,
          index,
          endIndex: index + length
        });
      }
    };
  };

  rule$28.ruleName = ruleName$29;
  rule$28.messages = messages$29;
  rule$28.meta = meta$29;
  var fontFamilyNoDuplicateNames = rule$28;

  const {
    fontWeightNonNumericKeywords,
    fontWeightRelativeKeywords
  } = keywords$4;











  const {
    assertString: assertString$5
  } = validateTypes;

  const ruleName$28 = 'font-weight-notation';
  const messages$28 = ruleMessages$1(ruleName$28, {
    expected: type => `Expected ${type} font-weight notation`,
    expectedWithActual: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$28 = {
    url: 'https://stylelint.io/user-guide/rules/font-weight-notation',
    fixable: true
  };
  const NORMAL_KEYWORD = 'normal';
  const NAMED_TO_NUMERIC = new Map([['normal', '400'], ['bold', '700']]);
  const NUMERIC_TO_NAMED = new Map([['400', 'normal'], ['700', 'bold']]);
  /** @type {import('stylelint').Rule<'numeric' | 'named-where-possible'>} */

  const rule$27 = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$28, {
        actual: primary,
        possible: ['numeric', 'named-where-possible']
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['relative']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const ignoreRelative = optionsMatches(secondaryOptions, 'ignore', 'relative');
      root.walkDecls(/^font(-weight)?$/i, decl => {
        const isFontShorthandProp = decl.prop.toLowerCase() === 'font';
        const parsedValue = lib$6(getDeclarationValue(decl));
        const valueNodes = parsedValue.nodes;
        const hasNumericFontWeight = valueNodes.some((node, index, nodes) => {
          return isNumbery(node.value) && !isDivNode(nodes[index - 1]);
        });

        for (const [index, valueNode] of valueNodes.entries()) {
          if (!isPossibleFontWeightNode(valueNode, index, valueNodes)) continue;
          const {
            value
          } = valueNode;

          if (isFontShorthandProp) {
            if (value.toLowerCase() === NORMAL_KEYWORD && hasNumericFontWeight) {
              continue; // Not `normal` for font-weight
            }

            if (checkWeight(decl, valueNode)) {
              break; // Stop traverse if font-weight is processed
            }
          }

          checkWeight(decl, valueNode);
        }

        if (context.fix) {
          // Autofix after the loop ends can prevent value nodes from changing their positions during the loop.
          setDeclarationValue(decl, parsedValue.toString());
        }
      });
      /**
       * @param {import('postcss').Declaration} decl
       * @param {import('postcss-value-parser').Node} weightValueNode
       * @returns {true | undefined}
       */

      function checkWeight(decl, weightValueNode) {
        const weightValue = weightValueNode.value;

        if (!isStandardSyntaxValue(weightValue)) {
          return;
        }

        if (isVariable(weightValue)) {
          return;
        }

        const lowerWeightValue = weightValue.toLowerCase();

        if (ignoreRelative && fontWeightRelativeKeywords.has(lowerWeightValue)) {
          return;
        }

        if (primary === 'numeric') {
          if (!isNumbery(lowerWeightValue) && fontWeightNonNumericKeywords.has(lowerWeightValue)) {
            const numericValue = NAMED_TO_NUMERIC.get(lowerWeightValue);

            if (context.fix) {
              if (numericValue) {
                weightValueNode.value = numericValue;
                return true;
              }
            }

            const msg = numericValue ? messages$28.expectedWithActual(weightValue, numericValue) : messages$28.expected('numeric');
            complain(msg, weightValueNode);
            return true;
          }
        }

        if (primary === 'named-where-possible') {
          if (isNumbery(lowerWeightValue) && NUMERIC_TO_NAMED.has(lowerWeightValue)) {
            const namedValue = NUMERIC_TO_NAMED.get(lowerWeightValue);
            assertString$5(namedValue);

            if (context.fix) {
              weightValueNode.value = namedValue;
              return true;
            }

            complain(messages$28.expectedWithActual(weightValue, namedValue), weightValueNode);
            return true;
          }
        }
        /**
         * @param {string} message
         * @param {import('postcss-value-parser').Node} valueNode
         */


        function complain(message, valueNode) {
          const index = declarationValueIndex(decl) + valueNode.sourceIndex;
          const endIndex = index + valueNode.value.length;
          report$1({
            ruleName: ruleName$28,
            result,
            message,
            node: decl,
            index,
            endIndex
          });
        }
      }
    };
  };
  /**
   * @param {import('postcss-value-parser').Node | undefined} node
   * @returns {boolean}
   */


  function isDivNode(node) {
    return node !== undefined && node.type === 'div';
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   * @param {number} index
   * @param {import('postcss-value-parser').Node[]} nodes
   * @returns {boolean}
   */


  function isPossibleFontWeightNode(node, index, nodes) {
    if (node.type !== 'word') return false; // Exclude `<font-size>/<line-height>` format like `16px/3`.

    if (isDivNode(nodes[index - 1])) return false;
    if (isDivNode(nodes[index + 1])) return false;
    return true;
  }

  rule$27.ruleName = ruleName$28;
  rule$27.messages = messages$28;
  rule$27.meta = meta$28;
  var fontWeightNotation = rule$27;

  const {
    isRegExp: isRegExp$J,
    isString: isString$T
  } = validateTypes;

  const ruleName$27 = 'function-allowed-list';
  const messages$27 = ruleMessages$1(ruleName$27, {
    rejected: name => `Unexpected function "${name}"`
  });
  const meta$27 = {
    url: 'https://stylelint.io/user-guide/rules/function-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$26 = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$27, {
        actual: primary,
        possible: [isString$T, isRegExp$J]
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        lib$6(decl.value).walk(node => {
          if (node.type !== 'function') {
            return;
          }

          if (!isStandardSyntaxFunction(node)) {
            return;
          }

          if (matchesStringOrRegExp(vendor.unprefixed(node.value), primary)) {
            return;
          }

          const index = declarationValueIndex(decl) + node.sourceIndex;
          const endIndex = index + node.value.length;
          report$1({
            message: messages$27.rejected,
            messageArgs: [node.value],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$27
          });
        });
      });
    };
  };

  rule$26.primaryOptionArray = true;
  rule$26.ruleName = ruleName$27;
  rule$26.messages = messages$27;
  rule$26.meta = meta$27;
  var functionAllowedList = rule$26;

  const {
    assert: assert$7
  } = validateTypes;

  const ruleName$26 = 'function-calc-no-unspaced-operator';
  const messages$26 = ruleMessages$1(ruleName$26, {
    expectedBefore: operator => `Expected single space before "${operator}" operator`,
    expectedAfter: operator => `Expected single space after "${operator}" operator`,
    expectedOperatorBeforeSign: operator => `Expected an operator before sign "${operator}"`
  });
  const meta$26 = {
    url: 'https://stylelint.io/user-guide/rules/function-calc-no-unspaced-operator',
    fixable: true
  };
  const OPERATORS = new Set(['+', '-']);
  const OPERATOR_REGEX = /[+-]/;
  const ALL_OPERATORS = new Set([...OPERATORS, '*', '/']);
  /** @type {import('stylelint').Rule} */

  const rule$25 = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$26, {
        actual: primary
      });
      if (!validOptions) return;
      /**
       * @param {string} message
       * @param {import('postcss').Node} node
       * @param {number} index
       * @param {string} operator
       */

      function complain(message, node, index, operator) {
        const endIndex = index + operator.length;
        report$1({
          message,
          node,
          index,
          endIndex,
          result,
          ruleName: ruleName$26
        });
      }

      root.walkDecls(decl => {
        const value = getDeclarationValue(decl);
        if (!OPERATOR_REGEX.test(value)) return;
        let needsFix = false;
        const valueIndex = declarationValueIndex(decl);
        const parsedValue = lib$6(value);
        /**
         * @param {import('postcss-value-parser').Node} operatorNode
         * @param {import('postcss-value-parser').Node} currentNode
         * @param {boolean} isBeforeOp
         */

        function checkAroundOperator(operatorNode, currentNode, isBeforeOp) {
          const operator = operatorNode.value;
          const operatorSourceIndex = operatorNode.sourceIndex;

          if (currentNode && !isSingleSpace(currentNode)) {
            if (currentNode.type === 'word') {
              if (isBeforeOp) {
                const lastChar = currentNode.value.slice(-1);

                if (OPERATORS.has(lastChar)) {
                  if (context.fix) {
                    currentNode.value = `${currentNode.value.slice(0, -1)} ${lastChar}`;
                    return true;
                  }

                  complain(messages$26.expectedOperatorBeforeSign(operator), decl, operatorSourceIndex, operator);
                  return true;
                }
              } else {
                const firstChar = currentNode.value.slice(0, 1);

                if (OPERATORS.has(firstChar)) {
                  if (context.fix) {
                    currentNode.value = `${firstChar} ${currentNode.value.slice(1)}`;
                    return true;
                  }

                  complain(messages$26.expectedAfter(operator), decl, operatorSourceIndex, operator);
                  return true;
                }
              }

              if (context.fix) {
                needsFix = true;
                currentNode.value = isBeforeOp ? `${currentNode.value} ` : ` ${currentNode.value}`;
                return true;
              }

              complain(isBeforeOp ? messages$26.expectedBefore(operator) : messages$26.expectedAfter(operator), decl, valueIndex + operatorSourceIndex, operator);
              return true;
            }

            if (currentNode.type === 'space') {
              const indexOfFirstNewLine = currentNode.value.search(/(\n|\r\n)/);
              if (indexOfFirstNewLine === 0) return;

              if (context.fix) {
                needsFix = true;
                currentNode.value = indexOfFirstNewLine === -1 ? ' ' : currentNode.value.slice(indexOfFirstNewLine);
                return true;
              }

              const message = isBeforeOp ? messages$26.expectedBefore(operator) : messages$26.expectedAfter(operator);
              complain(message, decl, valueIndex + operatorSourceIndex, operator);
              return true;
            }

            if (currentNode.type === 'function') {
              if (context.fix) {
                needsFix = true;
                currentNode.value = isBeforeOp ? `${currentNode.value} ` : ` ${currentNode.value}`;
                return true;
              }

              const message = isBeforeOp ? messages$26.expectedBefore(operator) : messages$26.expectedAfter(operator);
              complain(message, decl, valueIndex + operatorSourceIndex, operator);
              return true;
            }
          }

          return false;
        }
        /**
         * @param {import('postcss-value-parser').Node[]} nodes
         */


        function checkForOperatorInFirstNode(nodes) {
          const firstNode = nodes[0];
          assert$7(firstNode);
          if (firstNode.type !== 'word') return false;
          if (!isStandardSyntaxValue(firstNode.value)) return false;
          const operatorIndex = firstNode.value.search(OPERATOR_REGEX);
          const operator = firstNode.value.slice(operatorIndex, operatorIndex + 1);
          if (operatorIndex <= 0) return false;
          const charBefore = firstNode.value.charAt(operatorIndex - 1);
          const charAfter = firstNode.value.charAt(operatorIndex + 1);

          if (charBefore && charBefore !== ' ' && charAfter && charAfter !== ' ') {
            if (context.fix) {
              needsFix = true;
              firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex + 1, ' ');
              firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
            } else {
              complain(messages$26.expectedBefore(operator), decl, valueIndex + firstNode.sourceIndex + operatorIndex, operator);
              complain(messages$26.expectedAfter(operator), decl, valueIndex + firstNode.sourceIndex + operatorIndex + 1, operator);
            }
          } else if (charBefore && charBefore !== ' ') {
            if (context.fix) {
              needsFix = true;
              firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
            } else {
              complain(messages$26.expectedBefore(operator), decl, valueIndex + firstNode.sourceIndex + operatorIndex, operator);
            }
          } else if (charAfter && charAfter !== ' ') {
            if (context.fix) {
              needsFix = true;
              firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
            } else {
              complain(messages$26.expectedAfter(operator), decl, valueIndex + firstNode.sourceIndex + operatorIndex + 1, operator);
            }
          }

          return true;
        }
        /**
         * @param {import('postcss-value-parser').Node[]} nodes
         */


        function checkForOperatorInLastNode(nodes) {
          if (nodes.length === 1) return false;
          const lastNode = nodes[nodes.length - 1];
          assert$7(lastNode);
          if (lastNode.type !== 'word') return false;
          const operatorIndex = lastNode.value.search(OPERATOR_REGEX);
          if (operatorIndex === -1) return false;
          if (lastNode.value.charAt(operatorIndex - 1) === ' ') return false; // E.g. "10px * -2" when the last node is "-2"

          if (isOperator(nodes[nodes.length - 3], ALL_OPERATORS) && isSingleSpace(nodes[nodes.length - 2])) {
            return false;
          }

          if (context.fix) {
            needsFix = true;
            lastNode.value = insertCharAtIndex(lastNode.value, operatorIndex + 1, ' ').trim();
            lastNode.value = insertCharAtIndex(lastNode.value, operatorIndex, ' ').trim();
            return true;
          }

          const operator = lastNode.value.charAt(operatorIndex);
          complain(messages$26.expectedOperatorBeforeSign(operator), decl, valueIndex + lastNode.sourceIndex + operatorIndex, operator);
          return true;
        }
        /**
         * @param {import('postcss-value-parser').Node[]} nodes
         */


        function checkWords(nodes) {
          if (checkForOperatorInFirstNode(nodes) || checkForOperatorInLastNode(nodes)) return;

          for (const [index, node] of nodes.entries()) {
            const lastChar = node.value.slice(-1);
            const firstChar = node.value.slice(0, 1);

            if (node.type === 'word') {
              if (index === 0 && OPERATORS.has(lastChar)) {
                if (context.fix) {
                  node.value = `${node.value.slice(0, -1)} ${lastChar}`;
                  continue;
                }

                complain(messages$26.expectedBefore(lastChar), decl, node.sourceIndex, lastChar);
              } else if (index === nodes.length && OPERATORS.has(firstChar)) {
                if (context.fix) {
                  node.value = `${firstChar} ${node.value.slice(1)}`;
                  continue;
                }

                complain(messages$26.expectedOperatorBeforeSign(firstChar), decl, node.sourceIndex, firstChar);
              }
            }
          }
        }

        parsedValue.walk(node => {
          if (node.type !== 'function' || node.value.toLowerCase() !== 'calc') return;
          const {
            nodes
          } = node;
          if (!nodes.length) return;
          let foundOperatorNode = false;

          for (const [nodeIndex, currNode] of nodes.entries()) {
            if (!isOperator(currNode)) continue;
            foundOperatorNode = true;
            const nodeBefore = nodes[nodeIndex - 1];
            const nodeAfter = nodes[nodeIndex + 1];
            if (isSingleSpace(nodeBefore) && isSingleSpace(nodeAfter)) continue;
            if (nodeAfter && checkAroundOperator(currNode, nodeAfter, false)) continue;
            nodeBefore && checkAroundOperator(currNode, nodeBefore, true);
          }

          if (!foundOperatorNode) {
            checkWords(nodes);
          }
        });

        if (needsFix) {
          setDeclarationValue(decl, parsedValue.toString());
        }
      });
    };
  };
  /**
   * @param {string} str
   * @param {number} index
   * @param {string} char
   */


  function insertCharAtIndex(str, index, char) {
    return str.slice(0, index) + char + str.slice(index, str.length);
  }
  /**
   * @param {import('postcss-value-parser').Node | undefined} node
   * @returns {node is import('postcss-value-parser').SpaceNode & { value: ' ' } }
   */


  function isSingleSpace(node) {
    return node != null && node.type === 'space' && node.value === ' ';
  }
  /**
   * @param {import('postcss-value-parser').Node | undefined} node
   * @param {Set<string>} [operators]
   * @returns {node is import('postcss-value-parser').WordNode}
   */


  function isOperator(node, operators = OPERATORS) {
    return node != null && node.type === 'word' && operators.has(node.value);
  }

  rule$25.ruleName = ruleName$26;
  rule$25.messages = messages$26;
  rule$25.meta = meta$26;
  var functionCalcNoUnspacedOperator = rule$25;

  /**
   * @param {{
   *   div: import('postcss-value-parser').DivNode,
   *   index: number,
   *   nodes: import('postcss-value-parser').Node[],
   *   expectation: string,
   *   position: 'before' | 'after',
   *   symb: string,
   * }} params
   * @returns {boolean}
   */

  var functionCommaSpaceFix = function functionCommaSpaceFix(params) {
    const {
      div,
      index,
      nodes,
      expectation,
      position,
      symb
    } = params;

    if (expectation.startsWith('always')) {
      div[position] = symb;
      return true;
    }

    if (expectation.startsWith('never')) {
      div[position] = '';

      for (let i = index + 1; i < nodes.length; i++) {
        const node = nodes[i];

        if (node === undefined) {
          continue;
        }

        if (node.type === 'comment') {
          continue;
        }

        if (node.type === 'space') {
          node.value = '';
          continue;
        }

        break;
      }

      return true;
    }

    return false;
  };

  /** @typedef {import('postcss-value-parser').Node} ValueParserNode */

  /** @typedef {import('postcss-value-parser').DivNode} ValueParserDivNode */

  /** @typedef {(args: { source: string, index: number, err: (message: string) => void }) => void} LocationChecker */

  /**
   * @param {{
   *   root: import('postcss').Root,
   *   locationChecker: LocationChecker,
   *   fix: ((node: ValueParserDivNode, index: number, nodes: ValueParserNode[]) => boolean) | null,
   *   result: import('stylelint').PostcssResult,
   *   checkedRuleName: string,
   * }} opts
   */


  var functionCommaSpaceChecker = function functionCommaSpaceChecker(opts) {
    opts.root.walkDecls(decl => {
      const declValue = getDeclarationValue(decl);
      let hasFixed;
      const parsedValue = lib$6(declValue);
      parsedValue.walk(valueNode => {
        if (valueNode.type !== 'function') {
          return;
        }

        if (!isStandardSyntaxFunction(valueNode)) {
          return;
        } // Ignore `url()` arguments, which may contain data URIs or other funky stuff


        if (valueNode.value.toLowerCase() === 'url') {
          return;
        }

        const argumentStrings = valueNode.nodes.map(node => lib$6.stringify(node));

        const functionArguments = (() => {
          // Remove function name and parens
          let result = valueNode.before + argumentStrings.join('') + valueNode.after; // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)
          // 2. Remove all other comments, but leave adjacent whitespace intact
          // eslint-disable-next-line regexp/no-dupe-disjunctions -- TODO: Possible to simplify the regex.

          result = result.replace(/( *\/(\*.*\*\/(?!\S)|\/.*)|(\/(\*.*\*\/|\/.*)))/, '');
          return result;
        })();
        /**
         * Gets the index of the comma for checking.
         * @param {ValueParserDivNode} commaNode The comma node
         * @param {number} nodeIndex The index of the comma node
         * @returns {number} The index of the comma for checking
         */


        const getCommaCheckIndex = (commaNode, nodeIndex) => {
          let commaBefore = valueNode.before + argumentStrings.slice(0, nodeIndex).join('') + commaNode.before; // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)
          // 2. Remove all other comments, but leave adjacent whitespace intact
          // eslint-disable-next-line regexp/no-dupe-disjunctions -- TODO: Possible to simplify the regex.

          commaBefore = commaBefore.replace(/( *\/(\*.*\*\/(?!\S)|\/.*)|(\/(\*.*\*\/|\/.*)))/, '');
          return commaBefore.length;
        };
        /** @type {{ commaNode: ValueParserDivNode, checkIndex: number, nodeIndex: number }[]} */


        const commaDataList = [];

        for (const [nodeIndex, node] of valueNode.nodes.entries()) {
          if (node.type !== 'div' || node.value !== ',') {
            continue;
          }

          const checkIndex = getCommaCheckIndex(node, nodeIndex);
          commaDataList.push({
            commaNode: node,
            checkIndex,
            nodeIndex
          });
        }

        for (const {
          commaNode,
          checkIndex,
          nodeIndex
        } of commaDataList) {
          opts.locationChecker({
            source: functionArguments,
            index: checkIndex,
            err: message => {
              const index = declarationValueIndex(decl) + commaNode.sourceIndex + commaNode.before.length;

              if (opts.fix && opts.fix(commaNode, nodeIndex, valueNode.nodes)) {
                hasFixed = true;
                return;
              }

              report$1({
                index,
                message,
                node: decl,
                result: opts.result,
                ruleName: opts.checkedRuleName
              });
            }
          });
        }
      });

      if (hasFixed) {
        setDeclarationValue(decl, parsedValue.toString());
      }
    });
  };

  const ruleName$25 = 'function-comma-newline-after';
  const messages$25 = ruleMessages$1(ruleName$25, {
    expectedAfter: () => 'Expected newline after ","',
    expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line function',
    rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line function'
  });
  const meta$25 = {
    url: 'https://stylelint.io/user-guide/rules/function-comma-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$24 = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$25);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$25, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }

      functionCommaSpaceChecker({
        root,
        result,
        locationChecker: checker.afterOneOnly,
        checkedRuleName: ruleName$25,
        fix: context.fix ? (div, index, nodes) => functionCommaSpaceFix({
          div,
          index,
          nodes,
          expectation: primary,
          position: 'after',
          symb: context.newline || ''
        }) : null
      });
    };
  };

  rule$24.ruleName = ruleName$25;
  rule$24.messages = messages$25;
  rule$24.meta = meta$25;
  var functionCommaNewlineAfter = rule$24;

  const ruleName$24 = 'function-comma-newline-before';
  const messages$24 = ruleMessages$1(ruleName$24, {
    expectedBefore: () => 'Expected newline before ","',
    expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line function',
    rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line function'
  });
  const meta$24 = {
    url: 'https://stylelint.io/user-guide/rules/function-comma-newline-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$23 = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$24);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$24, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }

      functionCommaSpaceChecker({
        root,
        result,
        locationChecker: checker.beforeAllowingIndentation,
        checkedRuleName: ruleName$24,
        fix: context.fix ? (div, index, nodes) => functionCommaSpaceFix({
          div,
          index,
          nodes,
          expectation: primary,
          position: 'before',
          symb: context.newline || ''
        }) : null
      });
    };
  };

  rule$23.ruleName = ruleName$24;
  rule$23.messages = messages$24;
  rule$23.meta = meta$24;
  var functionCommaNewlineBefore = rule$23;

  const ruleName$23 = 'function-comma-space-after';
  const messages$23 = ruleMessages$1(ruleName$23, {
    expectedAfter: () => 'Expected single space after ","',
    rejectedAfter: () => 'Unexpected whitespace after ","',
    expectedAfterSingleLine: () => 'Expected single space after "," in a single-line function',
    rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line function'
  });
  const meta$23 = {
    url: 'https://stylelint.io/user-guide/rules/function-comma-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$22 = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$23);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$23, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }

      functionCommaSpaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$23,
        fix: context.fix ? (div, index, nodes) => functionCommaSpaceFix({
          div,
          index,
          nodes,
          expectation: primary,
          position: 'after',
          symb: ' '
        }) : null
      });
    };
  };

  rule$22.ruleName = ruleName$23;
  rule$22.messages = messages$23;
  rule$22.meta = meta$23;
  var functionCommaSpaceAfter = rule$22;

  const ruleName$22 = 'function-comma-space-before';
  const messages$22 = ruleMessages$1(ruleName$22, {
    expectedBefore: () => 'Expected single space before ","',
    rejectedBefore: () => 'Unexpected whitespace before ","',
    expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line function',
    rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line function'
  });
  const meta$22 = {
    url: 'https://stylelint.io/user-guide/rules/function-comma-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$21 = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$22);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$22, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }

      functionCommaSpaceChecker({
        root,
        result,
        locationChecker: checker.before,
        checkedRuleName: ruleName$22,
        fix: context.fix ? (div, index, nodes) => functionCommaSpaceFix({
          div,
          index,
          nodes,
          expectation: primary,
          position: 'before',
          symb: ' '
        }) : null
      });
    };
  };

  rule$21.ruleName = ruleName$22;
  rule$21.messages = messages$22;
  rule$21.meta = meta$22;
  var functionCommaSpaceBefore = rule$21;

  const {
    isRegExp: isRegExp$I,
    isString: isString$S
  } = validateTypes;

  const ruleName$21 = 'function-disallowed-list';
  const messages$21 = ruleMessages$1(ruleName$21, {
    rejected: name => `Unexpected function "${name}"`
  });
  const meta$21 = {
    url: 'https://stylelint.io/user-guide/rules/function-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$20 = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$21, {
        actual: primary,
        possible: [isString$S, isRegExp$I]
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        lib$6(decl.value).walk(node => {
          if (node.type !== 'function') {
            return;
          }

          if (!isStandardSyntaxFunction(node)) {
            return;
          }

          if (!matchesStringOrRegExp(vendor.unprefixed(node.value), primary)) {
            return;
          }

          const index = declarationValueIndex(decl) + node.sourceIndex;
          const endIndex = index + node.value.length;
          report$1({
            message: messages$21.rejected,
            messageArgs: [node.value],
            node: decl,
            index,
            endIndex,
            result,
            ruleName: ruleName$21
          });
        });
      });
    };
  };

  rule$20.primaryOptionArray = true;
  rule$20.ruleName = ruleName$21;
  rule$20.messages = messages$21;
  rule$20.meta = meta$21;
  var functionDisallowedList = rule$20;

  var balancedMatch$1 = balanced$1;

  function balanced$1(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch$1(a, str);
    if (b instanceof RegExp) b = maybeMatch$1(b, str);
    const r = range$1(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }

  function maybeMatch$1(reg, str) {
    const m = str.match(reg);
    return m ? m[0] : null;
  }

  balanced$1.range = range$1;

  function range$1(a, b, str) {
    let begs, beg, left, right, result;
    let ai = str.indexOf(a);
    let bi = str.indexOf(b, ai + 1);
    let i = ai;

    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }

      begs = [];
      left = str.length;

      while (i >= 0 && !result) {
        if (i === ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length === 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();

          if (beg < left) {
            left = beg;
            right = bi;
          }

          bi = str.indexOf(b, i + 1);
        }

        i = ai < bi && ai >= 0 ? ai : bi;
      }

      if (begs.length) {
        result = [left, right];
      }
    }

    return result;
  }

  const {
    assert: assert$6,
    isString: isString$R,
    isRegExp: isRegExp$H
  } = validateTypes;
  /**
   * Search a CSS string for functions by name.
   * For every match, invoke the callback, passing the function's
   * "argument(s) string" (whatever is inside the parentheses)
   * as an argument.
   *
   * Callback will be called once for every matching function found,
   * with the function's "argument(s) string" and its starting index
   * as the arguments.
   *
   * @param {string} source
   * @param {string | RegExp} functionName
   * @param {(expression: string, expressionIndex: number, funcNode: valueParser.FunctionNode) => void} callback
   * @returns {valueParser.ParsedValue}
   */


  var functionArgumentsSearch = function functionArgumentsSearch(source, functionName, callback) {
    return lib$6(source).walk(node => {
      if (node.type !== 'function') return;
      const {
        value
      } = node;
      if (isString$R(functionName) && value !== functionName) return;
      if (isRegExp$H(functionName) && !functionName.test(node.value)) return;
      const parensMatch = balancedMatch$1('(', ')', source.slice(node.sourceIndex));
      assert$6(parensMatch);
      const expression = parensMatch.body;
      const parenLength = 1; // == '('

      const expressionIndex = node.sourceIndex + value.length + parenLength;
      callback(expression, expressionIndex, node);
    });
  };

  const ruleName$20 = 'function-linear-gradient-no-nonstandard-direction';
  const messages$20 = ruleMessages$1(ruleName$20, {
    rejected: 'Unexpected nonstandard direction'
  });
  const meta$20 = {
    url: 'https://stylelint.io/user-guide/rules/function-linear-gradient-no-nonstandard-direction'
  };
  const LINEAR_GRADIENT_FUNCTION = '(?:-webkit-|-moz-|-o-|-ms-)?linear-gradient';
  const LINEAR_GRADIENT_FUNCTION_CALL = new RegExp(`${LINEAR_GRADIENT_FUNCTION}\\(`, 'i');
  const LINEAR_GRADIENT_FUNCTION_NAME = new RegExp(`^${LINEAR_GRADIENT_FUNCTION}$`, 'i');
  const DIRECTION = /top|left|bottom|right/i;
  const DIRECTION_WITH_TO = new RegExp(`^to (${DIRECTION.source})(?: (${DIRECTION.source}))?$`, 'i');
  const DIRECTION_WITHOUT_TO = new RegExp(`^(${DIRECTION.source})(?: (${DIRECTION.source}))?$`, 'i');
  const DIGIT$1 = /[\d.]/;
  const ANGLE = /^[\d.]+(?:deg|grad|rad|turn)$/;
  const IN_KEYWORD = /\bin\b/i;
  /**
   * @param {string} source
   * @param {boolean} withToPrefix
   */

  function isStandardDirection(source, withToPrefix) {
    const regexp = withToPrefix ? DIRECTION_WITH_TO : DIRECTION_WITHOUT_TO;
    const matches = source.match(regexp);

    if (!matches) {
      return false;
    }

    if (matches.length === 2) {
      return true;
    } // Cannot repeat side-or-corner, e.g. "to top top"


    if (matches.length === 3 && matches[1] !== matches[2]) {
      return true;
    }

    return false;
  }
  /** @type {import('stylelint').Rule} */


  const rule$1$ = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$20, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!LINEAR_GRADIENT_FUNCTION_CALL.test(decl.value)) return;
        lib$6(decl.value).walk(valueNode => {
          if (valueNode.type !== 'function') {
            return;
          }

          functionArgumentsSearch(lib$6.stringify(valueNode).toLowerCase(), LINEAR_GRADIENT_FUNCTION_NAME, (expression, expressionIndex) => {
            const args = expression.split(',');
            const firstArg = (args[0] || '').trim(); // If the first arg is not standard, return early

            if (!isStandardSyntaxValue(firstArg)) {
              return;
            } // Ignore gradients with modern syntax that have color space interpolation arguments


            if (IN_KEYWORD.test(firstArg)) {
              return;
            } // If the first character is a number, we can assume the user intends an angle


            if (DIGIT$1.test(firstArg.charAt(0))) {
              if (ANGLE.test(firstArg)) {
                return;
              }

              complain();
              return;
            } // The first argument may not be a direction: it may be an angle,
            // or a color stop (in which case user gets default direction, "to bottom")
            // cf. https://drafts.csswg.org/css-images-3/#linear-gradient-syntax


            if (!DIRECTION.test(firstArg)) {
              return;
            }

            const withToPrefix = !vendor.prefix(valueNode.value);

            if (!isStandardDirection(firstArg, withToPrefix)) {
              complain();
            }

            function complain() {
              const index = declarationValueIndex(decl) + valueNode.sourceIndex + expressionIndex;
              const endIndex = index + (args[0] || '').trimEnd().length;
              report$1({
                message: messages$20.rejected,
                node: decl,
                index,
                endIndex,
                result,
                ruleName: ruleName$20
              });
            }
          });
        });
      });
    };
  };

  rule$1$.ruleName = ruleName$20;
  rule$1$.messages = messages$20;
  rule$1$.meta = meta$20;
  var functionLinearGradientNoNonstandardDirection = rule$1$;

  const {
    isNumber: isNumber$c
  } = validateTypes;

  const ruleName$1$ = 'function-max-empty-lines';
  const messages$1$ = ruleMessages$1(ruleName$1$, {
    expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`
  });
  const meta$1$ = {
    url: 'https://stylelint.io/user-guide/rules/function-max-empty-lines',
    fixable: true,
    deprecated: true
  };
  /**
   * @param {import('postcss').Declaration} decl
   */

  function placeIndexOnValueStart(decl) {
    if (decl.raws.between == null) throw new Error('`between` must be present');
    return decl.prop.length + decl.raws.between.length - 1;
  }
  /** @type {import('stylelint').Rule} */


  const rule$1_ = (primary, _secondaryOptions, context) => {
    const maxAdjacentNewlines = primary + 1;
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1$, {
        actual: primary,
        possible: isNumber$c
      });

      if (!validOptions) {
        return;
      }

      const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
      const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
      const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
      const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';
      root.walkDecls(decl => {
        if (!decl.value.includes('(')) {
          return;
        }

        const stringValue = getDeclarationValue(decl);
        /** @type {Array<[string, string]>} */

        const splittedValue = [];
        let sourceIndexStart = 0;
        lib$6(stringValue).walk(node => {
          if (node.type !== 'function'
          /* ignore non functions */
          || node.value.length === 0
          /* ignore sass lists */
          ) {
              return;
            }

          const stringifiedNode = lib$6.stringify(node);

          if (!violatedLFNewLinesRegex.test(stringifiedNode) && !violatedCRLFNewLinesRegex.test(stringifiedNode)) {
            return;
          }

          if (context.fix) {
            const newNodeString = stringifiedNode.replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);
            splittedValue.push([stringValue.slice(sourceIndexStart, node.sourceIndex), newNodeString]);
            sourceIndexStart = node.sourceIndex + stringifiedNode.length;
          } else {
            report$1({
              message: messages$1$.expected(primary),
              node: decl,
              index: placeIndexOnValueStart(decl) + node.sourceIndex,
              result,
              ruleName: ruleName$1$
            });
          }
        });

        if (context.fix && splittedValue.length > 0) {
          const updatedValue = splittedValue.reduce((acc, curr) => acc + curr[0] + curr[1], '') + stringValue.slice(sourceIndexStart);
          setDeclarationValue(decl, updatedValue);
        }
      });
    };
  };

  rule$1_.ruleName = ruleName$1$;
  rule$1_.messages = messages$1$;
  rule$1_.meta = meta$1$;
  var functionMaxEmptyLines = rule$1_;

  const {
    camelCaseFunctions
  } = functions;













  const {
    isRegExp: isRegExp$G,
    isString: isString$Q
  } = validateTypes;



  const ruleName$1_ = 'function-name-case';
  const messages$1_ = ruleMessages$1(ruleName$1_, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$1_ = {
    url: 'https://stylelint.io/user-guide/rules/function-name-case',
    fixable: true
  };
  const mapLowercaseFunctionNamesToCamelCase = new Map();

  for (const func of camelCaseFunctions) {
    mapLowercaseFunctionNamesToCamelCase.set(func.toLowerCase(), func);
  }
  /** @type {import('stylelint').Rule} */


  const rule$1Z = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1_, {
        actual: primary,
        possible: ['lower', 'upper']
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreFunctions: [isString$Q, isRegExp$G]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!decl.value.includes('(')) return;
        if (!isStandardSyntaxValue(decl.value)) return;
        let needFix = false;
        const parsed = lib$6(getDeclarationValue(decl));
        parsed.walk(node => {
          if (node.type !== 'function' || !isStandardSyntaxFunction(node)) {
            return;
          }

          const functionName = node.value;
          const functionNameLowerCase = functionName.toLowerCase();

          if (optionsMatches(secondaryOptions, 'ignoreFunctions', functionName)) {
            return;
          }

          let expectedFunctionName = null;

          if (primary === 'lower' && mapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase)) {
            expectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase);
          } else if (primary === 'lower') {
            expectedFunctionName = functionNameLowerCase;
          } else {
            expectedFunctionName = functionName.toUpperCase();
          }

          if (functionName === expectedFunctionName) {
            return;
          }

          if (context.fix) {
            needFix = true;
            node.value = expectedFunctionName;
            return;
          }

          report$1({
            message: messages$1_.expected,
            messageArgs: [functionName, expectedFunctionName],
            node: decl,
            index: declarationValueIndex(decl) + node.sourceIndex,
            result,
            ruleName: ruleName$1_
          });
        });

        if (context.fix && needFix) {
          setDeclarationValue(decl, parsed.toString());
        }
      });
    };
  };

  rule$1Z.ruleName = ruleName$1_;
  rule$1Z.messages = messages$1_;
  rule$1Z.meta = meta$1_;
  var functionNameCase = rule$1Z;

  /**
   * Path to CSS functions list JSON file.
   */


  const location = url__default['default'].fileURLToPath(new url__default['default'].URL('index.json', typeof document === 'undefined' ? new (commonjsRequire('u' + 'rl').URL)('file:' + __filename).href : document.currentScript && document.currentScript.src || new URL('index.js', document.baseURI).href));
  var cjs$2 = location;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");

    return _classApplyDescriptorGet(receiver, descriptor);
  }

  function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");

    _classApplyDescriptorSet(receiver, descriptor, value);

    return value;
  }

  function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }

    return privateMap.get(receiver);
  }

  function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }

    return descriptor.value;
  }

  function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        throw new TypeError("attempted to set read only private field");
      }

      descriptor.value = value;
    }
  }

  function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return fn;
  }

  class ParseError extends Error {
    constructor(e, o, r, n) {
      (super(e), _defineProperty(this, "sourceStart", void 0), _defineProperty(this, "sourceEnd", void 0), _defineProperty(this, "parserState", void 0)), this.name = "ParseError", this.sourceStart = o, this.sourceEnd = r, this.parserState = n;
    }

  }

  class Reader$3 {
    constructor(e) {
      _defineProperty(this, "cursor", void 0);

      _defineProperty(this, "source", "");

      _defineProperty(this, "codePointSource", []);

      _defineProperty(this, "length", 0);

      _defineProperty(this, "representationStart", 0);

      _defineProperty(this, "representationEnd", -1);

      this.cursor = 0, this.source = e, this.length = e.length, this.codePointSource = new Array(this.length);

      for (let e = 0; e < this.length; e++) this.codePointSource[e] = this.source.charCodeAt(e);
    }

    advanceCodePoint(e = 1) {
      this.cursor += e, this.representationEnd = this.cursor - 1;
    }

    readCodePoint(e = 1) {
      const o = this.codePointSource[this.cursor];
      return void 0 !== o && (this.cursor += e, this.representationEnd = this.cursor - 1, o);
    }

    unreadCodePoint(e = 1) {
      this.cursor -= e, this.representationEnd = this.cursor - 1;
    }

  }

  var e$2, o$1, r$1;
  exports.TokenType = void 0, (e$2 = exports.TokenType || (exports.TokenType = {})).Comment = "comment", e$2.AtKeyword = "at-keyword-token", e$2.BadString = "bad-string-token", e$2.BadURL = "bad-url-token", e$2.CDC = "CDC-token", e$2.CDO = "CDO-token", e$2.Colon = "colon-token", e$2.Comma = "comma-token", e$2.Delim = "delim-token", e$2.Dimension = "dimension-token", e$2.EOF = "EOF-token", e$2.Function = "function-token", e$2.Hash = "hash-token", e$2.Ident = "ident-token", e$2.Number = "number-token", e$2.Percentage = "percentage-token", e$2.Semicolon = "semicolon-token", e$2.String = "string-token", e$2.URL = "url-token", e$2.Whitespace = "whitespace-token", e$2.OpenParen = "(-token", e$2.CloseParen = ")-token", e$2.OpenSquare = "[-token", e$2.CloseSquare = "]-token", e$2.OpenCurly = "{-token", e$2.CloseCurly = "}-token", exports.NumberType = void 0, (o$1 = exports.NumberType || (exports.NumberType = {})).Integer = "integer", o$1.Number = "number", function (e) {
    e.Unrestricted = "unrestricted", e.ID = "id";
  }(r$1 || (r$1 = {}));
  const n$2 = Object.values(exports.TokenType);
  const t$1 = 39,
        i$2 = 42,
        s$2 = 8,
        c = 13,
        a$1 = 9,
        u$1 = 58,
        d$2 = 44,
        p = 64,
        S = 127,
        P = 33,
        C = 12,
        T = 46,
        l = 62,
        k = 45,
        f = 31,
        m$1 = 69,
        E = 101,
        h$1 = 123,
        v = 40,
        x = 91,
        y$1 = 60,
        g = 10,
        I = 11,
        O = 95,
        w$1 = 1114111,
        A = 0,
        U = 35,
        D = 37,
        L = 43,
        N = 34,
        b = 65533,
        R = 92,
        q = 125,
        W = 41,
        F = 93,
        V = 59,
        B = 14,
        H = 47,
        z = 32;

  function checkIfFourCodePointsWouldStartCDO(e, o) {
    return o.codePointSource[o.cursor] === y$1 && o.codePointSource[o.cursor + 1] === P && o.codePointSource[o.cursor + 2] === k && o.codePointSource[o.cursor + 3] === k;
  }

  function isDigitCodePoint(e) {
    return e >= 48 && e <= 57;
  }

  function isUppercaseLetterCodePoint(e) {
    return e >= 65 && e <= 90;
  }

  function isLowercaseLetterCodePoint(e) {
    return e >= 97 && e <= 122;
  }

  function isHexDigitCodePoint(e) {
    return isDigitCodePoint(e) || e >= 97 && e <= 102 || e >= 65 && e <= 70;
  }

  function isLetterCodePoint(e) {
    return isLowercaseLetterCodePoint(e) || isUppercaseLetterCodePoint(e);
  }

  function isNonASCIICodePoint(e) {
    return e >= 128;
  }

  function isIdentStartCodePoint(e) {
    return isLetterCodePoint(e) || isNonASCIICodePoint(e) || e === O;
  }

  function isIdentCodePoint(e) {
    return isIdentStartCodePoint(e) || isDigitCodePoint(e) || e === k;
  }

  function isNewLine(e) {
    return 10 === e || 13 === e || 12 === e;
  }

  function isWhitespace$1(e) {
    return 32 === e || 10 === e || 9 === e || 13 === e || 12 === e;
  }

  function checkIfTwoCodePointsAreAValidEscape(e, o) {
    return o.codePointSource[o.cursor] === R && !isNewLine(o.codePointSource[o.cursor + 1]);
  }

  function checkIfThreeCodePointsWouldStartAnIdentSequence(e, o) {
    return o.codePointSource[o.cursor] === k ? o.codePointSource[o.cursor + 1] === k || !!isIdentStartCodePoint(o.codePointSource[o.cursor + 1]) || o.codePointSource[o.cursor + 1] === R && !isNewLine(o.codePointSource[o.cursor + 2]) : !!isIdentStartCodePoint(o.codePointSource[o.cursor]) || checkIfTwoCodePointsAreAValidEscape(0, o);
  }

  function checkIfThreeCodePointsWouldStartANumber(e, o) {
    return o.codePointSource[o.cursor] === L || o.codePointSource[o.cursor] === k ? !!isDigitCodePoint(o.codePointSource[o.cursor + 1]) || o.codePointSource[o.cursor + 1] === T && isDigitCodePoint(o.codePointSource[o.cursor + 2]) : o.codePointSource[o.cursor] === T ? isDigitCodePoint(o.codePointSource[o.cursor + 1]) : isDigitCodePoint(o.codePointSource[o.cursor]);
  }

  function checkIfTwoCodePointsStartAComment(e, o) {
    return o.codePointSource[o.cursor] === H && o.codePointSource[o.cursor + 1] === i$2;
  }

  function checkIfThreeCodePointsWouldStartCDC(e, o) {
    return o.codePointSource[o.cursor] === k && o.codePointSource[o.cursor + 1] === k && o.codePointSource[o.cursor + 2] === l;
  }

  function consumeComment$1(e, o) {
    for (o.advanceCodePoint(2);;) {
      const r = o.readCodePoint();

      if (!1 === r) {
        e.onParseError(new ParseError("Unexpected EOF while consuming a comment.", o.representationStart, o.representationEnd, ["4.3.2. Consume comments", "Unexpected EOF"]));
        break;
      }

      if (r === i$2 && void 0 !== o.codePointSource[o.cursor] && o.codePointSource[o.cursor] === H) {
        o.advanceCodePoint();
        break;
      }
    }

    return [exports.TokenType.Comment, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, void 0];
  }

  function consumeEscapedCodePoint(e, o) {
    const r = o.readCodePoint();
    if (!1 === r) return e.onParseError(new ParseError("Unexpected EOF while consuming an escaped code point.", o.representationStart, o.representationEnd, ["4.3.7. Consume an escaped code point", "Unexpected EOF"])), b;

    if (isHexDigitCodePoint(r)) {
      const e = [r];

      for (; void 0 !== o.codePointSource[o.cursor] && isHexDigitCodePoint(o.codePointSource[o.cursor]) && e.length < 6;) e.push(o.codePointSource[o.cursor]), o.advanceCodePoint();

      isWhitespace$1(o.codePointSource[o.cursor]) && o.advanceCodePoint();
      const t = parseInt(String.fromCharCode(...e), 16);
      return 0 === t ? b : (n = t) >= 55296 && n <= 57343 || t > w$1 ? b : t;
    }

    var n;
    return r;
  }

  function consumeIdentSequence(e, o) {
    const r = [];

    for (;;) if (isIdentCodePoint(o.codePointSource[o.cursor])) r.push(o.codePointSource[o.cursor]), o.advanceCodePoint();else {
      if (!checkIfTwoCodePointsAreAValidEscape(0, o)) return r;
      o.advanceCodePoint(), r.push(consumeEscapedCodePoint(e, o));
    }
  }

  function consumeHashToken(e, o) {
    if (o.advanceCodePoint(), void 0 !== o.codePointSource[o.cursor] && (isIdentCodePoint(o.codePointSource[o.cursor]) || checkIfTwoCodePointsAreAValidEscape(0, o))) {
      let n = r$1.Unrestricted;
      checkIfThreeCodePointsWouldStartAnIdentSequence(0, o) && (n = r$1.ID);
      const t = consumeIdentSequence(e, o);
      return [exports.TokenType.Hash, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
        value: String.fromCharCode(...t),
        type: n
      }];
    }

    return [exports.TokenType.Delim, "#", o.representationStart, o.representationEnd, {
      value: "#"
    }];
  }

  function consumeNumber(e, o) {
    let r = exports.NumberType.Integer;

    for (o.codePointSource[o.cursor] !== L && o.codePointSource[o.cursor] !== k || o.advanceCodePoint(); isDigitCodePoint(o.codePointSource[o.cursor]);) o.advanceCodePoint();

    if (o.codePointSource[o.cursor] === T && isDigitCodePoint(o.codePointSource[o.cursor + 1])) for (o.advanceCodePoint(2), r = exports.NumberType.Number; isDigitCodePoint(o.codePointSource[o.cursor]);) o.advanceCodePoint();

    if (o.codePointSource[o.cursor] === E || o.codePointSource[o.cursor] === m$1) {
      if (isDigitCodePoint(o.codePointSource[o.cursor + 1])) o.advanceCodePoint(2);else {
        if (o.codePointSource[o.cursor + 1] !== k && o.codePointSource[o.cursor + 1] !== L || !isDigitCodePoint(o.codePointSource[o.cursor + 2])) return r;
        o.advanceCodePoint(3);
      }

      for (r = exports.NumberType.Number; isDigitCodePoint(o.codePointSource[o.cursor]);) o.advanceCodePoint();
    }

    return r;
  }

  function consumeNumericToken(e, o) {
    const r = consumeNumber(0, o),
          n = parseFloat(o.source.slice(o.representationStart, o.representationEnd + 1));

    if (checkIfThreeCodePointsWouldStartAnIdentSequence(0, o)) {
      const t = consumeIdentSequence(e, o);
      return [exports.TokenType.Dimension, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
        value: n,
        type: r,
        unit: String.fromCharCode(...t)
      }];
    }

    return o.codePointSource[o.cursor] === D ? (o.advanceCodePoint(), [exports.TokenType.Percentage, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
      value: n
    }]) : [exports.TokenType.Number, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
      value: n,
      type: r
    }];
  }

  function consumeWhiteSpace(e, o) {
    for (; isWhitespace$1(o.codePointSource[o.cursor]);) o.advanceCodePoint();

    return [exports.TokenType.Whitespace, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, void 0];
  }

  function consumeStringToken(e, o) {
    let r = "";
    const n = o.readCodePoint();

    for (;;) {
      const t = o.readCodePoint();
      if (!1 === t) return e.onParseError(new ParseError("Unexpected EOF while consuming a string token.", o.representationStart, o.representationEnd, ["4.3.5. Consume a string token", "Unexpected EOF"])), [exports.TokenType.String, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
        value: r
      }];
      if (isNewLine(t)) return e.onParseError(new ParseError("Unexpected newline while consuming a string token.", o.representationStart, o.representationEnd, ["4.3.5. Consume a string token", "Unexpected newline"])), o.unreadCodePoint(), [exports.TokenType.BadString, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, void 0];
      if (t === n) return [exports.TokenType.String, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
        value: r
      }];
      if (t !== R) r += String.fromCharCode(t);else {
        if (void 0 === o.codePointSource[o.cursor]) continue;

        if (isNewLine(o.codePointSource[o.cursor])) {
          o.advanceCodePoint();
          continue;
        }

        r += String.fromCharCode(consumeEscapedCodePoint(e, o));
      }
    }
  }

  const K = "u".charCodeAt(0),
        M = "U".charCodeAt(0),
        $ = "r".charCodeAt(0),
        J = "R".charCodeAt(0),
        j = "l".charCodeAt(0),
        Q = "L".charCodeAt(0);

  function checkIfCodePointsMatchURLIdent(e, o) {
    return 3 === o.length && (o[0] === K || o[0] === M) && (o[1] === $ || o[1] === J) && (o[2] === j || o[2] === Q);
  }

  function consumeBadURL(e, o) {
    for (;;) {
      if (void 0 === o.codePointSource[o.cursor]) return;
      if (o.codePointSource[o.cursor] === W) return void o.advanceCodePoint();
      checkIfTwoCodePointsAreAValidEscape(0, o) ? (o.advanceCodePoint(), consumeEscapedCodePoint(e, o)) : o.advanceCodePoint();
    }
  }

  function consumeUrlToken(e, o) {
    consumeWhiteSpace(0, o);
    let r = "";

    for (;;) {
      if (void 0 === o.codePointSource[o.cursor]) return e.onParseError(new ParseError("Unexpected EOF while consuming a url token.", o.representationStart, o.representationEnd, ["4.3.6. Consume a url token", "Unexpected EOF"])), [exports.TokenType.URL, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
        value: r
      }];
      if (o.codePointSource[o.cursor] === W) return o.advanceCodePoint(), [exports.TokenType.URL, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
        value: r
      }];
      if (isWhitespace$1(o.codePointSource[o.cursor])) return consumeWhiteSpace(0, o), void 0 === o.codePointSource[o.cursor] ? (e.onParseError(new ParseError("Unexpected EOF while consuming a url token.", o.representationStart, o.representationEnd, ["4.3.6. Consume a url token", "Consume as much whitespace as possible", "Unexpected EOF"])), [exports.TokenType.URL, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
        value: r
      }]) : o.codePointSource[o.cursor] === W ? (o.advanceCodePoint(), [exports.TokenType.URL, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
        value: r
      }]) : (consumeBadURL(e, o), [exports.TokenType.BadURL, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, void 0]);
      if (o.codePointSource[o.cursor] === N || o.codePointSource[o.cursor] === t$1 || o.codePointSource[o.cursor] === v || (n = o.codePointSource[o.cursor]) === I || n === S || A <= n && n <= s$2 || B <= n && n <= f) return consumeBadURL(e, o), e.onParseError(new ParseError("Unexpected character while consuming a url token.", o.representationStart, o.representationEnd, ["4.3.6. Consume a url token", "Unexpected U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point"])), [exports.TokenType.BadURL, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, void 0];

      if (o.codePointSource[o.cursor] === R) {
        if (checkIfTwoCodePointsAreAValidEscape(0, o)) {
          o.advanceCodePoint(), r += String.fromCharCode(consumeEscapedCodePoint(e, o));
          continue;
        }

        return consumeBadURL(e, o), e.onParseError(new ParseError("Invalid escape sequence while consuming a url token.", o.representationStart, o.representationEnd, ["4.3.6. Consume a url token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"])), [exports.TokenType.BadURL, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, void 0];
      }

      r += String.fromCharCode(o.codePointSource[o.cursor]), o.advanceCodePoint();
    }

    var n;
  }

  function consumeIdentLikeToken(e, o) {
    const r = consumeIdentSequence(e, o);
    if (o.codePointSource[o.cursor] !== v) return [exports.TokenType.Ident, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
      value: String.fromCharCode(...r)
    }];

    if (checkIfCodePointsMatchURLIdent(0, r)) {
      o.advanceCodePoint();
      let n = 0;

      for (;;) {
        const e = isWhitespace$1(o.codePointSource[o.cursor]),
              i = isWhitespace$1(o.codePointSource[o.cursor + 1]);

        if (e && i) {
          n += 1, o.advanceCodePoint(1);
          continue;
        }

        const s = e ? o.codePointSource[o.cursor + 1] : o.codePointSource[o.cursor];
        if (s === N || s === t$1) return n > 0 && o.unreadCodePoint(n), [exports.TokenType.Function, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
          value: String.fromCharCode(...r)
        }];
        break;
      }

      return consumeUrlToken(e, o);
    }

    return o.advanceCodePoint(), [exports.TokenType.Function, o.source.slice(o.representationStart, o.representationEnd + 1), o.representationStart, o.representationEnd, {
      value: String.fromCharCode(...r)
    }];
  }

  function tokenizer(e, o) {
    const r = e.css.valueOf(),
          n = new Reader$3(r),
          i = {
      onParseError: (null == o ? void 0 : o.onParseError) ?? (() => {})
    };
    return {
      nextToken: function nextToken() {
        if (n.representationStart = n.cursor, n.representationEnd = -1, checkIfTwoCodePointsStartAComment(0, n)) return consumeComment$1(i, n);
        const e = n.codePointSource[n.cursor];
        if (void 0 === e) return [exports.TokenType.EOF, "", -1, -1, void 0];
        if (isIdentStartCodePoint(e)) return consumeIdentLikeToken(i, n);
        if (isDigitCodePoint(e)) return consumeNumericToken(i, n);

        switch (e) {
          case d$2:
            return n.advanceCodePoint(), [exports.TokenType.Comma, ",", n.representationStart, n.representationEnd, void 0];

          case u$1:
            return n.advanceCodePoint(), [exports.TokenType.Colon, ":", n.representationStart, n.representationEnd, void 0];

          case V:
            return n.advanceCodePoint(), [exports.TokenType.Semicolon, ";", n.representationStart, n.representationEnd, void 0];

          case v:
            return n.advanceCodePoint(), [exports.TokenType.OpenParen, "(", n.representationStart, n.representationEnd, void 0];

          case W:
            return n.advanceCodePoint(), [exports.TokenType.CloseParen, ")", n.representationStart, n.representationEnd, void 0];

          case x:
            return n.advanceCodePoint(), [exports.TokenType.OpenSquare, "[", n.representationStart, n.representationEnd, void 0];

          case F:
            return n.advanceCodePoint(), [exports.TokenType.CloseSquare, "]", n.representationStart, n.representationEnd, void 0];

          case h$1:
            return n.advanceCodePoint(), [exports.TokenType.OpenCurly, "{", n.representationStart, n.representationEnd, void 0];

          case q:
            return n.advanceCodePoint(), [exports.TokenType.CloseCurly, "}", n.representationStart, n.representationEnd, void 0];

          case t$1:
          case N:
            return consumeStringToken(i, n);

          case U:
            return consumeHashToken(i, n);

          case L:
          case T:
            return checkIfThreeCodePointsWouldStartANumber(0, n) ? consumeNumericToken(i, n) : (n.advanceCodePoint(), [exports.TokenType.Delim, n.source[n.representationStart], n.representationStart, n.representationEnd, {
              value: n.source[n.representationStart]
            }]);

          case g:
          case c:
          case C:
          case a$1:
          case z:
            return consumeWhiteSpace(0, n);

          case k:
            return checkIfThreeCodePointsWouldStartANumber(0, n) ? consumeNumericToken(i, n) : checkIfThreeCodePointsWouldStartCDC(0, n) ? (n.advanceCodePoint(3), [exports.TokenType.CDC, "--\x3e", n.representationStart, n.representationEnd, void 0]) : checkIfThreeCodePointsWouldStartAnIdentSequence(0, n) ? consumeIdentLikeToken(i, n) : (n.advanceCodePoint(), [exports.TokenType.Delim, "-", n.representationStart, n.representationEnd, {
              value: "-"
            }]);

          case y$1:
            return checkIfFourCodePointsWouldStartCDO(0, n) ? (n.advanceCodePoint(4), [exports.TokenType.CDO, "\x3c!--", n.representationStart, n.representationEnd, void 0]) : (n.advanceCodePoint(), [exports.TokenType.Delim, "<", n.representationStart, n.representationEnd, {
              value: "<"
            }]);

          case p:
            if (n.advanceCodePoint(), checkIfThreeCodePointsWouldStartAnIdentSequence(0, n)) {
              const e = consumeIdentSequence(i, n);
              return [exports.TokenType.AtKeyword, n.source.slice(n.representationStart, n.representationEnd + 1), n.representationStart, n.representationEnd, {
                value: String.fromCharCode(...e)
              }];
            }

            return [exports.TokenType.Delim, "@", n.representationStart, n.representationEnd, {
              value: "@"
            }];

          case R:
            return checkIfTwoCodePointsAreAValidEscape(0, n) ? consumeIdentLikeToken(i, n) : (n.advanceCodePoint(), i.onParseError(new ParseError('Invalid escape sequence after "\\"', n.representationStart, n.representationEnd, ["4.3.1. Consume a token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"])), [exports.TokenType.Delim, "\\", n.representationStart, n.representationEnd, {
              value: "\\"
            }]);
        }

        return n.advanceCodePoint(), [exports.TokenType.Delim, n.source[n.representationStart], n.representationStart, n.representationEnd, {
          value: n.source[n.representationStart]
        }];
      },
      endOfFile: function endOfFile() {
        return void 0 === n.codePointSource[n.cursor];
      }
    };
  }

  exports.ParseError = ParseError, exports.Reader = Reader$3, exports.cloneTokens = function cloneTokens(e) {
    return "undefined" != typeof globalThis && "structuredClone" in globalThis ? structuredClone(e) : JSON.parse(JSON.stringify(e));
  }, exports.isToken = function isToken(e) {
    return !!Array.isArray(e) && !(e.length < 4) && !!n$2.includes(e[0]) && "string" == typeof e[1] && "number" == typeof e[2] && "number" == typeof e[3];
  }, exports.mirrorVariant = function mirrorVariant(e) {
    switch (e[0]) {
      case exports.TokenType.OpenParen:
        return [exports.TokenType.CloseParen, ")", -1, -1, void 0];

      case exports.TokenType.CloseParen:
        return [exports.TokenType.OpenParen, "(", -1, -1, void 0];

      case exports.TokenType.OpenCurly:
        return [exports.TokenType.CloseCurly, "}", -1, -1, void 0];

      case exports.TokenType.CloseCurly:
        return [exports.TokenType.OpenCurly, "{", -1, -1, void 0];

      case exports.TokenType.OpenSquare:
        return [exports.TokenType.CloseSquare, "]", -1, -1, void 0];

      case exports.TokenType.CloseSquare:
        return [exports.TokenType.OpenSquare, "[", -1, -1, void 0];

      default:
        return null;
    }
  }, exports.mirrorVariantType = function mirrorVariantType(e) {
    switch (e) {
      case exports.TokenType.OpenParen:
        return exports.TokenType.CloseParen;

      case exports.TokenType.CloseParen:
        return exports.TokenType.OpenParen;

      case exports.TokenType.OpenCurly:
        return exports.TokenType.CloseCurly;

      case exports.TokenType.CloseCurly:
        return exports.TokenType.OpenCurly;

      case exports.TokenType.OpenSquare:
        return exports.TokenType.CloseSquare;

      case exports.TokenType.CloseSquare:
        return exports.TokenType.OpenSquare;

      default:
        return null;
    }
  }, exports.mutateIdent = function mutateIdent(e, o) {
    let r = "";
    const n = new Array(o.length);

    for (let e = 0; e < o.length; e++) n[e] = o.charCodeAt(e);

    let t = 0;
    n[0] === k && n[1] === k ? (r = "--", t = 2) : n[0] === k && n[1] ? (r = "-", t = 2, isIdentStartCodePoint(n[1]) ? r += o[1] : r += `\\${n[1].toString(16)} `) : isIdentStartCodePoint(n[0]) ? (r = o[0], t = 1) : (r = `\\${n[0].toString(16)} `, t = 1);

    for (let e = t; e < n.length; e++) isIdentCodePoint(n[e]) ? r += o[e] : r += `\\${n[e].toString(16)} `;

    e[1] = r, e[4].value = o;
  }, exports.stringify = function stringify(...e) {
    let o = "";

    for (let r = 0; r < e.length; r++) o += e[r][1];

    return o;
  }, exports.tokenize = function tokenize(e, o) {
    const r = tokenizer(e, o),
          n = [];
    {
      for (; !r.endOfFile();) {
        const e = r.nextToken();
        e && n.push(e);
      }

      const e = r.nextToken();
      e && n.push(e);
    }
    return n;
  }, exports.tokenizer = tokenizer;

  var dist$6 = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  var e$1,
      n$1 = require("@csstools/css-tokenizer");

  function consumeComponentValue(e, o) {
    const t = o[0];

    if (t[0] === n$1.TokenType.OpenParen || t[0] === n$1.TokenType.OpenCurly || t[0] === n$1.TokenType.OpenSquare) {
      const n = consumeSimpleBlock(e, o);
      return {
        advance: n.advance,
        node: n.node
      };
    }

    if (t[0] === n$1.TokenType.Function) {
      const n = consumeFunction(e, o);
      return {
        advance: n.advance,
        node: n.node
      };
    }

    if (t[0] === n$1.TokenType.Whitespace) {
      const n = consumeWhitespace(e, o);
      return {
        advance: n.advance,
        node: n.node
      };
    }

    if (t[0] === n$1.TokenType.Comment) {
      const n = consumeComment(e, o);
      return {
        advance: n.advance,
        node: n.node
      };
    }

    return {
      advance: 1,
      node: new TokenNode$1(t)
    };
  }

  exports.ComponentValueType = void 0, (e$1 = exports.ComponentValueType || (exports.ComponentValueType = {})).Function = "function", e$1.SimpleBlock = "simple-block", e$1.Whitespace = "whitespace", e$1.Comment = "comment", e$1.Token = "token";

  class FunctionNode {
    constructor(e, n, o) {
      _defineProperty(this, "type", exports.ComponentValueType.Function);

      _defineProperty(this, "name", void 0);

      _defineProperty(this, "endToken", void 0);

      _defineProperty(this, "value", void 0);

      this.name = e, this.endToken = n, this.value = o;
    }

    getName() {
      return this.name[4].value;
    }

    normalize() {
      this.endToken[0] === n$1.TokenType.EOF && (this.endToken = [n$1.TokenType.CloseParen, ")", -1, -1, void 0]);
    }

    tokens() {
      return this.endToken[0] === n$1.TokenType.EOF ? [this.name, ...this.value.flatMap(e => e.tokens())] : [this.name, ...this.value.flatMap(e => e.tokens()), this.endToken];
    }

    toString() {
      const e = this.value.map(e => n$1.isToken(e) ? n$1.stringify(e) : e.toString()).join("");
      return n$1.stringify(this.name) + e + n$1.stringify(this.endToken);
    }

    indexOf(e) {
      return this.value.indexOf(e);
    }

    at(e) {
      if ("number" == typeof e) return e < 0 && (e = this.value.length + e), this.value[e];
    }

    walk(e, n) {
      let o = !1;
      if (this.value.forEach((t, s) => {
        if (o) return;
        let i;
        n && (i = { ...n
        }), !1 !== e({
          node: t,
          parent: this,
          state: i
        }, s) ? "walk" in t && !1 === t.walk(e, i) && (o = !0) : o = !0;
      }), o) return !1;
    }

    toJSON() {
      return {
        type: this.type,
        name: this.getName(),
        tokens: this.tokens(),
        value: this.value.map(e => e.toJSON())
      };
    }

    isFunctionNode() {
      return FunctionNode.isFunctionNode(this);
    }

    static isFunctionNode(e) {
      return !!e && e instanceof FunctionNode && e.type === exports.ComponentValueType.Function;
    }

  }

  function consumeFunction(e, o) {
    const t = [];
    let s = 1;

    for (;;) {
      const i = o[s];
      if (!i || i[0] === n$1.TokenType.EOF) return e.onParseError(new n$1.ParseError("Unexpected EOF while consuming a function.", o[0][2], o[o.length - 1][3], ["5.4.9. Consume a function", "Unexpected EOF"])), {
        advance: o.length,
        node: new FunctionNode(o[0], i, t)
      };
      if (i[0] === n$1.TokenType.CloseParen) return {
        advance: s + 1,
        node: new FunctionNode(o[0], i, t)
      };

      if (i[0] === n$1.TokenType.Comment || i[0] === n$1.TokenType.Whitespace) {
        const n = consumeAllCommentsAndWhitespace(e, o.slice(s));
        s += n.advance, t.push(...n.nodes);
        continue;
      }

      const r = consumeComponentValue(e, o.slice(s));
      s += r.advance, t.push(r.node);
    }
  }

  class SimpleBlockNode {
    constructor(e, n, o) {
      _defineProperty(this, "type", exports.ComponentValueType.SimpleBlock);

      _defineProperty(this, "startToken", void 0);

      _defineProperty(this, "endToken", void 0);

      _defineProperty(this, "value", void 0);

      this.startToken = e, this.endToken = n, this.value = o;
    }

    normalize() {
      if (this.endToken[0] === n$1.TokenType.EOF) {
        const e = n$1.mirrorVariant(this.startToken);
        e && (this.endToken = e);
      }
    }

    tokens() {
      return this.endToken[0] === n$1.TokenType.EOF ? [this.startToken, ...this.value.flatMap(e => e.tokens())] : [this.startToken, ...this.value.flatMap(e => e.tokens()), this.endToken];
    }

    toString() {
      const e = this.value.map(e => n$1.isToken(e) ? n$1.stringify(e) : e.toString()).join("");
      return n$1.stringify(this.startToken) + e + n$1.stringify(this.endToken);
    }

    indexOf(e) {
      return this.value.indexOf(e);
    }

    at(e) {
      if ("number" == typeof e) return e < 0 && (e = this.value.length + e), this.value[e];
    }

    walk(e, n) {
      let o = !1;
      if (this.value.forEach((t, s) => {
        if (o) return;
        let i;
        n && (i = { ...n
        }), !1 !== e({
          node: t,
          parent: this,
          state: i
        }, s) ? "walk" in t && !1 === t.walk(e, i) && (o = !0) : o = !0;
      }), o) return !1;
    }

    toJSON() {
      return {
        type: this.type,
        startToken: this.startToken,
        tokens: this.tokens(),
        value: this.value.map(e => e.toJSON())
      };
    }

    isSimpleBlockNode() {
      return SimpleBlockNode.isSimpleBlockNode(this);
    }

    static isSimpleBlockNode(e) {
      return !!e && e instanceof SimpleBlockNode && e.type === exports.ComponentValueType.SimpleBlock;
    }

  }

  function consumeSimpleBlock(e, o) {
    const t = n$1.mirrorVariantType(o[0][0]);
    if (!t) throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
    const s = [];
    let i = 1;

    for (;;) {
      const r = o[i];
      if (!r || r[0] === n$1.TokenType.EOF) return e.onParseError(new n$1.ParseError("Unexpected EOF while consuming a simple block.", o[0][2], o[o.length - 1][3], ["5.4.8. Consume a simple block", "Unexpected EOF"])), {
        advance: o.length,
        node: new SimpleBlockNode(o[0], r, s)
      };
      if (r[0] === t) return {
        advance: i + 1,
        node: new SimpleBlockNode(o[0], r, s)
      };

      if (r[0] === n$1.TokenType.Comment || r[0] === n$1.TokenType.Whitespace) {
        const n = consumeAllCommentsAndWhitespace(e, o.slice(i));
        i += n.advance, s.push(...n.nodes);
        continue;
      }

      const a = consumeComponentValue(e, o.slice(i));
      i += a.advance, s.push(a.node);
    }
  }

  class WhitespaceNode {
    constructor(e) {
      _defineProperty(this, "type", exports.ComponentValueType.Whitespace);

      _defineProperty(this, "value", void 0);

      this.value = e;
    }

    tokens() {
      return this.value;
    }

    toString() {
      return n$1.stringify(...this.value);
    }

    toJSON() {
      return {
        type: this.type,
        tokens: this.tokens()
      };
    }

    isWhitespaceNode() {
      return WhitespaceNode.isWhitespaceNode(this);
    }

    static isWhitespaceNode(e) {
      return !!e && e instanceof WhitespaceNode && e.type === exports.ComponentValueType.Whitespace;
    }

  }

  function consumeWhitespace(e, o) {
    let t = 0;

    for (;;) {
      if (o[t][0] !== n$1.TokenType.Whitespace) return {
        advance: t,
        node: new WhitespaceNode(o.slice(0, t))
      };
      t++;
    }
  }

  class CommentNode {
    constructor(e) {
      _defineProperty(this, "type", exports.ComponentValueType.Comment);

      _defineProperty(this, "value", void 0);

      this.value = e;
    }

    tokens() {
      return [this.value];
    }

    toString() {
      return n$1.stringify(this.value);
    }

    toJSON() {
      return {
        type: this.type,
        tokens: this.tokens()
      };
    }

    isCommentNode() {
      return CommentNode.isCommentNode(this);
    }

    static isCommentNode(e) {
      return !!e && e instanceof CommentNode && e.type === exports.ComponentValueType.Comment;
    }

  }

  function consumeComment(e, n) {
    return {
      advance: 1,
      node: new CommentNode(n[0])
    };
  }

  function consumeAllCommentsAndWhitespace(e, o) {
    const t = [];
    let s = 0;

    for (;;) if (o[s][0] !== n$1.TokenType.Whitespace) {
      if (o[s][0] !== n$1.TokenType.Comment) return {
        advance: s,
        nodes: t
      };
      t.push(new CommentNode(o[s])), s++;
    } else {
      const e = consumeWhitespace(0, o.slice(s));
      s += e.advance, t.push(e.node);
    }
  }

  class TokenNode$1 {
    constructor(e) {
      _defineProperty(this, "type", exports.ComponentValueType.Token);

      _defineProperty(this, "value", void 0);

      this.value = e;
    }

    tokens() {
      return [this.value];
    }

    toString() {
      return n$1.stringify(this.value);
    }

    toJSON() {
      return {
        type: this.type,
        tokens: this.tokens()
      };
    }

    isTokenNode() {
      return TokenNode$1.isTokenNode(this);
    }

    static isTokenNode(e) {
      return !!e && e instanceof TokenNode$1 && e.type === exports.ComponentValueType.Token;
    }

  }

  function isSimpleBlockNode$5(e) {
    return SimpleBlockNode.isSimpleBlockNode(e);
  }

  function isFunctionNode$5(e) {
    return FunctionNode.isFunctionNode(e);
  }

  exports.CommentNode = CommentNode, exports.FunctionNode = FunctionNode, exports.SimpleBlockNode = SimpleBlockNode, exports.TokenNode = TokenNode$1, exports.WhitespaceNode = WhitespaceNode, exports.consumeAllCommentsAndWhitespace = consumeAllCommentsAndWhitespace, exports.consumeComment = consumeComment, exports.consumeComponentValue = consumeComponentValue, exports.consumeFunction = consumeFunction, exports.consumeSimpleBlock = consumeSimpleBlock, exports.consumeWhitespace = consumeWhitespace, exports.gatherNodeAncestry = function gatherNodeAncestry(e) {
    const n = new Map();
    return e.walk(e => {
      Array.isArray(e.node) ? e.node.forEach(o => {
        n.set(o, e.parent);
      }) : n.set(e.node, e.parent);
    }), n;
  }, exports.isCommentNode = function isCommentNode(e) {
    return CommentNode.isCommentNode(e);
  }, exports.isFunctionNode = isFunctionNode$5, exports.isSimpleBlockNode = isSimpleBlockNode$5, exports.isTokenNode = function isTokenNode(e) {
    return TokenNode$1.isTokenNode(e);
  }, exports.isWhitespaceNode = function isWhitespaceNode(e) {
    return WhitespaceNode.isWhitespaceNode(e);
  }, exports.parseCommaSeparatedListOfComponentValues = function parseCommaSeparatedListOfComponentValues(e, o) {
    const t = {
      onParseError: (null == o ? void 0 : o.onParseError) ?? (() => {})
    },
          s = [...e];
    if (0 === e.length) return [];
    s[s.length - 1][0] !== n$1.TokenType.EOF && s.push([n$1.TokenType.EOF, "", s[s.length - 1][2], s[s.length - 1][3], void 0]);
    const i = [];
    let r = [],
        a = 0;

    for (;;) {
      if (!s[a] || s[a][0] === n$1.TokenType.EOF) return r.length && i.push(r), i;

      if (s[a][0] === n$1.TokenType.Comma) {
        i.push(r), r = [], a++;
        continue;
      }

      const o = consumeComponentValue(t, e.slice(a));
      r.push(o.node), a += o.advance;
    }
  }, exports.parseComponentValue = function parseComponentValue(e, o) {
    const t = {
      onParseError: (null == o ? void 0 : o.onParseError) ?? (() => {})
    },
          s = [...e];
    s[s.length - 1][0] !== n$1.TokenType.EOF && s.push([n$1.TokenType.EOF, "", s[s.length - 1][2], s[s.length - 1][3], void 0]);
    const i = consumeComponentValue(t, s);
    if (s[Math.min(i.advance, s.length - 1)][0] === n$1.TokenType.EOF) return i.node;
    t.onParseError(new n$1.ParseError("Expected EOF after parsing a component value.", e[0][2], e[e.length - 1][3], ["5.3.9. Parse a component value", "Expected EOF"]));
  }, exports.parseListOfComponentValues = function parseListOfComponentValues(e, o) {
    const t = {
      onParseError: (null == o ? void 0 : o.onParseError) ?? (() => {})
    },
          s = [...e];
    s[s.length - 1][0] !== n$1.TokenType.EOF && s.push([n$1.TokenType.EOF, "", s[s.length - 1][2], s[s.length - 1][3], void 0]);
    const i = [];
    let r = 0;

    for (;;) {
      if (!s[r] || s[r][0] === n$1.TokenType.EOF) return i;
      const e = consumeComponentValue(t, s.slice(r));
      i.push(e.node), r += e.advance;
    }
  }, exports.replaceComponentValues = function replaceComponentValues(e, n) {
    for (let o = 0; o < e.length; o++) {
      const t = e[o];

      for (let e = 0; e < t.length; e++) {
        const o = t[e];
        {
          const s = n(o);

          if (s) {
            t.splice(e, 1, s);
            continue;
          }
        }
        (isSimpleBlockNode$5(o) || isFunctionNode$5(o)) && o.walk((e, o) => {
          if ("number" != typeof o) return;
          const t = e.node,
                s = n(t);
          s && e.parent.value.splice(o, 1, s);
        });
      }
    }

    return e;
  }, exports.sourceIndices = function sourceIndices(e) {
    if (Array.isArray(e)) {
      const n = e[0];
      if (!n) return [0, 0];
      const o = e[e.length - 1] || n;
      return [sourceIndices(n)[0], sourceIndices(o)[1]];
    }

    const n = e.tokens(),
          o = n[0],
          t = n[n.length - 1];
    return o && t ? [o[2], t[3]] : [0, 0];
  }, exports.stringify = function stringify(e) {
    return e.map(e => e.map(e => n$1.stringify(...e.tokens())).join("")).join(",");
  };

  var dist$5 = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  /**
   * Check whether a function is custom / user-defined
   * https://github.com/w3c/css-houdini-drafts/issues/1007
   * @param {string} func
   * @returns {boolean}
   */

  var isCustomFunction = function isCustomFunction(func) {
    return func.startsWith('--');
  };

  var require$$0$5 = /*@__PURE__*/getAugmentedNamespace(dist$6);

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(dist$5);

  const {
    tokenize: tokenize$5
  } = require$$0$5;

  const {
    isFunctionNode: isFunctionNode$4,
    isSimpleBlockNode: isSimpleBlockNode$4,
    parseListOfComponentValues: parseListOfComponentValues$3
  } = require$$1;













  const {
    isRegExp: isRegExp$F,
    isString: isString$P
  } = validateTypes;



  const ruleName$1Z = 'function-no-unknown';
  const messages$1Z = ruleMessages$1(ruleName$1Z, {
    rejected: name => `Unexpected unknown function "${name}"`
  });
  const meta$1Z = {
    url: 'https://stylelint.io/user-guide/rules/function-no-unknown'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1Y = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1Z, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreFunctions: [isString$P, isRegExp$F]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const functionsList = [...JSON.parse(fs__default['default'].readFileSync(cjs$2.toString(), 'utf8')), // #5960
      '-webkit-gradient', 'color-stop', 'from', 'to', // #6537
      'scroll'];
      root.walkDecls(decl => {
        const {
          value
        } = decl;
        if (!value.includes('(')) return;
        if (!isStandardSyntaxValue(value)) return;
        /**
         * @param {import('@csstools/css-parser-algorithms').ComponentValue} componentValue
         */

        const walker = componentValue => {
          if (!isFunctionNode$4(componentValue)) return;
          const name = componentValue.getName();
          if (isCustomFunction(name)) return;
          if (optionsMatches(secondaryOptions, 'ignoreFunctions', name)) return;
          if (functionsList.includes(name.toLowerCase())) return;
          report$1({
            message: messages$1Z.rejected,
            messageArgs: [name],
            node: decl,
            index: declarationValueIndex(decl) + componentValue.name[2],
            result,
            ruleName: ruleName$1Z,
            word: name
          });
        };

        parseListOfComponentValues$3(tokenize$5({
          css: value
        })).forEach(componentValue => {
          if (isFunctionNode$4(componentValue) || isSimpleBlockNode$4(componentValue)) {
            walker(componentValue);
            componentValue.walk(({
              node
            }) => {
              walker(node);
            });
          }
        });
      });
    };
  };

  rule$1Y.ruleName = ruleName$1Z;
  rule$1Y.messages = messages$1Z;
  rule$1Y.meta = meta$1Z;
  var functionNoUnknown = rule$1Y;

  const ruleName$1Y = 'function-parentheses-newline-inside';
  const messages$1Y = ruleMessages$1(ruleName$1Y, {
    expectedOpening: 'Expected newline after "("',
    expectedClosing: 'Expected newline before ")"',
    expectedOpeningMultiLine: 'Expected newline after "(" in a multi-line function',
    rejectedOpeningMultiLine: 'Unexpected whitespace after "(" in a multi-line function',
    expectedClosingMultiLine: 'Expected newline before ")" in a multi-line function',
    rejectedClosingMultiLine: 'Unexpected whitespace before ")" in a multi-line function'
  });
  const meta$1Y = {
    url: 'https://stylelint.io/user-guide/rules/function-parentheses-newline-inside',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1X = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1Y, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!decl.value.includes('(')) {
          return;
        }

        let hasFixed = false;
        const declValue = getDeclarationValue(decl);
        const parsedValue = lib$6(declValue);
        parsedValue.walk(valueNode => {
          if (valueNode.type !== 'function') {
            return;
          }

          if (!isStandardSyntaxFunction(valueNode)) {
            return;
          }

          const functionString = lib$6.stringify(valueNode);
          const isMultiLine = !isSingleLineString(functionString);

          const containsNewline =
          /** @type {string} */
          str => str.includes('\n'); // Check opening ...


          const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;
          const checkBefore = getCheckBefore(valueNode);

          if (primary === 'always' && !containsNewline(checkBefore)) {
            if (context.fix) {
              hasFixed = true;
              fixBeforeForAlways(valueNode, context.newline || '');
            } else {
              complain(messages$1Y.expectedOpening, openingIndex);
            }
          }

          if (isMultiLine && primary === 'always-multi-line' && !containsNewline(checkBefore)) {
            if (context.fix) {
              hasFixed = true;
              fixBeforeForAlways(valueNode, context.newline || '');
            } else {
              complain(messages$1Y.expectedOpeningMultiLine, openingIndex);
            }
          }

          if (isMultiLine && primary === 'never-multi-line' && checkBefore !== '') {
            if (context.fix) {
              hasFixed = true;
              fixBeforeForNever(valueNode);
            } else {
              complain(messages$1Y.rejectedOpeningMultiLine, openingIndex);
            }
          } // Check closing ...


          const closingIndex = valueNode.sourceIndex + functionString.length - 2;
          const checkAfter = getCheckAfter(valueNode);

          if (primary === 'always' && !containsNewline(checkAfter)) {
            if (context.fix) {
              hasFixed = true;
              fixAfterForAlways(valueNode, context.newline || '');
            } else {
              complain(messages$1Y.expectedClosing, closingIndex);
            }
          }

          if (isMultiLine && primary === 'always-multi-line' && !containsNewline(checkAfter)) {
            if (context.fix) {
              hasFixed = true;
              fixAfterForAlways(valueNode, context.newline || '');
            } else {
              complain(messages$1Y.expectedClosingMultiLine, closingIndex);
            }
          }

          if (isMultiLine && primary === 'never-multi-line' && checkAfter !== '') {
            if (context.fix) {
              hasFixed = true;
              fixAfterForNever(valueNode);
            } else {
              complain(messages$1Y.rejectedClosingMultiLine, closingIndex);
            }
          }
        });

        if (hasFixed) {
          setDeclarationValue(decl, parsedValue.toString());
        }
        /**
         * @param {string} message
         * @param {number} offset
         */


        function complain(message, offset) {
          report$1({
            ruleName: ruleName$1Y,
            result,
            message,
            node: decl,
            index: declarationValueIndex(decl) + offset
          });
        }
      });
    };
  };
  /** @typedef {import('postcss-value-parser').FunctionNode} FunctionNode */

  /**
   * @param {FunctionNode} valueNode
   */


  function getCheckBefore(valueNode) {
    let before = valueNode.before;

    for (const node of valueNode.nodes) {
      if (node.type === 'comment') {
        continue;
      }

      if (node.type === 'space') {
        before += node.value;
        continue;
      }

      break;
    }

    return before;
  }
  /**
   * @param {FunctionNode} valueNode
   */


  function getCheckAfter(valueNode) {
    let after = '';

    for (const node of [...valueNode.nodes].reverse()) {
      if (node.type === 'comment') {
        continue;
      }

      if (node.type === 'space') {
        after = node.value + after;
        continue;
      }

      break;
    }

    after += valueNode.after;
    return after;
  }
  /**
   * @param {FunctionNode} valueNode
   * @param {string} newline
   */


  function fixBeforeForAlways(valueNode, newline) {
    let target;

    for (const node of valueNode.nodes) {
      if (node.type === 'comment') {
        continue;
      }

      if (node.type === 'space') {
        target = node;
        continue;
      }

      break;
    }

    if (target) {
      target.value = newline + target.value;
    } else {
      valueNode.before = newline + valueNode.before;
    }
  }
  /**
   * @param {FunctionNode} valueNode
   */


  function fixBeforeForNever(valueNode) {
    valueNode.before = '';

    for (const node of valueNode.nodes) {
      if (node.type === 'comment') {
        continue;
      }

      if (node.type === 'space') {
        node.value = '';
        continue;
      }

      break;
    }
  }
  /**
   * @param {FunctionNode} valueNode
   * @param {string} newline
   */


  function fixAfterForAlways(valueNode, newline) {
    valueNode.after = newline + valueNode.after;
  }
  /**
   * @param {FunctionNode} valueNode
   */


  function fixAfterForNever(valueNode) {
    valueNode.after = '';

    for (const node of [...valueNode.nodes].reverse()) {
      if (node.type === 'comment') {
        continue;
      }

      if (node.type === 'space') {
        node.value = '';
        continue;
      }

      break;
    }
  }

  rule$1X.ruleName = ruleName$1Y;
  rule$1X.messages = messages$1Y;
  rule$1X.meta = meta$1Y;
  var functionParenthesesNewlineInside = rule$1X;

  const ruleName$1X = 'function-parentheses-space-inside';
  const messages$1X = ruleMessages$1(ruleName$1X, {
    expectedOpening: 'Expected single space after "("',
    rejectedOpening: 'Unexpected whitespace after "("',
    expectedClosing: 'Expected single space before ")"',
    rejectedClosing: 'Unexpected whitespace before ")"',
    expectedOpeningSingleLine: 'Expected single space after "(" in a single-line function',
    rejectedOpeningSingleLine: 'Unexpected whitespace after "(" in a single-line function',
    expectedClosingSingleLine: 'Expected single space before ")" in a single-line function',
    rejectedClosingSingleLine: 'Unexpected whitespace before ")" in a single-line function'
  });
  const meta$1X = {
    url: 'https://stylelint.io/user-guide/rules/function-parentheses-space-inside',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1W = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1X, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!decl.value.includes('(')) {
          return;
        }

        let hasFixed = false;
        const declValue = getDeclarationValue(decl);
        const parsedValue = lib$6(declValue);
        parsedValue.walk(valueNode => {
          if (valueNode.type !== 'function') {
            return;
          }

          if (!isStandardSyntaxFunction(valueNode)) {
            return;
          } // Ignore function without parameters


          if (!valueNode.nodes.length) {
            return;
          }

          const functionString = lib$6.stringify(valueNode);
          const isSingleLine = isSingleLineString(functionString); // Check opening ...

          const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;

          if (primary === 'always' && valueNode.before !== ' ') {
            if (context.fix) {
              hasFixed = true;
              valueNode.before = ' ';
            } else {
              complain(messages$1X.expectedOpening, openingIndex);
            }
          }

          if (primary === 'never' && valueNode.before !== '') {
            if (context.fix) {
              hasFixed = true;
              valueNode.before = '';
            } else {
              complain(messages$1X.rejectedOpening, openingIndex);
            }
          }

          if (isSingleLine && primary === 'always-single-line' && valueNode.before !== ' ') {
            if (context.fix) {
              hasFixed = true;
              valueNode.before = ' ';
            } else {
              complain(messages$1X.expectedOpeningSingleLine, openingIndex);
            }
          }

          if (isSingleLine && primary === 'never-single-line' && valueNode.before !== '') {
            if (context.fix) {
              hasFixed = true;
              valueNode.before = '';
            } else {
              complain(messages$1X.rejectedOpeningSingleLine, openingIndex);
            }
          } // Check closing ...


          const closingIndex = valueNode.sourceIndex + functionString.length - 2;

          if (primary === 'always' && valueNode.after !== ' ') {
            if (context.fix) {
              hasFixed = true;
              valueNode.after = ' ';
            } else {
              complain(messages$1X.expectedClosing, closingIndex);
            }
          }

          if (primary === 'never' && valueNode.after !== '') {
            if (context.fix) {
              hasFixed = true;
              valueNode.after = '';
            } else {
              complain(messages$1X.rejectedClosing, closingIndex);
            }
          }

          if (isSingleLine && primary === 'always-single-line' && valueNode.after !== ' ') {
            if (context.fix) {
              hasFixed = true;
              valueNode.after = ' ';
            } else {
              complain(messages$1X.expectedClosingSingleLine, closingIndex);
            }
          }

          if (isSingleLine && primary === 'never-single-line' && valueNode.after !== '') {
            if (context.fix) {
              hasFixed = true;
              valueNode.after = '';
            } else {
              complain(messages$1X.rejectedClosingSingleLine, closingIndex);
            }
          }
        });

        if (hasFixed) {
          setDeclarationValue(decl, parsedValue.toString());
        }
        /**
         * @param {string} message
         * @param {number} offset
         */


        function complain(message, offset) {
          report$1({
            ruleName: ruleName$1X,
            result,
            message,
            node: decl,
            index: declarationValueIndex(decl) + offset
          });
        }
      });
    };
  };

  rule$1W.ruleName = ruleName$1X;
  rule$1W.messages = messages$1X;
  rule$1W.meta = meta$1X;
  var functionParenthesesSpaceInside = rule$1W;

  const IS_LESS_VARIABLE_IN_URL = /^@@?[\w-]+$/;
  const IS_SCSS_VARIABLE_IN_URL = /^[$\s\w+\-,./*'"]+$/;
  /**
   * Check whether a URL is standard
   *
   * @param {string} url
   * @returns {boolean}
   */

  var isStandardSyntaxUrl = function isStandardSyntaxUrl(url) {
    if (url.length === 0) {
      return true;
    } // Sass interpolation works anywhere


    if (hasScssInterpolation(url) || hasTplInterpolation(url) || hasPsvInterpolation(url)) {
      return false;
    } // Inside `'` and `"` work only LESS interpolation


    if (url.startsWith(`'`) && url.endsWith(`'`) || url.startsWith(`"`) && url.endsWith(`"`)) {
      if (hasLessInterpolation(url)) {
        return false;
      }

      return true;
    } // Less variable works only at the beginning
    // Check is less variable, allow use '@url/some/path'
    // https://github.com/less/less.js/blob/3.x/lib/less/parser/parser.js#L547


    if (url.startsWith('@') && IS_LESS_VARIABLE_IN_URL.test(url)) {
      return false;
    } // In url without quotes scss variable can be everywhere
    // But in this case it is allowed to use only specific characters
    // Also forbidden "/" at the end of url


    if (url.includes('$') && IS_SCSS_VARIABLE_IN_URL.test(url) && !url.endsWith('/')) {
      return false;
    }

    return true;
  };

  const ruleName$1W = 'function-url-no-scheme-relative';
  const messages$1W = ruleMessages$1(ruleName$1W, {
    rejected: 'Unexpected scheme-relative url'
  });
  const meta$1W = {
    url: 'https://stylelint.io/user-guide/rules/function-url-no-scheme-relative'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1V = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1W, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
          const url = args.trim().replace(/^['"]+|['"]+$/g, '');

          if (!isStandardSyntaxUrl(url) || !url.startsWith('//')) {
            return;
          }

          report$1({
            message: messages$1W.rejected,
            node: decl,
            index,
            endIndex: index + args.length,
            result,
            ruleName: ruleName$1W
          });
        });
      });
    };
  };

  rule$1V.ruleName = ruleName$1W;
  rule$1V.messages = messages$1W;
  rule$1V.meta = meta$1W;
  var functionUrlNoSchemeRelative = rule$1V;

  /**
   * @param {import('postcss').AtRule} atRule
   * @returns {string}
   */

  var getAtRuleParams = function getAtRuleParams(atRule) {
    return atRule.raws.params?.raw ?? atRule.params;
  };

  const ruleName$1V = 'function-url-quotes';
  const messages$1V = ruleMessages$1(ruleName$1V, {
    expected: functionName => `Expected quotes around "${functionName}" function argument`,
    rejected: functionName => `Unexpected quotes around "${functionName}" function argument`
  });
  const meta$1V = {
    url: 'https://stylelint.io/user-guide/rules/function-url-quotes',
    fixable: true
  };
  const URL_FUNC_REGEX = /url\(/i;
  /** @type {import('stylelint').Rule} */

  const rule$1U = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1V, {
        actual: primary,
        possible: ['always', 'never']
      }, {
        actual: secondaryOptions,
        possible: {
          except: ['empty']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const exceptEmpty = optionsMatches(secondaryOptions, 'except', 'empty');
      const emptyArgumentPatterns = new Set(['', "''", '""']);
      root.walkAtRules(checkAtRuleParams);
      root.walkDecls(checkDeclParams);
      /**
       * @param {import('postcss').Declaration} decl
       */

      function checkDeclParams(decl) {
        if (!URL_FUNC_REGEX.test(decl.value)) return;
        if (!isStandardSyntaxDeclaration(decl)) return;
        const value = getDeclarationValue(decl);
        const startIndex = declarationValueIndex(decl);
        const parsed = functionArgumentsSearch(value, /^url$/i, (args, index, funcNode) => {
          checkArgs(decl, args, startIndex + index, funcNode);
        });

        if (context.fix) {
          decl.value = parsed.toString();
        }
      }
      /**
       * @param {import('postcss').AtRule} atRule
       */


      function checkAtRuleParams(atRule) {
        const params = getAtRuleParams(atRule);
        const startIndex = atRuleParamIndex(atRule);
        let hasUrlFunction = false;
        const parsed = functionArgumentsSearch(params, /^url$/i, (args, index, funcNode) => {
          hasUrlFunction = true;
          checkArgs(atRule, args, startIndex + index, funcNode);
        });
        if (!hasUrlFunction) return;

        if (context.fix) {
          atRule.params = parsed.toString();
        }
      }
      /**
       * @param {import('postcss-value-parser').FunctionNode} funcNode
       */


      function addQuotes(funcNode) {
        for (const argNode of funcNode.nodes) {
          if (argNode.type === 'word') {
            argNode.value = `"${argNode.value}"`;
          }
        }
      }
      /**
       * @param {import('postcss-value-parser').FunctionNode} funcNode
       */


      function removeQuotes(funcNode) {
        for (const argNode of funcNode.nodes) {
          if (argNode.type === 'string') {
            // NOTE: We can ignore this error because the test passes.
            // @ts-expect-error -- TS2322: Type '"word"' is not assignable to type '"string"'.
            argNode.type = 'word';
          }
        }
      }
      /**
       * @param {import('postcss').Declaration | import('postcss').AtRule} node
       * @param {string} args
       * @param {number} index
       * @param {import('postcss-value-parser').FunctionNode} funcNode
       */


      function checkArgs(node, args, index, funcNode) {
        const functionName = funcNode.value.toLowerCase();
        let shouldHasQuotes = primary === 'always';
        const leftTrimmedArgs = args.trimStart();

        if (!isStandardSyntaxUrl(leftTrimmedArgs)) {
          return;
        }

        const complaintIndex = index + args.length - leftTrimmedArgs.length;
        const complaintEndIndex = index + args.length;
        const hasQuotes = leftTrimmedArgs.startsWith("'") || leftTrimmedArgs.startsWith('"');

        if (exceptEmpty && emptyArgumentPatterns.has(args.trim())) {
          shouldHasQuotes = !shouldHasQuotes;
        }

        if (shouldHasQuotes) {
          if (hasQuotes) {
            return;
          }

          if (context.fix) {
            addQuotes(funcNode);
            return;
          }

          complain(messages$1V.expected(functionName), node, complaintIndex, complaintEndIndex);
        } else {
          if (!hasQuotes) {
            return;
          }

          if (context.fix) {
            removeQuotes(funcNode);
            return;
          }

          complain(messages$1V.rejected(functionName), node, complaintIndex, complaintEndIndex);
        }
      }
      /**
       * @param {string} message
       * @param {import('postcss').Node} node
       * @param {number} index
       * @param {number} endIndex
       */


      function complain(message, node, index, endIndex) {
        report$1({
          message,
          node,
          index,
          endIndex,
          result,
          ruleName: ruleName$1V
        });
      }
    };
  };

  rule$1U.ruleName = ruleName$1V;
  rule$1U.messages = messages$1V;
  rule$1U.meta = meta$1V;
  var functionUrlQuotes = rule$1U;

  const {
    URL: URL$1
  } = url__default['default'];
  /**
   * Get unit from value node
   *
   * Returns `null` if the unit is not found.
   *
   * @param {string} urlString
   */


  var getSchemeFromUrl = function getSchemeFromUrl(urlString) {
    let protocol = null;

    try {
      protocol = new URL$1(urlString).protocol;
    } catch {
      return null;
    }

    if (protocol === null || typeof protocol === 'undefined') {
      return null;
    }

    const scheme = protocol.slice(0, -1); // strip trailing `:`
    // The URL spec does not require a scheme to be followed by `//`, but checking
    // for it allows this rule to differentiate <scheme>:<hostname> urls from
    // <hostname>:<port> urls. `data:` scheme urls are an exception to this rule.

    const slashIndex = protocol.length;
    const expectedSlashes = urlString.slice(slashIndex, slashIndex + 2);
    const isSchemeLessUrl = expectedSlashes !== '//' && scheme !== 'data';

    if (isSchemeLessUrl) {
      return null;
    }

    return scheme;
  };

  const {
    isRegExp: isRegExp$E,
    isString: isString$O
  } = validateTypes;

  const ruleName$1U = 'function-url-scheme-allowed-list';
  const messages$1U = ruleMessages$1(ruleName$1U, {
    rejected: scheme => `Unexpected URL scheme "${scheme}:"`
  });
  const meta$1U = {
    url: 'https://stylelint.io/user-guide/rules/function-url-scheme-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$1T = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1U, {
        actual: primary,
        possible: [isString$O, isRegExp$E]
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
          const unspacedUrlString = args.trim();

          if (!isStandardSyntaxUrl(unspacedUrlString)) {
            return;
          }

          const urlString = unspacedUrlString.replace(/^['"]+|['"]+$/g, '');
          const scheme = getSchemeFromUrl(urlString);

          if (scheme === null) {
            return;
          }

          if (matchesStringOrRegExp(scheme, primary)) {
            return;
          }

          report$1({
            message: messages$1U.rejected,
            messageArgs: [scheme],
            node: decl,
            index,
            endIndex: index + args.length,
            result,
            ruleName: ruleName$1U
          });
        });
      });
    };
  };

  rule$1T.primaryOptionArray = true;
  rule$1T.ruleName = ruleName$1U;
  rule$1T.messages = messages$1U;
  rule$1T.meta = meta$1U;
  var functionUrlSchemeAllowedList = rule$1T;

  const {
    isRegExp: isRegExp$D,
    isString: isString$N
  } = validateTypes;

  const ruleName$1T = 'function-url-scheme-disallowed-list';
  const messages$1T = ruleMessages$1(ruleName$1T, {
    rejected: scheme => `Unexpected URL scheme "${scheme}:"`
  });
  const meta$1T = {
    url: 'https://stylelint.io/user-guide/rules/function-url-scheme-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$1S = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1T, {
        actual: primary,
        possible: [isString$N, isRegExp$D]
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
          const unspacedUrlString = args.trim();

          if (!isStandardSyntaxUrl(unspacedUrlString)) {
            return;
          }

          const urlString = unspacedUrlString.replace(/^['"]+|['"]+$/g, '');
          const scheme = getSchemeFromUrl(urlString);

          if (scheme === null) {
            return;
          }

          if (!matchesStringOrRegExp(scheme, primary)) {
            return;
          }

          report$1({
            message: messages$1T.rejected,
            messageArgs: [scheme],
            node: decl,
            index,
            endIndex: index + args.length,
            result,
            ruleName: ruleName$1T
          });
        });
      });
    };
  };

  rule$1S.primaryOptionArray = true;
  rule$1S.ruleName = ruleName$1T;
  rule$1S.messages = messages$1T;
  rule$1S.meta = meta$1T;
  var functionUrlSchemeDisallowedList = rule$1S;

  const ruleName$1S = 'function-whitespace-after';
  const messages$1S = ruleMessages$1(ruleName$1S, {
    expected: 'Expected whitespace after ")"',
    rejected: 'Unexpected whitespace after ")"'
  });
  const meta$1S = {
    url: 'https://stylelint.io/user-guide/rules/function-whitespace-after',
    fixable: true,
    deprecated: true
  };
  const ACCEPTABLE_AFTER_CLOSING_PAREN = new Set([')', ',', '}', ':', '/', undefined]);
  /** @type {import('stylelint').Rule} */

  const rule$1R = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1S, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {import('postcss').Node} node
       * @param {string} value
       * @param {number} nodeIndex
       * @param {((index: number) => void) | undefined} fix
       */


      function check(node, value, nodeIndex, fix) {
        styleSearch({
          source: value,
          target: ')',
          functionArguments: 'only'
        }, match => {
          checkClosingParen(value, match.startIndex + 1, node, nodeIndex, fix);
        });
      }
      /**
       * @param {string} source
       * @param {number} index
       * @param {import('postcss').Node} node
       * @param {number} nodeIndex
       * @param {((index: number) => void) | undefined} fix
       */


      function checkClosingParen(source, index, node, nodeIndex, fix) {
        const nextChar = source.charAt(index);
        if (!nextChar) return;

        if (primary === 'always') {
          // Allow for the next character to be a single empty space,
          // another closing parenthesis, a comma, or the end of the value
          if (nextChar === ' ') {
            return;
          }

          if (nextChar === '\n') {
            return;
          }

          if (source.slice(index, index + 2) === '\r\n') {
            return;
          }

          if (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {
            return;
          }

          if (fix) {
            fix(index);
            return;
          }

          report$1({
            message: messages$1S.expected,
            node,
            index: nodeIndex + index,
            result,
            ruleName: ruleName$1S
          });
        } else if (primary === 'never' && isWhitespace$2(nextChar)) {
          if (fix) {
            fix(index);
            return;
          }

          report$1({
            message: messages$1S.rejected,
            node,
            index: nodeIndex + index,
            result,
            ruleName: ruleName$1S
          });
        }
      }
      /**
       * @param {string} value
       */


      function createFixer(value) {
        let fixed = '';
        let lastIndex = 0;
        /** @type {(index: number) => void} */

        let applyFix;

        if (primary === 'always') {
          applyFix = index => {
            // eslint-disable-next-line prefer-template
            fixed += value.slice(lastIndex, index) + ' ';
            lastIndex = index;
          };
        } else if (primary === 'never') {
          applyFix = index => {
            let whitespaceEndIndex = index + 1;

            while (whitespaceEndIndex < value.length && isWhitespace$2(value.charAt(whitespaceEndIndex))) {
              whitespaceEndIndex++;
            }

            fixed += value.slice(lastIndex, index);
            lastIndex = whitespaceEndIndex;
          };
        } else {
          throw new Error(`Unexpected option: "${primary}"`);
        }

        return {
          applyFix,

          get hasFixed() {
            return Boolean(lastIndex);
          },

          get fixed() {
            return fixed + value.slice(lastIndex);
          }

        };
      }

      root.walkAtRules(/^import$/i, atRule => {
        const param = atRule.raws.params && atRule.raws.params.raw || atRule.params;
        const fixer = context.fix && createFixer(param);
        check(atRule, param, atRuleParamIndex(atRule), fixer ? fixer.applyFix : undefined);

        if (fixer && fixer.hasFixed) {
          if (atRule.raws.params) {
            atRule.raws.params.raw = fixer.fixed;
          } else {
            atRule.params = fixer.fixed;
          }
        }
      });
      root.walkDecls(decl => {
        const value = getDeclarationValue(decl);
        const fixer = context.fix && createFixer(value);
        check(decl, value, declarationValueIndex(decl), fixer ? fixer.applyFix : undefined);

        if (fixer && fixer.hasFixed) {
          setDeclarationValue(decl, fixer.fixed);
        }
      });
    };
  };

  rule$1R.ruleName = ruleName$1S;
  rule$1R.messages = messages$1S;
  rule$1R.meta = meta$1S;
  var functionWhitespaceAfter = rule$1R;

  const ruleName$1R = 'hue-degree-notation';
  const messages$1R = ruleMessages$1(ruleName$1R, {
    expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"`
  });
  const meta$1R = {
    url: 'https://stylelint.io/user-guide/rules/hue-degree-notation',
    fixable: true
  };
  const HUE_FIRST_ARG_FUNCS = ['hsl', 'hsla', 'hwb'];
  const HUE_THIRD_ARG_FUNCS = ['lch', 'oklch'];
  const HUE_FUNCS = new Set([...HUE_FIRST_ARG_FUNCS, ...HUE_THIRD_ARG_FUNCS]);
  const HAS_HUE_COLOR_FUNC = new RegExp(`\\b(?:${[...HUE_FUNCS].join('|')})\\(`, 'i');
  /** @type {import('stylelint').Rule} */

  const rule$1Q = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1R, {
        actual: primary,
        possible: ['angle', 'number']
      });
      if (!validOptions) return;
      root.walkDecls(decl => {
        if (!HAS_HUE_COLOR_FUNC.test(decl.value)) return;
        let needsFix = false;
        const parsedValue = lib$6(getDeclarationValue(decl));
        parsedValue.walk(node => {
          if (node.type !== 'function') return;
          if (!HUE_FUNCS.has(node.value.toLowerCase())) return;
          const hue = findHue(node);
          if (!hue) return;
          const {
            value
          } = hue;
          if (!isStandardSyntaxValue(value)) return;
          if (!isDegree(value) && !isNumber$b(value)) return;
          if (primary === 'angle' && isDegree(value)) return;
          if (primary === 'number' && isNumber$b(value)) return;
          const fixed = primary === 'angle' ? asDegree(value) : asNumber(value);
          const unfixed = value;

          if (context.fix) {
            hue.value = fixed;
            needsFix = true;
            return;
          }

          const valueIndex = declarationValueIndex(decl);
          report$1({
            message: messages$1R.expected,
            messageArgs: [unfixed, fixed],
            node: decl,
            index: valueIndex + hue.sourceIndex,
            endIndex: valueIndex + hue.sourceEndIndex,
            result,
            ruleName: ruleName$1R
          });
        });

        if (needsFix) {
          setDeclarationValue(decl, parsedValue.toString());
        }
      });
    };
  };
  /**
   * @param {string} value
   */


  function asDegree(value) {
    return `${value}deg`;
  }
  /**
   * @param {string} value
   */


  function asNumber(value) {
    const dimension = lib$6.unit(value);
    if (dimension) return dimension.number;
    throw new TypeError(`The "${value}" value must have a unit`);
  }
  /**
   * @param {import('postcss-value-parser').FunctionNode} node
   */


  function findHue(node) {
    const args = node.nodes.filter(({
      type
    }) => type === 'word' || type === 'function');
    const value = node.value.toLowerCase();

    if (HUE_FIRST_ARG_FUNCS.includes(value)) {
      return args[0];
    }

    if (HUE_THIRD_ARG_FUNCS.includes(value)) {
      return args[2];
    }

    return undefined;
  }
  /**
   * @param {string} value
   */


  function isDegree(value) {
    const dimension = lib$6.unit(value);
    return dimension && dimension.unit.toLowerCase() === 'deg';
  }
  /**
   * @param {string} value
   */


  function isNumber$b(value) {
    const dimension = lib$6.unit(value);
    return dimension && dimension.unit === '';
  }

  rule$1Q.ruleName = ruleName$1R;
  rule$1Q.messages = messages$1R;
  rule$1Q.meta = meta$1R;
  var hueDegreeNotation = rule$1Q;

  /** @typedef {import('postcss').AtRule} AtRule */

  /**
   * @param {AtRule} atRule
   * @param {string} params
   * @returns {AtRule} The atRulearation that was passed in.
   */

  var setAtRuleParams = function setAtRuleParams(atRule, params) {
    const raws = atRule.raws;

    if (raws.params) {
      raws.params.raw = params;
    } else {
      atRule.params = params;
    }

    return atRule;
  };

  const ruleName$1Q = 'import-notation';
  const messages$1Q = ruleMessages$1(ruleName$1Q, {
    expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"`
  });
  const meta$1Q = {
    url: 'https://stylelint.io/user-guide/rules/import-notation',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1P = (primary, _, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1Q, {
        actual: primary,
        possible: ['string', 'url']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^import$/i, checkAtRuleImportParams);
      /**
       * @param {import('postcss').AtRule} atRule
       */

      function checkAtRuleImportParams(atRule) {
        const params = getAtRuleParams(atRule);
        const parsed = lib$6(params);

        for (const node of parsed.nodes) {
          const start = atRuleParamIndex(atRule);
          const end = start + node.sourceEndIndex;

          if (primary === 'string') {
            if (node.type === 'function' && node.value.toLowerCase() === 'url') {
              const urlFunctionFull = lib$6.stringify(node);
              const urlFunctionArguments = lib$6.stringify(node.nodes);
              const quotedUrlFunctionFirstArgument = node.nodes[0] && node.nodes[0].type === 'word' ? `"${urlFunctionArguments}"` : urlFunctionArguments;

              if (context.fix) {
                const restAtRuleParams = atRule.params.slice(node.sourceEndIndex);
                setAtRuleParams(atRule, `${quotedUrlFunctionFirstArgument}${restAtRuleParams}`);
                return;
              }

              complain(messages$1Q.expected(urlFunctionFull, quotedUrlFunctionFirstArgument), atRule, start, end);
              return;
            }
          }

          if (primary === 'url') {
            if (node.type === 'space') return;

            if (node.type === 'word' || node.type === 'string') {
              const path = lib$6.stringify(node);
              const urlFunctionFull = `url(${path})`;

              if (context.fix) {
                const restAtRuleParams = atRule.params.slice(node.sourceEndIndex);
                setAtRuleParams(atRule, `${urlFunctionFull}${restAtRuleParams}`);
                return;
              }

              const quotedNodeValue = node.type === 'word' ? `"${node.value}"` : `${node.quote}${node.value}${node.quote}`;
              complain(messages$1Q.expected(quotedNodeValue, urlFunctionFull), atRule, start, end);
              return;
            }
          }
        }
      }
      /**
       * @param {string} message
       * @param {import('postcss').Node} node
       * @param {number} index
       * @param {number} endIndex
       */


      function complain(message, node, index, endIndex) {
        report$1({
          message,
          node,
          index,
          endIndex,
          result,
          ruleName: ruleName$1Q
        });
      }
    };
  };

  rule$1P.ruleName = ruleName$1Q;
  rule$1P.messages = messages$1Q;
  rule$1P.meta = meta$1Q;
  var importNotation = rule$1P;

  /**
   * Check whether a selector is standard
   *
   * @param {string} selector
   * @returns {boolean}
   */


  var isStandardSyntaxSelector = function isStandardSyntaxSelector(selector) {
    // SCSS or Less interpolation
    if (hasInterpolation(selector)) {
      return false;
    } // SCSS placeholder selectors


    if (selector.startsWith('%')) {
      return false;
    } // SCSS nested properties


    if (selector.endsWith(':')) {
      return false;
    } // Less :extend()


    if (/:extend(?:\(.*?\))?/.test(selector)) {
      return false;
    } // Less mixin with resolved nested selectors (e.g. .foo().bar or .foo(@a, @b)[bar])


    if (/\.[\w-]+\(.*\).+/.test(selector)) {
      return false;
    } // Less non-outputting mixin definition (e.g. .mixin() {})


    if (selector.endsWith(')') && !selector.includes(':')) {
      return false;
    } // Less Parametric mixins (e.g. .mixin(@variable: x) {})


    if (/\(@.*\)$/.test(selector)) {
      return false;
    } // ERB template tags


    if (selector.includes('<%') || selector.includes('%>')) {
      return false;
    } //  SCSS and Less comments


    if (selector.includes('//')) {
      return false;
    }

    return true;
  };

  const ruleName$1P = 'keyframe-block-no-duplicate-selectors';
  const messages$1P = ruleMessages$1(ruleName$1P, {
    rejected: selector => `Unexpected duplicate "${selector}"`
  });
  const meta$1P = {
    url: 'https://stylelint.io/user-guide/rules/keyframe-block-no-duplicate-selectors'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1O = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1P, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes => {
        const selectors = new Set();
        atRuleKeyframes.walkRules(keyframeRule => {
          const ruleSelectors = keyframeRule.selectors;
          ruleSelectors.forEach(selector => {
            if (!isStandardSyntaxSelector(selector)) {
              return;
            }

            const normalizedSelector = selector.toLowerCase();
            const isDuplicate = selectors.has(normalizedSelector);

            if (isDuplicate) {
              report$1({
                message: messages$1P.rejected,
                messageArgs: [selector],
                node: keyframeRule,
                result,
                ruleName: ruleName$1P,
                word: selector
              });
              return;
            }

            selectors.add(normalizedSelector);
          });
        });
      });
    };
  };

  rule$1O.ruleName = ruleName$1P;
  rule$1O.messages = messages$1P;
  rule$1O.meta = meta$1P;
  var keyframeBlockNoDuplicateSelectors = rule$1O;

  const {
    assert: assert$5
  } = validateTypes;

  const ruleName$1O = 'keyframe-declaration-no-important';
  const messages$1O = ruleMessages$1(ruleName$1O, {
    rejected: 'Unexpected !important'
  });
  const meta$1O = {
    url: 'https://stylelint.io/user-guide/rules/keyframe-declaration-no-important'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1N = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1O, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes => {
        atRuleKeyframes.walkDecls(decl => {
          if (!decl.important) {
            return;
          }

          const pos = getImportantPosition(decl.toString());
          assert$5(pos);
          report$1({
            message: messages$1O.rejected,
            node: decl,
            index: pos.index,
            endIndex: pos.endIndex,
            result,
            ruleName: ruleName$1O
          });
        });
      });
    };
  };

  rule$1N.ruleName = ruleName$1O;
  rule$1N.messages = messages$1O;
  rule$1N.meta = meta$1O;
  var keyframeDeclarationNoImportant = rule$1N;

  var unesc_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = unesc; // Many thanks for this post which made this migration much easier.
  // https://mathiasbynens.be/notes/css-escapes

  /**
   * 
   * @param {string} str 
   * @returns {[string, number]|undefined}
   */

  function gobbleHex(str) {
    var lower = str.toLowerCase();
    var hex = '';
    var spaceTerminated = false;

    for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
      var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]

      var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point

      spaceTerminated = code === 32;

      if (!valid) {
        break;
      }

      hex += lower[i];
    }

    if (hex.length === 0) {
      return undefined;
    }

    var codePoint = parseInt(hex, 16);
    var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for
    // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point

    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
      return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
    }

    return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
  }

  var CONTAINS_ESCAPE = /\\/;

  function unesc(str) {
    var needToProcess = CONTAINS_ESCAPE.test(str);

    if (!needToProcess) {
      return str;
    }

    var ret = "";

    for (var i = 0; i < str.length; i++) {
      if (str[i] === "\\") {
        var gobbled = gobbleHex(str.slice(i + 1, i + 7));

        if (gobbled !== undefined) {
          ret += gobbled[0];
          i += gobbled[1];
          continue;
        } // Retain a pair of \\ if double escaped `\\\\`
        // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e


        if (str[i + 1] === "\\") {
          ret += "\\";
          i++;
          continue;
        } // if \\ is at the end of the string retain it
        // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb


        if (str.length === i + 1) {
          ret += str[i];
        }

        continue;
      }

      ret += str[i];
    }

    return ret;
  }

  module.exports = exports.default;
  });

  var getProp_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = getProp;

  function getProp(obj) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }

    while (props.length > 0) {
      var prop = props.shift();

      if (!obj[prop]) {
        return undefined;
      }

      obj = obj[prop];
    }

    return obj;
  }

  module.exports = exports.default;
  });

  var ensureObject_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = ensureObject;

  function ensureObject(obj) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }

    while (props.length > 0) {
      var prop = props.shift();

      if (!obj[prop]) {
        obj[prop] = {};
      }

      obj = obj[prop];
    }
  }

  module.exports = exports.default;
  });

  var stripComments_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = stripComments;

  function stripComments(str) {
    var s = "";
    var commentStart = str.indexOf("/*");
    var lastEnd = 0;

    while (commentStart >= 0) {
      s = s + str.slice(lastEnd, commentStart);
      var commentEnd = str.indexOf("*/", commentStart + 2);

      if (commentEnd < 0) {
        return s;
      }

      lastEnd = commentEnd + 2;
      commentStart = str.indexOf("/*", lastEnd);
    }

    s = s + str.slice(lastEnd);
    return s;
  }

  module.exports = exports.default;
  });

  var util = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.unesc = exports.stripComments = exports.getProp = exports.ensureObject = void 0;

  var _unesc = _interopRequireDefault(unesc_1);

  exports.unesc = _unesc["default"];

  var _getProp = _interopRequireDefault(getProp_1);

  exports.getProp = _getProp["default"];

  var _ensureObject = _interopRequireDefault(ensureObject_1);

  exports.ensureObject = _ensureObject["default"];

  var _stripComments = _interopRequireDefault(stripComments_1);

  exports.stripComments = _stripComments["default"];

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  });

  var node$2 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;



  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var cloneNode = function cloneNode(obj, parent) {
    if (typeof obj !== 'object' || obj === null) {
      return obj;
    }

    var cloned = new obj.constructor();

    for (var i in obj) {
      if (!obj.hasOwnProperty(i)) {
        continue;
      }

      var value = obj[i];
      var type = typeof value;

      if (i === 'parent' && type === 'object') {
        if (parent) {
          cloned[i] = parent;
        }
      } else if (value instanceof Array) {
        cloned[i] = value.map(function (j) {
          return cloneNode(j, cloned);
        });
      } else {
        cloned[i] = cloneNode(value, cloned);
      }
    }

    return cloned;
  };

  var Node = /*#__PURE__*/function () {
    function Node(opts) {
      if (opts === void 0) {
        opts = {};
      }

      Object.assign(this, opts);
      this.spaces = this.spaces || {};
      this.spaces.before = this.spaces.before || '';
      this.spaces.after = this.spaces.after || '';
    }

    var _proto = Node.prototype;

    _proto.remove = function remove() {
      if (this.parent) {
        this.parent.removeChild(this);
      }

      this.parent = undefined;
      return this;
    };

    _proto.replaceWith = function replaceWith() {
      if (this.parent) {
        for (var index in arguments) {
          this.parent.insertBefore(this, arguments[index]);
        }

        this.remove();
      }

      return this;
    };

    _proto.next = function next() {
      return this.parent.at(this.parent.index(this) + 1);
    };

    _proto.prev = function prev() {
      return this.parent.at(this.parent.index(this) - 1);
    };

    _proto.clone = function clone(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }

      var cloned = cloneNode(this);

      for (var name in overrides) {
        cloned[name] = overrides[name];
      }

      return cloned;
    }
    /**
     * Some non-standard syntax doesn't follow normal escaping rules for css.
     * This allows non standard syntax to be appended to an existing property
     * by specifying the escaped value. By specifying the escaped value,
     * illegal characters are allowed to be directly inserted into css output.
     * @param {string} name the property to set
     * @param {any} value the unescaped value of the property
     * @param {string} valueEscaped optional. the escaped value of the property.
     */
    ;

    _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
      if (!this.raws) {
        this.raws = {};
      }

      var originalValue = this[name];
      var originalEscaped = this.raws[name];
      this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

      if (originalEscaped || valueEscaped !== value) {
        this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
      } else {
        delete this.raws[name]; // delete any escaped value that was created by the setter.
      }
    }
    /**
     * Some non-standard syntax doesn't follow normal escaping rules for css.
     * This allows the escaped value to be specified directly, allowing illegal
     * characters to be directly inserted into css output.
     * @param {string} name the property to set
     * @param {any} value the unescaped value of the property
     * @param {string} valueEscaped the escaped value of the property.
     */
    ;

    _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
      if (!this.raws) {
        this.raws = {};
      }

      this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

      this.raws[name] = valueEscaped;
    }
    /**
     * When you want a value to passed through to CSS directly. This method
     * deletes the corresponding raw value causing the stringifier to fallback
     * to the unescaped value.
     * @param {string} name the property to set.
     * @param {any} value The value that is both escaped and unescaped.
     */
    ;

    _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
      this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

      if (this.raws) {
        delete this.raws[name];
      }
    }
    /**
     *
     * @param {number} line The number (starting with 1)
     * @param {number} column The column number (starting with 1)
     */
    ;

    _proto.isAtPosition = function isAtPosition(line, column) {
      if (this.source && this.source.start && this.source.end) {
        if (this.source.start.line > line) {
          return false;
        }

        if (this.source.end.line < line) {
          return false;
        }

        if (this.source.start.line === line && this.source.start.column > column) {
          return false;
        }

        if (this.source.end.line === line && this.source.end.column < column) {
          return false;
        }

        return true;
      }

      return undefined;
    };

    _proto.stringifyProperty = function stringifyProperty(name) {
      return this.raws && this.raws[name] || this[name];
    };

    _proto.valueToString = function valueToString() {
      return String(this.stringifyProperty("value"));
    };

    _proto.toString = function toString() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
    };

    _createClass(Node, [{
      key: "rawSpaceBefore",
      get: function get() {
        var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

        if (rawSpace === undefined) {
          rawSpace = this.spaces && this.spaces.before;
        }

        return rawSpace || "";
      },
      set: function set(raw) {
        (0, util.ensureObject)(this, "raws", "spaces");
        this.raws.spaces.before = raw;
      }
    }, {
      key: "rawSpaceAfter",
      get: function get() {
        var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

        if (rawSpace === undefined) {
          rawSpace = this.spaces.after;
        }

        return rawSpace || "";
      },
      set: function set(raw) {
        (0, util.ensureObject)(this, "raws", "spaces");
        this.raws.spaces.after = raw;
      }
    }]);

    return Node;
  }();

  exports["default"] = Node;
  module.exports = exports.default;
  });

  var types$2 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.UNIVERSAL = exports.TAG = exports.STRING = exports.SELECTOR = exports.ROOT = exports.PSEUDO = exports.NESTING = exports.ID = exports.COMMENT = exports.COMBINATOR = exports.CLASS = exports.ATTRIBUTE = void 0;
  var TAG = 'tag';
  exports.TAG = TAG;
  var STRING = 'string';
  exports.STRING = STRING;
  var SELECTOR = 'selector';
  exports.SELECTOR = SELECTOR;
  var ROOT = 'root';
  exports.ROOT = ROOT;
  var PSEUDO = 'pseudo';
  exports.PSEUDO = PSEUDO;
  var NESTING = 'nesting';
  exports.NESTING = NESTING;
  var ID = 'id';
  exports.ID = ID;
  var COMMENT = 'comment';
  exports.COMMENT = COMMENT;
  var COMBINATOR = 'combinator';
  exports.COMBINATOR = COMBINATOR;
  var CLASS = 'class';
  exports.CLASS = CLASS;
  var ATTRIBUTE = 'attribute';
  exports.ATTRIBUTE = ATTRIBUTE;
  var UNIVERSAL = 'universal';
  exports.UNIVERSAL = UNIVERSAL;
  });

  var container = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node$2);

  var types = _interopRequireWildcard(types$2);

  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache(nodeInterop);

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);

    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Container = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Container, _Node);

    function Container(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;

      if (!_this.nodes) {
        _this.nodes = [];
      }

      return _this;
    }

    var _proto = Container.prototype;

    _proto.append = function append(selector) {
      selector.parent = this;
      this.nodes.push(selector);
      return this;
    };

    _proto.prepend = function prepend(selector) {
      selector.parent = this;
      this.nodes.unshift(selector);
      return this;
    };

    _proto.at = function at(index) {
      return this.nodes[index];
    };

    _proto.index = function index(child) {
      if (typeof child === 'number') {
        return child;
      }

      return this.nodes.indexOf(child);
    };

    _proto.removeChild = function removeChild(child) {
      child = this.index(child);
      this.at(child).parent = undefined;
      this.nodes.splice(child, 1);
      var index;

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (index >= child) {
          this.indexes[id] = index - 1;
        }
      }

      return this;
    };

    _proto.removeAll = function removeAll() {
      for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
        var node = _step.value;
        node.parent = undefined;
      }

      this.nodes = [];
      return this;
    };

    _proto.empty = function empty() {
      return this.removeAll();
    };

    _proto.insertAfter = function insertAfter(oldNode, newNode) {
      newNode.parent = this;
      var oldIndex = this.index(oldNode);
      this.nodes.splice(oldIndex + 1, 0, newNode);
      newNode.parent = this;
      var index;

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (oldIndex <= index) {
          this.indexes[id] = index + 1;
        }
      }

      return this;
    };

    _proto.insertBefore = function insertBefore(oldNode, newNode) {
      newNode.parent = this;
      var oldIndex = this.index(oldNode);
      this.nodes.splice(oldIndex, 0, newNode);
      newNode.parent = this;
      var index;

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (index <= oldIndex) {
          this.indexes[id] = index + 1;
        }
      }

      return this;
    };

    _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
      var found = undefined;
      this.each(function (node) {
        if (node.atPosition) {
          var foundChild = node.atPosition(line, col);

          if (foundChild) {
            found = foundChild;
            return false;
          }
        } else if (node.isAtPosition(line, col)) {
          found = node;
          return false;
        }
      });
      return found;
    }
    /**
     * Return the most specific node at the line and column number given.
     * The source location is based on the original parsed location, locations aren't
     * updated as selector nodes are mutated.
     * 
     * Note that this location is relative to the location of the first character
     * of the selector, and not the location of the selector in the overall document
     * when used in conjunction with postcss.
     *
     * If not found, returns undefined.
     * @param {number} line The line number of the node to find. (1-based index)
     * @param {number} col  The column number of the node to find. (1-based index)
     */
    ;

    _proto.atPosition = function atPosition(line, col) {
      if (this.isAtPosition(line, col)) {
        return this._findChildAtPosition(line, col) || this;
      } else {
        return undefined;
      }
    };

    _proto._inferEndPosition = function _inferEndPosition() {
      if (this.last && this.last.source && this.last.source.end) {
        this.source = this.source || {};
        this.source.end = this.source.end || {};
        Object.assign(this.source.end, this.last.source.end);
      }
    };

    _proto.each = function each(callback) {
      if (!this.lastEach) {
        this.lastEach = 0;
      }

      if (!this.indexes) {
        this.indexes = {};
      }

      this.lastEach++;
      var id = this.lastEach;
      this.indexes[id] = 0;

      if (!this.length) {
        return undefined;
      }

      var index, result;

      while (this.indexes[id] < this.length) {
        index = this.indexes[id];
        result = callback(this.at(index), index);

        if (result === false) {
          break;
        }

        this.indexes[id] += 1;
      }

      delete this.indexes[id];

      if (result === false) {
        return false;
      }
    };

    _proto.walk = function walk(callback) {
      return this.each(function (node, i) {
        var result = callback(node, i);

        if (result !== false && node.length) {
          result = node.walk(callback);
        }

        if (result === false) {
          return false;
        }
      });
    };

    _proto.walkAttributes = function walkAttributes(callback) {
      var _this2 = this;

      return this.walk(function (selector) {
        if (selector.type === types.ATTRIBUTE) {
          return callback.call(_this2, selector);
        }
      });
    };

    _proto.walkClasses = function walkClasses(callback) {
      var _this3 = this;

      return this.walk(function (selector) {
        if (selector.type === types.CLASS) {
          return callback.call(_this3, selector);
        }
      });
    };

    _proto.walkCombinators = function walkCombinators(callback) {
      var _this4 = this;

      return this.walk(function (selector) {
        if (selector.type === types.COMBINATOR) {
          return callback.call(_this4, selector);
        }
      });
    };

    _proto.walkComments = function walkComments(callback) {
      var _this5 = this;

      return this.walk(function (selector) {
        if (selector.type === types.COMMENT) {
          return callback.call(_this5, selector);
        }
      });
    };

    _proto.walkIds = function walkIds(callback) {
      var _this6 = this;

      return this.walk(function (selector) {
        if (selector.type === types.ID) {
          return callback.call(_this6, selector);
        }
      });
    };

    _proto.walkNesting = function walkNesting(callback) {
      var _this7 = this;

      return this.walk(function (selector) {
        if (selector.type === types.NESTING) {
          return callback.call(_this7, selector);
        }
      });
    };

    _proto.walkPseudos = function walkPseudos(callback) {
      var _this8 = this;

      return this.walk(function (selector) {
        if (selector.type === types.PSEUDO) {
          return callback.call(_this8, selector);
        }
      });
    };

    _proto.walkTags = function walkTags(callback) {
      var _this9 = this;

      return this.walk(function (selector) {
        if (selector.type === types.TAG) {
          return callback.call(_this9, selector);
        }
      });
    };

    _proto.walkUniversals = function walkUniversals(callback) {
      var _this10 = this;

      return this.walk(function (selector) {
        if (selector.type === types.UNIVERSAL) {
          return callback.call(_this10, selector);
        }
      });
    };

    _proto.split = function split(callback) {
      var _this11 = this;

      var current = [];
      return this.reduce(function (memo, node, index) {
        var split = callback.call(_this11, node);
        current.push(node);

        if (split) {
          memo.push(current);
          current = [];
        } else if (index === _this11.length - 1) {
          memo.push(current);
        }

        return memo;
      }, []);
    };

    _proto.map = function map(callback) {
      return this.nodes.map(callback);
    };

    _proto.reduce = function reduce(callback, memo) {
      return this.nodes.reduce(callback, memo);
    };

    _proto.every = function every(callback) {
      return this.nodes.every(callback);
    };

    _proto.some = function some(callback) {
      return this.nodes.some(callback);
    };

    _proto.filter = function filter(callback) {
      return this.nodes.filter(callback);
    };

    _proto.sort = function sort(callback) {
      return this.nodes.sort(callback);
    };

    _proto.toString = function toString() {
      return this.map(String).join('');
    };

    _createClass(Container, [{
      key: "first",
      get: function get() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function get() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function get() {
        return this.nodes.length;
      }
    }]);

    return Container;
  }(_node["default"]);

  exports["default"] = Container;
  module.exports = exports.default;
  });

  var root = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _container = _interopRequireDefault(container);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Root = /*#__PURE__*/function (_Container) {
    _inheritsLoose(Root, _Container);

    function Root(opts) {
      var _this;

      _this = _Container.call(this, opts) || this;
      _this.type = types$2.ROOT;
      return _this;
    }

    var _proto = Root.prototype;

    _proto.toString = function toString() {
      var str = this.reduce(function (memo, selector) {
        memo.push(String(selector));
        return memo;
      }, []).join(',');
      return this.trailingComma ? str + ',' : str;
    };

    _proto.error = function error(message, options) {
      if (this._error) {
        return this._error(message, options);
      } else {
        return new Error(message);
      }
    };

    _createClass(Root, [{
      key: "errorGenerator",
      set: function set(handler) {
        this._error = handler;
      }
    }]);

    return Root;
  }(_container["default"]);

  exports["default"] = Root;
  module.exports = exports.default;
  });

  var selector = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _container = _interopRequireDefault(container);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Selector = /*#__PURE__*/function (_Container) {
    _inheritsLoose(Selector, _Container);

    function Selector(opts) {
      var _this;

      _this = _Container.call(this, opts) || this;
      _this.type = types$2.SELECTOR;
      return _this;
    }

    return Selector;
  }(_container["default"]);

  exports["default"] = Selector;
  module.exports = exports.default;
  });

  /*! https://mths.be/cssesc v3.0.0 by @mathias */

  var object$1 = {};
  var hasOwnProperty$1 = object$1.hasOwnProperty;

  var merge$1 = function merge(options, defaults) {
    if (!options) {
      return defaults;
    }

    var result = {};

    for (var key in defaults) {
      // `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
      // only recognized option names are used.
      result[key] = hasOwnProperty$1.call(options, key) ? options[key] : defaults[key];
    }

    return result;
  };

  var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
  var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
  var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g; // https://mathiasbynens.be/notes/css-escapes#css

  var cssesc = function cssesc(string, options) {
    options = merge$1(options, cssesc.options);

    if (options.quotes != 'single' && options.quotes != 'double') {
      options.quotes = 'single';
    }

    var quote = options.quotes == 'double' ? '"' : '\'';
    var isIdentifier = options.isIdentifier;
    var firstChar = string.charAt(0);
    var output = '';
    var counter = 0;
    var length = string.length;

    while (counter < length) {
      var character = string.charAt(counter++);
      var codePoint = character.charCodeAt();
      var value = void 0; // If it’s not a printable ASCII character…

      if (codePoint < 0x20 || codePoint > 0x7E) {
        if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
          // It’s a high surrogate, and there is a next character.
          var extra = string.charCodeAt(counter++);

          if ((extra & 0xFC00) == 0xDC00) {
            // next character is low surrogate
            codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
          } else {
            // It’s an unmatched surrogate; only append this code unit, in case
            // the next code unit is the high surrogate of a surrogate pair.
            counter--;
          }
        }

        value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
      } else {
        if (options.escapeEverything) {
          if (regexAnySingleEscape.test(character)) {
            value = '\\' + character;
          } else {
            value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
          }
        } else if (/[\t\n\f\r\x0B]/.test(character)) {
          value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
        } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
          value = '\\' + character;
        } else {
          value = character;
        }
      }

      output += value;
    }

    if (isIdentifier) {
      if (/^-[-\d]/.test(output)) {
        output = '\\-' + output.slice(1);
      } else if (/\d/.test(firstChar)) {
        output = '\\3' + firstChar + ' ' + output.slice(1);
      }
    } // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
    // since they’re redundant. Note that this is only possible if the escape
    // sequence isn’t preceded by an odd number of backslashes.


    output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
      if ($1 && $1.length % 2) {
        // It’s not safe to remove the space, so don’t.
        return $0;
      } // Strip the space.


      return ($1 || '') + $2;
    });

    if (!isIdentifier && options.wrap) {
      return quote + output + quote;
    }

    return output;
  }; // Expose default options (so they can be overridden globally).


  cssesc.options = {
    'escapeEverything': false,
    'isIdentifier': false,
    'quotes': 'single',
    'wrap': false
  };
  cssesc.version = '3.0.0';
  var cssesc_1 = cssesc;

  var className = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _cssesc = _interopRequireDefault(cssesc_1);



  var _node = _interopRequireDefault(node$2);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var ClassName = /*#__PURE__*/function (_Node) {
    _inheritsLoose(ClassName, _Node);

    function ClassName(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = types$2.CLASS;
      _this._constructed = true;
      return _this;
    }

    var _proto = ClassName.prototype;

    _proto.valueToString = function valueToString() {
      return '.' + _Node.prototype.valueToString.call(this);
    };

    _createClass(ClassName, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(v) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(v, {
            isIdentifier: true
          });

          if (escaped !== v) {
            (0, util.ensureObject)(this, "raws");
            this.raws.value = escaped;
          } else if (this.raws) {
            delete this.raws.value;
          }
        }

        this._value = v;
      }
    }]);

    return ClassName;
  }(_node["default"]);

  exports["default"] = ClassName;
  module.exports = exports.default;
  });

  var comment = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node$2);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Comment = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Comment, _Node);

    function Comment(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = types$2.COMMENT;
      return _this;
    }

    return Comment;
  }(_node["default"]);

  exports["default"] = Comment;
  module.exports = exports.default;
  });

  var id = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node$2);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var ID = /*#__PURE__*/function (_Node) {
    _inheritsLoose(ID, _Node);

    function ID(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = types$2.ID;
      return _this;
    }

    var _proto = ID.prototype;

    _proto.valueToString = function valueToString() {
      return '#' + _Node.prototype.valueToString.call(this);
    };

    return ID;
  }(_node["default"]);

  exports["default"] = ID;
  module.exports = exports.default;
  });

  var namespace = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _cssesc = _interopRequireDefault(cssesc_1);



  var _node = _interopRequireDefault(node$2);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Namespace = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Namespace, _Node);

    function Namespace() {
      return _Node.apply(this, arguments) || this;
    }

    var _proto = Namespace.prototype;

    _proto.qualifiedName = function qualifiedName(value) {
      if (this.namespace) {
        return this.namespaceString + "|" + value;
      } else {
        return value;
      }
    };

    _proto.valueToString = function valueToString() {
      return this.qualifiedName(_Node.prototype.valueToString.call(this));
    };

    _createClass(Namespace, [{
      key: "namespace",
      get: function get() {
        return this._namespace;
      },
      set: function set(namespace) {
        if (namespace === true || namespace === "*" || namespace === "&") {
          this._namespace = namespace;

          if (this.raws) {
            delete this.raws.namespace;
          }

          return;
        }

        var escaped = (0, _cssesc["default"])(namespace, {
          isIdentifier: true
        });
        this._namespace = namespace;

        if (escaped !== namespace) {
          (0, util.ensureObject)(this, "raws");
          this.raws.namespace = escaped;
        } else if (this.raws) {
          delete this.raws.namespace;
        }
      }
    }, {
      key: "ns",
      get: function get() {
        return this._namespace;
      },
      set: function set(namespace) {
        this.namespace = namespace;
      }
    }, {
      key: "namespaceString",
      get: function get() {
        if (this.namespace) {
          var ns = this.stringifyProperty("namespace");

          if (ns === true) {
            return '';
          } else {
            return ns;
          }
        } else {
          return '';
        }
      }
    }]);

    return Namespace;
  }(_node["default"]);

  exports["default"] = Namespace;
  module.exports = exports.default;
  });

  var tag = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _namespace = _interopRequireDefault(namespace);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Tag = /*#__PURE__*/function (_Namespace) {
    _inheritsLoose(Tag, _Namespace);

    function Tag(opts) {
      var _this;

      _this = _Namespace.call(this, opts) || this;
      _this.type = types$2.TAG;
      return _this;
    }

    return Tag;
  }(_namespace["default"]);

  exports["default"] = Tag;
  module.exports = exports.default;
  });

  var string$2 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node$2);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var String = /*#__PURE__*/function (_Node) {
    _inheritsLoose(String, _Node);

    function String(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = types$2.STRING;
      return _this;
    }

    return String;
  }(_node["default"]);

  exports["default"] = String;
  module.exports = exports.default;
  });

  var pseudo = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _container = _interopRequireDefault(container);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Pseudo = /*#__PURE__*/function (_Container) {
    _inheritsLoose(Pseudo, _Container);

    function Pseudo(opts) {
      var _this;

      _this = _Container.call(this, opts) || this;
      _this.type = types$2.PSEUDO;
      return _this;
    }

    var _proto = Pseudo.prototype;

    _proto.toString = function toString() {
      var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
      return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
    };

    return Pseudo;
  }(_container["default"]);

  exports["default"] = Pseudo;
  module.exports = exports.default;
  });

  /**
   * For Node.js, simply re-export the core `util.deprecate` function.
   */

  var node$1 = util__default['default'].deprecate;

  var attribute = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;
  exports.unescapeValue = unescapeValue;

  var _cssesc = _interopRequireDefault(cssesc_1);

  var _unesc = _interopRequireDefault(unesc_1);

  var _namespace = _interopRequireDefault(namespace);



  var _CSSESC_QUOTE_OPTIONS;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }



  var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
  var warnOfDeprecatedValueAssignment = node$1(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
  var warnOfDeprecatedQuotedAssignment = node$1(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
  var warnOfDeprecatedConstructor = node$1(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

  function unescapeValue(value) {
    var deprecatedUsage = false;
    var quoteMark = null;
    var unescaped = value;
    var m = unescaped.match(WRAPPED_IN_QUOTES);

    if (m) {
      quoteMark = m[1];
      unescaped = m[2];
    }

    unescaped = (0, _unesc["default"])(unescaped);

    if (unescaped !== value) {
      deprecatedUsage = true;
    }

    return {
      deprecatedUsage: deprecatedUsage,
      unescaped: unescaped,
      quoteMark: quoteMark
    };
  }

  function handleDeprecatedContructorOpts(opts) {
    if (opts.quoteMark !== undefined) {
      return opts;
    }

    if (opts.value === undefined) {
      return opts;
    }

    warnOfDeprecatedConstructor();

    var _unescapeValue = unescapeValue(opts.value),
        quoteMark = _unescapeValue.quoteMark,
        unescaped = _unescapeValue.unescaped;

    if (!opts.raws) {
      opts.raws = {};
    }

    if (opts.raws.value === undefined) {
      opts.raws.value = opts.value;
    }

    opts.value = unescaped;
    opts.quoteMark = quoteMark;
    return opts;
  }

  var Attribute = /*#__PURE__*/function (_Namespace) {
    _inheritsLoose(Attribute, _Namespace);

    function Attribute(opts) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
      _this.type = types$2.ATTRIBUTE;
      _this.raws = _this.raws || {};
      Object.defineProperty(_this.raws, 'unquoted', {
        get: node$1(function () {
          return _this.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: node$1(function () {
          return _this.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      });
      _this._constructed = true;
      return _this;
    }
    /**
     * Returns the Attribute's value quoted such that it would be legal to use
     * in the value of a css file. The original value's quotation setting
     * used for stringification is left unchanged. See `setValue(value, options)`
     * if you want to control the quote settings of a new value for the attribute.
     *
     * You can also change the quotation used for the current value by setting quoteMark.
     *
     * Options:
     *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
     *     option is not set, the original value for quoteMark will be used. If
     *     indeterminate, a double quote is used. The legal values are:
     *     * `null` - the value will be unquoted and characters will be escaped as necessary.
     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
     *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
     *     over the quoteMark option value.
     *   * smart {boolean} - if true, will select a quote mark based on the value
     *     and the other options specified here. See the `smartQuoteMark()`
     *     method.
     **/


    var _proto = Attribute.prototype;

    _proto.getQuotedValue = function getQuotedValue(options) {
      if (options === void 0) {
        options = {};
      }

      var quoteMark = this._determineQuoteMark(options);

      var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
      var escaped = (0, _cssesc["default"])(this._value, cssescopts);
      return escaped;
    };

    _proto._determineQuoteMark = function _determineQuoteMark(options) {
      return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
    }
    /**
     * Set the unescaped value with the specified quotation options. The value
     * provided must not include any wrapping quote marks -- those quotes will
     * be interpreted as part of the value and escaped accordingly.
     */
    ;

    _proto.setValue = function setValue(value, options) {
      if (options === void 0) {
        options = {};
      }

      this._value = value;
      this._quoteMark = this._determineQuoteMark(options);

      this._syncRawValue();
    }
    /**
     * Intelligently select a quoteMark value based on the value's contents. If
     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
     * mark will be picked that minimizes the number of escapes.
     *
     * If there's no clear winner, the quote mark from these options is used,
     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
     * true). If the quoteMark is unspecified, a double quote is used.
     *
     * @param options This takes the quoteMark and preferCurrentQuoteMark options
     * from the quoteValue method.
     */
    ;

    _proto.smartQuoteMark = function smartQuoteMark(options) {
      var v = this.value;
      var numSingleQuotes = v.replace(/[^']/g, '').length;
      var numDoubleQuotes = v.replace(/[^"]/g, '').length;

      if (numSingleQuotes + numDoubleQuotes === 0) {
        var escaped = (0, _cssesc["default"])(v, {
          isIdentifier: true
        });

        if (escaped === v) {
          return Attribute.NO_QUOTE;
        } else {
          var pref = this.preferredQuoteMark(options);

          if (pref === Attribute.NO_QUOTE) {
            // pick a quote mark that isn't none and see if it's smaller
            var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
            var opts = CSSESC_QUOTE_OPTIONS[quote];
            var quoteValue = (0, _cssesc["default"])(v, opts);

            if (quoteValue.length < escaped.length) {
              return quote;
            }
          }

          return pref;
        }
      } else if (numDoubleQuotes === numSingleQuotes) {
        return this.preferredQuoteMark(options);
      } else if (numDoubleQuotes < numSingleQuotes) {
        return Attribute.DOUBLE_QUOTE;
      } else {
        return Attribute.SINGLE_QUOTE;
      }
    }
    /**
     * Selects the preferred quote mark based on the options and the current quote mark value.
     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
     * instead.
     */
    ;

    _proto.preferredQuoteMark = function preferredQuoteMark(options) {
      var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

      if (quoteMark === undefined) {
        quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
      }

      if (quoteMark === undefined) {
        quoteMark = Attribute.DOUBLE_QUOTE;
      }

      return quoteMark;
    };

    _proto._syncRawValue = function _syncRawValue() {
      var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

      if (rawValue === this._value) {
        if (this.raws) {
          delete this.raws.value;
        }
      } else {
        this.raws.value = rawValue;
      }
    };

    _proto._handleEscapes = function _handleEscapes(prop, value) {
      if (this._constructed) {
        var escaped = (0, _cssesc["default"])(value, {
          isIdentifier: true
        });

        if (escaped !== value) {
          this.raws[prop] = escaped;
        } else {
          delete this.raws[prop];
        }
      }
    };

    _proto._spacesFor = function _spacesFor(name) {
      var attrSpaces = {
        before: '',
        after: ''
      };
      var spaces = this.spaces[name] || {};
      var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
      return Object.assign(attrSpaces, spaces, rawSpaces);
    };

    _proto._stringFor = function _stringFor(name, spaceName, concat) {
      if (spaceName === void 0) {
        spaceName = name;
      }

      if (concat === void 0) {
        concat = defaultAttrConcat;
      }

      var attrSpaces = this._spacesFor(spaceName);

      return concat(this.stringifyProperty(name), attrSpaces);
    }
    /**
     * returns the offset of the attribute part specified relative to the
     * start of the node of the output string.
     *
     * * "ns" - alias for "namespace"
     * * "namespace" - the namespace if it exists.
     * * "attribute" - the attribute name
     * * "attributeNS" - the start of the attribute or its namespace
     * * "operator" - the match operator of the attribute
     * * "value" - The value (string or identifier)
     * * "insensitive" - the case insensitivity flag;
     * @param part One of the possible values inside an attribute.
     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
     */
    ;

    _proto.offsetOf = function offsetOf(name) {
      var count = 1;

      var attributeSpaces = this._spacesFor("attribute");

      count += attributeSpaces.before.length;

      if (name === "namespace" || name === "ns") {
        return this.namespace ? count : -1;
      }

      if (name === "attributeNS") {
        return count;
      }

      count += this.namespaceString.length;

      if (this.namespace) {
        count += 1;
      }

      if (name === "attribute") {
        return count;
      }

      count += this.stringifyProperty("attribute").length;
      count += attributeSpaces.after.length;

      var operatorSpaces = this._spacesFor("operator");

      count += operatorSpaces.before.length;
      var operator = this.stringifyProperty("operator");

      if (name === "operator") {
        return operator ? count : -1;
      }

      count += operator.length;
      count += operatorSpaces.after.length;

      var valueSpaces = this._spacesFor("value");

      count += valueSpaces.before.length;
      var value = this.stringifyProperty("value");

      if (name === "value") {
        return value ? count : -1;
      }

      count += value.length;
      count += valueSpaces.after.length;

      var insensitiveSpaces = this._spacesFor("insensitive");

      count += insensitiveSpaces.before.length;

      if (name === "insensitive") {
        return this.insensitive ? count : -1;
      }

      return -1;
    };

    _proto.toString = function toString() {
      var _this2 = this;

      var selector = [this.rawSpaceBefore, '['];
      selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

      if (this.operator && (this.value || this.value === '')) {
        selector.push(this._stringFor('operator'));
        selector.push(this._stringFor('value'));
        selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
          if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
            attrSpaces.before = " ";
          }

          return defaultAttrConcat(attrValue, attrSpaces);
        }));
      }

      selector.push(']');
      selector.push(this.rawSpaceAfter);
      return selector.join('');
    };

    _createClass(Attribute, [{
      key: "quoted",
      get: function get() {
        var qm = this.quoteMark;
        return qm === "'" || qm === '"';
      },
      set: function set(value) {
        warnOfDeprecatedQuotedAssignment();
      }
      /**
       * returns a single (`'`) or double (`"`) quote character if the value is quoted.
       * returns `null` if the value is not quoted.
       * returns `undefined` if the quotation state is unknown (this can happen when
       * the attribute is constructed without specifying a quote mark.)
       */

    }, {
      key: "quoteMark",
      get: function get() {
        return this._quoteMark;
      }
      /**
       * Set the quote mark to be used by this attribute's value.
       * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
       * value is updated accordingly.
       *
       * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
       */
      ,
      set: function set(quoteMark) {
        if (!this._constructed) {
          this._quoteMark = quoteMark;
          return;
        }

        if (this._quoteMark !== quoteMark) {
          this._quoteMark = quoteMark;

          this._syncRawValue();
        }
      }
    }, {
      key: "qualifiedAttribute",
      get: function get() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function get() {
        return this.insensitive ? 'i' : '';
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set:
      /**
       * Before 3.0, the value had to be set to an escaped value including any wrapped
       * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
       * is unescaped during parsing and any quote marks are removed.
       *
       * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
       * a deprecation warning is raised when the new value contains any characters that would
       * require escaping (including if it contains wrapped quotes).
       *
       * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
       * how the new value is quoted.
       */
      function set(v) {
        if (this._constructed) {
          var _unescapeValue2 = unescapeValue(v),
              deprecatedUsage = _unescapeValue2.deprecatedUsage,
              unescaped = _unescapeValue2.unescaped,
              quoteMark = _unescapeValue2.quoteMark;

          if (deprecatedUsage) {
            warnOfDeprecatedValueAssignment();
          }

          if (unescaped === this._value && quoteMark === this._quoteMark) {
            return;
          }

          this._value = unescaped;
          this._quoteMark = quoteMark;

          this._syncRawValue();
        } else {
          this._value = v;
        }
      }
    }, {
      key: "insensitive",
      get: function get() {
        return this._insensitive;
      }
      /**
       * Set the case insensitive flag.
       * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`
       * of the attribute is updated accordingly.
       *
       * @param {true | false} insensitive true if the attribute should match case-insensitively.
       */
      ,
      set: function set(insensitive) {
        if (!insensitive) {
          this._insensitive = false; // "i" and "I" can be used in "this.raws.insensitiveFlag" to store the original notation.
          // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.

          if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {
            this.raws.insensitiveFlag = undefined;
          }
        }

        this._insensitive = insensitive;
      }
    }, {
      key: "attribute",
      get: function get() {
        return this._attribute;
      },
      set: function set(name) {
        this._handleEscapes("attribute", name);

        this._attribute = name;
      }
    }]);

    return Attribute;
  }(_namespace["default"]);

  exports["default"] = Attribute;
  Attribute.NO_QUOTE = null;
  Attribute.SINGLE_QUOTE = "'";
  Attribute.DOUBLE_QUOTE = '"';
  var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
    "'": {
      quotes: 'single',
      wrap: true
    },
    '"': {
      quotes: 'double',
      wrap: true
    }
  }, _CSSESC_QUOTE_OPTIONS[null] = {
    isIdentifier: true
  }, _CSSESC_QUOTE_OPTIONS);

  function defaultAttrConcat(attrValue, attrSpaces) {
    return "" + attrSpaces.before + attrValue + attrSpaces.after;
  }
  });

  var universal = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _namespace = _interopRequireDefault(namespace);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Universal = /*#__PURE__*/function (_Namespace) {
    _inheritsLoose(Universal, _Namespace);

    function Universal(opts) {
      var _this;

      _this = _Namespace.call(this, opts) || this;
      _this.type = types$2.UNIVERSAL;
      _this.value = '*';
      return _this;
    }

    return Universal;
  }(_namespace["default"]);

  exports["default"] = Universal;
  module.exports = exports.default;
  });

  var combinator = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node$2);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Combinator = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Combinator, _Node);

    function Combinator(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = types$2.COMBINATOR;
      return _this;
    }

    return Combinator;
  }(_node["default"]);

  exports["default"] = Combinator;
  module.exports = exports.default;
  });

  var nesting = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node$2);



  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  var Nesting = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Nesting, _Node);

    function Nesting(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = types$2.NESTING;
      _this.value = '&';
      return _this;
    }

    return Nesting;
  }(_node["default"]);

  exports["default"] = Nesting;
  module.exports = exports.default;
  });

  var sortAscending_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = sortAscending;

  function sortAscending(list) {
    return list.sort(function (a, b) {
      return a - b;
    });
  }
  module.exports = exports.default;
  });

  var tokenTypes = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.word = exports.tilde = exports.tab = exports.str = exports.space = exports.slash = exports.singleQuote = exports.semicolon = exports.plus = exports.pipe = exports.openSquare = exports.openParenthesis = exports.newline = exports.greaterThan = exports.feed = exports.equals = exports.doubleQuote = exports.dollar = exports.cr = exports.comment = exports.comma = exports.combinator = exports.colon = exports.closeSquare = exports.closeParenthesis = exports.caret = exports.bang = exports.backslash = exports.at = exports.asterisk = exports.ampersand = void 0;
  var ampersand = 38; // `&`.charCodeAt(0);

  exports.ampersand = ampersand;
  var asterisk = 42; // `*`.charCodeAt(0);

  exports.asterisk = asterisk;
  var at = 64; // `@`.charCodeAt(0);

  exports.at = at;
  var comma = 44; // `,`.charCodeAt(0);

  exports.comma = comma;
  var colon = 58; // `:`.charCodeAt(0);

  exports.colon = colon;
  var semicolon = 59; // `;`.charCodeAt(0);

  exports.semicolon = semicolon;
  var openParenthesis = 40; // `(`.charCodeAt(0);

  exports.openParenthesis = openParenthesis;
  var closeParenthesis = 41; // `)`.charCodeAt(0);

  exports.closeParenthesis = closeParenthesis;
  var openSquare = 91; // `[`.charCodeAt(0);

  exports.openSquare = openSquare;
  var closeSquare = 93; // `]`.charCodeAt(0);

  exports.closeSquare = closeSquare;
  var dollar = 36; // `$`.charCodeAt(0);

  exports.dollar = dollar;
  var tilde = 126; // `~`.charCodeAt(0);

  exports.tilde = tilde;
  var caret = 94; // `^`.charCodeAt(0);

  exports.caret = caret;
  var plus = 43; // `+`.charCodeAt(0);

  exports.plus = plus;
  var equals = 61; // `=`.charCodeAt(0);

  exports.equals = equals;
  var pipe = 124; // `|`.charCodeAt(0);

  exports.pipe = pipe;
  var greaterThan = 62; // `>`.charCodeAt(0);

  exports.greaterThan = greaterThan;
  var space = 32; // ` `.charCodeAt(0);

  exports.space = space;
  var singleQuote = 39; // `'`.charCodeAt(0);

  exports.singleQuote = singleQuote;
  var doubleQuote = 34; // `"`.charCodeAt(0);

  exports.doubleQuote = doubleQuote;
  var slash = 47; // `/`.charCodeAt(0);

  exports.slash = slash;
  var bang = 33; // `!`.charCodeAt(0);

  exports.bang = bang;
  var backslash = 92; // '\\'.charCodeAt(0);

  exports.backslash = backslash;
  var cr = 13; // '\r'.charCodeAt(0);

  exports.cr = cr;
  var feed = 12; // '\f'.charCodeAt(0);

  exports.feed = feed;
  var newline = 10; // '\n'.charCodeAt(0);

  exports.newline = newline;
  var tab = 9; // '\t'.charCodeAt(0);
  // Expose aliases primarily for readability.

  exports.tab = tab;
  var str = singleQuote; // No good single character representation!

  exports.str = str;
  var comment = -1;
  exports.comment = comment;
  var word = -2;
  exports.word = word;
  var combinator = -3;
  exports.combinator = combinator;
  });

  var tokenize_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.FIELDS = void 0;
  exports["default"] = tokenize;

  var t = _interopRequireWildcard(tokenTypes);

  var _unescapable, _wordDelimiters;

  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache(nodeInterop);

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
  var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
  var hex = {};
  var hexChars = "0123456789abcdefABCDEF";

  for (var i = 0; i < hexChars.length; i++) {
    hex[hexChars.charCodeAt(i)] = true;
  }
  /**
   *  Returns the last index of the bar css word
   * @param {string} css The string in which the word begins
   * @param {number} start The index into the string where word's first letter occurs
   */


  function consumeWord(css, start) {
    var next = start;
    var code;

    do {
      code = css.charCodeAt(next);

      if (wordDelimiters[code]) {
        return next - 1;
      } else if (code === t.backslash) {
        next = consumeEscape(css, next) + 1;
      } else {
        // All other characters are part of the word
        next++;
      }
    } while (next < css.length);

    return next - 1;
  }
  /**
   *  Returns the last index of the escape sequence
   * @param {string} css The string in which the sequence begins
   * @param {number} start The index into the string where escape character (`\`) occurs.
   */


  function consumeEscape(css, start) {
    var next = start;
    var code = css.charCodeAt(next + 1);

    if (unescapable[code]) ; else if (hex[code]) {
      var hexDigits = 0; // consume up to 6 hex chars

      do {
        next++;
        hexDigits++;
        code = css.charCodeAt(next + 1);
      } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


      if (hexDigits < 6 && code === t.space) {
        next++;
      }
    } else {
      // the next char is part of the current word
      next++;
    }

    return next;
  }

  var FIELDS = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
  };
  exports.FIELDS = FIELDS;

  function tokenize(input) {
    var tokens = [];
    var css = input.css.valueOf();
    var _css = css,
        length = _css.length;
    var offset = -1;
    var line = 1;
    var start = 0;
    var end = 0;
    var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

    function unclosed(what, fix) {
      if (input.safe) {
        // fyi: this is never set to true.
        css += fix;
        next = css.length - 1;
      } else {
        throw input.error('Unclosed ' + what, line, start - offset, start);
      }
    }

    while (start < length) {
      code = css.charCodeAt(start);

      if (code === t.newline) {
        offset = start;
        line += 1;
      }

      switch (code) {
        case t.space:
        case t.tab:
        case t.newline:
        case t.cr:
        case t.feed:
          next = start;

          do {
            next += 1;
            code = css.charCodeAt(next);

            if (code === t.newline) {
              offset = next;
              line += 1;
            }
          } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

          tokenType = t.space;
          endLine = line;
          endColumn = next - offset - 1;
          end = next;
          break;

        case t.plus:
        case t.greaterThan:
        case t.tilde:
        case t.pipe:
          next = start;

          do {
            next += 1;
            code = css.charCodeAt(next);
          } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

          tokenType = t.combinator;
          endLine = line;
          endColumn = start - offset;
          end = next;
          break;
        // Consume these characters as single tokens.

        case t.asterisk:
        case t.ampersand:
        case t.bang:
        case t.comma:
        case t.equals:
        case t.dollar:
        case t.caret:
        case t.openSquare:
        case t.closeSquare:
        case t.colon:
        case t.semicolon:
        case t.openParenthesis:
        case t.closeParenthesis:
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
          break;

        case t.singleQuote:
        case t.doubleQuote:
          quote = code === t.singleQuote ? "'" : '"';
          next = start;

          do {
            escaped = false;
            next = css.indexOf(quote, next + 1);

            if (next === -1) {
              unclosed('quote', quote);
            }

            escapePos = next;

            while (css.charCodeAt(escapePos - 1) === t.backslash) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);

          tokenType = t.str;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
          break;

        default:
          if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
            next = css.indexOf('*/', start + 2) + 1;

            if (next === 0) {
              unclosed('comment', '*/');
            }

            content = css.slice(start, next + 1);
            lines = content.split('\n');
            last = lines.length - 1;

            if (last > 0) {
              nextLine = line + last;
              nextOffset = next - lines[last].length;
            } else {
              nextLine = line;
              nextOffset = offset;
            }

            tokenType = t.comment;
            line = nextLine;
            endLine = nextLine;
            endColumn = next - nextOffset;
          } else if (code === t.slash) {
            next = start;
            tokenType = code;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
          } else {
            next = consumeWord(css, start);
            tokenType = t.word;
            endLine = line;
            endColumn = next - offset;
          }

          end = next + 1;
          break;
      } // Ensure that the token structure remains consistent


      tokens.push([tokenType, // [0] Token type
      line, // [1] Starting line
      start - offset, // [2] Starting column
      endLine, // [3] Ending line
      endColumn, // [4] Ending column
      start, // [5] Start position / Source index
      end // [6] End position
      ]); // Reset offset for the next token

      if (nextOffset) {
        offset = nextOffset;
        nextOffset = null;
      }

      start = end;
    }

    return tokens;
  }
  });

  var parser = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _root = _interopRequireDefault(root);

  var _selector = _interopRequireDefault(selector);

  var _className = _interopRequireDefault(className);

  var _comment = _interopRequireDefault(comment);

  var _id = _interopRequireDefault(id);

  var _tag = _interopRequireDefault(tag);

  var _string = _interopRequireDefault(string$2);

  var _pseudo = _interopRequireDefault(pseudo);

  var _attribute = _interopRequireWildcard(attribute);

  var _universal = _interopRequireDefault(universal);

  var _combinator = _interopRequireDefault(combinator);

  var _nesting = _interopRequireDefault(nesting);

  var _sortAscending = _interopRequireDefault(sortAscending_1);

  var _tokenize = _interopRequireWildcard(tokenize_1);

  var tokens = _interopRequireWildcard(tokenTypes);

  var types = _interopRequireWildcard(types$2);



  var _WHITESPACE_TOKENS, _Object$assign;

  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache(nodeInterop);

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
  var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

  function tokenStart(token) {
    return {
      line: token[_tokenize.FIELDS.START_LINE],
      column: token[_tokenize.FIELDS.START_COL]
    };
  }

  function tokenEnd(token) {
    return {
      line: token[_tokenize.FIELDS.END_LINE],
      column: token[_tokenize.FIELDS.END_COL]
    };
  }

  function getSource(startLine, startColumn, endLine, endColumn) {
    return {
      start: {
        line: startLine,
        column: startColumn
      },
      end: {
        line: endLine,
        column: endColumn
      }
    };
  }

  function getTokenSource(token) {
    return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
  }

  function getTokenSourceSpan(startToken, endToken) {
    if (!startToken) {
      return undefined;
    }

    return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
  }

  function unescapeProp(node, prop) {
    var value = node[prop];

    if (typeof value !== "string") {
      return;
    }

    if (value.indexOf("\\") !== -1) {
      (0, util.ensureObject)(node, 'raws');
      node[prop] = (0, util.unesc)(value);

      if (node.raws[prop] === undefined) {
        node.raws[prop] = value;
      }
    }

    return node;
  }

  function indexesOf(array, item) {
    var i = -1;
    var indexes = [];

    while ((i = array.indexOf(item, i + 1)) !== -1) {
      indexes.push(i);
    }

    return indexes;
  }

  function uniqs() {
    var list = Array.prototype.concat.apply([], arguments);
    return list.filter(function (item, i) {
      return i === list.indexOf(item);
    });
  }

  var Parser = /*#__PURE__*/function () {
    function Parser(rule, options) {
      if (options === void 0) {
        options = {};
      }

      this.rule = rule;
      this.options = Object.assign({
        lossy: false,
        safe: false
      }, options);
      this.position = 0;
      this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
      this.tokens = (0, _tokenize["default"])({
        css: this.css,
        error: this._errorGenerator(),
        safe: this.options.safe
      });
      var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new _root["default"]({
        source: rootSource
      });
      this.root.errorGenerator = this._errorGenerator();
      var selector = new _selector["default"]({
        source: {
          start: {
            line: 1,
            column: 1
          }
        }
      });
      this.root.append(selector);
      this.current = selector;
      this.loop();
    }

    var _proto = Parser.prototype;

    _proto._errorGenerator = function _errorGenerator() {
      var _this = this;

      return function (message, errorOptions) {
        if (typeof _this.rule === 'string') {
          return new Error(message);
        }

        return _this.rule.error(message, errorOptions);
      };
    };

    _proto.attribute = function attribute() {
      var attr = [];
      var startingToken = this.currToken;
      this.position++;

      while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
        attr.push(this.currToken);
        this.position++;
      }

      if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
        return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
      }

      var len = attr.length;
      var node = {
        source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
        sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
      };

      if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
        return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
      }

      var pos = 0;
      var spaceBefore = '';
      var commentBefore = '';
      var lastAdded = null;
      var spaceAfterMeaningfulToken = false;

      while (pos < len) {
        var token = attr[pos];
        var content = this.content(token);
        var next = attr[pos + 1];

        switch (token[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            // if (
            //     len === 1 ||
            //     pos === 0 && this.content(next) === '|'
            // ) {
            //     return this.expected('attribute', token[TOKEN.START_POS], content);
            // }
            spaceAfterMeaningfulToken = true;

            if (this.options.lossy) {
              break;
            }

            if (lastAdded) {
              (0, util.ensureObject)(node, 'spaces', lastAdded);
              var prevContent = node.spaces[lastAdded].after || '';
              node.spaces[lastAdded].after = prevContent + content;
              var existingComment = (0, util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

              if (existingComment) {
                node.raws.spaces[lastAdded].after = existingComment + content;
              }
            } else {
              spaceBefore = spaceBefore + content;
              commentBefore = commentBefore + content;
            }

            break;

          case tokens.asterisk:
            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node.operator = content;
              lastAdded = 'operator';
            } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
              if (spaceBefore) {
                (0, util.ensureObject)(node, 'spaces', 'attribute');
                node.spaces.attribute.before = spaceBefore;
                spaceBefore = '';
              }

              if (commentBefore) {
                (0, util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                node.raws.spaces.attribute.before = spaceBefore;
                commentBefore = '';
              }

              node.namespace = (node.namespace || "") + content;
              var rawValue = (0, util.getProp)(node, 'raws', 'namespace') || null;

              if (rawValue) {
                node.raws.namespace += content;
              }

              lastAdded = 'namespace';
            }

            spaceAfterMeaningfulToken = false;
            break;

          case tokens.dollar:
            if (lastAdded === "value") {
              var oldRawValue = (0, util.getProp)(node, 'raws', 'value');
              node.value += "$";

              if (oldRawValue) {
                node.raws.value = oldRawValue + "$";
              }

              break;
            }

          // Falls through

          case tokens.caret:
            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node.operator = content;
              lastAdded = 'operator';
            }

            spaceAfterMeaningfulToken = false;
            break;

          case tokens.combinator:
            if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node.operator = content;
              lastAdded = 'operator';
            }

            if (content !== '|') {
              spaceAfterMeaningfulToken = false;
              break;
            }

            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node.operator = content;
              lastAdded = 'operator';
            } else if (!node.namespace && !node.attribute) {
              node.namespace = true;
            }

            spaceAfterMeaningfulToken = false;
            break;

          case tokens.word:
            if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
            !node.operator && !node.namespace) {
              node.namespace = content;
              lastAdded = 'namespace';
            } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
              if (spaceBefore) {
                (0, util.ensureObject)(node, 'spaces', 'attribute');
                node.spaces.attribute.before = spaceBefore;
                spaceBefore = '';
              }

              if (commentBefore) {
                (0, util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                node.raws.spaces.attribute.before = commentBefore;
                commentBefore = '';
              }

              node.attribute = (node.attribute || "") + content;

              var _rawValue = (0, util.getProp)(node, 'raws', 'attribute') || null;

              if (_rawValue) {
                node.raws.attribute += content;
              }

              lastAdded = 'attribute';
            } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
              var _unescaped = (0, util.unesc)(content);

              var _oldRawValue = (0, util.getProp)(node, 'raws', 'value') || '';

              var oldValue = node.value || '';
              node.value = oldValue + _unescaped;
              node.quoteMark = null;

              if (_unescaped !== content || _oldRawValue) {
                (0, util.ensureObject)(node, 'raws');
                node.raws.value = (_oldRawValue || oldValue) + content;
              }

              lastAdded = 'value';
            } else {
              var insensitive = content === 'i' || content === "I";

              if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
                node.insensitive = insensitive;

                if (!insensitive || content === "I") {
                  (0, util.ensureObject)(node, 'raws');
                  node.raws.insensitiveFlag = content;
                }

                lastAdded = 'insensitive';

                if (spaceBefore) {
                  (0, util.ensureObject)(node, 'spaces', 'insensitive');
                  node.spaces.insensitive.before = spaceBefore;
                  spaceBefore = '';
                }

                if (commentBefore) {
                  (0, util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                  node.raws.spaces.insensitive.before = commentBefore;
                  commentBefore = '';
                }
              } else if (node.value || node.value === '') {
                lastAdded = 'value';
                node.value += content;

                if (node.raws.value) {
                  node.raws.value += content;
                }
              }
            }

            spaceAfterMeaningfulToken = false;
            break;

          case tokens.str:
            if (!node.attribute || !node.operator) {
              return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: token[_tokenize.FIELDS.START_POS]
              });
            }

            var _unescapeValue = (0, _attribute.unescapeValue)(content),
                unescaped = _unescapeValue.unescaped,
                quoteMark = _unescapeValue.quoteMark;

            node.value = unescaped;
            node.quoteMark = quoteMark;
            lastAdded = 'value';
            (0, util.ensureObject)(node, 'raws');
            node.raws.value = content;
            spaceAfterMeaningfulToken = false;
            break;

          case tokens.equals:
            if (!node.attribute) {
              return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
            }

            if (node.value) {
              return this.error('Unexpected "=" found; an operator was already defined.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
            }

            node.operator = node.operator ? node.operator + content : content;
            lastAdded = 'operator';
            spaceAfterMeaningfulToken = false;
            break;

          case tokens.comment:
            if (lastAdded) {
              if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
                var lastComment = (0, util.getProp)(node, 'spaces', lastAdded, 'after') || '';
                var rawLastComment = (0, util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
                (0, util.ensureObject)(node, 'raws', 'spaces', lastAdded);
                node.raws.spaces[lastAdded].after = rawLastComment + content;
              } else {
                var lastValue = node[lastAdded] || '';
                var rawLastValue = (0, util.getProp)(node, 'raws', lastAdded) || lastValue;
                (0, util.ensureObject)(node, 'raws');
                node.raws[lastAdded] = rawLastValue + content;
              }
            } else {
              commentBefore = commentBefore + content;
            }

            break;

          default:
            return this.error("Unexpected \"" + content + "\" found.", {
              index: token[_tokenize.FIELDS.START_POS]
            });
        }

        pos++;
      }

      unescapeProp(node, "attribute");
      unescapeProp(node, "namespace");
      this.newNode(new _attribute["default"](node));
      this.position++;
    }
    /**
     * return a node containing meaningless garbage up to (but not including) the specified token position.
     * if the token position is negative, all remaining tokens are consumed.
     *
     * This returns an array containing a single string node if all whitespace,
     * otherwise an array of comment nodes with space before and after.
     *
     * These tokens are not added to the current selector, the caller can add them or use them to amend
     * a previous node's space metadata.
     *
     * In lossy mode, this returns only comments.
     */
    ;

    _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
      if (stopPosition < 0) {
        stopPosition = this.tokens.length;
      }

      var startPosition = this.position;
      var nodes = [];
      var space = "";
      var lastComment = undefined;

      do {
        if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
          if (!this.options.lossy) {
            space += this.content();
          }
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
          var spaces = {};

          if (space) {
            spaces.before = space;
            space = "";
          }

          lastComment = new _comment["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            spaces: spaces
          });
          nodes.push(lastComment);
        }
      } while (++this.position < stopPosition);

      if (space) {
        if (lastComment) {
          lastComment.spaces.after = space;
        } else if (!this.options.lossy) {
          var firstToken = this.tokens[startPosition];
          var lastToken = this.tokens[this.position - 1];
          nodes.push(new _string["default"]({
            value: '',
            source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces: {
              before: space,
              after: ''
            }
          }));
        }
      }

      return nodes;
    }
    /**
     *
     * @param {*} nodes
     */
    ;

    _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
      var _this2 = this;

      if (requiredSpace === void 0) {
        requiredSpace = false;
      }

      var space = "";
      var rawSpace = "";
      nodes.forEach(function (n) {
        var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

        var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

        space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
        rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
      });

      if (rawSpace === space) {
        rawSpace = undefined;
      }

      var result = {
        space: space,
        rawSpace: rawSpace
      };
      return result;
    };

    _proto.isNamedCombinator = function isNamedCombinator(position) {
      if (position === void 0) {
        position = this.position;
      }

      return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
    };

    _proto.namedCombinator = function namedCombinator() {
      if (this.isNamedCombinator()) {
        var nameRaw = this.content(this.tokens[this.position + 1]);
        var name = (0, util.unesc)(nameRaw).toLowerCase();
        var raws = {};

        if (name !== nameRaw) {
          raws.value = "/" + nameRaw + "/";
        }

        var node = new _combinator["default"]({
          value: "/" + name + "/",
          source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          raws: raws
        });
        this.position = this.position + 3;
        return node;
      } else {
        this.unexpected();
      }
    };

    _proto.combinator = function combinator() {
      var _this3 = this;

      if (this.content() === '|') {
        return this.namespace();
      } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


      var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

      if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
        var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

        if (nodes.length > 0) {
          var last = this.current.last;

          if (last) {
            var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
                space = _this$convertWhitespa.space,
                rawSpace = _this$convertWhitespa.rawSpace;

            if (rawSpace !== undefined) {
              last.rawSpaceAfter += rawSpace;
            }

            last.spaces.after += space;
          } else {
            nodes.forEach(function (n) {
              return _this3.newNode(n);
            });
          }
        }

        return;
      }

      var firstToken = this.currToken;
      var spaceOrDescendantSelectorNodes = undefined;

      if (nextSigTokenPos > this.position) {
        spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
      }

      var node;

      if (this.isNamedCombinator()) {
        node = this.namedCombinator();
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
        node = new _combinator["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
        });
        this.position++;
      } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) ; else if (!spaceOrDescendantSelectorNodes) {
        this.unexpected();
      }

      if (node) {
        if (spaceOrDescendantSelectorNodes) {
          var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
              _space = _this$convertWhitespa2.space,
              _rawSpace = _this$convertWhitespa2.rawSpace;

          node.spaces.before = _space;
          node.rawSpaceBefore = _rawSpace;
        }
      } else {
        // descendant combinator
        var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
            _space2 = _this$convertWhitespa3.space,
            _rawSpace2 = _this$convertWhitespa3.rawSpace;

        if (!_rawSpace2) {
          _rawSpace2 = _space2;
        }

        var spaces = {};
        var raws = {
          spaces: {}
        };

        if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
          spaces.before = _space2.slice(0, _space2.length - 1);
          raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
        } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
          spaces.after = _space2.slice(1);
          raws.spaces.after = _rawSpace2.slice(1);
        } else {
          raws.value = _rawSpace2;
        }

        node = new _combinator["default"]({
          value: ' ',
          source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces: spaces,
          raws: raws
        });
      }

      if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
        node.spaces.after = this.optionalSpace(this.content());
        this.position++;
      }

      return this.newNode(node);
    };

    _proto.comma = function comma() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true;
        this.position++;
        return;
      }

      this.current._inferEndPosition();

      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position + 1])
        }
      });
      this.current.parent.append(selector);
      this.current = selector;
      this.position++;
    };

    _proto.comment = function comment() {
      var current = this.currToken;
      this.newNode(new _comment["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };

    _proto.error = function error(message, opts) {
      throw this.root.error(message, opts);
    };

    _proto.missingBackslash = function missingBackslash() {
      return this.error('Expected a backslash preceding the semicolon.', {
        index: this.currToken[_tokenize.FIELDS.START_POS]
      });
    };

    _proto.missingParenthesis = function missingParenthesis() {
      return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    };

    _proto.missingSquareBracket = function missingSquareBracket() {
      return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    };

    _proto.unexpected = function unexpected() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
    };

    _proto.unexpectedPipe = function unexpectedPipe() {
      return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
    };

    _proto.namespace = function namespace() {
      var before = this.prevToken && this.content(this.prevToken) || true;

      if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
        this.position++;
        return this.word(before);
      } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
        this.position++;
        return this.universal(before);
      }

      this.unexpectedPipe();
    };

    _proto.nesting = function nesting() {
      if (this.nextToken) {
        var nextContent = this.content(this.nextToken);

        if (nextContent === "|") {
          this.position++;
          return;
        }
      }

      var current = this.currToken;
      this.newNode(new _nesting["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };

    _proto.parentheses = function parentheses() {
      var last = this.current.last;
      var unbalanced = 1;
      this.position++;

      if (last && last.type === types.PSEUDO) {
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position - 1])
          }
        });
        var cache = this.current;
        last.append(selector);
        this.current = selector;

        while (this.position < this.tokens.length && unbalanced) {
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            unbalanced++;
          }

          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            unbalanced--;
          }

          if (unbalanced) {
            this.parse();
          } else {
            this.current.source.end = tokenEnd(this.currToken);
            this.current.parent.source.end = tokenEnd(this.currToken);
            this.position++;
          }
        }

        this.current = cache;
      } else {
        // I think this case should be an error. It's used to implement a basic parse of media queries
        // but I don't think it's a good idea.
        var parenStart = this.currToken;
        var parenValue = "(";
        var parenEnd;

        while (this.position < this.tokens.length && unbalanced) {
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            unbalanced++;
          }

          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            unbalanced--;
          }

          parenEnd = this.currToken;
          parenValue += this.parseParenthesisToken(this.currToken);
          this.position++;
        }

        if (last) {
          last.appendToPropertyAndEscape("value", parenValue, parenValue);
        } else {
          this.newNode(new _string["default"]({
            value: parenValue,
            source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
            sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
          }));
        }
      }

      if (unbalanced) {
        return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
      }
    };

    _proto.pseudo = function pseudo() {
      var _this4 = this;

      var pseudoStr = '';
      var startingToken = this.currToken;

      while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
        pseudoStr += this.content();
        this.position++;
      }

      if (!this.currToken) {
        return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
      }

      if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
        this.splitWord(false, function (first, length) {
          pseudoStr += first;

          _this4.newNode(new _pseudo["default"]({
            value: pseudoStr,
            source: getTokenSourceSpan(startingToken, _this4.currToken),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          }));

          if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            _this4.error('Misplaced parenthesis.', {
              index: _this4.nextToken[_tokenize.FIELDS.START_POS]
            });
          }
        });
      } else {
        return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
      }
    };

    _proto.space = function space() {
      var content = this.content(); // Handle space before and after the selector

      if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
        return node.type === 'comment';
      })) {
        this.spaces = this.optionalSpace(content);
        this.position++;
      } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
        this.current.last.spaces.after = this.optionalSpace(content);
        this.position++;
      } else {
        this.combinator();
      }
    };

    _proto.string = function string() {
      var current = this.currToken;
      this.newNode(new _string["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };

    _proto.universal = function universal(namespace) {
      var nextToken = this.nextToken;

      if (nextToken && this.content(nextToken) === '|') {
        this.position++;
        return this.namespace();
      }

      var current = this.currToken;
      this.newNode(new _universal["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }), namespace);
      this.position++;
    };

    _proto.splitWord = function splitWord(namespace, firstCallback) {
      var _this5 = this;

      var nextToken = this.nextToken;
      var word = this.content();

      while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
        this.position++;
        var current = this.content();
        word += current;

        if (current.lastIndexOf('\\') === current.length - 1) {
          var next = this.nextToken;

          if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
            word += this.requiredSpace(this.content(next));
            this.position++;
          }
        }

        nextToken = this.nextToken;
      }

      var hasClass = indexesOf(word, '.').filter(function (i) {
        // Allow escaped dot within class name
        var escapedDot = word[i - 1] === '\\'; // Allow decimal numbers percent in @keyframes

        var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
        return !escapedDot && !isKeyframesPercent;
      });
      var hasId = indexesOf(word, '#').filter(function (i) {
        return word[i - 1] !== '\\';
      }); // Eliminate Sass interpolations from the list of id indexes

      var interpolations = indexesOf(word, '#{');

      if (interpolations.length) {
        hasId = hasId.filter(function (hashIndex) {
          return !~interpolations.indexOf(hashIndex);
        });
      }

      var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
      indices.forEach(function (ind, i) {
        var index = indices[i + 1] || word.length;
        var value = word.slice(ind, index);

        if (i === 0 && firstCallback) {
          return firstCallback.call(_this5, value, indices.length);
        }

        var node;
        var current = _this5.currToken;
        var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
        var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

        if (~hasClass.indexOf(ind)) {
          var classNameOpts = {
            value: value.slice(1),
            source: source,
            sourceIndex: sourceIndex
          };
          node = new _className["default"](unescapeProp(classNameOpts, "value"));
        } else if (~hasId.indexOf(ind)) {
          var idOpts = {
            value: value.slice(1),
            source: source,
            sourceIndex: sourceIndex
          };
          node = new _id["default"](unescapeProp(idOpts, "value"));
        } else {
          var tagOpts = {
            value: value,
            source: source,
            sourceIndex: sourceIndex
          };
          unescapeProp(tagOpts, "value");
          node = new _tag["default"](tagOpts);
        }

        _this5.newNode(node, namespace); // Ensure that the namespace is used only once


        namespace = null;
      });
      this.position++;
    };

    _proto.word = function word(namespace) {
      var nextToken = this.nextToken;

      if (nextToken && this.content(nextToken) === '|') {
        this.position++;
        return this.namespace();
      }

      return this.splitWord(namespace);
    };

    _proto.loop = function loop() {
      while (this.position < this.tokens.length) {
        this.parse(true);
      }

      this.current._inferEndPosition();

      return this.root;
    };

    _proto.parse = function parse(throwOnParenthesis) {
      switch (this.currToken[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          this.space();
          break;

        case tokens.comment:
          this.comment();
          break;

        case tokens.openParenthesis:
          this.parentheses();
          break;

        case tokens.closeParenthesis:
          if (throwOnParenthesis) {
            this.missingParenthesis();
          }

          break;

        case tokens.openSquare:
          this.attribute();
          break;

        case tokens.dollar:
        case tokens.caret:
        case tokens.equals:
        case tokens.word:
          this.word();
          break;

        case tokens.colon:
          this.pseudo();
          break;

        case tokens.comma:
          this.comma();
          break;

        case tokens.asterisk:
          this.universal();
          break;

        case tokens.ampersand:
          this.nesting();
          break;

        case tokens.slash:
        case tokens.combinator:
          this.combinator();
          break;

        case tokens.str:
          this.string();
          break;
        // These cases throw; no break needed.

        case tokens.closeSquare:
          this.missingSquareBracket();

        case tokens.semicolon:
          this.missingBackslash();

        default:
          this.unexpected();
      }
    }
    /**
     * Helpers
     */
    ;

    _proto.expected = function expected(description, index, found) {
      if (Array.isArray(description)) {
        var last = description.pop();
        description = description.join(', ') + " or " + last;
      }

      var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

      if (!found) {
        return this.error("Expected " + an + " " + description + ".", {
          index: index
        });
      }

      return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
        index: index
      });
    };

    _proto.requiredSpace = function requiredSpace(space) {
      return this.options.lossy ? ' ' : space;
    };

    _proto.optionalSpace = function optionalSpace(space) {
      return this.options.lossy ? '' : space;
    };

    _proto.lossySpace = function lossySpace(space, required) {
      if (this.options.lossy) {
        return required ? ' ' : '';
      } else {
        return space;
      }
    };

    _proto.parseParenthesisToken = function parseParenthesisToken(token) {
      var content = this.content(token);

      if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
        return this.requiredSpace(content);
      } else {
        return content;
      }
    };

    _proto.newNode = function newNode(node, namespace) {
      if (namespace) {
        if (/^ +$/.test(namespace)) {
          if (!this.options.lossy) {
            this.spaces = (this.spaces || '') + namespace;
          }

          namespace = true;
        }

        node.namespace = namespace;
        unescapeProp(node, "namespace");
      }

      if (this.spaces) {
        node.spaces.before = this.spaces;
        this.spaces = '';
      }

      return this.current.append(node);
    };

    _proto.content = function content(token) {
      if (token === void 0) {
        token = this.currToken;
      }

      return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
    };
    /**
     * returns the index of the next non-whitespace, non-comment token.
     * returns -1 if no meaningful token is found.
     */


    _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
      if (startPosition === void 0) {
        startPosition = this.position + 1;
      }

      var searchPosition = startPosition;

      while (searchPosition < this.tokens.length) {
        if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
          searchPosition++;
          continue;
        } else {
          return searchPosition;
        }
      }

      return -1;
    };

    _createClass(Parser, [{
      key: "currToken",
      get: function get() {
        return this.tokens[this.position];
      }
    }, {
      key: "nextToken",
      get: function get() {
        return this.tokens[this.position + 1];
      }
    }, {
      key: "prevToken",
      get: function get() {
        return this.tokens[this.position - 1];
      }
    }]);

    return Parser;
  }();

  exports["default"] = Parser;
  module.exports = exports.default;
  });

  var processor = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _parser = _interopRequireDefault(parser);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  var Processor = /*#__PURE__*/function () {
    function Processor(func, options) {
      this.func = func || function noop() {};

      this.funcRes = null;
      this.options = options;
    }

    var _proto = Processor.prototype;

    _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
      if (options === void 0) {
        options = {};
      }

      var merged = Object.assign({}, this.options, options);

      if (merged.updateSelector === false) {
        return false;
      } else {
        return typeof rule !== "string";
      }
    };

    _proto._isLossy = function _isLossy(options) {
      if (options === void 0) {
        options = {};
      }

      var merged = Object.assign({}, this.options, options);

      if (merged.lossless === false) {
        return true;
      } else {
        return false;
      }
    };

    _proto._root = function _root(rule, options) {
      if (options === void 0) {
        options = {};
      }

      var parser = new _parser["default"](rule, this._parseOptions(options));
      return parser.root;
    };

    _proto._parseOptions = function _parseOptions(options) {
      return {
        lossy: this._isLossy(options)
      };
    };

    _proto._run = function _run(rule, options) {
      var _this = this;

      if (options === void 0) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        try {
          var root = _this._root(rule, options);

          Promise.resolve(_this.func(root)).then(function (transform) {
            var string = undefined;

            if (_this._shouldUpdateSelector(rule, options)) {
              string = root.toString();
              rule.selector = string;
            }

            return {
              transform: transform,
              root: root,
              string: string
            };
          }).then(resolve, reject);
        } catch (e) {
          reject(e);
          return;
        }
      });
    };

    _proto._runSync = function _runSync(rule, options) {
      if (options === void 0) {
        options = {};
      }

      var root = this._root(rule, options);

      var transform = this.func(root);

      if (transform && typeof transform.then === "function") {
        throw new Error("Selector processor returned a promise to a synchronous call.");
      }

      var string = undefined;

      if (options.updateSelector && typeof rule !== "string") {
        string = root.toString();
        rule.selector = string;
      }

      return {
        transform: transform,
        root: root,
        string: string
      };
    }
    /**
     * Process rule into a selector AST.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {Promise<parser.Root>} The AST of the selector after processing it.
     */
    ;

    _proto.ast = function ast(rule, options) {
      return this._run(rule, options).then(function (result) {
        return result.root;
      });
    }
    /**
     * Process rule into a selector AST synchronously.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {parser.Root} The AST of the selector after processing it.
     */
    ;

    _proto.astSync = function astSync(rule, options) {
      return this._runSync(rule, options).root;
    }
    /**
     * Process a selector into a transformed value asynchronously
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {Promise<any>} The value returned by the processor.
     */
    ;

    _proto.transform = function transform(rule, options) {
      return this._run(rule, options).then(function (result) {
        return result.transform;
      });
    }
    /**
     * Process a selector into a transformed value synchronously.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {any} The value returned by the processor.
     */
    ;

    _proto.transformSync = function transformSync(rule, options) {
      return this._runSync(rule, options).transform;
    }
    /**
     * Process a selector into a new selector string asynchronously.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {string} the selector after processing.
     */
    ;

    _proto.process = function process(rule, options) {
      return this._run(rule, options).then(function (result) {
        return result.string || result.root.toString();
      });
    }
    /**
     * Process a selector into a new selector string synchronously.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {string} the selector after processing.
     */
    ;

    _proto.processSync = function processSync(rule, options) {
      var result = this._runSync(rule, options);

      return result.string || result.root.toString();
    };

    return Processor;
  }();

  exports["default"] = Processor;
  module.exports = exports.default;
  });

  var constructors = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

  var _attribute = _interopRequireDefault(attribute);

  var _className = _interopRequireDefault(className);

  var _combinator = _interopRequireDefault(combinator);

  var _comment = _interopRequireDefault(comment);

  var _id = _interopRequireDefault(id);

  var _nesting = _interopRequireDefault(nesting);

  var _pseudo = _interopRequireDefault(pseudo);

  var _root = _interopRequireDefault(root);

  var _selector = _interopRequireDefault(selector);

  var _string = _interopRequireDefault(string$2);

  var _tag = _interopRequireDefault(tag);

  var _universal = _interopRequireDefault(universal);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  var attribute$1 = function attribute(opts) {
    return new _attribute["default"](opts);
  };

  exports.attribute = attribute$1;

  var className$1 = function className(opts) {
    return new _className["default"](opts);
  };

  exports.className = className$1;

  var combinator$1 = function combinator(opts) {
    return new _combinator["default"](opts);
  };

  exports.combinator = combinator$1;

  var comment$1 = function comment(opts) {
    return new _comment["default"](opts);
  };

  exports.comment = comment$1;

  var id$1 = function id(opts) {
    return new _id["default"](opts);
  };

  exports.id = id$1;

  var nesting$1 = function nesting(opts) {
    return new _nesting["default"](opts);
  };

  exports.nesting = nesting$1;

  var pseudo$1 = function pseudo(opts) {
    return new _pseudo["default"](opts);
  };

  exports.pseudo = pseudo$1;

  var root$1 = function root(opts) {
    return new _root["default"](opts);
  };

  exports.root = root$1;

  var selector$1 = function selector(opts) {
    return new _selector["default"](opts);
  };

  exports.selector = selector$1;

  var string = function string(opts) {
    return new _string["default"](opts);
  };

  exports.string = string;

  var tag$1 = function tag(opts) {
    return new _tag["default"](opts);
  };

  exports.tag = tag$1;

  var universal$1 = function universal(opts) {
    return new _universal["default"](opts);
  };

  exports.universal = universal$1;
  });

  var guards = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
  exports.isContainer = isContainer;
  exports.isIdentifier = void 0;
  exports.isNamespace = isNamespace;
  exports.isNesting = void 0;
  exports.isNode = isNode;
  exports.isPseudo = void 0;
  exports.isPseudoClass = isPseudoClass;
  exports.isPseudoElement = isPseudoElement;
  exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = void 0;



  var _IS_TYPE;

  var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[types$2.ATTRIBUTE] = true, _IS_TYPE[types$2.CLASS] = true, _IS_TYPE[types$2.COMBINATOR] = true, _IS_TYPE[types$2.COMMENT] = true, _IS_TYPE[types$2.ID] = true, _IS_TYPE[types$2.NESTING] = true, _IS_TYPE[types$2.PSEUDO] = true, _IS_TYPE[types$2.ROOT] = true, _IS_TYPE[types$2.SELECTOR] = true, _IS_TYPE[types$2.STRING] = true, _IS_TYPE[types$2.TAG] = true, _IS_TYPE[types$2.UNIVERSAL] = true, _IS_TYPE);

  function isNode(node) {
    return typeof node === "object" && IS_TYPE[node.type];
  }

  function isNodeType(type, node) {
    return isNode(node) && node.type === type;
  }

  var isAttribute = isNodeType.bind(null, types$2.ATTRIBUTE);
  exports.isAttribute = isAttribute;
  var isClassName = isNodeType.bind(null, types$2.CLASS);
  exports.isClassName = isClassName;
  var isCombinator = isNodeType.bind(null, types$2.COMBINATOR);
  exports.isCombinator = isCombinator;
  var isComment = isNodeType.bind(null, types$2.COMMENT);
  exports.isComment = isComment;
  var isIdentifier = isNodeType.bind(null, types$2.ID);
  exports.isIdentifier = isIdentifier;
  var isNesting = isNodeType.bind(null, types$2.NESTING);
  exports.isNesting = isNesting;
  var isPseudo = isNodeType.bind(null, types$2.PSEUDO);
  exports.isPseudo = isPseudo;
  var isRoot = isNodeType.bind(null, types$2.ROOT);
  exports.isRoot = isRoot;
  var isSelector = isNodeType.bind(null, types$2.SELECTOR);
  exports.isSelector = isSelector;
  var isString = isNodeType.bind(null, types$2.STRING);
  exports.isString = isString;
  var isTag = isNodeType.bind(null, types$2.TAG);
  exports.isTag = isTag;
  var isUniversal = isNodeType.bind(null, types$2.UNIVERSAL);
  exports.isUniversal = isUniversal;

  function isPseudoElement(node) {
    return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
  }

  function isPseudoClass(node) {
    return isPseudo(node) && !isPseudoElement(node);
  }

  function isContainer(node) {
    return !!(isNode(node) && node.walk);
  }

  function isNamespace(node) {
    return isAttribute(node) || isTag(node);
  }
  });

  var selectors$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  Object.keys(types$2).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === types$2[key]) return;
    exports[key] = types$2[key];
  });



  Object.keys(constructors).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === constructors[key]) return;
    exports[key] = constructors[key];
  });



  Object.keys(guards).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === guards[key]) return;
    exports[key] = guards[key];
  });
  });

  var dist$4 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _processor = _interopRequireDefault(processor);

  var selectors = _interopRequireWildcard(selectors$1);

  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache(nodeInterop);

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  var parser = function parser(processor) {
    return new _processor["default"](processor);
  };

  Object.assign(parser, selectors);
  delete parser.__esModule;
  var _default = parser;
  exports["default"] = _default;
  module.exports = exports.default;
  });

  /**
   * @param {import('stylelint').PostcssResult} result
   * @param {import('postcss').Rule} node
   * @param {(root: import('postcss-selector-parser').Root) => void} callback
   * @returns {string | undefined}
   */


  var transformSelector = function transformSelector(result, node, callback) {
    try {
      return dist$4(callback).processSync(node, {
        updateSelector: true
      });
    } catch {
      result.warn('Cannot parse selector', {
        node,
        stylelintType: 'parseError'
      });
      return undefined;
    }
  };

  const {
    assertString: assertString$4
  } = validateTypes;

  const ruleName$1N = 'keyframe-selector-notation';
  const messages$1N = ruleMessages$1(ruleName$1N, {
    expected: (selector, fixedSelector) => `Expected "${selector}" to be "${fixedSelector}"`
  });
  const meta$1N = {
    url: 'https://stylelint.io/user-guide/rules/keyframe-selector-notation',
    fixable: true
  };
  const PERCENTAGE_SELECTORS = new Set(['0%', '100%']);
  const KEYWORD_SELECTORS = new Set(['from', 'to']);
  const NAMED_TIMELINE_RANGE_SELECTORS = new Set(['cover', 'contain', 'entry', 'enter', 'exit']);
  const PERCENTAGE_TO_KEYWORD = new Map([['0%', 'from'], ['100%', 'to']]);
  const KEYWORD_TO_PERCENTAGE = new Map([['from', '0%'], ['to', '100%']]);
  /** @type {import('stylelint').Rule<'keyword' | 'percentage' | 'percentage-unless-within-keyword-only-block'>} */

  const rule$1M = (primary, _, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1N, {
        actual: primary,
        possible: ['keyword', 'percentage', 'percentage-unless-within-keyword-only-block']
      });
      if (!validOptions) return;
      /**
       * @typedef {{
       *   expFunc: (selector: string, selectorsInBlock: string[]) => boolean,
       *   fixFunc: (selector: string) => string,
       * }} OptionFuncs
       *
       * @type {Record<primary, OptionFuncs>}
       */

      const optionFuncs = Object.freeze({
        keyword: {
          expFunc: selector => KEYWORD_SELECTORS.has(selector),
          fixFunc: selector => getFromMap(PERCENTAGE_TO_KEYWORD, selector)
        },
        percentage: {
          expFunc: selector => PERCENTAGE_SELECTORS.has(selector),
          fixFunc: selector => getFromMap(KEYWORD_TO_PERCENTAGE, selector)
        },
        'percentage-unless-within-keyword-only-block': {
          expFunc: (selector, selectorsInBlock) => {
            if (selectorsInBlock.every(s => KEYWORD_SELECTORS.has(s))) return true;
            return PERCENTAGE_SELECTORS.has(selector);
          },
          fixFunc: selector => getFromMap(KEYWORD_TO_PERCENTAGE, selector)
        }
      });
      root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes => {
        const selectorsInBlock = primary === 'percentage-unless-within-keyword-only-block' ? getSelectorsInBlock(atRuleKeyframes) : [];
        atRuleKeyframes.walkRules(keyframeRule => {
          transformSelector(result, keyframeRule, selectors => {
            let first = true;
            selectors.walkTags(selectorTag => {
              if (first && NAMED_TIMELINE_RANGE_SELECTORS.has(selectorTag.value)) {
                return false;
              }

              first = false;
              checkSelector(selectorTag.value, optionFuncs[primary], fixedSelector => selectorTag.value = fixedSelector);
            });
          });
          /**
           * @param {string} selector
           * @param {OptionFuncs} funcs
           * @param {(fixedSelector: string) => void} fixer
           */

          function checkSelector(selector, {
            expFunc,
            fixFunc
          }, fixer) {
            const normalizedSelector = selector.toLowerCase();

            if (!KEYWORD_SELECTORS.has(normalizedSelector) && !PERCENTAGE_SELECTORS.has(normalizedSelector)) {
              return;
            }

            if (expFunc(selector, selectorsInBlock)) return;
            const fixedSelector = fixFunc(selector);

            if (context.fix) {
              fixer(fixedSelector);
              return;
            }

            report$1({
              message: messages$1N.expected,
              messageArgs: [selector, fixedSelector],
              node: keyframeRule,
              result,
              ruleName: ruleName$1N,
              word: selector
            });
          }
        });
      });
    };
  };
  /**
   * @param {Map<string, string>} map
   * @param {string} key
   * @returns {string}
   */


  function getFromMap(map, key) {
    const value = map.get(key);
    assertString$4(value);
    return value;
  }
  /**
   * @param {import('postcss').AtRule} atRule
   * @returns {string[]}
   */


  function getSelectorsInBlock(atRule) {
    /** @type {string[]} */
    const selectors = [];
    atRule.walkRules(r => {
      selectors.push(...r.selectors);
    });
    return selectors;
  }

  rule$1M.ruleName = ruleName$1N;
  rule$1M.messages = messages$1N;
  rule$1M.meta = meta$1N;
  var keyframeSelectorNotation = rule$1M;

  /**
   * Check whether a keyframes name is standard
   *
   * @param {string} keyframesName
   * @returns {boolean}
   */


  var isStandardSyntaxKeyframesName = function isStandardSyntaxKeyframesName(keyframesName) {
    if (hasInterpolation(keyframesName)) {
      return false;
    }

    return true;
  };

  const {
    isRegExp: isRegExp$C,
    isString: isString$M
  } = validateTypes;

  const ruleName$1M = 'keyframes-name-pattern';
  const messages$1M = ruleMessages$1(ruleName$1M, {
    expected: (keyframeName, pattern) => `Expected "${keyframeName}" to match pattern "${pattern}"`
  });
  const meta$1M = {
    url: 'https://stylelint.io/user-guide/rules/keyframes-name-pattern'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1L = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1M, {
        actual: primary,
        possible: [isRegExp$C, isString$M]
      });

      if (!validOptions) {
        return;
      }

      const regex = isString$M(primary) ? new RegExp(primary) : primary;
      root.walkAtRules(/keyframes/i, keyframesNode => {
        const value = keyframesNode.params;

        if (!isStandardSyntaxKeyframesName(value)) {
          return;
        }

        if (regex.test(value)) {
          return;
        }

        const index = atRuleParamIndex(keyframesNode);
        const endIndex = index + value.length;
        report$1({
          index,
          endIndex,
          message: messages$1M.expected,
          messageArgs: [value, primary],
          node: keyframesNode,
          ruleName: ruleName$1M,
          result
        });
      });
    };
  };

  rule$1L.ruleName = ruleName$1M;
  rule$1L.messages = messages$1M;
  rule$1L.meta = meta$1M;
  var keyframesNamePattern = rule$1L;

  const {
    mathFunctions: mathFunctions$1
  } = functions;
  /**
   * Check whether a node is math function
   *
   * @param {import('postcss-value-parser').Node} node postcss-value-parser node
   * @return {boolean} If `true`, the node is math function
   */


  var isMathFunction = function isMathFunction(node) {
    return node.type === 'function' && mathFunctions$1.has(node.value.toLowerCase());
  };

  const {
    lengthUnits: lengthUnits$1
  } = units_1;













  const {
    isRegExp: isRegExp$B,
    isString: isString$L
  } = validateTypes;

  const ruleName$1L = 'length-zero-no-unit';
  const messages$1L = ruleMessages$1(ruleName$1L, {
    rejected: 'Unexpected unit'
  });
  const meta$1L = {
    url: 'https://stylelint.io/user-guide/rules/length-zero-no-unit',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1K = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1L, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['custom-properties'],
          ignoreFunctions: [isString$L, isRegExp$B]
        },
        optional: true
      });
      if (!validOptions) return;
      let needsFix;
      /**
       * @param {import('postcss').Node} node
       * @param {number} nodeIndex
       * @param {import('postcss-value-parser').Node} valueNode
       */

      function check(node, nodeIndex, valueNode) {
        const {
          value,
          sourceIndex
        } = valueNode;
        if (isMathFunction(valueNode)) return false;
        if (isFunction(valueNode) && optionsMatches(secondaryOptions, 'ignoreFunctions', value)) return false;
        if (!isWord(valueNode)) return;
        const numberUnit = lib$6.unit(value);
        if (numberUnit === false) return;
        const {
          number,
          unit
        } = numberUnit;
        if (unit === '') return;
        if (!isLength(unit)) return;
        if (isFraction(unit)) return;
        if (!isZero(number)) return;

        if (context.fix) {
          let regularNumber = number;

          if (regularNumber.startsWith('.')) {
            regularNumber = number.slice(1);
          }

          valueNode.value = regularNumber;
          needsFix = true;
          return;
        }

        const index = nodeIndex + sourceIndex + number.length;
        const endIndex = index + unit.length;
        report$1({
          index,
          endIndex,
          message: messages$1L.rejected,
          node,
          result,
          ruleName: ruleName$1L
        });
      }
      /**
       * @param {import('postcss').AtRule} node
       */


      function checkAtRule(node) {
        if (!isStandardSyntaxAtRule(node)) return;
        needsFix = false;
        const index = atRuleParamIndex(node);
        const parsedValue = lib$6(getAtRuleParams(node));
        parsedValue.walk(valueNode => check(node, index, valueNode));

        if (needsFix) {
          setAtRuleParams(node, parsedValue.toString());
        }
      }
      /**
       * @param {import('postcss').Declaration} node
       */


      function checkDecl(node) {
        needsFix = false;
        const {
          prop
        } = node;
        if (isLineHeight(prop)) return;
        if (isFlex(prop)) return;
        if (optionsMatches(secondaryOptions, 'ignore', 'custom-properties') && isCustomProperty$2(prop)) return;
        const index = declarationValueIndex(node);
        const parsedValue = lib$6(getDeclarationValue(node));
        parsedValue.walk((valueNode, valueNodeIndex, valueNodes) => {
          if (isLineHeightValue(node, valueNodes, valueNodeIndex)) return;
          return check(node, index, valueNode);
        });

        if (needsFix) {
          setDeclarationValue(node, parsedValue.toString());
        }
      }

      root.walkAtRules(checkAtRule);
      root.walkDecls(checkDecl);
    };
  };
  /**
   * @param {import('postcss').Declaration} decl
   * @param {import('postcss-value-parser').Node[]} nodes
   * @param {number} index
   */


  function isLineHeightValue({
    prop
  }, nodes, index) {
    const lastNode = nodes[index - 1];
    return prop.toLowerCase() === 'font' && lastNode && lastNode.type === 'div' && lastNode.value === '/';
  }
  /**
   * @param {string} prop
   */


  function isLineHeight(prop) {
    return prop.toLowerCase() === 'line-height';
  }
  /**
   * @param {string} prop
   */


  function isFlex(prop) {
    return prop.toLowerCase() === 'flex';
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isWord({
    type
  }) {
    return type === 'word';
  }
  /**
   * @param {string} unit
   */


  function isLength(unit) {
    return lengthUnits$1.has(unit.toLowerCase());
  }
  /**
   * @param {import('postcss-value-parser').Node} node
   */


  function isFunction({
    type
  }) {
    return type === 'function';
  }
  /**
   * @param {string} unit
   */


  function isFraction(unit) {
    return unit.toLowerCase() === 'fr';
  }
  /**
   * @param {string} number
   */


  function isZero(number) {
    return Number.parseFloat(number) === 0;
  }

  rule$1K.ruleName = ruleName$1L;
  rule$1K.messages = messages$1L;
  rule$1K.meta = meta$1L;
  var lengthZeroNoUnit = rule$1K;

  const ruleName$1K = 'linebreaks';
  const messages$1K = ruleMessages$1(ruleName$1K, {
    expected: linebreak => `Expected linebreak to be ${linebreak}`
  });
  const meta$1K = {
    url: 'https://stylelint.io/user-guide/rules/linebreaks',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1J = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1K, {
        actual: primary,
        possible: ['unix', 'windows']
      });

      if (!validOptions) {
        return;
      }

      const shouldHaveCR = primary === 'windows';

      if (context.fix) {
        root.walk(node => {
          if ('selector' in node) {
            node.selector = fixData(node.selector);
          }

          if ('value' in node) {
            node.value = fixData(node.value);
          }

          if ('text' in node) {
            node.text = fixData(node.text);
          }

          if (node.raws.before) {
            node.raws.before = fixData(node.raws.before);
          }

          if (typeof node.raws.after === 'string') {
            node.raws.after = fixData(node.raws.after);
          }
        });

        if (typeof root.raws.after === 'string') {
          root.raws.after = fixData(root.raws.after);
        }
      } else {
        if (root.source == null) throw new Error('The root node must have a source');
        const lines = root.source.input.css.split('\n');

        for (let [i, line] of lines.entries()) {
          if (i < lines.length - 1 && !line.includes('\r')) {
            line += '\n';
          }

          if (hasError(line)) {
            const lineNum = i + 1;
            const colNum = line.length;
            reportNewlineError(lineNum, colNum);
          }
        }
      }
      /**
       * @param {string} dataToCheck
       */


      function hasError(dataToCheck) {
        const hasNewlineToVerify = /[\r\n]/.test(dataToCheck);
        const hasCR = hasNewlineToVerify ? /\r/.test(dataToCheck) : false;
        return hasNewlineToVerify && hasCR !== shouldHaveCR;
      }
      /**
       * @param {string} data
       */


      function fixData(data) {
        if (data) {
          let res = data.replace(/\r/g, '');

          if (shouldHaveCR) {
            res = res.replace(/\n/g, '\r\n');
          }

          return res;
        }

        return data;
      }
      /**
       * @param {number} line
       * @param {number} column
       */


      function reportNewlineError(line, column) {
        // Creating a node manually helps us to point to empty lines.
        const node = postcss_1.rule({
          source: {
            start: {
              line,
              column,
              offset: 0
            },
            input: new postcss_1.Input('')
          }
        });
        report$1({
          message: messages$1K.expected(primary),
          node,
          result,
          ruleName: ruleName$1K
        });
      }
    };
  };

  rule$1J.ruleName = ruleName$1K;
  rule$1J.messages = messages$1K;
  rule$1J.meta = meta$1K;
  var linebreaks = rule$1J;

  const {
    isNumber: isNumber$a
  } = validateTypes;

  const ruleName$1J = 'max-empty-lines';
  const messages$1J = ruleMessages$1(ruleName$1J, {
    expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`
  });
  const meta$1J = {
    url: 'https://stylelint.io/user-guide/rules/max-empty-lines',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1I = (primary, secondaryOptions, context) => {
    let emptyLines = 0;
    let lastIndex = -1;
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1J, {
        actual: primary,
        possible: isNumber$a
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['comments']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments');
      const getChars = replaceEmptyLines.bind(null, primary);
      /**
       * 1. walk nodes & replace enterchar
       * 2. deal with special case.
       */

      if (context.fix) {
        root.walk(node => {
          if (node.type === 'comment' && !ignoreComments) {
            node.raws.left = getChars(node.raws.left);
            node.raws.right = getChars(node.raws.right);
          }

          if (node.raws.before) {
            node.raws.before = getChars(node.raws.before);
          }
        }); // first node

        const firstNodeRawsBefore = root.first && root.first.raws.before; // root raws

        const rootRawsAfter = root.raws.after; // not document node
        // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Root'.

        if ((root.document && root.document.constructor.name) !== 'Document') {
          if (firstNodeRawsBefore) {
            root.first.raws.before = getChars(firstNodeRawsBefore, true);
          }

          if (rootRawsAfter) {
            // when max set 0, should be treated as 1 in this situation.
            root.raws.after = replaceEmptyLines(primary === 0 ? 1 : primary, rootRawsAfter, true);
          }
        } else if (rootRawsAfter) {
          // `css in js` or `html`
          root.raws.after = replaceEmptyLines(primary === 0 ? 1 : primary, rootRawsAfter);
        }

        return;
      }

      emptyLines = 0;
      lastIndex = -1;
      const rootString = root.toString();
      styleSearch({
        source: rootString,
        target: /\r\n/.test(rootString) ? '\r\n' : '\n',
        comments: ignoreComments ? 'skip' : 'check'
      }, match => {
        checkMatch(rootString, match.startIndex, match.endIndex, root);
      });
      /**
       * @param {string} source
       * @param {number} matchStartIndex
       * @param {number} matchEndIndex
       * @param {import('postcss').Root} node
       */

      function checkMatch(source, matchStartIndex, matchEndIndex, node) {
        const eof = matchEndIndex === source.length;
        let problem = false; // Additional check for beginning of file

        if (!matchStartIndex || lastIndex === matchStartIndex) {
          emptyLines++;
        } else {
          emptyLines = 0;
        }

        lastIndex = matchEndIndex;
        if (emptyLines > primary) problem = true;
        if (!eof && !problem) return;

        if (problem) {
          report$1({
            message: messages$1J.expected(primary),
            node,
            index: matchStartIndex,
            result,
            ruleName: ruleName$1J
          });
        } // Additional check for end of file


        if (eof && primary) {
          emptyLines++;

          if (emptyLines > primary && isEofNode(result.root, node)) {
            report$1({
              message: messages$1J.expected(primary),
              node,
              index: matchEndIndex,
              result,
              ruleName: ruleName$1J
            });
          }
        }
      }
      /**
       * @param {number} maxLines
       * @param {unknown} str
       * @param {boolean?} isSpecialCase
       */


      function replaceEmptyLines(maxLines, str, isSpecialCase = false) {
        const repeatTimes = isSpecialCase ? maxLines : maxLines + 1;

        if (repeatTimes === 0 || typeof str !== 'string') {
          return '';
        }

        const emptyLFLines = '\n'.repeat(repeatTimes);
        const emptyCRLFLines = '\r\n'.repeat(repeatTimes);
        return /(?:\r\n)+/.test(str) ? str.replace(/(\r\n)+/g, $1 => {
          if ($1.length / 2 > repeatTimes) {
            return emptyCRLFLines;
          }

          return $1;
        }) : str.replace(/(\n)+/g, $1 => {
          if ($1.length > repeatTimes) {
            return emptyLFLines;
          }

          return $1;
        });
      }
    };
  };
  /**
   * Checks whether the given node is the last node of file.
   * @param {import('stylelint').PostcssResult['root']} document - the document node with `postcss-html` and `postcss-jsx`.
   * @param {import('postcss').Root} root - the root node of css
   */


  function isEofNode(document, root) {
    if (!document || document.constructor.name !== 'Document' || !('type' in document)) {
      return true;
    } // In the `postcss-html` and `postcss-jsx` syntax, checks that there is text after the given node.


    let after;

    if (root === document.last) {
      after = document.raws && document.raws.codeAfter;
    } else {
      // @ts-expect-error -- TS2345: Argument of type 'Root' is not assignable to parameter of type 'number | ChildNode'.
      const rootIndex = document.index(root);
      const nextNode = document.nodes[rootIndex + 1];
      after = nextNode && nextNode.raws && nextNode.raws.codeBefore;
    }

    return !String(after).trim();
  }

  rule$1I.ruleName = ruleName$1J;
  rule$1I.messages = messages$1J;
  rule$1I.meta = meta$1J;
  var maxEmptyLines = rule$1I;

  const {
    isNumber: isNumber$9,
    isRegExp: isRegExp$A,
    isString: isString$K,
    assert: assert$4
  } = validateTypes;

  const ruleName$1I = 'max-line-length';
  const messages$1I = ruleMessages$1(ruleName$1I, {
    expected: max => `Expected line length to be no more than ${max} ${max === 1 ? 'character' : 'characters'}`
  });
  const meta$1I = {
    url: 'https://stylelint.io/user-guide/rules/max-line-length',
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1H = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1I, {
        actual: primary,
        possible: isNumber$9
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['non-comments', 'comments'],
          ignorePattern: [isString$K, isRegExp$A]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      if (root.source == null) {
        throw new Error('The root node must have a source');
      }

      const EXCLUDED_PATTERNS = [/url\(\s*(\S.*\S)\s*\)/gi, // allow tab, whitespace in url content
      /@import\s+(['"].*['"])/gi];
      const ignoreNonComments = optionsMatches(secondaryOptions, 'ignore', 'non-comments');
      const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments');
      const rootString = context.fix ? root.toString() : root.source.input.css; // Array of skipped sub strings, i.e `url(...)`, `@import "..."`

      /** @type {Array<[number, number]>} */

      let skippedSubStrings = [];
      let skippedSubStringsIndex = 0;

      for (const pattern of EXCLUDED_PATTERNS) {
        for (const match of rootString.matchAll(pattern)) {
          const subMatch = match[1] || '';
          const startOfSubString = (match.index || 0) + (match[0] || '').indexOf(subMatch);
          skippedSubStrings.push([startOfSubString, startOfSubString + subMatch.length]);
        }
      }

      skippedSubStrings = skippedSubStrings.sort((a, b) => a[0] - b[0]); // Check first line

      checkNewline({
        endIndex: 0
      }); // Check subsequent lines

      styleSearch({
        source: rootString,
        target: ['\n'],
        comments: 'check'
      }, match => checkNewline(match));
      /**
       * @param {number} index
       */

      function complain(index) {
        report$1({
          index,
          result,
          ruleName: ruleName$1I,
          message: messages$1I.expected(primary),
          node: root
        });
      }
      /**
       * @param {number} start
       * @param {number} end
       */


      function tryToPopSubString(start, end) {
        const skippedSubString = skippedSubStrings[skippedSubStringsIndex];
        assert$4(skippedSubString);
        const [startSubString, endSubString] = skippedSubString; // Excluded substring does not presented in current line

        if (end < startSubString) {
          return 0;
        } // Compute excluded substring size regarding to current line indexes


        const excluded = Math.min(end, endSubString) - Math.max(start, startSubString); // Current substring is out of range for next lines

        if (endSubString <= end) {
          skippedSubStringsIndex++;
        }

        return excluded;
      }
      /**
       * @param {import('style-search').StyleSearchMatch | { endIndex: number }} match
       */


      function checkNewline(match) {
        let nextNewlineIndex = rootString.indexOf('\n', match.endIndex);

        if (rootString[nextNewlineIndex - 1] === '\r') {
          nextNewlineIndex -= 1;
        } // Accommodate last line


        if (nextNewlineIndex === -1) {
          nextNewlineIndex = rootString.length;
        }

        const rawLineLength = nextNewlineIndex - match.endIndex;
        const excludedLength = skippedSubStrings[skippedSubStringsIndex] ? tryToPopSubString(match.endIndex, nextNewlineIndex) : 0;
        const lineText = rootString.slice(match.endIndex, nextNewlineIndex); // Case sensitive ignorePattern match

        if (optionsMatches(secondaryOptions, 'ignorePattern', lineText)) {
          return;
        } // If the line's length is less than or equal to the specified
        // max, ignore it ... So anything below is liable to be complained about.
        // **Note that the length of any url arguments or import urls
        // are excluded from the calculation.**


        if (rawLineLength - excludedLength <= primary) {
          return;
        }

        const complaintIndex = nextNewlineIndex - 1;

        if (ignoreComments) {
          if ('insideComment' in match && match.insideComment) {
            return;
          } // This trimming business is to notice when the line starts a
          // comment but that comment is indented, e.g.
          //       /* something here */


          const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);

          if (nextTwoChars === '/*' || nextTwoChars === '//') {
            return;
          }
        }

        if (ignoreNonComments) {
          if ('insideComment' in match && match.insideComment) {
            return complain(complaintIndex);
          } // This trimming business is to notice when the line starts a
          // comment but that comment is indented, e.g.
          //       /* something here */


          const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);

          if (nextTwoChars !== '/*' && nextTwoChars !== '//') {
            return;
          }

          return complain(complaintIndex);
        } // If there are no spaces besides initial (indent) spaces, ignore it


        const lineString = rootString.slice(match.endIndex, nextNewlineIndex);

        if (!lineString.replace(/^\s+/, '').includes(' ')) {
          return;
        }

        return complain(complaintIndex);
      }
    };
  };

  rule$1H.ruleName = ruleName$1I;
  rule$1H.messages = messages$1I;
  rule$1H.meta = meta$1I;
  var maxLineLength = rule$1H;

  /**
   * Check whether a Node is a standard rule
   *
   * @param {import('postcss').Rule | import('postcss-less').Rule} rule
   * @returns {boolean}
   */


  var isStandardSyntaxRule = function isStandardSyntaxRule(rule) {
    if (rule.type !== 'rule') {
      return false;
    } // Ignore Less &:extend rule


    if ('extend' in rule && rule.extend) {
      return false;
    }

    if (!isStandardSyntaxSelector(rule.selector)) {
      return false;
    }

    return true;
  };

  const {
    isAtRule: isAtRule$c,
    isDeclaration: isDeclaration$2,
    isRoot: isRoot$1,
    isRule: isRule$5
  } = typeGuards;

  const {
    isNumber: isNumber$8,
    isRegExp: isRegExp$z,
    isString: isString$J
  } = validateTypes;

  const ruleName$1H = 'max-nesting-depth';
  const messages$1H = ruleMessages$1(ruleName$1H, {
    expected: depth => `Expected nesting depth to be no more than ${depth}`
  });
  const meta$1H = {
    url: 'https://stylelint.io/user-guide/rules/max-nesting-depth'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1G = (primary, secondaryOptions) => {
    /**
     * @param {import('postcss').Node} node
     */
    const isIgnoreAtRule = node => isAtRule$c(node) && optionsMatches(secondaryOptions, 'ignoreAtRules', node.name);

    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1H, {
        actual: primary,
        possible: [isNumber$8]
      }, {
        optional: true,
        actual: secondaryOptions,
        possible: {
          ignore: ['blockless-at-rules', 'pseudo-classes'],
          ignoreAtRules: [isString$J, isRegExp$z],
          ignorePseudoClasses: [isString$J, isRegExp$z]
        }
      });
      if (!validOptions) return;
      root.walkRules(checkStatement);
      root.walkAtRules(checkStatement);
      /**
       * @param {import('postcss').Rule | import('postcss').AtRule} statement
       */

      function checkStatement(statement) {
        if (isIgnoreAtRule(statement)) {
          return;
        }

        if (!hasBlock(statement)) {
          return;
        }

        if (isRule$5(statement) && !isStandardSyntaxRule(statement)) {
          return;
        }

        const depth = nestingDepth(statement, 0);

        if (depth > primary) {
          report$1({
            ruleName: ruleName$1H,
            result,
            node: statement,
            message: messages$1H.expected,
            messageArgs: [primary]
          });
        }
      }
    };
    /**
     * @param {import('postcss').Node} node
     * @param {number} level
     * @returns {number}
     */

    function nestingDepth(node, level) {
      const parent = node.parent;

      if (!parent) {
        return 0;
      }

      if (isIgnoreAtRule(parent)) {
        return 0;
      } // The nesting depth level's computation has finished
      // when this function, recursively called, receives
      // a node that is not nested -- a direct child of the
      // root node


      if (isRoot$1(parent) || isAtRule$c(parent) && parent.parent && isRoot$1(parent.parent)) {
        return level;
      }
      /**
       * @param {string} selector
       */


      function containsPseudoClassesOnly(selector) {
        const normalized = dist$4().processSync(selector, {
          lossless: false
        });
        const selectors = normalized.split(',');
        return selectors.every(sel => extractPseudoRule(sel));
      }
      /**
       * @param {string[]} selectors
       * @returns {boolean}
       */


      function containsIgnoredPseudoClassesOnly(selectors) {
        if (!(secondaryOptions && secondaryOptions.ignorePseudoClasses)) return false;
        return selectors.every(selector => {
          const pseudoRule = extractPseudoRule(selector);
          if (!pseudoRule) return false;
          return optionsMatches(secondaryOptions, 'ignorePseudoClasses', pseudoRule);
        });
      }

      if (optionsMatches(secondaryOptions, 'ignore', 'blockless-at-rules') && isAtRule$c(node) && node.every(child => !isDeclaration$2(child)) || optionsMatches(secondaryOptions, 'ignore', 'pseudo-classes') && isRule$5(node) && containsPseudoClassesOnly(node.selector) || isRule$5(node) && containsIgnoredPseudoClassesOnly(node.selectors)) {
        return nestingDepth(parent, level);
      } // Unless any of the conditions above apply, we want to
      // add 1 to the nesting depth level and then check the parent,
      // continuing to add and move up the hierarchy
      // until we hit the root node


      return nestingDepth(parent, level + 1);
    }
  };
  /**
   * @param {string} selector
   * @returns {string | undefined}
   */


  function extractPseudoRule(selector) {
    return selector.startsWith('&:') && selector[2] !== ':' ? selector.slice(2) : undefined;
  }

  rule$1G.ruleName = ruleName$1H;
  rule$1G.messages = messages$1H;
  rule$1G.meta = meta$1H;
  var maxNestingDepth = rule$1G;

  /**
   * @param {{
   *   root: import('postcss').Root,
   *   locationChecker: (args: { source: string, index: number, err: (message: string) => void }) => void,
   *   fix: ((node: import('postcss').AtRule, index: number) => boolean) | null,
   *   result: import('stylelint').PostcssResult,
   *   checkedRuleName: string,
   * }} opts
   */


  var mediaFeatureColonSpaceChecker = function mediaFeatureColonSpaceChecker(opts) {
    opts.root.walkAtRules(/^media$/i, atRule => {
      const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;
      styleSearch({
        source: params,
        target: ':'
      }, match => {
        checkColon(params, match.startIndex, atRule);
      });
    });
    /**
     * @param {string} source
     * @param {number} index
     * @param {import('postcss').AtRule} node
     */

    function checkColon(source, index, node) {
      opts.locationChecker({
        source,
        index,
        err: message => {
          const colonIndex = index + atRuleParamIndex(node);

          if (opts.fix && opts.fix(node, colonIndex)) {
            return;
          }

          report$1({
            message,
            node,
            index: colonIndex,
            result: opts.result,
            ruleName: opts.checkedRuleName
          });
        }
      });
    }
  };

  const ruleName$1G = 'media-feature-colon-space-after';
  const messages$1G = ruleMessages$1(ruleName$1G, {
    expectedAfter: () => 'Expected single space after ":"',
    rejectedAfter: () => 'Unexpected whitespace after ":"'
  });
  const meta$1G = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-colon-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1F = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$1G);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1G, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').AtRule, number[]> | undefined} */


      let fixData;
      mediaFeatureColonSpaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$1G,
        fix: context.fix ? (atRule, index) => {
          const paramColonIndex = index - atRuleParamIndex(atRule);
          fixData = fixData || new Map();
          const colonIndices = fixData.get(atRule) || [];
          colonIndices.push(paramColonIndex);
          fixData.set(atRule, colonIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [atRule, colonIndices] of fixData.entries()) {
          let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          for (const index of colonIndices.sort((a, b) => b - a)) {
            const beforeColon = params.slice(0, index + 1);
            const afterColon = params.slice(index + 1);

            if (primary === 'always') {
              params = beforeColon + afterColon.replace(/^\s*/, ' ');
            } else if (primary === 'never') {
              params = beforeColon + afterColon.replace(/^\s*/, '');
            }
          }

          if (atRule.raws.params) {
            atRule.raws.params.raw = params;
          } else {
            atRule.params = params;
          }
        }
      }
    };
  };

  rule$1F.ruleName = ruleName$1G;
  rule$1F.messages = messages$1G;
  rule$1F.meta = meta$1G;
  var mediaFeatureColonSpaceAfter = rule$1F;

  const ruleName$1F = 'media-feature-colon-space-before';
  const messages$1F = ruleMessages$1(ruleName$1F, {
    expectedBefore: () => 'Expected single space before ":"',
    rejectedBefore: () => 'Unexpected whitespace before ":"'
  });
  const meta$1F = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-colon-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1E = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$1F);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1F, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').AtRule, number[]> | undefined} */


      let fixData;
      mediaFeatureColonSpaceChecker({
        root,
        result,
        locationChecker: checker.before,
        checkedRuleName: ruleName$1F,
        fix: context.fix ? (atRule, index) => {
          const paramColonIndex = index - atRuleParamIndex(atRule);
          fixData = fixData || new Map();
          const colonIndices = fixData.get(atRule) || [];
          colonIndices.push(paramColonIndex);
          fixData.set(atRule, colonIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [atRule, colonIndices] of fixData.entries()) {
          let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          for (const index of colonIndices.sort((a, b) => b - a)) {
            const beforeColon = params.slice(0, index);
            const afterColon = params.slice(index);

            if (primary === 'always') {
              params = beforeColon.replace(/\s*$/, ' ') + afterColon;
            } else if (primary === 'never') {
              params = beforeColon.replace(/\s*$/, '') + afterColon;
            }
          }

          if (atRule.raws.params) {
            atRule.raws.params.raw = params;
          } else {
            atRule.params = params;
          }
        }
      }
    };
  };

  rule$1E.ruleName = ruleName$1F;
  rule$1E.messages = messages$1F;
  rule$1E.meta = meta$1F;
  var mediaFeatureColonSpaceBefore = rule$1E;

  var e,
      t = require("@csstools/css-parser-algorithms"),
      i$1 = require("@csstools/css-tokenizer");

  exports.NodeType = void 0, (e = exports.NodeType || (exports.NodeType = {})).CustomMedia = "custom-media", e.GeneralEnclosed = "general-enclosed", e.MediaAnd = "media-and", e.MediaCondition = "media-condition", e.MediaConditionListWithAnd = "media-condition-list-and", e.MediaConditionListWithOr = "media-condition-list-or", e.MediaFeature = "media-feature", e.MediaFeatureBoolean = "mf-boolean", e.MediaFeatureName = "mf-name", e.MediaFeaturePlain = "mf-plain", e.MediaFeatureRangeNameValue = "mf-range-name-value", e.MediaFeatureRangeValueName = "mf-range-value-name", e.MediaFeatureRangeValueNameValue = "mf-range-value-name-value", e.MediaFeatureValue = "mf-value", e.MediaInParens = "media-in-parens", e.MediaNot = "media-not", e.MediaOr = "media-or", e.MediaQueryWithType = "media-query-with-type", e.MediaQueryWithoutType = "media-query-without-type", e.MediaQueryInvalid = "media-query-invalid";
  const a = /[A-Z]/g;

  function toLowerCaseAZ(e) {
    return e.replace(a, e => String.fromCharCode(e.charCodeAt(0) + 32));
  }

  class MediaCondition {
    constructor(e) {
      _defineProperty(this, "type", exports.NodeType.MediaCondition);

      _defineProperty(this, "media", void 0);

      this.media = e;
    }

    tokens() {
      return this.media.tokens();
    }

    toString() {
      return this.media.toString();
    }

    indexOf(e) {
      return e === this.media ? "media" : -1;
    }

    at(e) {
      if ("media" === e) return this.media;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.media,
        parent: this,
        state: i
      }, "media") && this.media.walk(e, i);
    }

    toJSON() {
      return {
        type: this.type,
        media: this.media.toJSON()
      };
    }

    isMediaCondition() {
      return MediaCondition.isMediaCondition(this);
    }

    static isMediaCondition(e) {
      return !!e && e instanceof MediaCondition && e.type === exports.NodeType.MediaCondition;
    }

  }

  class MediaInParens {
    constructor(e, t = [], i = []) {
      _defineProperty(this, "type", exports.NodeType.MediaInParens);

      _defineProperty(this, "media", void 0);

      _defineProperty(this, "before", void 0);

      _defineProperty(this, "after", void 0);

      this.media = e, this.before = t, this.after = i;
    }

    tokens() {
      return [...this.before, ...this.media.tokens(), ...this.after];
    }

    toString() {
      return i$1.stringify(...this.before) + this.media.toString() + i$1.stringify(...this.after);
    }

    indexOf(e) {
      return e === this.media ? "media" : -1;
    }

    at(e) {
      if ("media" === e) return this.media;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.media,
        parent: this,
        state: i
      }, "media") && ("walk" in this.media ? this.media.walk(e, i) : void 0);
    }

    toJSON() {
      return {
        type: this.type,
        media: this.media.toJSON(),
        before: this.before,
        after: this.after
      };
    }

    isMediaInParens() {
      return MediaInParens.isMediaInParens(this);
    }

    static isMediaInParens(e) {
      return !!e && e instanceof MediaInParens && e.type === exports.NodeType.MediaInParens;
    }

  }

  class MediaQueryWithType {
    constructor(e, t, i, a) {
      _defineProperty(this, "type", exports.NodeType.MediaQueryWithType);

      _defineProperty(this, "modifier", void 0);

      _defineProperty(this, "mediaType", void 0);

      _defineProperty(this, "and", void 0);

      _defineProperty(this, "media", void 0);

      this.modifier = e, this.mediaType = t, i && a && (this.and = i, this.media = a);
    }

    getModifier() {
      if (!this.modifier.length) return "";

      for (let e = 0; e < this.modifier.length; e++) {
        const t = this.modifier[e];
        if (t[0] === i$1.TokenType.Ident) return t[4].value;
      }

      return "";
    }

    negateQuery() {
      const e = new MediaQueryWithType([...this.modifier], [...this.mediaType], this.and, this.media);
      if (0 === e.modifier.length) return e.modifier = [[i$1.TokenType.Ident, "not", -1, -1, {
        value: "not"
      }], [i$1.TokenType.Whitespace, " ", -1, -1, void 0]], e;

      for (let t = 0; t < e.modifier.length; t++) {
        const a = e.modifier[t];

        if (a[0] === i$1.TokenType.Ident && "not" === toLowerCaseAZ(a[4].value)) {
          e.modifier.splice(t, 1);
          break;
        }

        if (a[0] === i$1.TokenType.Ident && "only" === toLowerCaseAZ(a[4].value)) {
          a[1] = "not", a[4].value = "not";
          break;
        }
      }

      return e;
    }

    getMediaType() {
      if (!this.mediaType.length) return "";

      for (let e = 0; e < this.mediaType.length; e++) {
        const t = this.mediaType[e];
        if (t[0] === i$1.TokenType.Ident) return t[4].value;
      }

      return "";
    }

    tokens() {
      return this.and && this.media ? [...this.modifier, ...this.mediaType, ...this.and, ...this.media.tokens()] : [...this.modifier, ...this.mediaType];
    }

    toString() {
      return this.and && this.media ? i$1.stringify(...this.modifier) + i$1.stringify(...this.mediaType) + i$1.stringify(...this.and) + this.media.toString() : i$1.stringify(...this.modifier) + i$1.stringify(...this.mediaType);
    }

    indexOf(e) {
      return e === this.media ? "media" : -1;
    }

    at(e) {
      if ("media" === e) return this.media;
    }

    walk(e, t) {
      let i;
      if (t && (i = { ...t
      }), this.media) return !1 !== e({
        node: this.media,
        parent: this,
        state: i
      }, "media") && this.media.walk(e, i);
    }

    toJSON() {
      return {
        type: this.type,
        string: this.toString(),
        modifier: this.modifier,
        mediaType: this.mediaType,
        and: this.and,
        media: this.media
      };
    }

    isMediaQueryWithType() {
      return MediaQueryWithType.isMediaQueryWithType(this);
    }

    static isMediaQueryWithType(e) {
      return !!e && e instanceof MediaQueryWithType && e.type === exports.NodeType.MediaQueryWithType;
    }

  }

  class MediaQueryWithoutType {
    constructor(e) {
      _defineProperty(this, "type", exports.NodeType.MediaQueryWithoutType);

      _defineProperty(this, "media", void 0);

      this.media = e;
    }

    negateQuery() {
      let e = this.media;
      if (e.media.type === exports.NodeType.MediaNot) return new MediaQueryWithoutType(new MediaCondition(e.media.media));
      e.media.type === exports.NodeType.MediaConditionListWithOr && (e = new MediaCondition(new MediaInParens(e, [[i$1.TokenType.Whitespace, " ", 0, 0, void 0], [i$1.TokenType.OpenParen, "(", 0, 0, void 0]], [[i$1.TokenType.CloseParen, ")", 0, 0, void 0]])));
      return new MediaQueryWithType([[i$1.TokenType.Ident, "not", 0, 0, {
        value: "not"
      }], [i$1.TokenType.Whitespace, " ", 0, 0, void 0]], [[i$1.TokenType.Ident, "all", 0, 0, {
        value: "all"
      }], [i$1.TokenType.Whitespace, " ", 0, 0, void 0]], [[i$1.TokenType.Ident, "and", 0, 0, {
        value: "and"
      }]], e);
    }

    tokens() {
      return this.media.tokens();
    }

    toString() {
      return this.media.toString();
    }

    indexOf(e) {
      return e === this.media ? "media" : -1;
    }

    at(e) {
      if ("media" === e) return this.media;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.media,
        parent: this,
        state: i
      }, "media") && this.media.walk(e, i);
    }

    toJSON() {
      return {
        type: this.type,
        string: this.toString(),
        media: this.media
      };
    }

    isMediaQueryWithoutType() {
      return MediaQueryWithoutType.isMediaQueryWithoutType(this);
    }

    static isMediaQueryWithoutType(e) {
      return !!e && e instanceof MediaQueryWithoutType && e.type === exports.NodeType.MediaQueryWithoutType;
    }

  }

  class MediaQueryInvalid {
    constructor(e) {
      _defineProperty(this, "type", exports.NodeType.MediaQueryInvalid);

      _defineProperty(this, "media", void 0);

      this.media = e;
    }

    negateQuery() {
      return new MediaQueryInvalid(this.media);
    }

    tokens() {
      return this.media.flatMap(e => e.tokens());
    }

    toString() {
      return this.media.map(e => e.toString()).join("");
    }

    walk(e, t) {
      let i = !1;
      if (this.media.forEach((a, r) => {
        if (i) return;
        let n;
        t && (n = { ...t
        }), !1 !== e({
          node: a,
          parent: this,
          state: n
        }, r) ? "walk" in a && !1 === a.walk(e, n) && (i = !0) : i = !0;
      }), i) return !1;
    }

    toJSON() {
      return {
        type: this.type,
        string: this.toString(),
        media: this.media
      };
    }

    isMediaQueryInvalid() {
      return MediaQueryInvalid.isMediaQueryInvalid(this);
    }

    static isMediaQueryInvalid(e) {
      return !!e && e instanceof MediaQueryInvalid && e.type === exports.NodeType.MediaQueryInvalid;
    }

  }

  class GeneralEnclosed {
    constructor(e) {
      _defineProperty(this, "type", exports.NodeType.GeneralEnclosed);

      _defineProperty(this, "value", void 0);

      this.value = e;
    }

    tokens() {
      return this.value.tokens();
    }

    toString() {
      return this.value.toString();
    }

    indexOf(e) {
      return e === this.value ? "value" : -1;
    }

    at(e) {
      if ("value" === e) return this.value;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.value,
        parent: this,
        state: i
      }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }

    toJSON() {
      return {
        type: this.type,
        tokens: this.tokens()
      };
    }

    isGeneralEnclosed() {
      return GeneralEnclosed.isGeneralEnclosed(this);
    }

    static isGeneralEnclosed(e) {
      return !!e && e instanceof GeneralEnclosed && e.type === exports.NodeType.GeneralEnclosed;
    }

  }

  class MediaAnd {
    constructor(e, t) {
      _defineProperty(this, "type", exports.NodeType.MediaAnd);

      _defineProperty(this, "modifier", void 0);

      _defineProperty(this, "media", void 0);

      this.modifier = e, this.media = t;
    }

    tokens() {
      return [...this.modifier, ...this.media.tokens()];
    }

    toString() {
      return i$1.stringify(...this.modifier) + this.media.toString();
    }

    indexOf(e) {
      return e === this.media ? "media" : -1;
    }

    at(e) {
      return "media" === e ? this.media : null;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.media,
        parent: this,
        state: i
      }, "media") && this.media.walk(e, i);
    }

    toJSON() {
      return {
        type: this.type,
        modifier: this.modifier,
        media: this.media.toJSON()
      };
    }

    isMediaAnd() {
      return MediaAnd.isMediaAnd(this);
    }

    static isMediaAnd(e) {
      return !!e && e instanceof MediaAnd && e.type === exports.NodeType.MediaAnd;
    }

  }

  class MediaConditionListWithAnd {
    constructor(e, t, i = [], a = []) {
      _defineProperty(this, "type", exports.NodeType.MediaConditionListWithAnd);

      _defineProperty(this, "leading", void 0);

      _defineProperty(this, "list", void 0);

      _defineProperty(this, "before", void 0);

      _defineProperty(this, "after", void 0);

      this.leading = e, this.list = t, this.before = i, this.after = a;
    }

    tokens() {
      return [...this.before, ...this.leading.tokens(), ...this.list.flatMap(e => e.tokens()), ...this.after];
    }

    toString() {
      return i$1.stringify(...this.before) + this.leading.toString() + this.list.map(e => e.toString()).join("") + i$1.stringify(...this.after);
    }

    indexOf(e) {
      return e === this.leading ? "leading" : "media-and" === e.type ? this.list.indexOf(e) : -1;
    }

    at(e) {
      return "leading" === e ? this.leading : "number" == typeof e ? (e < 0 && (e = this.list.length + e), this.list[e]) : void 0;
    }

    walk(e, t) {
      let i;
      if (t && (i = { ...t
      }), !1 === e({
        node: this.leading,
        parent: this,
        state: i
      }, "leading")) return !1;
      if ("walk" in this.leading && !1 === this.leading.walk(e, i)) return !1;
      let a = !1;
      return this.list.forEach((r, n) => {
        a || (t && (i = { ...t
        }), !1 !== e({
          node: r,
          parent: this,
          state: i
        }, n) ? "walk" in r && !1 === r.walk(e, i) && (a = !0) : a = !0);
      }), !a && void 0;
    }

    toJSON() {
      return {
        type: this.type,
        leading: this.leading.toJSON(),
        list: this.list.map(e => e.toJSON()),
        before: this.before,
        after: this.after
      };
    }

    isMediaConditionListWithAnd() {
      return MediaConditionListWithAnd.isMediaConditionListWithAnd(this);
    }

    static isMediaConditionListWithAnd(e) {
      return !!e && e instanceof MediaConditionListWithAnd && e.type === exports.NodeType.MediaConditionListWithAnd;
    }

  }

  class MediaConditionListWithOr {
    constructor(e, t, i = [], a = []) {
      _defineProperty(this, "type", exports.NodeType.MediaConditionListWithOr);

      _defineProperty(this, "leading", void 0);

      _defineProperty(this, "list", void 0);

      _defineProperty(this, "before", void 0);

      _defineProperty(this, "after", void 0);

      this.leading = e, this.list = t, this.before = i, this.after = a;
    }

    tokens() {
      return [...this.before, ...this.leading.tokens(), ...this.list.flatMap(e => e.tokens()), ...this.after];
    }

    toString() {
      return i$1.stringify(...this.before) + this.leading.toString() + this.list.map(e => e.toString()).join("") + i$1.stringify(...this.after);
    }

    indexOf(e) {
      return e === this.leading ? "leading" : "media-or" === e.type ? this.list.indexOf(e) : -1;
    }

    at(e) {
      return "leading" === e ? this.leading : "number" == typeof e ? (e < 0 && (e = this.list.length + e), this.list[e]) : void 0;
    }

    walk(e, t) {
      let i;
      if (t && (i = { ...t
      }), !1 === e({
        node: this.leading,
        parent: this,
        state: i
      }, "leading")) return !1;
      if ("walk" in this.leading && !1 === this.leading.walk(e, i)) return !1;
      let a = !1;
      return this.list.forEach((r, n) => {
        a || (t && (i = { ...t
        }), !1 !== e({
          node: r,
          parent: this,
          state: i
        }, n) ? "walk" in r && !1 === r.walk(e, i) && (a = !0) : a = !0);
      }), !a && void 0;
    }

    toJSON() {
      return {
        type: this.type,
        leading: this.leading.toJSON(),
        list: this.list.map(e => e.toJSON()),
        before: this.before,
        after: this.after
      };
    }

    isMediaConditionListWithOr() {
      return MediaConditionListWithOr.isMediaConditionListWithOr(this);
    }

    static isMediaConditionListWithOr(e) {
      return !!e && e instanceof MediaConditionListWithOr && e.type === exports.NodeType.MediaConditionListWithOr;
    }

  }

  function isNumber$7(e) {
    return !!(e.type === t.ComponentValueType.Token && e.value[0] === i$1.TokenType.Number || e.type === t.ComponentValueType.Function && r.has(toLowerCaseAZ(e.name[4].value)));
  }

  const r = new Set(["abs", "acos", "asin", "atan", "atan2", "calc", "clamp", "cos", "exp", "hypot", "log", "max", "min", "mod", "pow", "rem", "round", "sign", "sin", "sqrt", "tan"]);

  function isDimension(e) {
    return e.type === t.ComponentValueType.Token && e.value[0] === i$1.TokenType.Dimension;
  }

  function isIdent(e) {
    return e.type === t.ComponentValueType.Token && e.value[0] === i$1.TokenType.Ident;
  }

  function isEnvironmentVariable(e) {
    return e.type === t.ComponentValueType.Function && "env" === toLowerCaseAZ(e.name[4].value);
  }

  class MediaFeatureName$1 {
    constructor(e, t = [], i = []) {
      _defineProperty(this, "type", exports.NodeType.MediaFeatureName);

      _defineProperty(this, "name", void 0);

      _defineProperty(this, "before", void 0);

      _defineProperty(this, "after", void 0);

      this.name = e, this.before = t, this.after = i;
    }

    getName() {
      return this.name.value[4].value;
    }

    getNameToken() {
      return this.name.value;
    }

    tokens() {
      return [...this.before, ...this.name.tokens(), ...this.after];
    }

    toString() {
      return i$1.stringify(...this.before) + this.name.toString() + i$1.stringify(...this.after);
    }

    indexOf(e) {
      return e === this.name ? "name" : -1;
    }

    at(e) {
      if ("name" === e) return this.name;
    }

    toJSON() {
      return {
        type: this.type,
        name: this.getName(),
        tokens: this.tokens()
      };
    }

    isMediaFeatureName() {
      return MediaFeatureName$1.isMediaFeatureName(this);
    }

    static isMediaFeatureName(e) {
      return !!e && e instanceof MediaFeatureName$1 && e.type === exports.NodeType.MediaFeatureName;
    }

  }

  function parseMediaFeatureName(e) {
    let i = -1;

    for (let a = 0; a < e.length; a++) {
      const r = e[a];

      if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
        if (!isIdent(r)) return !1;
        if (-1 !== i) return !1;
        i = a;
      }
    }

    return -1 !== i && new MediaFeatureName$1(e[i], e.slice(0, i).flatMap(e => e.tokens()), e.slice(i + 1).flatMap(e => e.tokens()));
  }

  class MediaFeatureBoolean {
    constructor(e) {
      _defineProperty(this, "type", exports.NodeType.MediaFeatureBoolean);

      _defineProperty(this, "name", void 0);

      this.name = e;
    }

    getName() {
      return this.name.getName();
    }

    getNameToken() {
      return this.name.getNameToken();
    }

    tokens() {
      return this.name.tokens();
    }

    toString() {
      return this.name.toString();
    }

    indexOf(e) {
      return e === this.name ? "name" : -1;
    }

    at(e) {
      if ("name" === e) return this.name;
    }

    toJSON() {
      return {
        type: this.type,
        name: this.name.toJSON(),
        tokens: this.tokens()
      };
    }

    isMediaFeatureBoolean() {
      return MediaFeatureBoolean.isMediaFeatureBoolean(this);
    }

    static isMediaFeatureBoolean(e) {
      return !!e && e instanceof MediaFeatureBoolean && e.type === exports.NodeType.MediaFeatureBoolean;
    }

  }

  function parseMediaFeatureBoolean(e) {
    const t = parseMediaFeatureName(e);
    return !1 === t ? t : new MediaFeatureBoolean(t);
  }

  class MediaFeatureValue {
    constructor(e, t = [], i = []) {
      _defineProperty(this, "type", exports.NodeType.MediaFeatureValue);

      _defineProperty(this, "value", void 0);

      _defineProperty(this, "before", void 0);

      _defineProperty(this, "after", void 0);

      Array.isArray(e) && 1 === e.length ? this.value = e[0] : this.value = e, this.before = t, this.after = i;
    }

    tokens() {
      return Array.isArray(this.value) ? [...this.before, ...this.value.flatMap(e => e.tokens()), ...this.after] : [...this.before, ...this.value.tokens(), ...this.after];
    }

    toString() {
      return Array.isArray(this.value) ? i$1.stringify(...this.before) + this.value.map(e => e.toString()).join("") + i$1.stringify(...this.after) : i$1.stringify(...this.before) + this.value.toString() + i$1.stringify(...this.after);
    }

    indexOf(e) {
      return e === this.value ? "value" : -1;
    }

    at(e) {
      return "value" === e ? this.value : Array.isArray(this.value) && "number" == typeof e ? (e < 0 && (e = this.value.length + e), this.value[e]) : void 0;
    }

    walk(e, t) {
      if (Array.isArray(this.value)) {
        let i = !1;
        if (this.value.forEach((a, r) => {
          if (i) return;
          let n;
          t && (n = { ...t
          }), !1 !== e({
            node: a,
            parent: this,
            state: n
          }, r) ? "walk" in a && !1 === a.walk(e, n) && (i = !0) : i = !0;
        }), i) return !1;
      } else {
        let i;
        if (t && (i = { ...t
        }), !1 === e({
          node: this.value,
          parent: this,
          state: i
        }, "value")) return !1;
        if ("walk" in this.value) return this.value.walk(e, i);
      }
    }

    toJSON() {
      return Array.isArray(this.value) ? {
        type: this.type,
        value: this.value.map(e => e.toJSON()),
        tokens: this.tokens()
      } : {
        type: this.type,
        value: this.value.toJSON(),
        tokens: this.tokens()
      };
    }

    isMediaFeatureValue() {
      return MediaFeatureValue.isMediaFeatureValue(this);
    }

    static isMediaFeatureValue(e) {
      return !!e && e instanceof MediaFeatureValue && e.type === exports.NodeType.MediaFeatureValue;
    }

  }

  function parseMediaFeatureValue(e) {
    let i = -1,
        a = -1;

    for (let r = 0; r < e.length; r++) {
      const n = e[r];

      if (n.type !== t.ComponentValueType.Whitespace && n.type !== t.ComponentValueType.Comment) {
        if (-1 !== i) return !1;

        if (isNumber$7(n)) {
          const t = matchesRatioExactly$1(e.slice(r));

          if (-1 !== t) {
            i = t[0] + r, a = t[1] + r, r += t[1] - t[0];
            continue;
          }

          i = r, a = r;
        } else if (isEnvironmentVariable(n)) i = r, a = r;else if (isDimension(n)) i = r, a = r;else {
          if (!isIdent(n)) return !1;
          i = r, a = r;
        }
      }
    }

    return -1 !== i && new MediaFeatureValue(e.slice(i, a + 1), e.slice(0, i).flatMap(e => e.tokens()), e.slice(a + 1).flatMap(e => e.tokens()));
  }

  function matchesRatioExactly$1(e) {
    let t = -1,
        i = -1;
    const a = matchesRatio(e);
    if (-1 === a) return -1;
    t = a[0], i = a[1];

    for (let t = i + 1; t < e.length; t++) {
      const i = e[t];
      if ("whitespace" !== i.type && "comment" !== i.type) return -1;
    }

    return [t, i];
  }

  function matchesRatio(e) {
    let t = -1,
        a = -1;

    for (let r = 0; r < e.length; r++) {
      const n = e[r];

      if ("whitespace" !== n.type && "comment" !== n.type) {
        if ("token" === n.type) {
          const e = n.value;

          if (e[0] === i$1.TokenType.Delim && "/" === e[4].value) {
            if (-1 === t) return -1;
            if (-1 !== a) return -1;
            a = r;
            continue;
          }
        }

        if (!isNumber$7(n)) return -1;
        if (-1 !== a) return [t, r];
        if (-1 !== t) return -1;
        t = r;
      }
    }

    return -1;
  }

  class MediaFeaturePlain {
    constructor(e, t, i) {
      _defineProperty(this, "type", exports.NodeType.MediaFeaturePlain);

      _defineProperty(this, "name", void 0);

      _defineProperty(this, "colon", void 0);

      _defineProperty(this, "value", void 0);

      this.name = e, this.colon = t, this.value = i;
    }

    getName() {
      return this.name.getName();
    }

    getNameToken() {
      return this.name.getNameToken();
    }

    tokens() {
      return [...this.name.tokens(), this.colon, ...this.value.tokens()];
    }

    toString() {
      return this.name.toString() + i$1.stringify(this.colon) + this.value.toString();
    }

    indexOf(e) {
      return e === this.name ? "name" : e === this.value ? "value" : -1;
    }

    at(e) {
      return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.value,
        parent: this,
        state: i
      }, "value") && this.value.walk(e, i);
    }

    toJSON() {
      return {
        type: this.type,
        name: this.name.toJSON(),
        value: this.value.toJSON(),
        tokens: this.tokens()
      };
    }

    isMediaFeaturePlain() {
      return MediaFeaturePlain.isMediaFeaturePlain(this);
    }

    static isMediaFeaturePlain(e) {
      return !!e && e instanceof MediaFeaturePlain && e.type === exports.NodeType.MediaFeaturePlain;
    }

  }

  function parseMediaFeaturePlain(e) {
    let a = [],
        r = [],
        n = null;

    for (let o = 0; o < e.length; o++) {
      const s = e[o];

      if (s.type === t.ComponentValueType.Token) {
        const t = s.value;

        if (t[0] === i$1.TokenType.Colon) {
          a = e.slice(0, o), r = e.slice(o + 1), n = t;
          break;
        }
      }
    }

    if (!a.length || !r.length || !n) return !1;
    const o = parseMediaFeatureName(a);
    if (!1 === o) return !1;
    const s = parseMediaFeatureValue(r);
    return !1 !== s && new MediaFeaturePlain(o, n, s);
  }

  var n, o;

  function matchesComparison(e) {
    let a = -1;

    for (let r = 0; r < e.length; r++) {
      const n = e[r];

      if (n.type === t.ComponentValueType.Token) {
        const e = n.value;

        if (e[0] === i$1.TokenType.Delim) {
          if (e[4].value === exports.MediaFeatureEQ.EQ) return -1 !== a ? [a, r] : [r, r];

          if (e[4].value === exports.MediaFeatureLT.LT) {
            a = r;
            continue;
          }

          if (e[4].value === exports.MediaFeatureGT.GT) {
            a = r;
            continue;
          }
        }
      }

      break;
    }

    return -1 !== a && [a, a];
  }

  function comparisonFromTokens(e) {
    if (0 === e.length || e.length > 2) return !1;
    if (e[0][0] !== i$1.TokenType.Delim) return !1;
    if (1 === e.length) switch (e[0][4].value) {
      case exports.MediaFeatureEQ.EQ:
        return exports.MediaFeatureEQ.EQ;

      case exports.MediaFeatureLT.LT:
        return exports.MediaFeatureLT.LT;

      case exports.MediaFeatureGT.GT:
        return exports.MediaFeatureGT.GT;

      default:
        return !1;
    }
    if (e[1][0] !== i$1.TokenType.Delim) return !1;
    if (e[1][4].value !== exports.MediaFeatureEQ.EQ) return !1;

    switch (e[0][4].value) {
      case exports.MediaFeatureLT.LT:
        return exports.MediaFeatureLT.LT_OR_EQ;

      case exports.MediaFeatureGT.GT:
        return exports.MediaFeatureGT.GT_OR_EQ;

      default:
        return !1;
    }
  }

  exports.MediaFeatureLT = void 0, (n = exports.MediaFeatureLT || (exports.MediaFeatureLT = {})).LT = "<", n.LT_OR_EQ = "<=", exports.MediaFeatureGT = void 0, (o = exports.MediaFeatureGT || (exports.MediaFeatureGT = {})).GT = ">", o.GT_OR_EQ = ">=", exports.MediaFeatureEQ = void 0, (exports.MediaFeatureEQ || (exports.MediaFeatureEQ = {})).EQ = "=";

  class MediaFeatureRangeNameValue$1 {
    constructor(e, t, i) {
      _defineProperty(this, "type", exports.NodeType.MediaFeatureRangeNameValue);

      _defineProperty(this, "name", void 0);

      _defineProperty(this, "operator", void 0);

      _defineProperty(this, "value", void 0);

      this.name = e, this.operator = t, this.value = i;
    }

    operatorKind() {
      return comparisonFromTokens(this.operator);
    }

    getName() {
      return this.name.getName();
    }

    getNameToken() {
      return this.name.getNameToken();
    }

    tokens() {
      return [...this.name.tokens(), ...this.operator, ...this.value.tokens()];
    }

    toString() {
      return this.name.toString() + i$1.stringify(...this.operator) + this.value.toString();
    }

    indexOf(e) {
      return e === this.name ? "name" : e === this.value ? "value" : -1;
    }

    at(e) {
      return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.value,
        parent: this,
        state: i
      }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }

    toJSON() {
      return {
        type: this.type,
        name: this.name.toJSON(),
        value: this.value.toJSON(),
        tokens: this.tokens()
      };
    }

    isMediaFeatureRangeNameValue() {
      return MediaFeatureRangeNameValue$1.isMediaFeatureRangeNameValue(this);
    }

    static isMediaFeatureRangeNameValue(e) {
      return !!e && e instanceof MediaFeatureRangeNameValue$1 && e.type === exports.NodeType.MediaFeatureRangeNameValue;
    }

  }

  class MediaFeatureRangeValueName {
    constructor(e, t, i) {
      _defineProperty(this, "type", exports.NodeType.MediaFeatureRangeValueName);

      _defineProperty(this, "name", void 0);

      _defineProperty(this, "operator", void 0);

      _defineProperty(this, "value", void 0);

      this.name = e, this.operator = t, this.value = i;
    }

    operatorKind() {
      return comparisonFromTokens(this.operator);
    }

    getName() {
      return this.name.getName();
    }

    getNameToken() {
      return this.name.getNameToken();
    }

    tokens() {
      return [...this.value.tokens(), ...this.operator, ...this.name.tokens()];
    }

    toString() {
      return this.value.toString() + i$1.stringify(...this.operator) + this.name.toString();
    }

    indexOf(e) {
      return e === this.name ? "name" : e === this.value ? "value" : -1;
    }

    at(e) {
      return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.value,
        parent: this,
        state: i
      }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }

    toJSON() {
      return {
        type: this.type,
        name: this.name.toJSON(),
        value: this.value.toJSON(),
        tokens: this.tokens()
      };
    }

    isMediaFeatureRangeValueName() {
      return MediaFeatureRangeValueName.isMediaFeatureRangeValueName(this);
    }

    static isMediaFeatureRangeValueName(e) {
      return !!e && e instanceof MediaFeatureRangeValueName && e.type === exports.NodeType.MediaFeatureRangeValueName;
    }

  }

  class MediaFeatureRangeValueNameValue {
    constructor(e, t, i, a, r) {
      _defineProperty(this, "type", exports.NodeType.MediaFeatureRangeValueNameValue);

      _defineProperty(this, "name", void 0);

      _defineProperty(this, "valueOne", void 0);

      _defineProperty(this, "valueOneOperator", void 0);

      _defineProperty(this, "valueTwo", void 0);

      _defineProperty(this, "valueTwoOperator", void 0);

      this.name = e, this.valueOne = t, this.valueOneOperator = i, this.valueTwo = a, this.valueTwoOperator = r;
    }

    valueOneOperatorKind() {
      return comparisonFromTokens(this.valueOneOperator);
    }

    valueTwoOperatorKind() {
      return comparisonFromTokens(this.valueTwoOperator);
    }

    getName() {
      return this.name.getName();
    }

    getNameToken() {
      return this.name.getNameToken();
    }

    tokens() {
      return [...this.valueOne.tokens(), ...this.valueOneOperator, ...this.name.tokens(), ...this.valueTwoOperator, ...this.valueTwo.tokens()];
    }

    toString() {
      return this.valueOne.toString() + i$1.stringify(...this.valueOneOperator) + this.name.toString() + i$1.stringify(...this.valueTwoOperator) + this.valueTwo.toString();
    }

    indexOf(e) {
      return e === this.name ? "name" : e === this.valueOne ? "valueOne" : e === this.valueTwo ? "valueTwo" : -1;
    }

    at(e) {
      return "name" === e ? this.name : "valueOne" === e ? this.valueOne : "valueTwo" === e ? this.valueTwo : void 0;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.valueOne,
        parent: this,
        state: i
      }, "valueOne") && (!("walk" in this.valueOne) || !1 !== this.valueOne.walk(e, i)) && (t && (i = { ...t
      }), !1 !== e({
        node: this.valueTwo,
        parent: this,
        state: i
      }, "valueTwo") && (!("walk" in this.valueTwo) || !1 !== this.valueTwo.walk(e, i)) && void 0);
    }

    toJSON() {
      return {
        type: this.type,
        name: this.name.toJSON(),
        valueOne: this.valueOne.toJSON(),
        valueTwo: this.valueTwo.toJSON(),
        tokens: this.tokens()
      };
    }

    isMediaFeatureRangeValueNameValue() {
      return MediaFeatureRangeValueNameValue.isMediaFeatureRangeValueNameValue(this);
    }

    static isMediaFeatureRangeValueNameValue(e) {
      return !!e && e instanceof MediaFeatureRangeValueNameValue && e.type === exports.NodeType.MediaFeatureRangeValueNameValue;
    }

  }

  function parseMediaFeatureRange(e) {
    let a = !1,
        r = !1;

    for (let n = 0; n < e.length; n++) {
      const o = e[n];

      if (o.type === t.ComponentValueType.Token) {
        if (o.value[0] === i$1.TokenType.Delim) {
          const t = matchesComparison(e.slice(n));

          if (!1 !== t) {
            if (!1 !== a) {
              r = [t[0] + n, t[1] + n];
              break;
            }

            a = [t[0] + n, t[1] + n], n += t[1];
          }
        }
      }
    }

    if (!1 === a) return !1;
    const n = [e[a[0]].value];

    if (a[0] !== a[1] && n.push(e[a[1]].value), !1 === r) {
      const t = e.slice(0, a[0]),
            i = e.slice(a[1] + 1),
            r = parseMediaFeatureName(t),
            o = parseMediaFeatureName(i);
      if (!r && !o) return !1;

      if (r && !o || r && s$1.has(toLowerCaseAZ(r.getName()))) {
        const e = parseMediaFeatureValue(i);
        return !!e && new MediaFeatureRangeNameValue$1(r, n, e);
      }

      if (!r && o || o && s$1.has(toLowerCaseAZ(o.getName()))) {
        const e = parseMediaFeatureValue(t);
        return !!e && new MediaFeatureRangeValueName(o, n, e);
      }

      return !1;
    }

    const o = [e[r[0]].value];
    r[0] !== r[1] && o.push(e[r[1]].value);
    const u = e.slice(0, a[0]),
          d = e.slice(a[1] + 1, r[0]),
          l = e.slice(r[1] + 1),
          p = parseMediaFeatureValue(u),
          h = parseMediaFeatureName(d),
          m = parseMediaFeatureValue(l);
    if (!p || !h || !m) return !1;
    {
      const e = comparisonFromTokens(n);
      if (!1 === e || e === exports.MediaFeatureEQ.EQ) return !1;
      const t = comparisonFromTokens(o);
      if (!1 === t || t === exports.MediaFeatureEQ.EQ) return !1;
      if (!(e !== exports.MediaFeatureLT.LT && e !== exports.MediaFeatureLT.LT_OR_EQ || t !== exports.MediaFeatureGT.GT && t !== exports.MediaFeatureGT.GT_OR_EQ)) return !1;
      if (!(e !== exports.MediaFeatureGT.GT && e !== exports.MediaFeatureGT.GT_OR_EQ || t !== exports.MediaFeatureLT.LT && t !== exports.MediaFeatureLT.LT_OR_EQ)) return !1;
    }
    return new MediaFeatureRangeValueNameValue(h, p, n, m, o);
  }

  const s$1 = new Set(["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "dynamic-range", "environment-blending", "forced-colors", "grid", "height", "horizontal-viewport-segments", "hover", "inverted-colors", "monochrome", "nav-controls", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-data", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "vertical-viewport-segments", "video-color-gamut", "video-dynamic-range", "width"]);

  class MediaFeature {
    constructor(e, t = [], i = []) {
      _defineProperty(this, "type", exports.NodeType.MediaFeature);

      _defineProperty(this, "feature", void 0);

      _defineProperty(this, "before", void 0);

      _defineProperty(this, "after", void 0);

      this.feature = e, this.before = t, this.after = i;
    }

    getName() {
      return this.feature.getName();
    }

    getNameToken() {
      return this.feature.getNameToken();
    }

    tokens() {
      return [...this.before, ...this.feature.tokens(), ...this.after];
    }

    toString() {
      return i$1.stringify(...this.before) + this.feature.toString() + i$1.stringify(...this.after);
    }

    indexOf(e) {
      return e === this.feature ? "feature" : -1;
    }

    at(e) {
      if ("feature" === e) return this.feature;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.feature,
        parent: this,
        state: i
      }, "feature") && ("walk" in this.feature ? this.feature.walk(e, i) : void 0);
    }

    toJSON() {
      return {
        type: this.type,
        feature: this.feature.toJSON(),
        before: this.before,
        after: this.after
      };
    }

    isMediaFeature() {
      return MediaFeature.isMediaFeature(this);
    }

    static isMediaFeature(e) {
      return !!e && e instanceof MediaFeature && e.type === exports.NodeType.MediaFeature;
    }

  }

  function parseMediaFeature(e, t = [], a = []) {
    if (e.startToken[0] !== i$1.TokenType.OpenParen) return !1;
    const r = parseMediaFeatureBoolean(e.value);
    if (!1 !== r) return new MediaFeature(r, t, a);
    const n = parseMediaFeaturePlain(e.value);
    if (!1 !== n) return new MediaFeature(n, t, a);
    const o = parseMediaFeatureRange(e.value);
    return !1 !== o && new MediaFeature(o, t, a);
  }

  class MediaNot {
    constructor(e, t) {
      _defineProperty(this, "type", exports.NodeType.MediaNot);

      _defineProperty(this, "modifier", void 0);

      _defineProperty(this, "media", void 0);

      this.modifier = e, this.media = t;
    }

    tokens() {
      return [...this.modifier, ...this.media.tokens()];
    }

    toString() {
      return i$1.stringify(...this.modifier) + this.media.toString();
    }

    indexOf(e) {
      return e === this.media ? "media" : -1;
    }

    at(e) {
      if ("media" === e) return this.media;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.media,
        parent: this,
        state: i
      }, "media") && this.media.walk(e, i);
    }

    toJSON() {
      return {
        type: this.type,
        modifier: this.modifier,
        media: this.media.toJSON()
      };
    }

    isMediaNot() {
      return MediaNot.isMediaNot(this);
    }

    static isMediaNot(e) {
      return !!e && e instanceof MediaNot && e.type === exports.NodeType.MediaNot;
    }

  }

  class MediaOr {
    constructor(e, t) {
      _defineProperty(this, "type", exports.NodeType.MediaOr);

      _defineProperty(this, "modifier", void 0);

      _defineProperty(this, "media", void 0);

      this.modifier = e, this.media = t;
    }

    tokens() {
      return [...this.modifier, ...this.media.tokens()];
    }

    toString() {
      return i$1.stringify(...this.modifier) + this.media.toString();
    }

    indexOf(e) {
      return e === this.media ? "media" : -1;
    }

    at(e) {
      if ("media" === e) return this.media;
    }

    walk(e, t) {
      let i;
      return t && (i = { ...t
      }), !1 !== e({
        node: this.media,
        parent: this,
        state: i
      }, "media") && this.media.walk(e, i);
    }

    toJSON() {
      return {
        type: this.type,
        modifier: this.modifier,
        media: this.media.toJSON()
      };
    }

    isMediaOr() {
      return MediaOr.isMediaOr(this);
    }

    static isMediaOr(e) {
      return !!e && e instanceof MediaOr && e.type === exports.NodeType.MediaOr;
    }

  }

  var u, d$1;

  function modifierFromToken(e) {
    if (e[0] !== i$1.TokenType.Ident) return !1;

    switch (toLowerCaseAZ(e[4].value)) {
      case exports.MediaQueryModifier.Not:
        return exports.MediaQueryModifier.Not;

      case exports.MediaQueryModifier.Only:
        return exports.MediaQueryModifier.Only;

      default:
        return !1;
    }
  }

  function parseMediaQuery$1(e) {
    {
      const t = parseMediaCondition(e);
      if (!1 !== t) return new MediaQueryWithoutType(t);
    }
    {
      let a = -1,
          r = -1,
          n = -1;

      for (let o = 0; o < e.length; o++) {
        const s = e[o];

        if (!t.isWhitespaceNode(s) && !t.isCommentNode(s)) {
          if (t.isTokenNode(s)) {
            const t = s.value;

            if (-1 === a && t[0] === i$1.TokenType.Ident && modifierFromToken(t)) {
              a = o;
              continue;
            }

            if (-1 === r && t[0] === i$1.TokenType.Ident && !modifierFromToken(t)) {
              r = o;
              continue;
            }

            if (-1 === n && t[0] === i$1.TokenType.Ident && "and" === toLowerCaseAZ(t[4].value)) {
              n = o;
              if (!1 === parseMediaConditionWithoutOr(e.slice(o + 1))) return !1;
              break;
            }

            return !1;
          }

          return !1;
        }
      }

      let o = [],
          s = [];
      -1 !== a ? (o = e.slice(0, a + 1).flatMap(e => e.tokens()), -1 !== r && (s = e.slice(a + 1, r + 1).flatMap(e => e.tokens()))) : -1 !== r && (s = e.slice(0, r + 1).flatMap(e => e.tokens()));
      const u = parseMediaConditionWithoutOr(e.slice(Math.max(a, r, n) + 1));
      return !1 === u ? new MediaQueryWithType(o, [...s, ...e.slice(r + 1).flatMap(e => e.tokens())]) : new MediaQueryWithType(o, s, e.slice(r + 1, n + 1).flatMap(e => e.tokens()), u);
    }
  }

  function parseMediaConditionListWithOr(e) {
    let i = !1;
    const a = [];
    let r = -1,
        n = -1;

    for (let o = 0; o < e.length; o++) {
      if (i) {
        const t = parseMediaOr(e.slice(o));

        if (!1 !== t) {
          o += t.advance, a.push(t.node), n = o;
          continue;
        }
      }

      const s = e[o];

      if (s.type !== t.ComponentValueType.Whitespace && s.type !== t.ComponentValueType.Comment) {
        if (i) return !1;
        if (!1 !== i || !t.isSimpleBlockNode(s)) return !1;
        if (s.normalize(), i = parseMediaInParensFromSimpleBlock(s), !1 === i) return !1;
        r = o;
      }
    }

    return !(!i || !a.length) && new MediaConditionListWithOr(i, a, e.slice(0, r).flatMap(e => e.tokens()), e.slice(n + 1).flatMap(e => e.tokens()));
  }

  function parseMediaConditionListWithAnd(e) {
    let i = !1;
    const a = [];
    let r = -1,
        n = -1;

    for (let o = 0; o < e.length; o++) {
      if (i) {
        const t = parseMediaAnd(e.slice(o));

        if (!1 !== t) {
          o += t.advance, a.push(t.node), n = o;
          continue;
        }
      }

      const s = e[o];

      if (s.type !== t.ComponentValueType.Whitespace && s.type !== t.ComponentValueType.Comment) {
        if (i) return !1;
        if (!1 !== i || !t.isSimpleBlockNode(s)) return !1;
        if (s.normalize(), i = parseMediaInParensFromSimpleBlock(s), !1 === i) return !1;
        r = o;
      }
    }

    return !(!i || !a.length) && new MediaConditionListWithAnd(i, a, e.slice(0, r).flatMap(e => e.tokens()), e.slice(n + 1).flatMap(e => e.tokens()));
  }

  function parseMediaCondition(e) {
    const t = parseMediaNot(e);
    if (!1 !== t) return new MediaCondition(t);
    const i = parseMediaConditionListWithAnd(e);
    if (!1 !== i) return new MediaCondition(i);
    const a = parseMediaConditionListWithOr(e);
    if (!1 !== a) return new MediaCondition(a);
    const r = parseMediaInParens(e);
    return !1 !== r && new MediaCondition(r);
  }

  function parseMediaConditionWithoutOr(e) {
    const t = parseMediaNot(e);
    if (!1 !== t) return new MediaCondition(t);
    const i = parseMediaConditionListWithAnd(e);
    if (!1 !== i) return new MediaCondition(i);
    const a = parseMediaInParens(e);
    return !1 !== a && new MediaCondition(a);
  }

  function parseMediaInParens(e) {
    let a = -1;

    for (let i = 0; i < e.length; i++) {
      const r = e[i];

      if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
        if (!t.isSimpleBlockNode(r)) return !1;
        if (-1 !== a) return !1;
        a = i;
      }
    }

    if (-1 === a) return !1;
    const r = e[a];
    if (r.startToken[0] !== i$1.TokenType.OpenParen) return !1;
    r.normalize();
    const n = [...e.slice(0, a).flatMap(e => e.tokens()), r.startToken],
          o = [r.endToken, ...e.slice(a + 1).flatMap(e => e.tokens())],
          s = parseMediaFeature(r, n, o);
    if (!1 !== s) return new MediaInParens(s);
    const u = parseMediaCondition(r.value);
    return !1 !== u ? new MediaInParens(u, n, o) : new MediaInParens(new GeneralEnclosed(r), e.slice(0, a).flatMap(e => e.tokens()), e.slice(a + 1).flatMap(e => e.tokens()));
  }

  function parseMediaInParensFromSimpleBlock(e) {
    if (e.startToken[0] !== i$1.TokenType.OpenParen) return !1;
    const t = parseMediaFeature(e, [e.startToken], [e.endToken]);
    if (!1 !== t) return new MediaInParens(t);
    const a = parseMediaCondition(e.value);
    return !1 !== a ? new MediaInParens(a, [e.startToken], [e.endToken]) : new MediaInParens(new GeneralEnclosed(e));
  }

  function parseMediaNot(e) {
    let i = !1,
        a = null;

    for (let r = 0; r < e.length; r++) {
      const n = e[r];

      if (n.type !== t.ComponentValueType.Whitespace && n.type !== t.ComponentValueType.Comment) {
        if (isIdent(n)) {
          if ("not" === toLowerCaseAZ(n.value[4].value)) {
            if (i) return !1;
            i = !0;
            continue;
          }

          return !1;
        }

        if (!i || !t.isSimpleBlockNode(n)) return !1;
        {
          n.normalize();
          const t = parseMediaInParensFromSimpleBlock(n);
          if (!1 === t) return !1;
          a = new MediaNot(e.slice(0, r).flatMap(e => e.tokens()), t);
        }
      }
    }

    return a || !1;
  }

  function parseMediaOr(e) {
    let i = !1;

    for (let a = 0; a < e.length; a++) {
      const r = e[a];

      if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
        if (isIdent(r)) {
          if ("or" === toLowerCaseAZ(r.value[4].value)) {
            if (i) return !1;
            i = !0;
            continue;
          }

          return !1;
        }

        if (i && t.isSimpleBlockNode(r)) {
          r.normalize();
          const t = parseMediaInParensFromSimpleBlock(r);
          return !1 !== t && {
            advance: a,
            node: new MediaOr(e.slice(0, a).flatMap(e => e.tokens()), t)
          };
        }

        return !1;
      }
    }

    return !1;
  }

  function parseMediaAnd(e) {
    let i = !1;

    for (let a = 0; a < e.length; a++) {
      const r = e[a];

      if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
        if (isIdent(r)) {
          if ("and" === toLowerCaseAZ(r.value[4].value)) {
            if (i) return !1;
            i = !0;
            continue;
          }

          return !1;
        }

        if (i && t.isSimpleBlockNode(r)) {
          r.normalize();
          const t = parseMediaInParensFromSimpleBlock(r);
          return !1 !== t && {
            advance: a,
            node: new MediaAnd(e.slice(0, a).flatMap(e => e.tokens()), t)
          };
        }

        return !1;
      }
    }

    return !1;
  }

  function parseFromTokens$3(e, i) {
    const a = t.parseCommaSeparatedListOfComponentValues(e, {
      onParseError: null == i ? void 0 : i.onParseError
    });
    return a.map((e, t) => {
      const r = parseMediaQuery$1(e);
      return 0 == r && !0 === (null == i ? void 0 : i.preserveInvalidMediaQueries) ? new MediaQueryInvalid(a[t]) : r;
    }).filter(e => !!e);
  }

  exports.MediaQueryModifier = void 0, (u = exports.MediaQueryModifier || (exports.MediaQueryModifier = {})).Not = "not", u.Only = "only";

  class CustomMedia {
    constructor(e, t, i) {
      _defineProperty(this, "type", exports.NodeType.CustomMedia);

      _defineProperty(this, "name", void 0);

      _defineProperty(this, "mediaQueryList", null);

      _defineProperty(this, "trueOrFalseKeyword", null);

      this.name = e, this.mediaQueryList = t, this.trueOrFalseKeyword = i ?? null;
    }

    getName() {
      for (let e = 0; e < this.name.length; e++) {
        const t = this.name[e];
        if (t[0] === i$1.TokenType.Ident) return t[4].value;
      }

      return "";
    }

    getNameToken() {
      for (let e = 0; e < this.name.length; e++) {
        const t = this.name[e];
        if (t[0] === i$1.TokenType.Ident) return t;
      }

      return null;
    }

    hasMediaQueryList() {
      return !!this.mediaQueryList;
    }

    hasTrueKeyword() {
      if (!this.trueOrFalseKeyword) return !1;

      for (let e = 0; e < this.trueOrFalseKeyword.length; e++) {
        const t = this.trueOrFalseKeyword[e];
        if (t[0] !== i$1.TokenType.Comment && t[0] !== i$1.TokenType.Whitespace) return t[0] === i$1.TokenType.Ident && "true" === toLowerCaseAZ(t[4].value);
      }

      return !1;
    }

    hasFalseKeyword() {
      if (!this.trueOrFalseKeyword) return !1;

      for (let e = 0; e < this.trueOrFalseKeyword.length; e++) {
        const t = this.trueOrFalseKeyword[e];
        if (t[0] !== i$1.TokenType.Comment && t[0] !== i$1.TokenType.Whitespace) return t[0] === i$1.TokenType.Ident && "false" === toLowerCaseAZ(t[4].value);
      }

      return !1;
    }

    tokens() {
      if (this.trueOrFalseKeyword) return [...this.name, ...this.trueOrFalseKeyword];
      if (!this.mediaQueryList) return [...this.name];
      const e = [];

      for (let t = 0; t < this.mediaQueryList.length; t++) {
        const a = this.mediaQueryList[t];
        0 !== t && e.push([i$1.TokenType.Comma, ",", -1, -1, void 0]), e.push(...a.tokens());
      }

      return [...this.name, ...e];
    }

    toString() {
      return i$1.stringify(...this.tokens());
    }

    toJSON() {
      var e;
      return {
        type: this.type,
        string: this.toString(),
        nameValue: this.getName(),
        name: this.name,
        hasFalseKeyword: this.hasFalseKeyword(),
        hasTrueKeyword: this.hasTrueKeyword(),
        trueOrFalseKeyword: this.trueOrFalseKeyword,
        mediaQueryList: null == (e = this.mediaQueryList) ? void 0 : e.map(e => e.toJSON())
      };
    }

    isCustomMedia() {
      return CustomMedia.isCustomMedia(this);
    }

    static isCustomMedia(e) {
      return !!e && e instanceof CustomMedia && e.type === exports.NodeType.CustomMedia;
    }

  }

  function parseCustomMediaFromTokens(e, t) {
    let a = [],
        r = e;

    for (let t = 0; t < e.length; t++) if (e[t][0] !== i$1.TokenType.Comment && e[t][0] !== i$1.TokenType.Whitespace) {
      if (e[t][0] === i$1.TokenType.Ident) {
        if (e[t][4].value.startsWith("--")) {
          a = e.slice(0, t + 1), r = e.slice(t + 1);
          break;
        }
      }

      return !1;
    }

    let n = !0;

    for (let e = 0; e < r.length; e++) if (r[e][0] !== i$1.TokenType.Comment && r[e][0] !== i$1.TokenType.Whitespace) {
      if (r[e][0] === i$1.TokenType.Ident) {
        const t = toLowerCaseAZ(r[e][4].value);
        if ("false" === t) continue;
        if ("true" === t) continue;
      }

      if (r[e][0] === i$1.TokenType.EOF) break;
      n = !1;
    }

    return n ? new CustomMedia(a, null, r) : new CustomMedia(a, parseFromTokens$3(i$1.cloneTokens(r), t));
  }

  function isMediaConditionListWithAnd(e) {
    return MediaConditionListWithAnd.isMediaConditionListWithAnd(e);
  }

  function isMediaConditionListWithOr(e) {
    return MediaConditionListWithOr.isMediaConditionListWithOr(e);
  }

  function isMediaFeatureRangeNameValue(e) {
    return MediaFeatureRangeNameValue$1.isMediaFeatureRangeNameValue(e);
  }

  function isMediaFeatureRangeValueName(e) {
    return MediaFeatureRangeValueName.isMediaFeatureRangeValueName(e);
  }

  function isMediaFeatureRangeValueNameValue(e) {
    return MediaFeatureRangeValueNameValue.isMediaFeatureRangeValueNameValue(e);
  }

  function isMediaQueryWithType(e) {
    return MediaQueryWithType.isMediaQueryWithType(e);
  }

  function isMediaQueryWithoutType(e) {
    return MediaQueryWithoutType.isMediaQueryWithoutType(e);
  }

  function isMediaQueryInvalid$6(e) {
    return MediaQueryInvalid.isMediaQueryInvalid(e);
  }

  exports.MediaType = void 0, (d$1 = exports.MediaType || (exports.MediaType = {})).All = "all", d$1.Print = "print", d$1.Screen = "screen", d$1.Tty = "tty", d$1.Tv = "tv", d$1.Projection = "projection", d$1.Handheld = "handheld", d$1.Braille = "braille", d$1.Embossed = "embossed", d$1.Aural = "aural", d$1.Speech = "speech", exports.CustomMedia = CustomMedia, exports.GeneralEnclosed = GeneralEnclosed, exports.MediaAnd = MediaAnd, exports.MediaCondition = MediaCondition, exports.MediaConditionListWithAnd = MediaConditionListWithAnd, exports.MediaConditionListWithOr = MediaConditionListWithOr, exports.MediaFeature = MediaFeature, exports.MediaFeatureBoolean = MediaFeatureBoolean, exports.MediaFeatureName = MediaFeatureName$1, exports.MediaFeaturePlain = MediaFeaturePlain, exports.MediaFeatureRangeNameValue = MediaFeatureRangeNameValue$1, exports.MediaFeatureRangeValueName = MediaFeatureRangeValueName, exports.MediaFeatureRangeValueNameValue = MediaFeatureRangeValueNameValue, exports.MediaFeatureValue = MediaFeatureValue, exports.MediaInParens = MediaInParens, exports.MediaNot = MediaNot, exports.MediaOr = MediaOr, exports.MediaQueryInvalid = MediaQueryInvalid, exports.MediaQueryWithType = MediaQueryWithType, exports.MediaQueryWithoutType = MediaQueryWithoutType, exports.cloneMediaQuery = function cloneMediaQuery(e) {
    const t = i$1.cloneTokens(e.tokens()),
          a = parseFromTokens$3(t, {
      preserveInvalidMediaQueries: !0
    })[0];
    if (!a) throw new Error(`Failed to clone media query for : "${i$1.stringify(...t)}"`);
    if (isMediaQueryInvalid$6(e) && isMediaQueryInvalid$6(a)) return a;
    if (isMediaQueryWithType(e) && isMediaQueryWithType(a)) return a;
    if (isMediaQueryWithoutType(e) && isMediaQueryWithoutType(a)) return a;
    throw new Error(`Failed to clone media query for : "${i$1.stringify(...t)}"`);
  }, exports.comparisonFromTokens = comparisonFromTokens, exports.invertComparison = function invertComparison(e) {
    switch (e) {
      case exports.MediaFeatureEQ.EQ:
        return exports.MediaFeatureEQ.EQ;

      case exports.MediaFeatureLT.LT:
        return exports.MediaFeatureGT.GT;

      case exports.MediaFeatureLT.LT_OR_EQ:
        return exports.MediaFeatureGT.GT_OR_EQ;

      case exports.MediaFeatureGT.GT:
        return exports.MediaFeatureLT.LT;

      case exports.MediaFeatureGT.GT_OR_EQ:
        return exports.MediaFeatureLT.LT_OR_EQ;

      default:
        return !1;
    }
  }, exports.isCustomMedia = function isCustomMedia(e) {
    return CustomMedia.isCustomMedia(e);
  }, exports.isGeneralEnclosed = function isGeneralEnclosed(e) {
    return GeneralEnclosed.isGeneralEnclosed(e);
  }, exports.isMediaAnd = function isMediaAnd(e) {
    return MediaAnd.isMediaAnd(e);
  }, exports.isMediaCondition = function isMediaCondition(e) {
    return MediaCondition.isMediaCondition(e);
  }, exports.isMediaConditionList = function isMediaConditionList(e) {
    return isMediaConditionListWithAnd(e) || isMediaConditionListWithOr(e);
  }, exports.isMediaConditionListWithAnd = isMediaConditionListWithAnd, exports.isMediaConditionListWithOr = isMediaConditionListWithOr, exports.isMediaFeature = function isMediaFeature(e) {
    return MediaFeature.isMediaFeature(e);
  }, exports.isMediaFeatureBoolean = function isMediaFeatureBoolean(e) {
    return MediaFeatureBoolean.isMediaFeatureBoolean(e);
  }, exports.isMediaFeatureName = function isMediaFeatureName(e) {
    return MediaFeatureName$1.isMediaFeatureName(e);
  }, exports.isMediaFeaturePlain = function isMediaFeaturePlain(e) {
    return MediaFeaturePlain.isMediaFeaturePlain(e);
  }, exports.isMediaFeatureRange = function isMediaFeatureRange(e) {
    return isMediaFeatureRangeNameValue(e) || isMediaFeatureRangeValueName(e) || isMediaFeatureRangeValueNameValue(e);
  }, exports.isMediaFeatureRangeNameValue = isMediaFeatureRangeNameValue, exports.isMediaFeatureRangeValueName = isMediaFeatureRangeValueName, exports.isMediaFeatureRangeValueNameValue = isMediaFeatureRangeValueNameValue, exports.isMediaFeatureValue = function isMediaFeatureValue(e) {
    return MediaFeatureValue.isMediaFeatureValue(e);
  }, exports.isMediaInParens = function isMediaInParens(e) {
    return MediaInParens.isMediaInParens(e);
  }, exports.isMediaNot = function isMediaNot(e) {
    return MediaNot.isMediaNot(e);
  }, exports.isMediaOr = function isMediaOr(e) {
    return MediaOr.isMediaOr(e);
  }, exports.isMediaQuery = function isMediaQuery(e) {
    return isMediaQueryWithType(e) || isMediaQueryWithoutType(e) || isMediaQueryInvalid$6(e);
  }, exports.isMediaQueryInvalid = isMediaQueryInvalid$6, exports.isMediaQueryWithType = isMediaQueryWithType, exports.isMediaQueryWithoutType = isMediaQueryWithoutType, exports.matchesComparison = matchesComparison, exports.matchesRatio = matchesRatio, exports.matchesRatioExactly = matchesRatioExactly$1, exports.modifierFromToken = modifierFromToken, exports.newMediaFeatureBoolean = function newMediaFeatureBoolean(e) {
    const a = [i$1.TokenType.Ident, "", -1, -1, {
      value: ""
    }];
    return i$1.mutateIdent(a, e), new MediaFeature(new MediaFeatureBoolean(new MediaFeatureName$1(new t.TokenNode(a))), [[i$1.TokenType.OpenParen, "(", -1, -1, void 0]], [[i$1.TokenType.CloseParen, ")", -1, -1, void 0]]);
  }, exports.newMediaFeaturePlain = function newMediaFeaturePlain(e, ...a) {
    const r = [i$1.TokenType.Ident, "", -1, -1, {
      value: ""
    }];
    i$1.mutateIdent(r, e);
    const n = t.parseListOfComponentValues(a);
    return new MediaFeature(new MediaFeaturePlain(new MediaFeatureName$1(new t.TokenNode(r)), [i$1.TokenType.Colon, ":", -1, -1, void 0], new MediaFeatureValue(1 === n.length ? n[0] : n)), [[i$1.TokenType.OpenParen, "(", -1, -1, void 0]], [[i$1.TokenType.CloseParen, ")", -1, -1, void 0]]);
  }, exports.parse = function parse(e, t) {
    const a = i$1.tokenizer({
      css: e
    }, {
      onParseError: null == t ? void 0 : t.onParseError
    }),
          r = [];

    for (; !a.endOfFile();) r.push(a.nextToken());

    return r.push(a.nextToken()), parseFromTokens$3(r, t);
  }, exports.parseCustomMedia = function parseCustomMedia(e, t) {
    const a = i$1.tokenizer({
      css: e
    }, {
      onParseError: null == t ? void 0 : t.onParseError
    }),
          r = [];

    for (; !a.endOfFile();) r.push(a.nextToken());

    return r.push(a.nextToken()), parseCustomMediaFromTokens(r, t);
  }, exports.parseCustomMediaFromTokens = parseCustomMediaFromTokens, exports.parseFromTokens = parseFromTokens$3, exports.typeFromToken = function typeFromToken(e) {
    if (e[0] !== i$1.TokenType.Ident) return !1;

    switch (toLowerCaseAZ(e[4].value)) {
      case exports.MediaType.All:
        return exports.MediaType.All;

      case exports.MediaType.Print:
        return exports.MediaType.Print;

      case exports.MediaType.Screen:
        return exports.MediaType.Screen;

      case exports.MediaType.Tty:
        return exports.MediaType.Tty;

      case exports.MediaType.Tv:
        return exports.MediaType.Tv;

      case exports.MediaType.Projection:
        return exports.MediaType.Projection;

      case exports.MediaType.Handheld:
        return exports.MediaType.Handheld;

      case exports.MediaType.Braille:
        return exports.MediaType.Braille;

      case exports.MediaType.Embossed:
        return exports.MediaType.Embossed;

      case exports.MediaType.Aural:
        return exports.MediaType.Aural;

      case exports.MediaType.Speech:
        return exports.MediaType.Speech;

      default:
        return !1;
    }
  };

  var dist$3 = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  var require$$2 = /*@__PURE__*/getAugmentedNamespace(dist$3);

  const {
    TokenType: TokenType$6,
    isToken,
    stringify: stringify$3,
    tokenize: tokenize$4
  } = require$$0$5;

  const {
    isTokenNode: isTokenNode$5,
    parseCommaSeparatedListOfComponentValues,
    isSimpleBlockNode: isSimpleBlockNode$3
  } = require$$1;

  const {
    isGeneralEnclosed: isGeneralEnclosed$1,
    isMediaFeature: isMediaFeature$5,
    isMediaQueryInvalid: isMediaQueryInvalid$5,
    parseFromTokens: parseFromTokens$2
  } = require$$2;
  /** @typedef {Array<import('@csstools/media-query-list-parser').MediaQuery>} MediaQueryList */

  /** @typedef {import('@csstools/css-tokenizer').TokenIdent} TokenIdent */

  /** @typedef {{ stringify: () => string }} MediaQuerySerializer */


  const rangeFeatureOperator = /[<>=]/;
  /**
   * Search a CSS string for Media Feature names.
   * For every found name, invoke the callback, passing the token
   * as an argument.
   *
   * Found tokens are mutable and modifications made to them will be reflected in the output.
   *
   * This function supports some non-standard syntaxes like SCSS variables and interpolation.
   *
   * @param {string} mediaQueryParams
   * @param {(mediaFeatureName: TokenIdent) => void} callback
   *
   * @returns {MediaQuerySerializer}
   */

  var findMediaFeatureNames = function findMediaFeatureNames(mediaQueryParams, callback) {
    const tokens = tokenize$4({
      css: mediaQueryParams
    });
    const list = parseCommaSeparatedListOfComponentValues(tokens);
    const mediaQueryConditions = list.flatMap(listItem => {
      return listItem.flatMap(componentValue => {
        if (!isSimpleBlockNode$3(componentValue) || componentValue.startToken[0] !== TokenType$6.OpenParen) {
          return [];
        }

        const blockTokens = componentValue.tokens();
        const mediaQueryList = parseFromTokens$2(blockTokens, {
          preserveInvalidMediaQueries: true
        });
        return mediaQueryList.filter(mediaQuery => {
          return !isMediaQueryInvalid$5(mediaQuery);
        });
      });
    });
    mediaQueryConditions.forEach(mediaQuery => {
      mediaQuery.walk(({
        node
      }) => {
        if (isMediaFeature$5(node)) {
          const token = node.getNameToken();
          if (token[0] !== TokenType$6.Ident) return;
          callback(token);
        }

        if (isGeneralEnclosed$1(node)) {
          topLevelTokenNodes(node).forEach((token, i, topLevelTokens) => {
            if (token[0] !== TokenType$6.Ident) {
              return;
            }

            const nextToken = topLevelTokens[i + 1];
            const prevToken = topLevelTokens[i - 1];

            if ( // Media Feature
            !prevToken && nextToken && nextToken[0] === TokenType$6.Colon || // Range Feature
            nextToken && nextToken[0] === TokenType$6.Delim && rangeFeatureOperator.test(nextToken[4].value) || // Range Feature
            prevToken && prevToken[0] === TokenType$6.Delim && rangeFeatureOperator.test(prevToken[4].value)) {
              callback(token);
            }
          });
        }
      });
    }); // Serializing takes time/resources and not all callers will use this.
    // By returning an object with a stringify method, we can avoid doing
    // this work when it's not needed.

    return {
      stringify() {
        return stringify$3(...tokens);
      }

    };
  };
  /** @param {import('@csstools/media-query-list-parser').GeneralEnclosed} node */


  function topLevelTokenNodes(node) {
    const components = node.value.value;

    if (isToken(components) || components.length === 0 || isToken(components[0])) {
      return [];
    }
    /** @type {Array<import('@csstools/css-tokenizer').CSSToken>} */


    const relevantTokens = []; // To consume the next token if it is a scss variable

    let lastWasDollarSign = false;
    components.forEach(component => {
      // Only preserve top level tokens (idents, delims, ...)
      // Discard all blocks, functions, ...
      if (component && isTokenNode$5(component)) {
        if (component.value[0] === TokenType$6.Delim && component.value[4].value === '$') {
          lastWasDollarSign = true;
          return;
        }

        if (lastWasDollarSign) {
          lastWasDollarSign = false;
          return;
        }

        relevantTokens.push(component.value);
      }
    });
    return relevantTokens;
  }

  /**
   * Check whether a media query is a custom
   * @param {string} mediaQuery
   * @returns {boolean}
   */

  var isCustomMediaQuery = function isCustomMediaQuery(mediaQuery) {
    return mediaQuery.startsWith('--');
  };

  const {
    isRegExp: isRegExp$y,
    isString: isString$I
  } = validateTypes;

  const ruleName$1E = 'media-feature-name-allowed-list';
  const messages$1E = ruleMessages$1(ruleName$1E, {
    rejected: name => `Unexpected media feature name "${name}"`
  });
  const meta$1E = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-name-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$1D = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1E, {
        actual: primary,
        possible: [isString$I, isRegExp$y]
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        findMediaFeatureNames(getAtRuleParams(atRule), mediaFeatureNameToken => {
          const [,, startIndex, endIndex, {
            value: featureName
          }] = mediaFeatureNameToken;

          if (isCustomMediaQuery(featureName)) {
            return;
          }

          if (matchesStringOrRegExp(featureName, primary)) {
            return;
          }

          const atRuleIndex = atRuleParamIndex(atRule);
          report$1({
            message: messages$1E.rejected,
            messageArgs: [featureName],
            node: atRule,
            index: atRuleIndex + startIndex,
            endIndex: atRuleIndex + endIndex + 1,
            ruleName: ruleName$1E,
            result
          });
        });
      });
    };
  };

  rule$1D.primaryOptionArray = true;
  rule$1D.ruleName = ruleName$1E;
  rule$1D.messages = messages$1E;
  rule$1D.meta = meta$1E;
  var mediaFeatureNameAllowedList = rule$1D;

  const {
    mutateIdent
  } = require$$0$5;













  const ruleName$1D = 'media-feature-name-case';
  const messages$1D = ruleMessages$1(ruleName$1D, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$1D = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-name-case',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1C = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1D, {
        actual: primary,
        possible: ['lower', 'upper']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        let hasComments = atRule.raws.params?.raw;
        let mediaRule = hasComments ? hasComments : atRule.params;
        let hasFixes = false;
        mediaRule = findMediaFeatureNames(mediaRule, mediaFeatureNameToken => {
          const [,, startIndex, endIndex, {
            value: featureName
          }] = mediaFeatureNameToken;

          if (isCustomMediaQuery(featureName)) {
            return;
          }

          const expectedFeatureName = primary === 'lower' ? featureName.toLowerCase() : featureName.toUpperCase();

          if (featureName === expectedFeatureName) {
            return;
          }

          if (context.fix) {
            mutateIdent(mediaFeatureNameToken, expectedFeatureName);
            hasFixes = true;
            return;
          }

          const atRuleIndex = atRuleParamIndex(atRule);
          report$1({
            message: messages$1D.expected(featureName, expectedFeatureName),
            node: atRule,
            index: atRuleIndex + startIndex,
            endIndex: atRuleIndex + endIndex + 1,
            ruleName: ruleName$1D,
            result
          });
        }).stringify();

        if (hasFixes) {
          if (hasComments) {
            if (atRule.raws.params == null) {
              throw new Error('The `AtRuleRaws` node must have a `params` property');
            }

            atRule.raws.params.raw = mediaRule;
          } else {
            atRule.params = mediaRule;
          }
        }
      });
    };
  };

  rule$1C.ruleName = ruleName$1D;
  rule$1C.messages = messages$1D;
  rule$1C.meta = meta$1D;
  var mediaFeatureNameCase = rule$1C;

  const {
    isRegExp: isRegExp$x,
    isString: isString$H
  } = validateTypes;

  const ruleName$1C = 'media-feature-name-disallowed-list';
  const messages$1C = ruleMessages$1(ruleName$1C, {
    rejected: name => `Unexpected media feature name "${name}"`
  });
  const meta$1C = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-name-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$1B = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1C, {
        actual: primary,
        possible: [isString$H, isRegExp$x]
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        findMediaFeatureNames(getAtRuleParams(atRule), mediaFeatureNameToken => {
          const [,, startIndex, endIndex, {
            value: featureName
          }] = mediaFeatureNameToken;

          if (isCustomMediaQuery(featureName)) {
            return;
          }

          if (!matchesStringOrRegExp(featureName, primary)) {
            return;
          }

          const atRuleIndex = atRuleParamIndex(atRule);
          report$1({
            message: messages$1C.rejected,
            messageArgs: [featureName],
            node: atRule,
            index: atRuleIndex + startIndex,
            endIndex: atRuleIndex + endIndex + 1,
            ruleName: ruleName$1C,
            result
          });
        });
      });
    };
  };

  rule$1B.primaryOptionArray = true;
  rule$1B.ruleName = ruleName$1C;
  rule$1B.messages = messages$1C;
  rule$1B.meta = meta$1C;
  var mediaFeatureNameDisallowedList = rule$1B;

  const deprecatedMediaFeatureNames = new Set(['device-aspect-ratio', 'device-height', 'device-width']);
  const rangeTypeMediaFeatureNames$2 = uniteSets(deprecatedMediaFeatureNames, ['aspect-ratio', 'color', 'color-index', 'height', 'horizontal-viewport-segments', 'monochrome', 'resolution', 'vertical-viewport-segments', 'width']);
  const rangeTypeMediaFeatureNamesWithMinMaxPrefix = new Set([...rangeTypeMediaFeatureNames$2].flatMap(name => {
    return [`min-${name}`, `max-${name}`];
  }));
  const discreteTypeMediaFeatureNames = new Set(['any-hover', 'any-pointer', 'color-gamut', 'display-mode', 'dynamic-range', 'environment-blending', 'forced-colors', 'grid', 'hover', 'inverted-colors', 'light-level', 'nav-controls', 'orientation', 'overflow-block', 'overflow-inline', 'pointer', 'prefers-color-scheme', 'prefers-contrast', 'prefers-reduced-data', 'prefers-reduced-motion', 'prefers-reduced-transparency', 'scan', 'scripting', 'update', 'video-color-gamut', 'video-dynamic-range']);
  const mediaFeatureNames$2 = uniteSets(deprecatedMediaFeatureNames, rangeTypeMediaFeatureNames$2, rangeTypeMediaFeatureNamesWithMinMaxPrefix, discreteTypeMediaFeatureNames);
  const mediaFeatureNameAllowedValueKeywords$1 = new Map([['any-hover', new Set(['none', 'hover'])], ['any-pointer', new Set(['none', 'coarse', 'fine'])], ['color-gamut', new Set(['srgb', 'p3', 'rec2020'])], ['display-mode', new Set(['fullscreen', 'standalone', 'minimal-ui', 'browser'])], ['dynamic-range', new Set(['standard', 'high'])], ['environment-blending', new Set(['opaque', 'additive', 'subtractive'])], ['forced-colors', new Set(['none', 'active'])], ['hover', new Set(['none', 'hover'])], ['inverted-colors', new Set(['none', 'inverted'])], ['nav-controls', new Set(['none', 'back'])], ['orientation', new Set(['portrait', 'landscape'])], ['overflow-block', new Set(['none', 'scroll', 'paged'])], ['overflow-inline', new Set(['none', 'scroll'])], ['pointer', new Set(['none', 'coarse', 'fine'])], ['prefers-color-scheme', new Set(['light', 'dark'])], ['prefers-contrast', new Set(['no-preference', 'less', 'more', 'custom'])], ['prefers-reduced-data', new Set(['no-preference', 'reduce'])], ['prefers-reduced-motion', new Set(['no-preference', 'reduce'])], ['prefers-reduced-transparency', new Set(['no-preference', 'reduce'])], ['resolution', new Set(['infinite'])], ['scan', new Set(['interlace', 'progressive'])], ['scripting', new Set(['none', 'initial-only', 'enabled'])], ['update', new Set(['none', 'slow', 'fast'])], ['video-color-gamut', new Set(['srgb', 'p3', 'rec2020'])], ['video-dynamic-range', new Set(['standard', 'high'])]]);
  const mediaFeatureNameAllowedValueTypes$1 = new Map([['aspect-ratio', new Set(['ratio'])], ['color', new Set(['integer'])], ['color-index', new Set(['integer'])], ['device-aspect-ratio', new Set(['ratio'])], ['device-height', new Set(['length'])], ['device-width', new Set(['length'])], ['grid', new Set(['mq-boolean'])], ['height', new Set(['length'])], ['horizontal-viewport-segments', new Set(['integer'])], ['monochrome', new Set(['integer'])], ['resolution', new Set(['resolution'])], ['vertical-viewport-segments', new Set(['integer'])], ['width', new Set(['length'])]]);
  var mediaFeatures = {
    mediaFeatureNameAllowedValueKeywords: mediaFeatureNameAllowedValueKeywords$1,
    mediaFeatureNameAllowedValueTypes: mediaFeatureNameAllowedValueTypes$1,
    mediaFeatureNames: mediaFeatureNames$2,
    rangeTypeMediaFeatureNames: rangeTypeMediaFeatureNames$2,
    rangeTypeMediaFeatureNamesWithMinMaxPrefix
  };

  const {
    mediaFeatureNames: mediaFeatureNames$1
  } = mediaFeatures;











  const {
    isRegExp: isRegExp$w,
    isString: isString$G
  } = validateTypes;

  const ruleName$1B = 'media-feature-name-no-unknown';
  const messages$1B = ruleMessages$1(ruleName$1B, {
    rejected: mediaFeatureName => `Unexpected unknown media feature name "${mediaFeatureName}"`
  });
  const meta$1B = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-name-no-unknown'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1A = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1B, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreMediaFeatureNames: [isString$G, isRegExp$w]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        findMediaFeatureNames(getAtRuleParams(atRule), mediaFeatureNameToken => {
          const [,, startIndex, endIndex, {
            value: featureName
          }] = mediaFeatureNameToken;

          if (isCustomMediaQuery(featureName)) {
            return;
          }

          if (optionsMatches(secondaryOptions, 'ignoreMediaFeatureNames', featureName)) {
            return;
          }

          if (vendor.prefix(featureName) || mediaFeatureNames$1.has(featureName.toLowerCase())) {
            return;
          }

          const atRuleIndex = atRuleParamIndex(atRule);
          report$1({
            message: messages$1B.rejected,
            messageArgs: [featureName],
            node: atRule,
            index: atRuleIndex + startIndex,
            endIndex: atRuleIndex + endIndex + 1,
            ruleName: ruleName$1B,
            result
          });
        });
      });
    };
  };

  rule$1A.ruleName = ruleName$1B;
  rule$1A.messages = messages$1B;
  rule$1A.meta = meta$1B;
  var mediaFeatureNameNoUnknown = rule$1A;

  const ruleName$1A = 'media-feature-name-no-vendor-prefix';
  const messages$1A = ruleMessages$1(ruleName$1A, {
    rejected: 'Unexpected vendor-prefix'
  });
  const meta$1A = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-name-no-vendor-prefix',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1z = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1A, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        const params = atRule.params;

        if (!isAutoprefixable.mediaFeatureName(params)) {
          return;
        }

        const matches = atRule.toString().match(/(?:min-|max-)?-[a-z-]+device-pixel-ratio/gi);

        if (!matches) {
          return;
        }

        if (context.fix) {
          atRule.params = isAutoprefixable.unprefix(atRule.params);
          return;
        }

        for (const match of matches) {
          report$1({
            message: messages$1A.rejected,
            node: atRule,
            word: match,
            result,
            ruleName: ruleName$1A
          });
        }
      });
    };
  };

  rule$1z.ruleName = ruleName$1A;
  rule$1z.messages = messages$1A;
  rule$1z.meta = meta$1A;
  var mediaFeatureNameNoVendorPrefix = rule$1z;

  const {
    parse: parse$8
  } = require$$2;


  /**
   * @param {import('postcss').AtRule} atRule
   * @returns {ReturnType<typeof parse>}
   */


  var parseMediaQuery = function parseMediaQuery(atRule) {
    const mediaQueries = parse$8(getAtRuleParams(atRule), {
      preserveInvalidMediaQueries: true
    });
    return mediaQueries;
  };

  const {
    TokenType: TokenType$5
  } = require$$0$5;

  const {
    isTokenNode: isTokenNode$4
  } = require$$1;

  const {
    isMediaFeaturePlain: isMediaFeaturePlain$2,
    isMediaFeatureRange: isMediaFeatureRange$2,
    isMediaQueryInvalid: isMediaQueryInvalid$4
  } = require$$2;









  const {
    isString: isString$F
  } = validateTypes;







  const ruleName$1z = 'media-feature-name-unit-allowed-list';
  const messages$1z = ruleMessages$1(ruleName$1z, {
    rejected: (unit, name) => `Unexpected unit "${unit}" for name "${name}"`
  });
  const meta$1z = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-name-unit-allowed-list'
  };
  /** @type {import('stylelint').Rule<Record<string, string | string[]>>} */

  const rule$1y = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1z, {
        actual: primary,
        possible: [validateObjectWithArrayProps(isString$F)]
      });

      if (!validOptions) {
        return;
      }

      const primaryPairs = Object.entries(primary);

      const primaryUnitList =
      /** @type {string} */
      featureName => {
        for (const [name, unit] of primaryPairs) {
          if (matchesStringOrRegExp(featureName, name)) return [unit].flat();
        }

        return undefined;
      };

      root.walkAtRules(/^media$/i, atRule => {
        const mediaQueryList = parseMediaQuery(atRule);
        mediaQueryList.forEach(mediaQuery => {
          if (isMediaQueryInvalid$4(mediaQuery)) return;
          const initialState = {
            mediaFeatureName: '',

            /** @type {string[] | undefined} */
            unitList: undefined
          };
          mediaQuery.walk(({
            node,
            state
          }) => {
            if (!state) return;

            if (isMediaFeaturePlain$2(node) || isMediaFeatureRange$2(node)) {
              state.mediaFeatureName = node.getName();
              state.unitList = primaryUnitList(state.mediaFeatureName);
              return;
            }

            if (!isTokenNode$4(node)) return;
            const {
              mediaFeatureName,
              unitList
            } = state;
            if (!mediaFeatureName || !unitList) return;
            const [tokenType,, startIndex, endIndex, parsedValue] = node.value;

            if (tokenType !== TokenType$5.Dimension) {
              return;
            }

            if (unitList.includes(parsedValue.unit.toLowerCase())) {
              return;
            }

            const atRuleIndex = atRuleParamIndex(atRule);
            report$1({
              message: messages$1z.rejected(parsedValue.unit, mediaFeatureName),
              node: atRule,
              index: atRuleIndex + startIndex,
              endIndex: atRuleIndex + endIndex + 1,
              result,
              ruleName: ruleName$1z
            });
          }, initialState);
        });
      });
    };
  };

  rule$1y.ruleName = ruleName$1z;
  rule$1y.messages = messages$1z;
  rule$1y.meta = meta$1z;
  var mediaFeatureNameUnitAllowedList = rule$1y;

  const {
    sourceIndices: sourceIndices$3
  } = require$$1;

  const {
    isMediaQueryInvalid: isMediaQueryInvalid$3,
    isMediaFeature: isMediaFeature$4,
    isMediaFeatureValue: isMediaFeatureValue$1
  } = require$$2;



















  const {
    isString: isString$E,
    isRegExp: isRegExp$v
  } = validateTypes;

  const ruleName$1y = 'media-feature-name-value-allowed-list';
  const messages$1y = ruleMessages$1(ruleName$1y, {
    rejected: (name, value) => `Unexpected value "${value}" for name "${name}"`
  });
  const meta$1y = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-name-value-allowed-list'
  };
  /** @type {import('stylelint').Rule<Record<string, string | RegExp | Array<string | RegExp>>>} */

  const rule$1x = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1y, {
        actual: primary,
        possible: [validateObjectWithArrayProps(isString$E, isRegExp$v)]
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        parseMediaQuery(atRule).forEach(mediaQuery => {
          if (isMediaQueryInvalid$3(mediaQuery)) return;
          const initialState = {
            mediaFeatureName: '',
            unprefixedMediaFeatureName: ''
          };
          mediaQuery.walk(({
            node,
            state
          }) => {
            if (!state) return;

            if (isMediaFeature$4(node)) {
              state.mediaFeatureName = node.getName();
              state.unprefixedMediaFeatureName = vendor.unprefixed(node.getName());
              return;
            }

            if (!isMediaFeatureValue$1(node)) return;
            const {
              mediaFeatureName,
              unprefixedMediaFeatureName
            } = state;
            if (!mediaFeatureName || !unprefixedMediaFeatureName) return;
            const componentValues = [node.value].flat();
            const value = componentValues.map(x => x.toString()).join('');
            const allowedValuesKey = Object.keys(primary).find(featureName => matchesStringOrRegExp(unprefixedMediaFeatureName, featureName));

            if (allowedValuesKey == null) {
              return;
            }

            if (optionsMatches(primary, allowedValuesKey, value)) {
              return;
            }

            const atRuleIndex = atRuleParamIndex(atRule);
            const [startIndex, endIndex] = sourceIndices$3(componentValues);
            report$1({
              index: atRuleIndex + startIndex,
              endIndex: atRuleIndex + endIndex + 1,
              message: messages$1y.rejected,
              messageArgs: [mediaFeatureName, value],
              node: atRule,
              ruleName: ruleName$1y,
              result
            });
          }, initialState);
        });
      });
    };
  };

  rule$1x.ruleName = ruleName$1y;
  rule$1x.messages = messages$1y;
  rule$1x.meta = meta$1y;
  var mediaFeatureNameValueAllowedList = rule$1x;

  const {
    TokenType: TokenType$4,
    NumberType: NumberType$1
  } = require$$0$5;

  const {
    isTokenNode: isTokenNode$3,
    isFunctionNode: isFunctionNode$3,
    sourceIndices: sourceIndices$2
  } = require$$1;

  const {
    isMediaFeature: isMediaFeature$3,
    isMediaFeatureValue,
    matchesRatioExactly,
    isMediaQueryInvalid: isMediaQueryInvalid$2
  } = require$$2;













  const {
    lengthUnits,
    resolutionUnits
  } = units_1;

  const {
    mathFunctions
  } = functions;

  const {
    mediaFeatureNameAllowedValueKeywords,
    mediaFeatureNameAllowedValueTypes,
    mediaFeatureNames
  } = mediaFeatures;

  const ruleName$1x = 'media-feature-name-value-no-unknown';
  const messages$1x = ruleMessages$1(ruleName$1x, {
    rejected: (name, value) => `Unexpected unknown media feature value "${value}" for name "${name}"`
  });
  const HAS_MIN_MAX_PREFIX$1 = /^(?:min|max)-/i;
  const meta$1x = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-name-value-no-unknown'
  };
  /** @typedef {{ mediaFeatureName: string, mediaFeatureNameRaw: string }} State */

  /** @typedef { (state: State, valuePart: string, start: number, end: number) => void } Reporter */

  /** @type {import('stylelint').Rule} */

  const rule$1w = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1x, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }
      /**
       * Check that a single token value is valid for a given media feature name.
       *
       * @param {State} state
       * @param {import('@csstools/css-tokenizer').CSSToken} token
       * @param {Reporter} reporter
       * @returns {void}
       */


      function checkSingleToken(state, token, reporter) {
        const [type, raw, start, end, parsed] = token;

        if (type === TokenType$4.Ident) {
          const supportedKeywords = mediaFeatureNameAllowedValueKeywords.get(state.mediaFeatureName);

          if (supportedKeywords) {
            const keyword = vendor.unprefixed(parsed.value.toLowerCase());
            if (supportedKeywords.has(keyword)) return;
          } // An ident that isn't expected for the given media feature name


          reporter(state, raw, start, end);
          return;
        }

        const supportedValueTypes = mediaFeatureNameAllowedValueTypes.get(state.mediaFeatureName);

        if (!supportedValueTypes) {
          // The given media feature name doesn't support any single token values.
          reporter(state, raw, start, end);
          return;
        }

        if (type === TokenType$4.Number) {
          if (parsed.type === NumberType$1.Integer) {
            if ( // Integer values are valid for types "integer" and "ratio".
            supportedValueTypes.has('integer') || supportedValueTypes.has('ratio') || // Integer values of "0" are also valid for "length", "resolution" and "mq-boolean".
            parsed.value === 0 && (supportedValueTypes.has('length') || supportedValueTypes.has('resolution') || supportedValueTypes.has('mq-boolean')) || // Integer values of "1" are also valid for "mq-boolean".
            parsed.value === 1 && supportedValueTypes.has('mq-boolean')) {
              return;
            } // An integer when the media feature doesn't support integers.


            reporter(state, raw, start, end);
            return;
          }

          if ( // Numbers are valid for "ratio".
          supportedValueTypes.has('ratio') || // Numbers with value "0" are also valid for "length".
          parsed.value === 0 && (supportedValueTypes.has('length') || supportedValueTypes.has('resolution'))) {
            return;
          } // A number when the media feature doesn't support numbers.


          reporter(state, raw, start, end);
          return;
        }

        if (type === TokenType$4.Dimension) {
          const unit = parsed.unit.toLowerCase();
          if (supportedValueTypes.has('resolution') && resolutionUnits.has(unit)) return;
          if (supportedValueTypes.has('length') && lengthUnits.has(unit)) return; // An unexpected dimension or a media feature that doesn't support dimensions.

          reporter(state, raw, start, end);
        }
      }
      /**
       * Check that a function node is valid for a given media feature name.
       *
       * @param {State} state
       * @param {import('@csstools/css-parser-algorithms').FunctionNode} functionNode
       * @param {Reporter} reporter
       * @returns {void}
       */


      function checkFunction(state, functionNode, reporter) {
        const functionName = functionNode.getName().toLowerCase(); // "env()" can represent any value, it is treated as valid for static analysis.

        if (functionName === 'env') return;
        const supportedValueTypes = mediaFeatureNameAllowedValueTypes.get(state.mediaFeatureName);

        if (supportedValueTypes && mathFunctions.has(functionName) && (supportedValueTypes.has('integer') || supportedValueTypes.has('length') || supportedValueTypes.has('ratio') || supportedValueTypes.has('resolution'))) {
          return;
        } // An unexpected function or a media feature that doesn't support types that can be the result of a function.


        reporter(state, functionNode.toString(), ...sourceIndices$2(functionNode));
      }
      /**
       * Check that an array of component values is valid for a given media feature name.
       *
       * @param {State} state
       * @param {Array<import('@csstools/css-parser-algorithms').ComponentValue>} componentValues
       * @param {Reporter} reporter
       * @returns {void}
       */


      function checkListOfComponentValues(state, componentValues, reporter) {
        const supportedValueTypes = mediaFeatureNameAllowedValueTypes.get(state.mediaFeatureName);

        if (supportedValueTypes && supportedValueTypes.has('ratio') && matchesRatioExactly(componentValues) !== -1) {
          return;
        } // An invalid aspect ratio or a media feature that doesn't support aspect ratios.


        reporter(state, componentValues.map(x => x.toString()).join(''), ...sourceIndices$2(componentValues));
      }
      /**
       * @param {State} state
       * @param {import('@csstools/media-query-list-parser').MediaFeatureValue} valueNode
       * @param {Reporter} reporter
       * @returns {void}
       */


      function checkMediaFeatureValue(state, valueNode, reporter) {
        if (isTokenNode$3(valueNode.value)) {
          checkSingleToken(state, valueNode.value.value, reporter);
          return;
        }

        if (isFunctionNode$3(valueNode.value)) {
          checkFunction(state, valueNode.value, reporter);
          return;
        }

        if (Array.isArray(valueNode.value)) {
          checkListOfComponentValues(state, valueNode.value, reporter);
        }
      }

      root.walkAtRules(/^media$/i, atRule => {
        /**
         * @type {Reporter}
         */
        const reporter = (state, valuePart, start, end) => {
          const atRuleParamIndexValue = atRuleParamIndex(atRule);
          report$1({
            message: messages$1x.rejected,
            messageArgs: [state.mediaFeatureNameRaw, valuePart],
            index: atRuleParamIndexValue + start,
            endIndex: atRuleParamIndexValue + end + 1,
            node: atRule,
            ruleName: ruleName$1x,
            result
          });
        };
        /** @type {State} */


        const initialState = {
          mediaFeatureName: '',
          mediaFeatureNameRaw: ''
        };
        parseMediaQuery(atRule).forEach(mediaQuery => {
          if (isMediaQueryInvalid$2(mediaQuery)) return;
          mediaQuery.walk(({
            node,
            state
          }) => {
            if (!state) return;

            if (isMediaFeature$3(node)) {
              const mediaFeatureNameRaw = node.getName();
              let mediaFeatureName = vendor.unprefixed(mediaFeatureNameRaw.toLowerCase()); // Unknown media feature names are handled by "media-feature-name-no-unknown".

              if (!mediaFeatureNames.has(mediaFeatureName)) return;
              mediaFeatureName = mediaFeatureName.replace(HAS_MIN_MAX_PREFIX$1, '');
              state.mediaFeatureName = mediaFeatureName;
              state.mediaFeatureNameRaw = mediaFeatureNameRaw;
              return;
            }

            if (!state.mediaFeatureName || !state.mediaFeatureNameRaw) return;

            if (isMediaFeatureValue(node)) {
              checkMediaFeatureValue(state, node, reporter);
            }
          }, initialState);
        });
      });
    };
  };

  rule$1w.ruleName = ruleName$1x;
  rule$1w.messages = messages$1x;
  rule$1w.meta = meta$1x;
  var mediaFeatureNameValueNoUnknown = rule$1w;

  const ruleName$1w = 'media-feature-parentheses-space-inside';
  const messages$1w = ruleMessages$1(ruleName$1w, {
    expectedOpening: 'Expected single space after "("',
    rejectedOpening: 'Unexpected whitespace after "("',
    expectedClosing: 'Expected single space before ")"',
    rejectedClosing: 'Unexpected whitespace before ")"'
  });
  const meta$1w = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-parentheses-space-inside',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1v = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1w, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        // If there are comments in the params, the complete string
        // will be at atRule.raws.params.raw
        const params = atRule.raws.params && atRule.raws.params.raw || atRule.params;
        const indexBoost = atRuleParamIndex(atRule);
        /** @type {Array<{ message: string, index: number }>} */

        const problems = [];
        const parsedParams = lib$6(params).walk(node => {
          if (node.type === 'function') {
            const len = lib$6.stringify(node).length;

            if (primary === 'never') {
              if (/[ \t]/.test(node.before)) {
                if (context.fix) node.before = '';
                problems.push({
                  message: messages$1w.rejectedOpening,
                  index: node.sourceIndex + 1 + indexBoost
                });
              }

              if (/[ \t]/.test(node.after)) {
                if (context.fix) node.after = '';
                problems.push({
                  message: messages$1w.rejectedClosing,
                  index: node.sourceIndex - 2 + len + indexBoost
                });
              }
            } else if (primary === 'always') {
              if (node.before === '') {
                if (context.fix) node.before = ' ';
                problems.push({
                  message: messages$1w.expectedOpening,
                  index: node.sourceIndex + 1 + indexBoost
                });
              }

              if (node.after === '') {
                if (context.fix) node.after = ' ';
                problems.push({
                  message: messages$1w.expectedClosing,
                  index: node.sourceIndex - 2 + len + indexBoost
                });
              }
            }
          }
        });

        if (problems.length) {
          if (context.fix) {
            atRule.params = parsedParams.toString();
            return;
          }

          for (const err of problems) {
            report$1({
              message: err.message,
              node: atRule,
              index: err.index,
              result,
              ruleName: ruleName$1w
            });
          }
        }
      });
    };
  };

  rule$1v.ruleName = ruleName$1w;
  rule$1v.messages = messages$1w;
  rule$1v.meta = meta$1w;
  var mediaFeatureParenthesesSpaceInside = rule$1v;

  const {
    TokenType: TokenType$3
  } = require$$0$5;

  const {
    TokenNode,
    sourceIndices: sourceIndices$1
  } = require$$1;

  const {
    MediaFeatureName,
    MediaFeatureRangeNameValue,
    isMediaFeature: isMediaFeature$2,
    isMediaFeaturePlain: isMediaFeaturePlain$1,
    isMediaFeatureRange: isMediaFeatureRange$1,
    isMediaQueryInvalid: isMediaQueryInvalid$1
  } = require$$2;











  const {
    rangeTypeMediaFeatureNames: rangeTypeMediaFeatureNames$1
  } = mediaFeatures;

  const ruleName$1v = 'media-feature-range-notation';
  const messages$1v = ruleMessages$1(ruleName$1v, {
    expected: primary => `Expected "${primary}" media feature range notation`
  });
  const meta$1v = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-range-notation',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1u = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1v, {
        actual: primary,
        possible: ['prefix', 'context']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        const mediaQueryList = parseMediaQuery(atRule);
        let hasFixes = false;
        mediaQueryList.forEach(mediaQuery => {
          if (isMediaQueryInvalid$1(mediaQuery)) return;
          mediaQuery.walk(({
            node,
            parent
          }) => {
            // Only look at plain and range notation media features
            if (!isMediaFeatureRange$1(node) && !isMediaFeaturePlain$1(node)) return; // Expected plain notation and received plain notation

            if (primary === 'prefix' && isMediaFeaturePlain$1(node)) return; // Expected range notation and received range notation

            if (primary === 'context' && isMediaFeatureRange$1(node)) return;
            const featureName = node.getName();
            const unprefixedMediaFeature = featureName.replace(/^(?:min|max)-/i, '');
            if (!rangeTypeMediaFeatureNames$1.has(unprefixedMediaFeature)) return;

            if (context.fix && primary === 'context' && isMediaFeaturePlain$1(node)) {
              if (!isMediaFeature$2(parent)) return;
              hasFixes = true;
              /** @type {import('@csstools/css-tokenizer').TokenDelim} */

              const operator = /^min-/i.test(featureName) ? [TokenType$3.Delim, '>', -1, -1, {
                value: '>'
              }] : [TokenType$3.Delim, '<', -1, -1, {
                value: '<'
              }];
              parent.feature = new MediaFeatureRangeNameValue(new MediaFeatureName(new TokenNode([TokenType$3.Ident, unprefixedMediaFeature, -1, -1, {
                value: unprefixedMediaFeature
              }]), node.name.before, node.name.after.length > 0 ? node.name.after : [[TokenType$3.Whitespace, ' ', -1, -1, undefined]]), [operator, [TokenType$3.Delim, '=', -1, -1, {
                value: '='
              }]], node.value);
              return;
            }

            const [startIndex, endIndex] = sourceIndices$1(node);
            const atRuleIndex = atRuleParamIndex(atRule);
            report$1({
              message: messages$1v.expected,
              messageArgs: [primary],
              node: atRule,
              index: atRuleIndex + startIndex - 1,
              endIndex: atRuleIndex + endIndex + 1 + 1,
              result,
              ruleName: ruleName$1v
            });
          });
        });

        if (hasFixes) {
          const expectedMediaQueryList = mediaQueryList.map(mediaQuery => mediaQuery.toString()).join(',');
          if (expectedMediaQueryList === atRule.params) return;
          atRule.params = expectedMediaQueryList;
        }
      });
    };
  };

  rule$1u.ruleName = ruleName$1v;
  rule$1u.messages = messages$1v;
  rule$1u.meta = meta$1v;
  var mediaFeatureRangeNotation = rule$1u;

  const rangeOperators = ['>=', '<=', '>', '<', '='];
  /** @typedef {import('style-search').StyleSearchMatch} StyleSearchMatch */

  /**
   * @template {import('postcss').AtRule} T
   * @param {T} atRule
   * @param {(match: StyleSearchMatch, params: string, atRule: T) => void} cb
   */

  var findMediaOperator = function findMediaOperator(atRule, cb) {
    if (atRule.name.toLowerCase() !== 'media') {
      return;
    }

    const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;
    styleSearch({
      source: params,
      target: rangeOperators
    }, match => {
      const before = params[match.startIndex - 1];

      if (before === '>' || before === '<') {
        return;
      }

      cb(match, params, atRule);
    });
  };

  const ruleName$1u = 'media-feature-range-operator-space-after';
  const messages$1u = ruleMessages$1(ruleName$1u, {
    expectedAfter: () => 'Expected single space after range operator',
    rejectedAfter: () => 'Unexpected whitespace after range operator'
  });
  const meta$1u = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-range-operator-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1t = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$1u);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1u, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        /** @type {number[]} */
        const fixOperatorIndices = [];
        /** @type {((index: number) => void) | null} */

        const fix = context.fix ? index => fixOperatorIndices.push(index) : null;
        findMediaOperator(atRule, (match, params, node) => {
          checkAfterOperator(match, params, node, fix);
        });

        if (fixOperatorIndices.length) {
          let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          for (const index of fixOperatorIndices.sort((a, b) => b - a)) {
            const beforeOperator = params.slice(0, index + 1);
            const afterOperator = params.slice(index + 1);

            if (primary === 'always') {
              params = beforeOperator + afterOperator.replace(/^\s*/, ' ');
            } else if (primary === 'never') {
              params = beforeOperator + afterOperator.replace(/^\s*/, '');
            }
          }

          if (atRule.raws.params) {
            atRule.raws.params.raw = params;
          } else {
            atRule.params = params;
          }
        }
      });
      /**
       * @param {import('style-search').StyleSearchMatch} match
       * @param {string} params
       * @param {import('postcss').AtRule} node
       * @param {((index: number) => void) | null} fix
       */

      function checkAfterOperator(match, params, node, fix) {
        const endIndex = match.startIndex + match.target.length - 1;
        checker.after({
          source: params,
          index: endIndex,
          err: m => {
            if (fix) {
              fix(endIndex);
              return;
            }

            report$1({
              message: m,
              node,
              index: endIndex + atRuleParamIndex(node) + 1,
              result,
              ruleName: ruleName$1u
            });
          }
        });
      }
    };
  };

  rule$1t.ruleName = ruleName$1u;
  rule$1t.messages = messages$1u;
  rule$1t.meta = meta$1u;
  var mediaFeatureRangeOperatorSpaceAfter = rule$1t;

  const ruleName$1t = 'media-feature-range-operator-space-before';
  const messages$1t = ruleMessages$1(ruleName$1t, {
    expectedBefore: () => 'Expected single space before range operator',
    rejectedBefore: () => 'Unexpected whitespace before range operator'
  });
  const meta$1t = {
    url: 'https://stylelint.io/user-guide/rules/media-feature-range-operator-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1s = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$1t);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1t, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        /** @type {number[]} */
        const fixOperatorIndices = [];
        /** @type {((index: number) => void) | null} */

        const fix = context.fix ? index => fixOperatorIndices.push(index) : null;
        findMediaOperator(atRule, (match, params, node) => {
          checkBeforeOperator(match, params, node, fix);
        });

        if (fixOperatorIndices.length) {
          let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          for (const index of fixOperatorIndices.sort((a, b) => b - a)) {
            const beforeOperator = params.slice(0, index);
            const afterOperator = params.slice(index);

            if (primary === 'always') {
              params = beforeOperator.replace(/\s*$/, ' ') + afterOperator;
            } else if (primary === 'never') {
              params = beforeOperator.replace(/\s*$/, '') + afterOperator;
            }
          }

          if (atRule.raws.params) {
            atRule.raws.params.raw = params;
          } else {
            atRule.params = params;
          }
        }
      });
      /**
       * @param {import('style-search').StyleSearchMatch} match
       * @param {string} params
       * @param {import('postcss').AtRule} node
       * @param {((index: number) => void) | null} fix
       */

      function checkBeforeOperator(match, params, node, fix) {
        // The extra `+ 1` is because the match itself contains
        // the character before the operator
        checker.before({
          source: params,
          index: match.startIndex,
          err: m => {
            if (fix) {
              fix(match.startIndex);
              return;
            }

            report$1({
              message: m,
              node,
              index: match.startIndex - 1 + atRuleParamIndex(node),
              result,
              ruleName: ruleName$1t
            });
          }
        });
      }
    };
  };

  rule$1s.ruleName = ruleName$1t;
  rule$1s.messages = messages$1t;
  rule$1s.meta = meta$1t;
  var mediaFeatureRangeOperatorSpaceBefore = rule$1s;

  const {
    assertString: assertString$3
  } = validateTypes;
  /**
   * @param {{
   *   root: import('postcss').Root,
   *   result: import('stylelint').PostcssResult,
   *   locationChecker: (args: { source: string, index: number, err: (message: string) => void }) => void,
   *   checkedRuleName: string,
   *   fix?: ((atRule: import('postcss').AtRule, index: number) => boolean) | null | undefined,
   *   allowTrailingComments?: boolean,
   * }} opts
   */


  var mediaQueryListCommaWhitespaceChecker = function mediaQueryListCommaWhitespaceChecker(opts) {
    opts.root.walkAtRules(/^media$/i, atRule => {
      const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;
      styleSearch({
        source: params,
        target: ','
      }, match => {
        let index = match.startIndex;

        if (opts.allowTrailingComments) {
          // if there is a comment on the same line at after the comma, check the space after the comment.
          let execResult;

          while (execResult = /^[^\S\r\n]*\/\*([\s\S]*?)\*\//.exec(params.slice(index + 1))) {
            assertString$3(execResult[0]);
            index += execResult[0].length;
          }

          if (execResult = /^([^\S\r\n]*\/\/[\s\S]*?)\r?\n/.exec(params.slice(index + 1))) {
            assertString$3(execResult[1]);
            index += execResult[1].length;
          }
        }

        checkComma(params, index, atRule);
      });
    });
    /**
     * @param {string} source
     * @param {number} index
     * @param {import('postcss').AtRule} node
     */

    function checkComma(source, index, node) {
      opts.locationChecker({
        source,
        index,
        err: message => {
          const commaIndex = index + atRuleParamIndex(node);

          if (opts.fix && opts.fix(node, commaIndex)) {
            return;
          }

          report$1({
            message,
            node,
            index: commaIndex,
            result: opts.result,
            ruleName: opts.checkedRuleName
          });
        }
      });
    }
  };

  const ruleName$1s = 'media-query-list-comma-newline-after';
  const messages$1s = ruleMessages$1(ruleName$1s, {
    expectedAfter: () => 'Expected newline after ","',
    expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
    rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list'
  });
  const meta$1s = {
    url: 'https://stylelint.io/user-guide/rules/media-query-list-comma-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1r = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$1s);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1s, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      } // Only check for the newline after the comma, while allowing
      // arbitrary indentation after the newline

      /** @type {Map<import('postcss').AtRule, number[]> | undefined} */


      let fixData;
      mediaQueryListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.afterOneOnly,
        checkedRuleName: ruleName$1s,
        allowTrailingComments: primary.startsWith('always'),
        fix: context.fix ? (atRule, index) => {
          const paramCommaIndex = index - atRuleParamIndex(atRule);
          fixData = fixData || new Map();
          const commaIndices = fixData.get(atRule) || [];
          commaIndices.push(paramCommaIndex);
          fixData.set(atRule, commaIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [atRule, commaIndices] of fixData.entries()) {
          let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          for (const index of commaIndices.sort((a, b) => b - a)) {
            const beforeComma = params.slice(0, index + 1);
            const afterComma = params.slice(index + 1);

            if (primary.startsWith('always')) {
              params = /^\s*\n/.test(afterComma) ? beforeComma + afterComma.replace(/^[^\S\r\n]*/, '') : beforeComma + context.newline + afterComma;
            } else if (primary.startsWith('never')) {
              params = beforeComma + afterComma.replace(/^\s*/, '');
            }
          }

          if (atRule.raws.params) {
            atRule.raws.params.raw = params;
          } else {
            atRule.params = params;
          }
        }
      }
    };
  };

  rule$1r.ruleName = ruleName$1s;
  rule$1r.messages = messages$1s;
  rule$1r.meta = meta$1s;
  var mediaQueryListCommaNewlineAfter = rule$1r;

  const ruleName$1r = 'media-query-list-comma-newline-before';
  const messages$1r = ruleMessages$1(ruleName$1r, {
    expectedBefore: () => 'Expected newline before ","',
    expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
    rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list'
  });
  const meta$1r = {
    url: 'https://stylelint.io/user-guide/rules/media-query-list-comma-newline-before',
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1q = primary => {
    const checker = whitespaceChecker('newline', primary, messages$1r);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1r, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }

      mediaQueryListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.beforeAllowingIndentation,
        checkedRuleName: ruleName$1r
      });
    };
  };

  rule$1q.ruleName = ruleName$1r;
  rule$1q.messages = messages$1r;
  rule$1q.meta = meta$1r;
  var mediaQueryListCommaNewlineBefore = rule$1q;

  const ruleName$1q = 'media-query-list-comma-space-after';
  const messages$1q = ruleMessages$1(ruleName$1q, {
    expectedAfter: () => 'Expected single space after ","',
    rejectedAfter: () => 'Unexpected whitespace after ","',
    expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
    rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list'
  });
  const meta$1q = {
    url: 'https://stylelint.io/user-guide/rules/media-query-list-comma-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1p = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$1q);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1q, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').AtRule, number[]> | undefined} */


      let fixData;
      mediaQueryListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$1q,
        fix: context.fix ? (atRule, index) => {
          const paramCommaIndex = index - atRuleParamIndex(atRule);
          fixData = fixData || new Map();
          const commaIndices = fixData.get(atRule) || [];
          commaIndices.push(paramCommaIndex);
          fixData.set(atRule, commaIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [atRule, commaIndices] of fixData.entries()) {
          let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          for (const index of commaIndices.sort((a, b) => b - a)) {
            const beforeComma = params.slice(0, index + 1);
            const afterComma = params.slice(index + 1);

            if (primary.startsWith('always')) {
              params = beforeComma + afterComma.replace(/^\s*/, ' ');
            } else if (primary.startsWith('never')) {
              params = beforeComma + afterComma.replace(/^\s*/, '');
            }
          }

          if (atRule.raws.params) {
            atRule.raws.params.raw = params;
          } else {
            atRule.params = params;
          }
        }
      }
    };
  };

  rule$1p.ruleName = ruleName$1q;
  rule$1p.messages = messages$1q;
  rule$1p.meta = meta$1q;
  var mediaQueryListCommaSpaceAfter = rule$1p;

  const ruleName$1p = 'media-query-list-comma-space-before';
  const messages$1p = ruleMessages$1(ruleName$1p, {
    expectedBefore: () => 'Expected single space before ","',
    rejectedBefore: () => 'Unexpected whitespace before ","',
    expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line list',
    rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list'
  });
  const meta$1p = {
    url: 'https://stylelint.io/user-guide/rules/media-query-list-comma-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1o = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$1p);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1p, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').AtRule, number[]> | undefined} */


      let fixData;
      mediaQueryListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.before,
        checkedRuleName: ruleName$1p,
        fix: context.fix ? (atRule, index) => {
          const paramCommaIndex = index - atRuleParamIndex(atRule);
          fixData = fixData || new Map();
          const commaIndices = fixData.get(atRule) || [];
          commaIndices.push(paramCommaIndex);
          fixData.set(atRule, commaIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [atRule, commaIndices] of fixData.entries()) {
          let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          for (const index of commaIndices.sort((a, b) => b - a)) {
            const beforeComma = params.slice(0, index);
            const afterComma = params.slice(index);

            if (primary.startsWith('always')) {
              params = beforeComma.replace(/\s*$/, ' ') + afterComma;
            } else if (primary.startsWith('never')) {
              params = beforeComma.replace(/\s*$/, '') + afterComma;
            }
          }

          if (atRule.raws.params) {
            atRule.raws.params.raw = params;
          } else {
            atRule.params = params;
          }
        }
      }
    };
  };

  rule$1o.ruleName = ruleName$1p;
  rule$1o.messages = messages$1p;
  rule$1o.meta = meta$1p;
  var mediaQueryListCommaSpaceBefore = rule$1o;

  const {
    sourceIndices
  } = require$$1;

  const {
    isMediaQueryInvalid,
    isGeneralEnclosed,
    isMediaFeaturePlain,
    isMediaFeatureRange,
    isMediaFeatureBoolean
  } = require$$2;













  const {
    rangeTypeMediaFeatureNames
  } = mediaFeatures;

  const ruleName$1o = 'media-query-no-invalid';
  const messages$1o = ruleMessages$1(ruleName$1o, {
    rejected: query => `Unexpected invalid media query "${query}"`
  });
  const HAS_MIN_MAX_PREFIX = /^(?:min|max)-/i;
  const meta$1o = {
    url: 'https://stylelint.io/user-guide/rules/media-query-no-invalid'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1n = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1o, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(/^media$/i, atRule => {
        /** @type {Array<{tokens(): Array<import('@csstools/css-tokenizer').CSSToken>}>} */
        let invalidNodes = [];
        parseMediaQuery(atRule).forEach(mediaQuery => {
          if (isMediaQueryInvalid(mediaQuery)) {
            // Queries that fail to parse are invalid.
            invalidNodes.push(mediaQuery);
            return;
          }

          mediaQuery.walk(({
            node,
            parent
          }) => {
            // All general enclosed nodes are invalid.
            if (isGeneralEnclosed(node)) {
              invalidNodes.push(node);
              return;
            } // Invalid plain media features.


            if (isMediaFeaturePlain(node)) {
              const name = node.getName();

              if (isCustomMediaQuery(name)) {
                // In a plain context, custom media queries are invalid.
                invalidNodes.push(parent);
                return;
              }

              return;
            } // Invalid range media features.


            if (isMediaFeatureRange(node)) {
              const name = node.getName().toLowerCase();

              if (isCustomMediaQuery(name)) {
                // In a range context, custom media queries are invalid.
                invalidNodes.push(parent);
                return;
              }

              if (HAS_MIN_MAX_PREFIX.test(name)) {
                // In a range context, min- and max- prefixed feature names are invalid.
                invalidNodes.push(parent);
                return;
              }

              if (!rangeTypeMediaFeatureNames.has(name)) {
                // In a range context, non-range typed features are invalid.
                invalidNodes.push(parent);
                return;
              }

              return;
            } // Invalid boolean media features.


            if (isMediaFeatureBoolean(node)) {
              const name = node.getName().toLowerCase();

              if (HAS_MIN_MAX_PREFIX.test(name)) {
                // In a range context, min- and max- prefixed feature names are invalid
                invalidNodes.push(parent);
              }
            }
          });
        });
        if (invalidNodes.length === 0) return;
        const atRuleParamIndexValue = atRuleParamIndex(atRule);
        invalidNodes.forEach(invalidNode => {
          const [start, end] = sourceIndices(invalidNode);
          report$1({
            message: messages$1o.rejected,
            messageArgs: [invalidNode.toString()],
            index: atRuleParamIndexValue + start,
            endIndex: atRuleParamIndexValue + end + 1,
            node: atRule,
            ruleName: ruleName$1o,
            result
          });
        });
      });
    };
  };

  rule$1n.ruleName = ruleName$1o;
  rule$1n.messages = messages$1o;
  rule$1n.meta = meta$1o;
  var mediaQueryNoInvalid = rule$1n;

  /**
   *
   * @param {string[][]} areas
   * @param {string} name
   * @returns {boolean}
   */


  function isContiguousAndRectangular(areas, name) {
    const indicesByRow = areas.map(row => {
      const indices = [];
      let idx = row.indexOf(name);

      while (idx !== -1) {
        indices.push(idx);
        idx = row.indexOf(name, idx + 1);
      }

      return indices;
    });

    for (let i = 0; i < indicesByRow.length; i++) {
      for (let j = i + 1; j < indicesByRow.length; j++) {
        const x = indicesByRow[i];
        const y = indicesByRow[j];

        if (x && x.length === 0 || y && y.length === 0) {
          continue;
        }

        if (!arrayEqual(x, y)) {
          return false;
        }
      }
    }

    return true;
  }
  /**
   *
   * @param {string[][]} areas
   * @returns {string[]}
   */


  function namedAreas(areas) {
    const names = new Set(areas.flat());
    names.delete('.');
    return [...names];
  }
  /**
   *
   * @param {string[][]} areas
   * @returns {string[]}
   */


  function findNotContiguousOrRectangular(areas) {
    return namedAreas(areas).filter(name => !isContiguousAndRectangular(areas, name));
  }

  var findNotContiguousOrRectangular_1 = findNotContiguousOrRectangular;

  const {
    assert: assert$3
  } = validateTypes;

  const ruleName$1n = 'named-grid-areas-no-invalid';
  const messages$1n = ruleMessages$1(ruleName$1n, {
    expectedToken: () => 'Expected cell token within string',
    expectedSameNumber: () => 'Expected same number of cell tokens in each string',
    expectedRectangle: name => `Expected single filled-in rectangle for "${name}"`
  });
  const meta$1n = {
    url: 'https://stylelint.io/user-guide/rules/named-grid-areas-no-invalid'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1m = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1n, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(/^(?:grid|grid-template|grid-template-areas)$/i, decl => {
        const {
          value
        } = decl;
        if (value.toLowerCase().trim() === 'none') return;
        /** @type {Array<{ values: string[], index: number, endIndex: number }>} */

        const areas = [];
        let reportSent = false;
        lib$6(value).walk(({
          sourceIndex,
          sourceEndIndex,
          type,
          value: tokenValue
        }) => {
          if (type !== 'string') return;

          if (tokenValue === '') {
            complain(messages$1n.expectedToken(), sourceIndex, sourceEndIndex);
            reportSent = true;
            return;
          }

          areas.push({
            values: tokenValue.trim().split(' ').filter(Boolean),
            index: sourceIndex,
            endIndex: sourceEndIndex
          });
        });
        if (reportSent) return;
        const [firstArea] = areas;
        if (firstArea === undefined) return;
        const notSameNumberArea = areas.find(area => area.values.length !== firstArea.values.length);

        if (notSameNumberArea !== undefined) {
          complain(messages$1n.expectedSameNumber(), notSameNumberArea.index, notSameNumberArea.endIndex);
          return;
        }

        const notContiguousOrRectangular = findNotContiguousOrRectangular_1(areas.map(a => a.values));

        for (const name of notContiguousOrRectangular.sort()) {
          const area = areas.find(a => a.values.includes(name));
          assert$3(area);
          complain(messages$1n.expectedRectangle(name), area.index, area.endIndex);
        }
        /**
         * @param {string} message
         * @param {number} index
         * @param {number} endIndex
         */


        function complain(message, index, endIndex) {
          const start = declarationValueIndex(decl);
          report$1({
            message,
            node: decl,
            index: start + index,
            endIndex: start + endIndex,
            result,
            ruleName: ruleName$1n
          });
        }
      });
    };
  };

  rule$1m.ruleName = ruleName$1n;
  rule$1m.messages = messages$1n;
  rule$1m.meta = meta$1n;
  var namedGridAreasNoInvalid = rule$1m;

  var postcssResolveNestedSelector = function resolveNestedSelector(selector, node) {
    var parent = node.parent;
    var parentIsNestAtRule = parent.type === 'atrule' && parent.name === 'nest';
    if (parent.type === 'root') return [selector];
    if (parent.type !== 'rule' && !parentIsNestAtRule) return resolveNestedSelector(selector, parent);
    var parentSelectors = parentIsNestAtRule ? parent.params.split(',').map(function (s) {
      return s.trim();
    }) : parent.selectors;
    var resolvedSelectors = parentSelectors.reduce(function (result, parentSelector) {
      if (selector.indexOf('&') !== -1) {
        var newlyResolvedSelectors = resolveNestedSelector(parentSelector, parent).map(function (resolvedParentSelector) {
          return selector.replace(/&/g, resolvedParentSelector);
        });
        return result.concat(newlyResolvedSelectors);
      }

      var combinedSelector = [parentSelector, selector].join(' ');
      return result.concat(resolveNestedSelector(combinedSelector, parent));
    }, []);
    return resolvedSelectors;
  };

  var dist$2 = createCommonjsModule(function (module, exports) {



  const s = /[A-Z]/g;

  function toLowerCaseAZ(e) {
    return e.replace(s, e => String.fromCharCode(e.charCodeAt(0) + 32));
  }

  function selectorSpecificity(s) {
    if (!s) return {
      a: 0,
      b: 0,
      c: 0
    };
    let t = 0,
        c = 0,
        i = 0;
    if ("universal" == s.type) return {
      a: 0,
      b: 0,
      c: 0
    };
    if ("id" === s.type) t += 1;else if ("tag" === s.type) i += 1;else if ("class" === s.type) c += 1;else if ("attribute" === s.type) c += 1;else if (isPseudoElement(s)) switch (toLowerCaseAZ(s.value)) {
      case "::slotted":
        if (i += 1, s.nodes && s.nodes.length > 0) {
          const e = specificityOfMostSpecificListItem(s.nodes);
          t += e.a, c += e.b, i += e.c;
        }

        break;

      case "::view-transition-group":
      case "::view-transition-image-pair":
      case "::view-transition-old":
      case "::view-transition-new":
        if (s.nodes && 1 === s.nodes.length && "selector" === s.nodes[0].type && selectorNodeContainsOnlyUniversal(s.nodes[0])) return {
          a: 0,
          b: 0,
          c: 0
        };
        i += 1;
        break;

      default:
        i += 1;
    } else if (dist$4.isPseudoClass(s)) switch (toLowerCaseAZ(s.value)) {
      case ":-moz-any":
      case ":-webkit-any":
      case ":any":
      case ":has":
      case ":is":
      case ":matches":
      case ":not":
        if (s.nodes && s.nodes.length > 0) {
          const e = specificityOfMostSpecificListItem(s.nodes);
          t += e.a, c += e.b, i += e.c;
        }

        break;

      case ":where":
        break;

      case ":nth-child":
      case ":nth-last-child":
        if (c += 1, s.nodes && s.nodes.length > 0) {
          const n = s.nodes[0].nodes.findIndex(e => "tag" === e.type && "of" === toLowerCaseAZ(e.value));

          if (n > -1) {
            const o = [dist$4.selector({
              nodes: s.nodes[0].nodes.slice(n + 1),
              value: ""
            })];
            s.nodes.length > 1 && o.push(...s.nodes.slice(1));
            const a = specificityOfMostSpecificListItem(o);
            t += a.a, c += a.b, i += a.c;
          }
        }

        break;

      case ":local":
      case ":global":
        s.nodes && s.nodes.length > 0 && s.nodes.forEach(e => {
          const s = selectorSpecificity(e);
          t += s.a, c += s.b, i += s.c;
        });
        break;

      case ":host":
      case ":host-context":
        if (c += 1, s.nodes && s.nodes.length > 0) {
          const e = specificityOfMostSpecificListItem(s.nodes);
          t += e.a, c += e.b, i += e.c;
        }

        break;

      default:
        c += 1;
    } else dist$4.isContainer(s) && s.nodes.length > 0 && s.nodes.forEach(e => {
      const s = selectorSpecificity(e);
      t += s.a, c += s.b, i += s.c;
    });
    return {
      a: t,
      b: c,
      c: i
    };
  }

  function specificityOfMostSpecificListItem(e) {
    let s = {
      a: 0,
      b: 0,
      c: 0
    };
    return e.forEach(e => {
      const t = selectorSpecificity(e);
      t.a > s.a ? s = t : t.a < s.a || (t.b > s.b ? s = t : t.b < s.b || t.c > s.c && (s = t));
    }), s;
  }

  function isPseudoElement(s) {
    return dist$4.isPseudoElement(s);
  }

  function selectorNodeContainsOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const s = e.nodes.filter(e => "comment" !== e.type);
    return 1 === s.length && "universal" === s[0].type;
  }

  exports.compare = function compare(e, s) {
    return e.a === s.a ? e.b === s.b ? e.c - s.c : e.b - s.b : e.a - s.a;
  }, exports.selectorSpecificity = selectorSpecificity;
  });

  const {
    isAtRule: isAtRule$b,
    isRule: isRule$4
  } = typeGuards;
  /**
   * Find the at-rule in which a rule is nested.
   *
   * Returns `null` if the rule is not nested within an at-rule.
   *
   * @param {import('postcss').Rule} rule
   * @returns {null | import('postcss').AtRule}
   */


  var findAtRuleContext = function findAtRuleContext(rule) {
    const parent = rule.parent;

    if (!parent) {
      return null;
    }

    if (isAtRule$b(parent)) {
      return parent;
    }

    if (isRule$4(parent)) {
      return findAtRuleContext(parent);
    }

    return null;
  };

  var require$$0$4 = [
  	"a",
  	"abbr",
  	"address",
  	"area",
  	"article",
  	"aside",
  	"audio",
  	"b",
  	"base",
  	"bdi",
  	"bdo",
  	"blockquote",
  	"body",
  	"br",
  	"button",
  	"canvas",
  	"caption",
  	"cite",
  	"code",
  	"col",
  	"colgroup",
  	"data",
  	"datalist",
  	"dd",
  	"del",
  	"details",
  	"dfn",
  	"dialog",
  	"div",
  	"dl",
  	"dt",
  	"em",
  	"embed",
  	"fieldset",
  	"figcaption",
  	"figure",
  	"footer",
  	"form",
  	"h1",
  	"h2",
  	"h3",
  	"h4",
  	"h5",
  	"h6",
  	"head",
  	"header",
  	"hgroup",
  	"hr",
  	"html",
  	"i",
  	"iframe",
  	"img",
  	"input",
  	"ins",
  	"kbd",
  	"label",
  	"legend",
  	"li",
  	"link",
  	"main",
  	"map",
  	"mark",
  	"math",
  	"menu",
  	"menuitem",
  	"meta",
  	"meter",
  	"nav",
  	"noscript",
  	"object",
  	"ol",
  	"optgroup",
  	"option",
  	"output",
  	"p",
  	"param",
  	"picture",
  	"pre",
  	"progress",
  	"q",
  	"rb",
  	"rp",
  	"rt",
  	"rtc",
  	"ruby",
  	"s",
  	"samp",
  	"script",
  	"search",
  	"section",
  	"select",
  	"slot",
  	"small",
  	"source",
  	"span",
  	"strong",
  	"style",
  	"sub",
  	"summary",
  	"sup",
  	"svg",
  	"table",
  	"tbody",
  	"td",
  	"template",
  	"textarea",
  	"tfoot",
  	"th",
  	"thead",
  	"time",
  	"title",
  	"tr",
  	"track",
  	"u",
  	"ul",
  	"var",
  	"video",
  	"wbr"
  ];

  var htmlTags = require$$0$4;

  const deprecatedHtmlTypeSelectors = new Set(['acronym', 'applet', 'basefont', 'big', 'blink', 'center', 'content', 'dir', 'font', 'frame', 'frameset', 'hgroup', 'isindex', 'keygen', 'listing', 'marquee', 'nobr', 'noembed', 'plaintext', 'spacer', 'strike', 'tt', 'xmp']); // typecasting htmlTags to be more generic; see https://github.com/stylelint/stylelint/pull/6013 for discussion

  /** @type {Set<string>} */

  const standardHtmlTypeSelectors = new Set(htmlTags);
  const htmlTypeSelectors$2 = uniteSets(deprecatedHtmlTypeSelectors, standardHtmlTypeSelectors);
  const mixedCaseSvgTypeSelectors$1 = new Set(['altGlyph', 'altGlyphDef', 'altGlyphItem', 'animateColor', 'animateMotion', 'animateTransform', 'clipPath', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'foreignObject', 'glyphRef', 'linearGradient', 'radialGradient', 'textPath']); // These are the ones that can have single-colon notation

  const levelOneAndTwoPseudoElements$5 = new Set(['before', 'after', 'first-line', 'first-letter']);
  const shadowTreePseudoElements$1 = new Set(['part']);
  const webkitScrollbarPseudoElements$1 = new Set(['-webkit-resizer', '-webkit-scrollbar', '-webkit-scrollbar-button', '-webkit-scrollbar-corner', '-webkit-scrollbar-thumb', '-webkit-scrollbar-track', '-webkit-scrollbar-track-piece']);
  const vendorSpecificPseudoElements = uniteSets(webkitScrollbarPseudoElements$1, ['-moz-focus-inner', '-moz-focus-outer', '-moz-list-bullet', '-moz-meter-bar', '-moz-placeholder', '-moz-progress-bar', '-moz-range-progress', '-moz-range-thumb', '-moz-range-track', '-ms-browse', '-ms-check', '-ms-clear', '-ms-expand', '-ms-fill', '-ms-fill-lower', '-ms-fill-upper', '-ms-reveal', '-ms-thumb', '-ms-ticks-after', '-ms-ticks-before', '-ms-tooltip', '-ms-track', '-ms-value', '-webkit-color-swatch', '-webkit-color-swatch-wrapper', '-webkit-calendar-picker-indicator', '-webkit-clear-button', '-webkit-date-and-time-value', '-webkit-datetime-edit', '-webkit-datetime-edit-ampm-field', '-webkit-datetime-edit-day-field', '-webkit-datetime-edit-fields-wrapper', '-webkit-datetime-edit-hour-field', '-webkit-datetime-edit-millisecond-field', '-webkit-datetime-edit-minute-field', '-webkit-datetime-edit-month-field', '-webkit-datetime-edit-second-field', '-webkit-datetime-edit-text', '-webkit-datetime-edit-week-field', '-webkit-datetime-edit-year-field', '-webkit-details-marker', '-webkit-distributed', '-webkit-file-upload-button', '-webkit-input-placeholder', '-webkit-keygen-select', '-webkit-meter-bar', '-webkit-meter-even-less-good-value', '-webkit-meter-inner-element', '-webkit-meter-optimum-value', '-webkit-meter-suboptimum-value', '-webkit-progress-bar', '-webkit-progress-inner-element', '-webkit-progress-value', '-webkit-search-cancel-button', '-webkit-search-decoration', '-webkit-search-results-button', '-webkit-search-results-decoration', '-webkit-slider-runnable-track', '-webkit-slider-thumb', '-webkit-textfield-decoration-container', '-webkit-validation-bubble', '-webkit-validation-bubble-arrow', '-webkit-validation-bubble-arrow-clipper', '-webkit-validation-bubble-heading', '-webkit-validation-bubble-message', '-webkit-validation-bubble-text-block']);
  const pseudoElements$3 = uniteSets(levelOneAndTwoPseudoElements$5, vendorSpecificPseudoElements, shadowTreePseudoElements$1, ['backdrop', 'content', 'cue', 'file-selector-button', 'grammar-error', 'highlight', 'marker', 'placeholder', 'selection', 'shadow', 'slotted', 'spelling-error', 'target-text']);
  const aNPlusBNotationPseudoClasses$4 = new Set(['nth-column', 'nth-last-column', 'nth-last-of-type', 'nth-of-type']);
  const aNPlusBOfSNotationPseudoClasses$5 = new Set(['nth-child', 'nth-last-child']);
  const atRulePagePseudoClasses$1 = new Set(['first', 'right', 'left', 'blank']);
  const linguisticPseudoClasses$2 = new Set(['dir', 'lang']);
  const logicalCombinationsPseudoClasses$1 = new Set(['has', 'is', 'matches', 'not', 'where']);
  const vendorSpecificPseudoClasses = new Set(['-khtml-drag', '-moz-any', '-moz-any-link', '-moz-broken', '-moz-drag-over', '-moz-first-node', '-moz-focusring', '-moz-full-screen', '-moz-full-screen-ancestor', '-moz-last-node', '-moz-loading', '-moz-meter-optimum', '-moz-meter-sub-optimum', '-moz-meter-sub-sub-optimum', '-moz-placeholder', '-moz-submit-invalid', '-moz-suppressed', '-moz-ui-invalid', '-moz-ui-valid', '-moz-user-disabled', '-moz-window-inactive', '-ms-fullscreen', '-ms-input-placeholder', '-webkit-drag', '-webkit-any', '-webkit-any-link', '-webkit-autofill', '-webkit-full-screen', '-webkit-full-screen-ancestor']); // https://webkit.org/blog/363/styling-scrollbars/

  const webkitScrollbarPseudoClasses$1 = new Set(['horizontal', 'vertical', 'decrement', 'increment', 'start', 'end', 'double-button', 'single-button', 'no-button', 'corner-present', 'window-inactive']);
  const pseudoClasses$1 = uniteSets(aNPlusBNotationPseudoClasses$4, linguisticPseudoClasses$2, logicalCombinationsPseudoClasses$1, aNPlusBOfSNotationPseudoClasses$5, vendorSpecificPseudoClasses, ['active', 'any-link', 'autofill', 'blank', 'checked', 'current', 'default', 'defined', 'disabled', 'empty', 'enabled', 'first-child', 'first-of-type', 'focus', 'focus-within', 'focus-visible', 'fullscreen', 'fullscreen-ancestor', 'future', 'host', 'host-context', 'hover', 'indeterminate', 'in-range', 'invalid', 'last-child', 'last-of-type', 'link', 'modal', 'only-child', 'only-of-type', 'optional', 'out-of-range', 'past', 'placeholder-shown', 'playing', 'picture-in-picture', 'paused', 'read-only', 'read-write', 'required', 'root', 'scope', 'state', 'target', 'unresolved', 'user-invalid', 'user-valid', 'valid', 'visited', 'window-inactive' // for ::selection (chrome)
  ]);
  var selectors = {
    aNPlusBNotationPseudoClasses: aNPlusBNotationPseudoClasses$4,
    aNPlusBOfSNotationPseudoClasses: aNPlusBOfSNotationPseudoClasses$5,
    atRulePagePseudoClasses: atRulePagePseudoClasses$1,
    levelOneAndTwoPseudoElements: levelOneAndTwoPseudoElements$5,
    linguisticPseudoClasses: linguisticPseudoClasses$2,
    logicalCombinationsPseudoClasses: logicalCombinationsPseudoClasses$1,
    mixedCaseSvgTypeSelectors: mixedCaseSvgTypeSelectors$1,
    pseudoClasses: pseudoClasses$1,
    pseudoElements: pseudoElements$3,
    shadowTreePseudoElements: shadowTreePseudoElements$1,
    htmlTypeSelectors: htmlTypeSelectors$2,
    webkitScrollbarPseudoClasses: webkitScrollbarPseudoClasses$1,
    webkitScrollbarPseudoElements: webkitScrollbarPseudoElements$1
  };

  /**
   * Create a collection of Maps that serve to contextualize a given node.
   * This is useful to ensure that you only compare nodes that share a certain
   * context.
   *
   * All nodes are initially contextualized by their input source.
   * From there, you can contextualize them however you want.
   *
   * For a usage example, see `selector-no-descending-specificity`.
   */

  var nodeContextLookup = function nodeContextLookup() {
    const contextMap = new Map();
    return {
      /**
       * @param {import('postcss').Node} node
       * @param {any[]} subContexts
       * @returns {Map<any, any>}
       */
      getContext(node, ...subContexts) {
        if (!node.source) throw new Error('The node source must be present');
        const nodeSource = node.source.input.from;
        const baseContext = creativeGetMap(contextMap, nodeSource);
        return subContexts.reduce((result, context) => creativeGetMap(result, context), baseContext);
      }

    };
  };
  /**
   * @param {Map<any, any>} someMap
   * @param {any} someThing
   */


  function creativeGetMap(someMap, someThing) {
    if (!someMap.has(someThing)) {
      someMap.set(someThing, new Map());
    }

    return someMap.get(someThing);
  }

  /**
   * @param {string} selector
   * @param {import('stylelint').PostcssResult} result
   * @param {import('postcss').Node} node
   * @param {(root: import('postcss-selector-parser').Root) => void} callback
   * @returns {string | undefined}
   */


  var parseSelector = function parseSelector(selector, result, node, callback) {
    try {
      return dist$4(callback).processSync(selector);
    } catch (err) {
      result.warn(`Cannot parse selector (${err})`, {
        node,
        stylelintType: 'parseError'
      });
      return undefined;
    }
  };

  const {
    selectorSpecificity: calculate,
    compare: compare$2
  } = dist$2;







  const {
    pseudoElements: pseudoElements$2
  } = selectors;













  const ruleName$1m = 'no-descending-specificity';
  const messages$1m = ruleMessages$1(ruleName$1m, {
    rejected: (b, a) => `Expected selector "${b}" to come before selector "${a}"`
  });
  const meta$1m = {
    url: 'https://stylelint.io/user-guide/rules/no-descending-specificity'
  };
  /** @typedef {{ selector: string, specificity: import('@csstools/selector-specificity').Specificity }} Entry */

  /** @type {import('stylelint').Rule} */

  const rule$1l = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1m, {
        actual: primary
      }, {
        optional: true,
        actual: secondaryOptions,
        possible: {
          ignore: ['selectors-within-list']
        }
      });

      if (!validOptions) {
        return;
      }

      const ignoreSelectorsWithinList = optionsMatches(secondaryOptions, 'ignore', 'selectors-within-list');
      const selectorContextLookup = nodeContextLookup();
      root.walkRules(ruleNode => {
        // Ignore nested property `foo: {};`
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selectors = ruleNode.selectors; // Ignores selectors within list of selectors

        if (ignoreSelectorsWithinList && selectors.length > 1) {
          return;
        }
        /** @type {Map<string, Entry[]>} */


        const comparisonContext = selectorContextLookup.getContext(ruleNode, findAtRuleContext(ruleNode));

        for (const selector of selectors) {
          // Ignore `.selector, { }`
          if (selector.trim() === '') {
            continue;
          } // Resolve any nested selectors before checking


          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            if (!isStandardSyntaxSelector(resolvedSelector)) {
              continue;
            }

            parseSelector(resolvedSelector, result, ruleNode, s => {
              checkSelector(resolvedSelector, s, ruleNode, comparisonContext);
            });
          }
        }
      });
      /**
       * @param {string} selector
       * @param {import('postcss-selector-parser').Root} selectorNode
       * @param {import('postcss').Rule} ruleNode
       * @param {Map<string, Entry[]>} comparisonContext
       */

      function checkSelector(selector, selectorNode, ruleNode, comparisonContext) {
        const referenceSelector = lastCompoundSelectorWithoutPseudoClasses(selectorNode);
        if (!referenceSelector) return;
        const selectorSpecificity = calculate(selectorNode);
        const entry = {
          selector,
          specificity: selectorSpecificity
        };
        const priorComparableSelectors = comparisonContext.get(referenceSelector);

        if (!priorComparableSelectors) {
          comparisonContext.set(referenceSelector, [entry]);
          return;
        }

        for (const priorEntry of priorComparableSelectors) {
          if (compare$2(selectorSpecificity, priorEntry.specificity) < 0) {
            report$1({
              ruleName: ruleName$1m,
              result,
              node: ruleNode,
              message: messages$1m.rejected,
              messageArgs: [selector, priorEntry.selector],
              word: selector
            });
            break;
          }
        }

        priorComparableSelectors.push(entry);
      }
    };
  };
  /**
   * @param {import('postcss-selector-parser').Root} selectorNode
   * @returns {string | undefined}
   */


  function lastCompoundSelectorWithoutPseudoClasses(selectorNode) {
    const firstChild = selectorNode.nodes[0];
    if (!firstChild) return undefined;
    const nodesByCombinator = firstChild.split(node => node.type === 'combinator');
    const nodesAfterLastCombinator = nodesByCombinator[nodesByCombinator.length - 1];
    if (!nodesAfterLastCombinator) return undefined;
    const nodesWithoutPseudoClasses = nodesAfterLastCombinator.filter(node => {
      return node.type !== 'pseudo' || node.value.startsWith('::') || pseudoElements$2.has(node.value.replace(/:/g, ''));
    });
    if (nodesWithoutPseudoClasses.length === 0) return undefined;
    return nodesWithoutPseudoClasses.join('');
  }

  rule$1l.ruleName = ruleName$1m;
  rule$1l.messages = messages$1m;
  rule$1l.meta = meta$1m;
  var noDescendingSpecificity = rule$1l;

  const ruleName$1l = 'no-duplicate-at-import-rules';
  const messages$1l = ruleMessages$1(ruleName$1l, {
    rejected: atImport => `Unexpected duplicate @import rule ${atImport}`
  });
  const meta$1l = {
    url: 'https://stylelint.io/user-guide/rules/no-duplicate-at-import-rules'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1k = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1l, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }
      /** @type {Record<string, string[]>} */


      const imports = {};
      root.walkAtRules(/^import$/i, atRule => {
        const [firstParam, ...restParams] = lib$6(getAtRuleParams(atRule)).nodes;

        if (!firstParam) {
          return;
        } // extract uri from url() if exists


        const uri = firstParam.type === 'function' && firstParam.value === 'url' && firstParam.nodes[0] ? firstParam.nodes[0].value : firstParam.value;
        const media = listImportConditions(restParams);
        let importedUris = imports[uri];
        const isDuplicate = media.length ? media.some(q => importedUris && importedUris.includes(q)) : importedUris;

        if (isDuplicate) {
          report$1({
            message: messages$1l.rejected,
            messageArgs: [uri],
            node: atRule,
            result,
            ruleName: ruleName$1l,
            word: atRule.toString()
          });
          return;
        }

        if (!importedUris) {
          importedUris = imports[uri] = [];
        }

        importedUris.push(...media);
      });
    };
  };
  /** @typedef { import('postcss-value-parser').Node } Node */

  /**
   * @param {Node | Array<Node>} node
   * @returns {string}
   */


  function stringifyCondition(node) {
    // remove whitespace to get a more consistent key
    return lib$6.stringify(node).replace(/\s/g, '');
  }
  /**
   * List the import conditions found in the prelude of an `@import` rule
   *
   * @param {Node[]} params
   * @returns {Array<string>}
   */


  function listImportConditions(params) {
    if (!params.length) return [];
    const separator = ' ';
    /** @type {Array<string>} */

    const sharedConditions = [];
    /** @type {Array<string>} */

    const media = [];
    /** @type {Array<Node>} */

    let lastMediaQuery = [];

    for (const param of params) {
      // remove top level whitespace and comments to get a more consistent key
      if (param.type === 'space' || param.type === 'comment') {
        continue;
      } // layer and supports conditions must precede media query conditions


      if (!media.length) {
        // @import url(...) layer(base) supports(display: flex)
        if (param.type === 'function' && (param.value === 'supports' || param.value === 'layer')) {
          sharedConditions.push(stringifyCondition(param));
          continue;
        } // @import url(...) layer


        if (param.type === 'word' && param.value === 'layer') {
          sharedConditions.push(stringifyCondition(param));
          continue;
        }
      }

      if (param.type === 'div' && param.value === ',') {
        media.push(stringifyCondition(lastMediaQuery));
        lastMediaQuery = [];
        continue;
      }

      lastMediaQuery.push(param);
    }

    if (lastMediaQuery.length) {
      media.push(stringifyCondition(lastMediaQuery));
    } // Only media query conditions


    if (media.length && !sharedConditions.length) {
      return media;
    } // Only layer and supports conditions


    if (!media.length && sharedConditions.length) {
      return [sharedConditions.join(separator)];
    }

    const sharedConditionsString = sharedConditions.join(separator);
    return media.map(m => {
      return sharedConditionsString + separator + m;
    });
  }

  rule$1k.ruleName = ruleName$1l;
  rule$1k.messages = messages$1l;
  rule$1k.meta = meta$1l;
  var noDuplicateAtImportRules = rule$1k;

  const {
    isAtRule: isAtRule$a
  } = typeGuards;
  /**
   * Check if a rule is a keyframe one
   *
   * @param {import('postcss').Rule} rule
   * @returns {boolean}
   */


  var isKeyframeRule = function isKeyframeRule(rule) {
    const parent = rule.parent;

    if (!parent) {
      return false;
    }

    return isAtRule$a(parent) && parent.name.toLowerCase() === 'keyframes';
  };

  const {
    isBoolean: isBoolean$8
  } = validateTypes;

  const ruleName$1k = 'no-duplicate-selectors';
  const messages$1k = ruleMessages$1(ruleName$1k, {
    rejected: (selector, firstDuplicateLine) => `Unexpected duplicate selector "${selector}", first used at line ${firstDuplicateLine}`
  });
  const meta$1k = {
    url: 'https://stylelint.io/user-guide/rules/no-duplicate-selectors'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1j = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1k, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          disallowInList: [isBoolean$8]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const shouldDisallowDuplicateInList = secondaryOptions && secondaryOptions.disallowInList; // The top level of this map will be rule sources.
      // Each source maps to another map, which maps rule parents to a set of selectors.
      // This ensures that selectors are only checked against selectors
      // from other rules that share the same parent and the same source.

      const selectorContextLookup = nodeContextLookup();
      root.walkRules(ruleNode => {
        if (isKeyframeRule(ruleNode)) {
          return;
        }

        const contextSelectorSet = selectorContextLookup.getContext(ruleNode, findAtRuleContext(ruleNode));
        const resolvedSelectorList = [...new Set(ruleNode.selectors.flatMap(selector => postcssResolveNestedSelector(selector, ruleNode)))];
        const normalizedSelectorList = resolvedSelectorList.map(normalize); // Sort the selectors list so that the order of the constituents
        // doesn't matter

        const sortedSelectorList = [...normalizedSelectorList].sort().join(',');
        if (!ruleNode.source) throw new Error('The rule node must have a source');
        if (!ruleNode.source.start) throw new Error('The rule source must have a start position');
        const selectorLine = ruleNode.source.start.line; // Complain if the same selector list occurs twice

        let previousDuplicatePosition; // When `disallowInList` is true, we must parse `sortedSelectorList` into
        // list items.

        /** @type {string[]} */

        const selectorListParsed = [];

        if (shouldDisallowDuplicateInList) {
          parseSelector(sortedSelectorList, result, ruleNode, selectors => {
            selectors.each(s => {
              const selector = String(s);
              selectorListParsed.push(selector);

              if (contextSelectorSet.get(selector)) {
                previousDuplicatePosition = contextSelectorSet.get(selector);
              }
            });
          });
        } else {
          previousDuplicatePosition = contextSelectorSet.get(sortedSelectorList);
        }

        if (previousDuplicatePosition) {
          // If the selector isn't nested we can use its raw value; otherwise,
          // we have to approximate something for the message -- which is close enough
          const isNestedSelector = resolvedSelectorList.join(',') !== ruleNode.selectors.join(',');
          const selectorForMessage = isNestedSelector ? resolvedSelectorList.join(', ') : ruleNode.selector;
          return report$1({
            result,
            ruleName: ruleName$1k,
            node: ruleNode,
            message: messages$1k.rejected,
            messageArgs: [selectorForMessage, previousDuplicatePosition],
            word: selectorForMessage
          });
        }

        const presentedSelectors = new Set();
        const reportedSelectors = new Set(); // Or complain if one selector list contains the same selector more than once

        for (const selector of ruleNode.selectors) {
          const normalized = normalize(selector);

          if (presentedSelectors.has(normalized)) {
            if (reportedSelectors.has(normalized)) {
              continue;
            }

            report$1({
              result,
              ruleName: ruleName$1k,
              node: ruleNode,
              message: messages$1k.rejected,
              messageArgs: [selector, selectorLine],
              word: selector
            });
            reportedSelectors.add(normalized);
          } else {
            presentedSelectors.add(normalized);
          }
        }

        if (shouldDisallowDuplicateInList) {
          for (const selector of selectorListParsed) {
            // [selectorLine] will not really be accurate for multi-line
            // selectors, such as "bar" in "foo,\nbar {}".
            contextSelectorSet.set(selector, selectorLine);
          }
        } else {
          contextSelectorSet.set(sortedSelectorList, selectorLine);
        }
      });
    };
  };
  /**
   * @param {string} selector
   * @returns {string}
   */


  function normalize(selector) {
    if (!isStandardSyntaxSelector(selector)) {
      return selector;
    }

    return dist$4().processSync(selector, {
      lossless: false
    });
  }

  rule$1j.ruleName = ruleName$1k;
  rule$1j.messages = messages$1k;
  rule$1j.meta = meta$1k;
  var noDuplicateSelectors = rule$1j;

  const ruleName$1j = 'no-empty-source';
  const messages$1j = ruleMessages$1(ruleName$1j, {
    rejected: 'Unexpected empty source'
  });
  const meta$1j = {
    url: 'https://stylelint.io/user-guide/rules/no-empty-source'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1i = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1j, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';

      if (rootString.trim()) {
        return;
      }

      report$1({
        message: messages$1j.rejected,
        node: root,
        result,
        ruleName: ruleName$1j
      });
    };
  };

  rule$1i.ruleName = ruleName$1j;
  rule$1i.messages = messages$1j;
  rule$1i.meta = meta$1j;
  var noEmptySource = rule$1i;

  const ruleName$1i = 'no-empty-first-line';
  const noEmptyFirstLineTest = /^\s*[\r\n]/;
  const messages$1i = ruleMessages$1(ruleName$1i, {
    rejected: 'Unexpected empty line'
  });
  const meta$1i = {
    url: 'https://stylelint.io/user-guide/rules/no-empty-first-line',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1h = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1i, {
        actual: primary
      }); // @ts-expect-error -- TS2339: Property 'inline' does not exist on type 'Source'. Property 'lang' does not exist on type 'Source'.

      if (!validOptions || root.source.inline || root.source.lang === 'object-literal') {
        return;
      }

      const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';

      if (!rootString.trim()) {
        return;
      }

      if (noEmptyFirstLineTest.test(rootString)) {
        if (context.fix) {
          if (root.first == null) {
            throw new Error('The root node must have the first node.');
          }

          if (root.first.raws.before == null) {
            throw new Error('The first node must have spaces before.');
          }

          root.first.raws.before = root.first.raws.before.trimStart();
          return;
        }

        report$1({
          message: messages$1i.rejected,
          node: root,
          result,
          ruleName: ruleName$1i
        });
      }
    };
  };

  rule$1h.ruleName = ruleName$1i;
  rule$1h.messages = messages$1i;
  rule$1h.meta = meta$1i;
  var noEmptyFirstLine = rule$1h;

  /**
   * Returns a Boolean indicating whether the input string is only whitespace.
   *
   * @param {string} input
   * @returns {boolean}
   */


  var isOnlyWhitespace = function isOnlyWhitespace(input) {
    for (const element of input) {
      if (!isWhitespace$2(element)) {
        return false;
      }
    }

    return true;
  };

  const {
    isAtRule: isAtRule$9,
    isComment,
    isDeclaration: isDeclaration$1,
    isRule: isRule$3
  } = typeGuards;



  const ruleName$1h = 'no-eol-whitespace';
  const messages$1h = ruleMessages$1(ruleName$1h, {
    rejected: 'Unexpected whitespace at end of line'
  });
  const meta$1h = {
    url: 'https://stylelint.io/user-guide/rules/no-eol-whitespace',
    fixable: true,
    deprecated: true
  };
  const whitespacesToReject = new Set([' ', '\t']);
  /**
   * @param {string} str
   * @returns {string}
   */

  function fixString(str) {
    return str.replace(/[ \t]+$/, '');
  }
  /**
   * @param {number} lastEOLIndex
   * @param {string} string
   * @param {{ ignoreEmptyLines: boolean, isRootFirst: boolean }} options
   * @returns {number}
   */


  function findErrorStartIndex(lastEOLIndex, string, {
    ignoreEmptyLines,
    isRootFirst
  }) {
    const eolWhitespaceIndex = lastEOLIndex - 1; // If the character before newline is not whitespace, ignore

    if (!whitespacesToReject.has(string.charAt(eolWhitespaceIndex))) {
      return -1;
    }

    if (ignoreEmptyLines) {
      // If there is only whitespace between the previous newline and
      // this newline, ignore
      const beforeNewlineIndex = string.lastIndexOf('\n', eolWhitespaceIndex);

      if (beforeNewlineIndex >= 0 || isRootFirst) {
        const line = string.substring(beforeNewlineIndex, eolWhitespaceIndex);

        if (isOnlyWhitespace(line)) {
          return -1;
        }
      }
    }

    return eolWhitespaceIndex;
  }
  /** @type {import('stylelint').Rule} */


  const rule$1g = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1h, {
        actual: primary
      }, {
        optional: true,
        actual: secondaryOptions,
        possible: {
          ignore: ['empty-lines']
        }
      });

      if (!validOptions) {
        return;
      }

      const ignoreEmptyLines = optionsMatches(secondaryOptions, 'ignore', 'empty-lines');

      if (context.fix) {
        fix(root);
      }

      const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';
      /**
       * @param {number} index
       */

      const reportFromIndex = index => {
        report$1({
          message: messages$1h.rejected,
          node: root,
          index,
          result,
          ruleName: ruleName$1h
        });
      };

      eachEolWhitespace(rootString, reportFromIndex, true);
      const errorIndex = findErrorStartIndex(rootString.length, rootString, {
        ignoreEmptyLines,
        isRootFirst: true
      });

      if (errorIndex > -1) {
        reportFromIndex(errorIndex);
      }
      /**
       * Iterate each whitespace at the end of each line of the given string.
       * @param {string} string - the source code string
       * @param {(index: number) => void} callback - callback the whitespace index at the end of each line.
       * @param {boolean} isRootFirst - set `true` if the given string is the first token of the root.
       * @returns {void}
       */


      function eachEolWhitespace(string, callback, isRootFirst) {
        styleSearch({
          source: string,
          target: ['\n', '\r'],
          comments: 'check'
        }, match => {
          const index = findErrorStartIndex(match.startIndex, string, {
            ignoreEmptyLines,
            isRootFirst
          });

          if (index > -1) {
            callback(index);
          }
        });
      }
      /**
       * @param {import('postcss').Root} rootNode
       */


      function fix(rootNode) {
        let isRootFirst = true;
        rootNode.walk(node => {
          fixText(node.raws.before, fixed => {
            node.raws.before = fixed;
          }, isRootFirst);
          isRootFirst = false;

          if (isAtRule$9(node)) {
            fixText(node.raws.afterName, fixed => {
              node.raws.afterName = fixed;
            });
            const rawsParams = node.raws.params;

            if (rawsParams) {
              fixText(rawsParams.raw, fixed => {
                rawsParams.raw = fixed;
              });
            } else {
              fixText(node.params, fixed => {
                node.params = fixed;
              });
            }
          }

          if (isRule$3(node)) {
            const rawsSelector = node.raws.selector;

            if (rawsSelector) {
              fixText(rawsSelector.raw, fixed => {
                rawsSelector.raw = fixed;
              });
            } else {
              fixText(node.selector, fixed => {
                node.selector = fixed;
              });
            }
          }

          if (isAtRule$9(node) || isRule$3(node) || isDeclaration$1(node)) {
            fixText(node.raws.between, fixed => {
              node.raws.between = fixed;
            });
          }

          if (isDeclaration$1(node)) {
            const rawsValue = node.raws.value;

            if (rawsValue) {
              fixText(rawsValue.raw, fixed => {
                rawsValue.raw = fixed;
              });
            } else {
              fixText(node.value, fixed => {
                node.value = fixed;
              });
            }
          }

          if (isComment(node)) {
            fixText(node.raws.left, fixed => {
              node.raws.left = fixed;
            });

            if (!isStandardSyntaxComment(node)) {
              node.raws.right = node.raws.right && fixString(node.raws.right);
            } else {
              fixText(node.raws.right, fixed => {
                node.raws.right = fixed;
              });
            }

            fixText(node.text, fixed => {
              node.text = fixed;
            });
          }

          if (isAtRule$9(node) || isRule$3(node)) {
            fixText(node.raws.after, fixed => {
              node.raws.after = fixed;
            });
          }
        });
        fixText(rootNode.raws.after, fixed => {
          rootNode.raws.after = fixed;
        }, isRootFirst);

        if (typeof rootNode.raws.after === 'string') {
          const lastEOL = Math.max(rootNode.raws.after.lastIndexOf('\n'), rootNode.raws.after.lastIndexOf('\r'));

          if (lastEOL !== rootNode.raws.after.length - 1) {
            rootNode.raws.after = rootNode.raws.after.slice(0, lastEOL + 1) + fixString(rootNode.raws.after.slice(lastEOL + 1));
          }
        }
      }
      /**
       * @param {string | undefined} value
       * @param {(text: string) => void} fixFn
       * @param {boolean} isRootFirst
       */


      function fixText(value, fixFn, isRootFirst = false) {
        if (!value) {
          return;
        }

        let fixed = '';
        let lastIndex = 0;
        eachEolWhitespace(value, index => {
          const newlineIndex = index + 1;
          fixed += fixString(value.slice(lastIndex, newlineIndex));
          lastIndex = newlineIndex;
        }, isRootFirst);

        if (lastIndex) {
          fixed += value.slice(lastIndex);
          fixFn(fixed);
        }
      }
    };
  };

  rule$1g.ruleName = ruleName$1h;
  rule$1g.messages = messages$1h;
  rule$1g.meta = meta$1h;
  var noEolWhitespace = rule$1g;

  const {
    isAtRule: isAtRule$8
  } = typeGuards;

  const ruleName$1g = 'no-extra-semicolons';
  const messages$1g = ruleMessages$1(ruleName$1g, {
    rejected: 'Unexpected extra semicolon'
  });
  const meta$1g = {
    url: 'https://stylelint.io/user-guide/rules/no-extra-semicolons',
    fixable: true,
    deprecated: true
  };
  /**
   * @param {import('postcss').Node} node
   * @returns {number}
   */

  function getOffsetByNode(node) {
    // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Document | Container<ChildNode>'
    if (node.parent && node.parent.document) {
      return 0;
    }

    const root = node.root();
    if (!root.source) throw new Error('The root node must have a source');
    if (!node.source) throw new Error('The node must have a source');
    if (!node.source.start) throw new Error('The source must have a start position');
    const string = root.source.input.css;
    const nodeColumn = node.source.start.column;
    const nodeLine = node.source.start.line;
    let line = 1;
    let column = 1;
    let index = 0;

    for (let i = 0; i < string.length; i++) {
      if (column === nodeColumn && nodeLine === line) {
        index = i;
        break;
      }

      if (string[i] === '\n') {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }

    return index;
  }
  /** @type {import('stylelint').Rule} */


  const rule$1f = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1g, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      if (root.raws.after && root.raws.after.trim().length !== 0) {
        const rawAfterRoot = root.raws.after;
        /** @type {number[]} */

        const fixSemiIndices = [];
        styleSearch({
          source: rawAfterRoot,
          target: ';'
        }, match => {
          if (context.fix) {
            fixSemiIndices.push(match.startIndex);
            return;
          }

          if (!root.source) throw new Error('The root node must have a source');
          complain(root.source.input.css.length - rawAfterRoot.length + match.startIndex);
        }); // fix

        if (fixSemiIndices.length) {
          root.raws.after = removeIndices(rawAfterRoot, fixSemiIndices);
        }
      }

      root.walk(node => {
        if (isAtRule$8(node) && !isStandardSyntaxAtRule(node)) {
          return;
        }

        if (node.type === 'rule' && !isStandardSyntaxRule(node)) {
          return;
        }

        if (node.raws.before && node.raws.before.trim().length !== 0) {
          const rawBeforeNode = node.raws.before;
          const allowedSemi = 0;
          const rawBeforeIndexStart = 0;
          /** @type {number[]} */

          const fixSemiIndices = [];
          styleSearch({
            source: rawBeforeNode,
            target: ';'
          }, (match, count) => {
            if (count === allowedSemi) {
              return;
            }

            if (context.fix) {
              fixSemiIndices.push(match.startIndex - rawBeforeIndexStart);
              return;
            }

            complain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex);
          }); // fix

          if (fixSemiIndices.length) {
            node.raws.before = removeIndices(rawBeforeNode, fixSemiIndices);
          }
        }

        if (typeof node.raws.after === 'string' && node.raws.after.trim().length !== 0) {
          const rawAfterNode = node.raws.after;
          /**
           * If the last child is a Less mixin followed by more than one semicolon,
           * node.raws.after will be populated with that semicolon.
           * Since we ignore Less mixins, exit here
           */

          if ('last' in node && node.last && node.last.type === 'atrule' && !isStandardSyntaxAtRule(node.last)) {
            return;
          }
          /** @type {number[]} */


          const fixSemiIndices = [];
          styleSearch({
            source: rawAfterNode,
            target: ';'
          }, match => {
            if (context.fix) {
              fixSemiIndices.push(match.startIndex);
              return;
            }

            const index = getOffsetByNode(node) + node.toString().length - 1 - rawAfterNode.length + match.startIndex;
            complain(index);
          }); // fix

          if (fixSemiIndices.length) {
            node.raws.after = removeIndices(rawAfterNode, fixSemiIndices);
          }
        }

        if (typeof node.raws.ownSemicolon === 'string') {
          const rawOwnSemicolon = node.raws.ownSemicolon;
          const allowedSemi = 0;
          /** @type {number[]} */

          const fixSemiIndices = [];
          styleSearch({
            source: rawOwnSemicolon,
            target: ';'
          }, (match, count) => {
            if (count === allowedSemi) {
              return;
            }

            if (context.fix) {
              fixSemiIndices.push(match.startIndex);
              return;
            }

            const index = getOffsetByNode(node) + node.toString().length - rawOwnSemicolon.length + match.startIndex;
            complain(index);
          }); // fix

          if (fixSemiIndices.length) {
            node.raws.ownSemicolon = removeIndices(rawOwnSemicolon, fixSemiIndices);
          }
        }
      });
      /**
       * @param {number} index
       */

      function complain(index) {
        report$1({
          message: messages$1g.rejected,
          node: root,
          index,
          result,
          ruleName: ruleName$1g
        });
      }
      /**
       * @param {string} str
       * @param {number[]} indices
       * @returns {string}
       */


      function removeIndices(str, indices) {
        for (const index of indices.reverse()) {
          str = str.slice(0, index) + str.slice(index + 1);
        }

        return str;
      }
    };
  };

  rule$1f.ruleName = ruleName$1g;
  rule$1f.messages = messages$1g;
  rule$1f.meta = meta$1g;
  var noExtraSemicolons = rule$1f;

  const ruleName$1f = 'no-invalid-double-slash-comments';
  const messages$1f = ruleMessages$1(ruleName$1f, {
    rejected: 'Unexpected double-slash CSS comment'
  });
  const meta$1f = {
    url: 'https://stylelint.io/user-guide/rules/no-invalid-double-slash-comments'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1e = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1f, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (decl.prop.startsWith('//')) {
          report$1({
            message: messages$1f.rejected,
            node: decl,
            result,
            ruleName: ruleName$1f,
            word: decl.toString()
          });
        }
      });
      root.walkRules(ruleNode => {
        for (const selector of ruleNode.selectors) {
          if (selector.startsWith('//')) {
            report$1({
              message: messages$1f.rejected,
              node: ruleNode,
              result,
              ruleName: ruleName$1f,
              word: ruleNode.toString()
            });
          }
        }
      });
    };
  };

  rule$1e.ruleName = ruleName$1f;
  rule$1e.messages = messages$1f;
  rule$1e.meta = meta$1f;
  var noInvalidDoubleSlashComments = rule$1e;

  const {
    isAtRule: isAtRule$7
  } = typeGuards;



  const {
    isRegExp: isRegExp$u,
    isString: isString$D
  } = validateTypes;

  const ruleName$1e = 'no-invalid-position-at-import-rule';
  const messages$1e = ruleMessages$1(ruleName$1e, {
    rejected: 'Unexpected invalid position @import rule'
  });
  const meta$1e = {
    url: 'https://stylelint.io/user-guide/rules/no-invalid-position-at-import-rule'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1d = (primary, options) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1e, {
        actual: primary
      }, {
        actual: options,
        possible: {
          ignoreAtRules: [isString$D, isRegExp$u]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      let invalidPosition = false;
      root.walk(node => {
        const nodeName = 'name' in node && node.name && node.name.toLowerCase() || '';

        if (isAtRule$7(node) && nodeName !== 'charset' && nodeName !== 'import' && nodeName !== 'layer' && !optionsMatches(options, 'ignoreAtRules', node.name) && isStandardSyntaxAtRule(node) || node.type === 'rule' && isStandardSyntaxRule(node)) {
          invalidPosition = true;
          return;
        }

        if (isAtRule$7(node) && nodeName === 'import' && invalidPosition) {
          report$1({
            message: messages$1e.rejected,
            node,
            result,
            ruleName: ruleName$1e,
            word: node.toString()
          });
        }
      });
    };
  };

  rule$1d.ruleName = ruleName$1e;
  rule$1d.messages = messages$1e;
  rule$1d.meta = meta$1e;
  var noInvalidPositionAtImportRule = rule$1d;

  const ruleName$1d = 'no-irregular-whitespace';
  const messages$1d = ruleMessages$1(ruleName$1d, {
    unexpected: 'Unexpected irregular whitespace'
  });
  const meta$1d = {
    url: 'https://stylelint.io/user-guide/rules/no-irregular-whitespace'
  };
  const IRREGULAR_WHITESPACES = ['\u000B', // Line Tabulation (\v) - <VT>
  '\u000C', // Form Feed (\f) - <FF>
  '\u00A0', // No-Break Space - <NBSP>
  '\u0085', // Next Line
  '\u1680', // Ogham Space Mark
  '\u180E', // Mongolian Vowel Separator - <MVS>
  '\uFEFF', // Zero Width No-Break Space - <BOM>
  '\u2000', // En Quad
  '\u2001', // Em Quad
  '\u2002', // En Space - <ENSP>
  '\u2003', // Em Space - <EMSP>
  '\u2004', // Tree-Per-Em
  '\u2005', // Four-Per-Em
  '\u2006', // Six-Per-Em
  '\u2007', // Figure Space
  '\u2008', // Punctuation Space - <PUNCSP>
  '\u2009', // Thin Space
  '\u200A', // Hair Space
  '\u200B', // Zero Width Space - <ZWSP>
  '\u2028', // Line Separator
  '\u2029', // Paragraph Separator
  '\u202F', // Narrow No-Break Space
  '\u205F', // Medium Mathematical Space
  '\u3000' // Ideographic Space
  ];
  const IRREGULAR_WHITESPACES_PATTERN = new RegExp(`([${IRREGULAR_WHITESPACES.join('')}])`);
  /**
   * @param {string} str
   * @returns {string | null}
   */

  const findIrregularWhitespace = str => {
    const result = IRREGULAR_WHITESPACES_PATTERN.exec(str);
    return result && result[1] || null;
  };
  /** @type {import('stylelint').Rule} */


  const rule$1c = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1d, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {import('postcss').Node} node
       * @param {string | undefined} value
       */


      const validate = (node, value) => {
        const issue = value && findIrregularWhitespace(value);

        if (issue) {
          report$1({
            ruleName: ruleName$1d,
            result,
            message: messages$1d.unexpected,
            node,
            word: issue
          });
        }
      };

      root.walkAtRules(atRule => {
        validate(atRule, atRule.name);
        validate(atRule, atRule.params);
        validate(atRule, atRule.raws.before);
        validate(atRule, atRule.raws.after);
        validate(atRule, atRule.raws.afterName);
        validate(atRule, atRule.raws.between);
      });
      root.walkRules(ruleNode => {
        validate(ruleNode, ruleNode.selector);
        validate(ruleNode, ruleNode.raws.before);
        validate(ruleNode, ruleNode.raws.after);
        validate(ruleNode, ruleNode.raws.between);
      });
      root.walkDecls(decl => {
        validate(decl, decl.prop);
        validate(decl, decl.value);
        validate(decl, decl.raws.before);
        validate(decl, decl.raws.between);
      });
    };
  };

  rule$1c.ruleName = ruleName$1d;
  rule$1c.messages = messages$1d;
  rule$1c.meta = meta$1d;
  var noIrregularWhitespace = rule$1c;

  const ruleName$1c = 'no-missing-end-of-source-newline';
  const messages$1c = ruleMessages$1(ruleName$1c, {
    rejected: 'Unexpected missing end-of-source newline'
  });
  const meta$1c = {
    url: 'https://stylelint.io/user-guide/rules/no-missing-end-of-source-newline',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1b = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1c, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      if (root.source == null) {
        throw new Error('The root node must have a source property');
      } // @ts-expect-error -- TS2339: Property 'inline' does not exist on type 'Source'.


      if (root.source.inline || root.source.lang === 'object-literal') {
        return;
      }

      const rootString = context.fix ? root.toString() : root.source.input.css;

      if (!rootString.trim() || rootString.endsWith('\n')) {
        return;
      } // Fix


      if (context.fix) {
        root.raws.after = context.newline;
        return;
      }

      report$1({
        message: messages$1c.rejected,
        node: root,
        index: rootString.length - 1,
        result,
        ruleName: ruleName$1c
      });
    };
  };

  rule$1b.ruleName = ruleName$1c;
  rule$1b.messages = messages$1c;
  rule$1b.meta = meta$1c;
  var noMissingEndOfSourceNewline = rule$1b;

  const {
    animationShorthandKeywords: animationShorthandKeywords$1,
    basicKeywords
  } = keywords$4;


  /** @typedef {import('postcss-value-parser').Node} Node */

  /**
   * Get the animation name within an `animation` shorthand property value.
   *
   * @param {string} value
   *
   * @returns {Node[]}
   */


  var findAnimationName = function findAnimationName(value) {
    /** @type {Node[]} */
    const animationNames = [];
    const valueNodes = lib$6(value);
    const {
      nodes
    } = valueNodes; // Handle `inherit`, `initial` and etc

    if (nodes.length === 1 && nodes[0] && basicKeywords.has(nodes[0].value.toLowerCase())) {
      return [nodes[0]];
    }

    let shouldBeIgnored = false;
    valueNodes.walk(valueNode => {
      if (shouldBeIgnored) return;

      if (valueNode.type === 'function') {
        return false;
      }

      if (valueNode.type !== 'word') {
        return;
      }

      const valueLowerCase = valueNode.value.toLowerCase(); // Ignore non-standard syntax

      if (!isStandardSyntaxValue(valueLowerCase)) {
        // Cannot find animation name if shorthand has non-standard syntax value (#5532)
        shouldBeIgnored = true;
        animationNames.length = 0; // clears animationNames

        return;
      } // Ignore variables


      if (isVariable(valueLowerCase)) {
        return;
      } // Ignore keywords for other animation parts


      if (animationShorthandKeywords$1.has(valueLowerCase)) {
        return;
      } // Ignore numbers with units


      const {
        unit
      } = getDimension(valueNode);

      if (unit || unit === '') {
        return;
      }

      animationNames.push(valueNode);
    });
    return animationNames;
  };

  const {
    animationNameKeywords: animationNameKeywords$1
  } = keywords$4;







  const ruleName$1b = 'no-unknown-animations';
  const messages$1b = ruleMessages$1(ruleName$1b, {
    rejected: animationName => `Unexpected unknown animation name "${animationName}"`
  });
  const meta$1b = {
    url: 'https://stylelint.io/user-guide/rules/no-unknown-animations'
  };
  /** @type {import('stylelint').Rule} */

  const rule$1a = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1b, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      const declaredAnimations = new Set();
      root.walkAtRules(/(-(moz|webkit)-)?keyframes/i, atRule => {
        declaredAnimations.add(atRule.params);
      });
      root.walkDecls(decl => {
        if (decl.prop.toLowerCase() === 'animation' || decl.prop.toLowerCase() === 'animation-name') {
          const animationNames = findAnimationName(decl.value);

          if (animationNames.length === 0) {
            return;
          }

          for (const animationNameNode of animationNames) {
            if (animationNameKeywords$1.has(animationNameNode.value.toLowerCase())) {
              continue;
            }

            if (declaredAnimations.has(animationNameNode.value)) {
              continue;
            }

            const begin = declarationValueIndex(decl);
            report$1({
              result,
              ruleName: ruleName$1b,
              message: messages$1b.rejected,
              messageArgs: [animationNameNode.value],
              node: decl,
              index: begin + animationNameNode.sourceIndex,
              endIndex: begin + animationNameNode.sourceEndIndex
            });
          }
        }
      });
    };
  };

  rule$1a.ruleName = ruleName$1b;
  rule$1a.messages = messages$1b;
  rule$1a.meta = meta$1b;
  var noUnknownAnimations = rule$1a;

  const {
    isValueFunction
  } = typeGuards;



  const ruleName$1a = 'no-unknown-custom-properties';
  const messages$1a = ruleMessages$1(ruleName$1a, {
    rejected: propName => `Unexpected unknown custom property "${propName}"`
  });
  const meta$1a = {
    url: 'https://stylelint.io/user-guide/rules/no-unknown-custom-properties'
  };
  /** @type {import('stylelint').Rule} */

  const rule$19 = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1a, {
        actual: primary
      });
      if (!validOptions) return;
      /** @type {Set<string>} */

      const declaredCustomProps = new Set();
      root.walkAtRules(/^property$/i, ({
        params
      }) => {
        declaredCustomProps.add(params);
      });
      root.walkDecls(/^--/, ({
        prop
      }) => {
        declaredCustomProps.add(prop);
      });
      root.walkDecls(decl => {
        const {
          value
        } = decl;
        const parsedValue = lib$6(value);
        parsedValue.walk(node => {
          if (!isValueFunction(node) || node.value !== 'var') return;
          const [firstNode, secondNode] = node.nodes;
          if (!firstNode || declaredCustomProps.has(firstNode.value)) return; // Second node (div) indicates fallback exists in all cases

          if (secondNode && secondNode.type === 'div') return;
          const startIndex = declarationValueIndex(decl);
          report$1({
            result,
            ruleName: ruleName$1a,
            message: messages$1a.rejected,
            messageArgs: [firstNode.value],
            node: decl,
            index: startIndex + firstNode.sourceIndex,
            endIndex: startIndex + firstNode.sourceEndIndex
          });
        });
      });
    };
  };

  rule$19.ruleName = ruleName$1a;
  rule$19.messages = messages$1a;
  rule$19.meta = meta$1a;
  var noUnknownCustomProperties = rule$19;

  const {
    isAtRule: isAtRule$6
  } = typeGuards;



  const ruleName$19 = 'number-leading-zero';
  const messages$19 = ruleMessages$1(ruleName$19, {
    expected: 'Expected a leading zero',
    rejected: 'Unexpected leading zero'
  });
  const meta$19 = {
    url: 'https://stylelint.io/user-guide/rules/number-leading-zero',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$18 = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$19, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(atRule => {
        if (atRule.name.toLowerCase() === 'import') {
          return;
        }

        check(atRule, atRule.params);
      });
      root.walkDecls(decl => check(decl, decl.value));
      /**
       * @param {import('postcss').AtRule | import('postcss').Declaration} node
       * @param {string} value
       */

      function check(node, value) {
        /** @type {Array<{ startIndex: number, endIndex: number }>} */
        const neverFixPositions = [];
        /** @type {Array<{ index: number }>} */

        const alwaysFixPositions = []; // Get out quickly if there are no periods

        if (!value.includes('.')) {
          return;
        }

        lib$6(value).walk(valueNode => {
          // Ignore `url` function
          if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
            return false;
          } // Ignore strings, comments, etc


          if (valueNode.type !== 'word') {
            return;
          } // Check leading zero


          if (primary === 'always') {
            const match = /(?:\D|^)(\.\d+)/.exec(valueNode.value);

            if (match == null || match[0] == null || match[1] == null) {
              return;
            } // The regexp above consists of 2 capturing groups (or capturing parentheses).
            // We need the index of the second group. This makes sanse when we have "-.5" as an input
            // for regex. And we need the index of ".5".


            const capturingGroupIndex = match[0].length - match[1].length;
            const index = valueNode.sourceIndex + match.index + capturingGroupIndex;

            if (context.fix) {
              alwaysFixPositions.unshift({
                index
              });
              return;
            }

            const baseIndex = isAtRule$6(node) ? atRuleParamIndex(node) : declarationValueIndex(node);
            complain(messages$19.expected, node, baseIndex + index);
          }

          if (primary === 'never') {
            const match = /(?:\D|^)(0+)(\.\d+)/.exec(valueNode.value);

            if (match == null || match[0] == null || match[1] == null || match[2] == null) {
              return;
            } // The regexp above consists of 3 capturing groups (or capturing parentheses).
            // We need the index of the second group. This makes sanse when we have "-00.5"
            // as an input for regex. And we need the index of "00".


            const capturingGroupIndex = match[0].length - (match[1].length + match[2].length);
            const index = valueNode.sourceIndex + match.index + capturingGroupIndex;

            if (context.fix) {
              neverFixPositions.unshift({
                startIndex: index,
                // match[1].length is the length of our matched zero(s)
                endIndex: index + match[1].length
              });
              return;
            }

            const baseIndex = isAtRule$6(node) ? atRuleParamIndex(node) : declarationValueIndex(node);
            complain(messages$19.rejected, node, baseIndex + index);
          }
        });

        if (alwaysFixPositions.length) {
          for (const fixPosition of alwaysFixPositions) {
            const index = fixPosition.index;

            if (isAtRule$6(node)) {
              node.params = addLeadingZero(node.params, index);
            } else {
              node.value = addLeadingZero(node.value, index);
            }
          }
        }

        if (neverFixPositions.length) {
          for (const fixPosition of neverFixPositions) {
            const startIndex = fixPosition.startIndex;
            const endIndex = fixPosition.endIndex;

            if (isAtRule$6(node)) {
              node.params = removeLeadingZeros(node.params, startIndex, endIndex);
            } else {
              node.value = removeLeadingZeros(node.value, startIndex, endIndex);
            }
          }
        }
      }
      /**
       * @param {string} message
       * @param {import('postcss').Node} node
       * @param {number} index
       */


      function complain(message, node, index) {
        report$1({
          result,
          ruleName: ruleName$19,
          message,
          node,
          index
        });
      }
    };
  };
  /**
   * @param {string} input
   * @param {number} index
   * @returns {string}
   */


  function addLeadingZero(input, index) {
    // eslint-disable-next-line prefer-template
    return input.slice(0, index) + '0' + input.slice(index);
  }
  /**
   * @param {string} input
   * @param {number} startIndex
   * @param {number} endIndex
   * @returns {string}
   */


  function removeLeadingZeros(input, startIndex, endIndex) {
    return input.slice(0, startIndex) + input.slice(endIndex);
  }

  rule$18.ruleName = ruleName$19;
  rule$18.messages = messages$19;
  rule$18.meta = meta$19;
  var numberLeadingZero = rule$18;

  const {
    tokenize: tokenize$3,
    TokenType: TokenType$2
  } = require$$0$5;

  const {
    isFunctionNode: isFunctionNode$2,
    isSimpleBlockNode: isSimpleBlockNode$2,
    isTokenNode: isTokenNode$2,
    parseListOfComponentValues: parseListOfComponentValues$2
  } = require$$1;



















  const {
    isNumber: isNumber$6,
    isRegExp: isRegExp$t,
    isString: isString$C
  } = validateTypes;



  const ruleName$18 = 'number-max-precision';
  const messages$18 = ruleMessages$1(ruleName$18, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$18 = {
    url: 'https://stylelint.io/user-guide/rules/number-max-precision'
  };
  /** @type {import('stylelint').Rule<number>} */

  const rule$17 = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$18, {
        actual: primary,
        possible: [isNumber$6]
      }, {
        optional: true,
        actual: secondaryOptions,
        possible: {
          ignoreProperties: [isString$C, isRegExp$t],
          ignoreUnits: [isString$C, isRegExp$t],
          insideFunctions: [validateObjectWithProps(isNumber$6)]
        }
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<string, number>} */


      const insideFunctions = new Map(Object.entries(secondaryOptions?.insideFunctions ?? {}));
      root.walkAtRules(atRule => {
        if (atRule.name.toLowerCase() === 'import') {
          return;
        }

        check(atRule, atRuleParamIndex, getAtRuleParams(atRule));
      });
      root.walkDecls(decl => {
        check(decl, declarationValueIndex, getDeclarationValue(decl));
      });
      /**
       * @template {import('postcss').AtRule | import('postcss').Declaration} T
       * @param {T} node
       * @param {(node: T) => number} getIndex
       * @param {string} value
       */

      function check(node, getIndex, value) {
        // Get out quickly if there are no periods
        if (!value.includes('.')) {
          return;
        }

        const prop = 'prop' in node ? node.prop : undefined;

        if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
          return;
        }

        parseListOfComponentValues$2(tokenize$3({
          css: value
        })).forEach(componentValue => {
          const initialState = {
            ignored: false,
            precision: primary
          };
          walker(node, getIndex, componentValue, initialState);

          if (isFunctionNode$2(componentValue) || isSimpleBlockNode$2(componentValue)) {
            componentValue.walk(({
              node: mediaNode,
              state
            }) => {
              if (!state) return;
              if (state.ignored) return;
              walker(node, getIndex, mediaNode, state);
            }, initialState);
          }
        });
      }
      /**
       * @template {import('postcss').AtRule | import('postcss').Declaration} T
       * @param {T} node
       * @param {(node: T) => number} getIndex
       * @param {import('@csstools/css-parser-algorithms').ComponentValue} componentValue
       * @param {{ ignored: boolean, precision: number }} state
       */


      function walker(node, getIndex, componentValue, state) {
        if (isFunctionNode$2(componentValue)) {
          const name = componentValue.getName().toLowerCase();

          if (name === 'url') {
            // postcss-value-parser exposed url token contents as "word" tokens, these were indistinguishable from numeric values in any other function.
            // With @csstools/css-tokenizer this is no longer relevant, but we preserve the old condition to avoid breaking changes.
            state.ignored = true;
            return;
          }

          state.precision = precisionInsideFunction(name, state.precision);
          return;
        }

        if (!isTokenNode$2(componentValue)) {
          return;
        }

        const [tokenType, raw, startIndex, endIndex, parsedValue] = componentValue.value;

        if (tokenType !== TokenType$2.Number && tokenType !== TokenType$2.Dimension && tokenType !== TokenType$2.Percentage) {
          return;
        }

        let unitStringLength = 0;

        if (tokenType === TokenType$2.Dimension) {
          const unit = parsedValue.unit;
          unitStringLength = unit.length;

          if (optionsMatches(secondaryOptions, 'ignoreUnits', unit)) {
            return;
          }
        } else if (tokenType === TokenType$2.Percentage) {
          unitStringLength = 1;

          if (optionsMatches(secondaryOptions, 'ignoreUnits', '%')) {
            return;
          }
        }

        const match = /\d*\.(\d+)/.exec(raw);

        if (match == null || match[0] == null || match[1] == null) {
          return;
        }

        if (match[1].length <= state.precision) {
          return;
        }

        const nodeIndex = getIndex(node);
        report$1({
          result,
          ruleName: ruleName$18,
          node,
          index: nodeIndex + startIndex,
          endIndex: nodeIndex + (endIndex + 1) - unitStringLength,
          message: messages$18.expected,
          messageArgs: [parsedValue.value, parsedValue.value.toFixed(state.precision)]
        });
      }
      /**
       * @param {string} functionName
       * @param {number} currentPrecision
       * @returns {number}
       */


      function precisionInsideFunction(functionName, currentPrecision) {
        const precisionForFunction = insideFunctions.get(functionName);
        if (isNumber$6(precisionForFunction)) return precisionForFunction;

        for (const [name, precision] of insideFunctions) {
          if (matchesStringOrRegExp(functionName, name)) {
            return precision;
          }
        }

        return currentPrecision;
      }
    };
  };

  rule$17.ruleName = ruleName$18;
  rule$17.messages = messages$18;
  rule$17.meta = meta$18;
  var numberMaxPrecision = rule$17;

  const {
    isAtRule: isAtRule$5
  } = typeGuards;



  const ruleName$17 = 'number-no-trailing-zeros';
  const messages$17 = ruleMessages$1(ruleName$17, {
    rejected: 'Unexpected trailing zero(s)'
  });
  const meta$17 = {
    url: 'https://stylelint.io/user-guide/rules/number-no-trailing-zeros',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$16 = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$17, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkAtRules(atRule => {
        if (atRule.name.toLowerCase() === 'import') {
          return;
        }

        check(atRule, atRule.params);
      });
      root.walkDecls(decl => check(decl, decl.value));
      /**
       * @param {import('postcss').AtRule | import('postcss').Declaration} node
       * @param {string} value
       */

      function check(node, value) {
        /** @type {Array<{ startIndex: number, endIndex: number }>} */
        const fixPositions = []; // Get out quickly if there are no periods

        if (!value.includes('.')) {
          return;
        }

        lib$6(value).walk(valueNode => {
          // Ignore `url` function
          if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
            return false;
          } // Ignore strings, comments, etc


          if (valueNode.type !== 'word') {
            return;
          }

          const match = /\.(\d{0,100}?)(0+)(?:\D|$)/.exec(valueNode.value); // match[1] is any numbers between the decimal and our trailing zero, could be empty
          // match[2] is our trailing zero(s)

          if (match == null || match[1] == null || match[2] == null) {
            return;
          } // our index is:
          //  the index of our valueNode +
          //  the index of our match +
          //  1 for our decimal +
          //  the length of our potential non-zero number match (match[1])


          const index = valueNode.sourceIndex + match.index + 1 + match[1].length; // our startIndex is identical to our index except when we have only
          // trailing zeros after our decimal. in that case we don't need the decimal
          // either so we move our index back by 1.

          const startIndex = match[1].length > 0 ? index : index - 1; // our end index is our original index + the length of our trailing zeros

          const endIndex = index + match[2].length;

          if (context.fix) {
            fixPositions.unshift({
              startIndex,
              endIndex
            });
            return;
          }

          const baseIndex = isAtRule$5(node) ? atRuleParamIndex(node) : declarationValueIndex(node);
          report$1({
            message: messages$17.rejected,
            node,
            // this is the index of the _first_ trailing zero
            index: baseIndex + index,
            result,
            ruleName: ruleName$17
          });
        });

        if (fixPositions.length) {
          for (const fixPosition of fixPositions) {
            const startIndex = fixPosition.startIndex;
            const endIndex = fixPosition.endIndex;

            if (isAtRule$5(node)) {
              node.params = removeTrailingZeros(node.params, startIndex, endIndex);
            } else {
              node.value = removeTrailingZeros(node.value, startIndex, endIndex);
            }
          }
        }
      }
    };
  };
  /**
   * @param {string} input
   * @param {number} startIndex
   * @param {number} endIndex
   * @returns {string}
   */


  function removeTrailingZeros(input, startIndex, endIndex) {
    return input.slice(0, startIndex) + input.slice(endIndex);
  }

  rule$16.ruleName = ruleName$17;
  rule$16.messages = messages$17;
  rule$16.meta = meta$17;
  var numberNoTrailingZeros = rule$16;

  const {
    isRegExp: isRegExp$s,
    isString: isString$B
  } = validateTypes;

  const ruleName$16 = 'property-allowed-list';
  const messages$16 = ruleMessages$1(ruleName$16, {
    rejected: property => `Unexpected property "${property}"`
  });
  const meta$16 = {
    url: 'https://stylelint.io/user-guide/rules/property-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$15 = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$16, {
        actual: primary,
        possible: [isString$B, isRegExp$s]
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;

        if (!isStandardSyntaxProperty(prop)) {
          return;
        }

        if (isCustomProperty$2(prop)) {
          return;
        } // either the prefix or unprefixed version is in the list


        if (matchesStringOrRegExp([prop, vendor.unprefixed(prop)], primary)) {
          return;
        }

        report$1({
          message: messages$16.rejected,
          messageArgs: [prop],
          word: prop,
          node: decl,
          result,
          ruleName: ruleName$16
        });
      });
    };
  };

  rule$15.primaryOptionArray = true;
  rule$15.ruleName = ruleName$16;
  rule$15.messages = messages$16;
  rule$15.meta = meta$16;
  var propertyAllowedList = rule$15;

  const {
    isRegExp: isRegExp$r,
    isString: isString$A
  } = validateTypes;

  const {
    isRule: isRule$2
  } = typeGuards;

  const ruleName$15 = 'property-case';
  const messages$15 = ruleMessages$1(ruleName$15, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$15 = {
    url: 'https://stylelint.io/user-guide/rules/property-case',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$14 = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$15, {
        actual: primary,
        possible: ['lower', 'upper']
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreSelectors: [isString$A, isRegExp$r]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;

        if (!isStandardSyntaxProperty(prop)) {
          return;
        }

        if (isCustomProperty$2(prop)) {
          return;
        }

        const {
          parent
        } = decl;
        if (!parent) throw new Error('A parent node must be present');

        if (isRule$2(parent)) {
          const {
            selector
          } = parent;

          if (selector && optionsMatches(secondaryOptions, 'ignoreSelectors', selector)) {
            return;
          }
        }

        const expectedProp = primary === 'lower' ? prop.toLowerCase() : prop.toUpperCase();

        if (prop === expectedProp) {
          return;
        }

        if (context.fix) {
          decl.prop = expectedProp;
          return;
        }

        report$1({
          message: messages$15.expected(prop, expectedProp),
          word: prop,
          node: decl,
          ruleName: ruleName$15,
          result
        });
      });
    };
  };

  rule$14.ruleName = ruleName$15;
  rule$14.messages = messages$15;
  rule$14.meta = meta$15;
  var propertyCase = rule$14;

  const {
    isRegExp: isRegExp$q,
    isString: isString$z
  } = validateTypes;

  const ruleName$14 = 'property-disallowed-list';
  const messages$14 = ruleMessages$1(ruleName$14, {
    rejected: property => `Unexpected property "${property}"`
  });
  const meta$14 = {
    url: 'https://stylelint.io/user-guide/rules/property-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$13 = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$14, {
        actual: primary,
        possible: [isString$z, isRegExp$q]
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;

        if (!isStandardSyntaxProperty(prop)) {
          return;
        }

        if (isCustomProperty$2(prop)) {
          return;
        } // either the prefix or unprefixed version is in the list


        if (!matchesStringOrRegExp([prop, vendor.unprefixed(prop)], primary)) {
          return;
        }

        report$1({
          message: messages$14.rejected,
          messageArgs: [prop],
          word: prop,
          node: decl,
          result,
          ruleName: ruleName$14
        });
      });
    };
  };

  rule$13.primaryOptionArray = true;
  rule$13.ruleName = ruleName$14;
  rule$13.messages = messages$14;
  rule$13.meta = meta$14;
  var propertyDisallowedList = rule$13;

  var properties$1 = [
  	"-epub-caption-side",
  	"-epub-hyphens",
  	"-epub-text-combine",
  	"-epub-text-emphasis",
  	"-epub-text-emphasis-color",
  	"-epub-text-emphasis-style",
  	"-epub-text-orientation",
  	"-epub-text-transform",
  	"-epub-word-break",
  	"-epub-writing-mode",
  	"-internal-text-autosizing-status",
  	"accelerator",
  	"accent-color",
  	"-wap-accesskey",
  	"additive-symbols",
  	"align-content",
  	"-webkit-align-content",
  	"align-items",
  	"-webkit-align-items",
  	"align-self",
  	"-webkit-align-self",
  	"alignment-baseline",
  	"all",
  	"alt",
  	"-webkit-alt",
  	"animation",
  	"animation-composition",
  	"animation-delay",
  	"animation-delay-end",
  	"-moz-animation-delay",
  	"-ms-animation-delay",
  	"animation-delay-start",
  	"-webkit-animation-delay",
  	"animation-direction",
  	"-moz-animation-direction",
  	"-ms-animation-direction",
  	"-webkit-animation-direction",
  	"animation-duration",
  	"-moz-animation-duration",
  	"-ms-animation-duration",
  	"-webkit-animation-duration",
  	"animation-fill-mode",
  	"-moz-animation-fill-mode",
  	"-ms-animation-fill-mode",
  	"-webkit-animation-fill-mode",
  	"animation-iteration-count",
  	"-moz-animation-iteration-count",
  	"-ms-animation-iteration-count",
  	"-webkit-animation-iteration-count",
  	"-moz-animation",
  	"-ms-animation",
  	"animation-name",
  	"-moz-animation-name",
  	"-ms-animation-name",
  	"-webkit-animation-name",
  	"animation-play-state",
  	"-moz-animation-play-state",
  	"-ms-animation-play-state",
  	"-webkit-animation-play-state",
  	"animation-range",
  	"animation-range-end",
  	"animation-range-start",
  	"animation-timing-function",
  	"-moz-animation-timing-function",
  	"-ms-animation-timing-function",
  	"-webkit-animation-timing-function",
  	"-webkit-animation-trigger",
  	"-webkit-animation",
  	"app-region",
  	"-webkit-app-region",
  	"appearance",
  	"-moz-appearance",
  	"-webkit-appearance",
  	"ascent-override",
  	"aspect-ratio",
  	"-webkit-aspect-ratio",
  	"audio-level",
  	"azimuth",
  	"backdrop-filter",
  	"-webkit-backdrop-filter",
  	"backface-visibility",
  	"-moz-backface-visibility",
  	"-ms-backface-visibility",
  	"-webkit-backface-visibility",
  	"background",
  	"background-attachment",
  	"-webkit-background-attachment",
  	"background-blend-mode",
  	"background-clip",
  	"-moz-background-clip",
  	"-webkit-background-clip",
  	"background-color",
  	"-webkit-background-color",
  	"-webkit-background-composite",
  	"background-image",
  	"-webkit-background-image",
  	"-moz-background-inline-policy",
  	"background-origin",
  	"-moz-background-origin",
  	"-webkit-background-origin",
  	"background-position",
  	"-webkit-background-position",
  	"background-position-x",
  	"-webkit-background-position-x",
  	"background-position-y",
  	"-webkit-background-position-y",
  	"background-repeat",
  	"-webkit-background-repeat",
  	"background-repeat-x",
  	"background-repeat-y",
  	"background-size",
  	"-moz-background-size",
  	"-webkit-background-size",
  	"-webkit-background",
  	"base-palette",
  	"baseline-shift",
  	"baseline-source",
  	"behavior",
  	"-moz-binding",
  	"block-ellipsis",
  	"-ms-block-progression",
  	"block-size",
  	"block-step",
  	"block-step-align",
  	"block-step-insert",
  	"block-step-round",
  	"block-step-size",
  	"bookmark-label",
  	"bookmark-level",
  	"bookmark-state",
  	"border",
  	"-webkit-border-after-color",
  	"-webkit-border-after-style",
  	"-webkit-border-after",
  	"-webkit-border-after-width",
  	"-webkit-border-before-color",
  	"-webkit-border-before-style",
  	"-webkit-border-before",
  	"-webkit-border-before-width",
  	"border-block",
  	"border-block-color",
  	"border-block-end",
  	"border-block-end-color",
  	"border-block-end-style",
  	"border-block-end-width",
  	"border-block-start",
  	"border-block-start-color",
  	"border-block-start-style",
  	"border-block-start-width",
  	"border-block-style",
  	"border-block-width",
  	"border-bottom",
  	"border-bottom-color",
  	"-moz-border-bottom-colors",
  	"border-bottom-left-radius",
  	"-webkit-border-bottom-left-radius",
  	"border-bottom-right-radius",
  	"-webkit-border-bottom-right-radius",
  	"border-bottom-style",
  	"border-bottom-width",
  	"border-boundary",
  	"border-collapse",
  	"border-color",
  	"-moz-border-end-color",
  	"-webkit-border-end-color",
  	"border-end-end-radius",
  	"-moz-border-end",
  	"border-end-start-radius",
  	"-moz-border-end-style",
  	"-webkit-border-end-style",
  	"-webkit-border-end",
  	"-moz-border-end-width",
  	"-webkit-border-end-width",
  	"-webkit-border-fit",
  	"-webkit-border-horizontal-spacing",
  	"border-image",
  	"-moz-border-image",
  	"-o-border-image",
  	"border-image-outset",
  	"-webkit-border-image-outset",
  	"border-image-repeat",
  	"-webkit-border-image-repeat",
  	"border-image-slice",
  	"-webkit-border-image-slice",
  	"border-image-source",
  	"-webkit-border-image-source",
  	"-webkit-border-image",
  	"border-image-width",
  	"-webkit-border-image-width",
  	"border-inline",
  	"border-inline-color",
  	"border-inline-end",
  	"border-inline-end-color",
  	"border-inline-end-style",
  	"border-inline-end-width",
  	"border-inline-start",
  	"border-inline-start-color",
  	"border-inline-start-style",
  	"border-inline-start-width",
  	"border-inline-style",
  	"border-inline-width",
  	"border-left",
  	"border-left-color",
  	"-moz-border-left-colors",
  	"border-left-style",
  	"border-left-width",
  	"border-radius",
  	"-moz-border-radius-bottomleft",
  	"-moz-border-radius-bottomright",
  	"-moz-border-radius",
  	"-moz-border-radius-topleft",
  	"-moz-border-radius-topright",
  	"-webkit-border-radius",
  	"border-right",
  	"border-right-color",
  	"-moz-border-right-colors",
  	"border-right-style",
  	"border-right-width",
  	"border-spacing",
  	"-moz-border-start-color",
  	"-webkit-border-start-color",
  	"border-start-end-radius",
  	"-moz-border-start",
  	"border-start-start-radius",
  	"-moz-border-start-style",
  	"-webkit-border-start-style",
  	"-webkit-border-start",
  	"-moz-border-start-width",
  	"-webkit-border-start-width",
  	"border-style",
  	"border-top",
  	"border-top-color",
  	"-moz-border-top-colors",
  	"border-top-left-radius",
  	"-webkit-border-top-left-radius",
  	"border-top-right-radius",
  	"-webkit-border-top-right-radius",
  	"border-top-style",
  	"border-top-width",
  	"-webkit-border-vertical-spacing",
  	"border-width",
  	"bottom",
  	"-moz-box-align",
  	"-webkit-box-align",
  	"box-decoration-break",
  	"-webkit-box-decoration-break",
  	"-moz-box-direction",
  	"-webkit-box-direction",
  	"-webkit-box-flex-group",
  	"-moz-box-flex",
  	"-webkit-box-flex",
  	"-webkit-box-lines",
  	"-moz-box-ordinal-group",
  	"-webkit-box-ordinal-group",
  	"-moz-box-orient",
  	"-webkit-box-orient",
  	"-moz-box-pack",
  	"-webkit-box-pack",
  	"-webkit-box-reflect",
  	"box-shadow",
  	"-moz-box-shadow",
  	"-webkit-box-shadow",
  	"box-sizing",
  	"-moz-box-sizing",
  	"-webkit-box-sizing",
  	"box-snap",
  	"break-after",
  	"break-before",
  	"break-inside",
  	"buffered-rendering",
  	"caption-side",
  	"caret",
  	"caret-color",
  	"caret-shape",
  	"chains",
  	"clear",
  	"clip",
  	"clip-path",
  	"-webkit-clip-path",
  	"clip-rule",
  	"color",
  	"color-adjust",
  	"-webkit-color-correction",
  	"-apple-color-filter",
  	"color-interpolation",
  	"color-interpolation-filters",
  	"color-profile",
  	"color-rendering",
  	"color-scheme",
  	"-webkit-column-axis",
  	"-webkit-column-break-after",
  	"-webkit-column-break-before",
  	"-webkit-column-break-inside",
  	"column-count",
  	"-moz-column-count",
  	"-webkit-column-count",
  	"column-fill",
  	"-moz-column-fill",
  	"-webkit-column-fill",
  	"column-gap",
  	"-moz-column-gap",
  	"-webkit-column-gap",
  	"column-progression",
  	"-webkit-column-progression",
  	"column-rule",
  	"column-rule-color",
  	"-moz-column-rule-color",
  	"-webkit-column-rule-color",
  	"-moz-column-rule",
  	"column-rule-style",
  	"-moz-column-rule-style",
  	"-webkit-column-rule-style",
  	"-webkit-column-rule",
  	"column-rule-width",
  	"-moz-column-rule-width",
  	"-webkit-column-rule-width",
  	"column-span",
  	"-moz-column-span",
  	"-webkit-column-span",
  	"column-width",
  	"-moz-column-width",
  	"-webkit-column-width",
  	"columns",
  	"-moz-columns",
  	"-webkit-columns",
  	"-webkit-composition-fill-color",
  	"-webkit-composition-frame-color",
  	"contain",
  	"contain-intrinsic-block-size",
  	"contain-intrinsic-height",
  	"contain-intrinsic-inline-size",
  	"contain-intrinsic-size",
  	"contain-intrinsic-width",
  	"container",
  	"container-name",
  	"container-type",
  	"content",
  	"content-visibility",
  	"-ms-content-zoom-chaining",
  	"-ms-content-zoom-limit-max",
  	"-ms-content-zoom-limit-min",
  	"-ms-content-zoom-limit",
  	"-ms-content-zoom-snap",
  	"-ms-content-zoom-snap-points",
  	"-ms-content-zoom-snap-type",
  	"-ms-content-zooming",
  	"continue",
  	"counter-increment",
  	"counter-reset",
  	"counter-set",
  	"cue",
  	"cue-after",
  	"cue-before",
  	"cursor",
  	"-webkit-cursor-visibility",
  	"cx",
  	"cy",
  	"d",
  	"-apple-dashboard-region",
  	"-webkit-dashboard-region",
  	"descent-override",
  	"direction",
  	"display",
  	"display-align",
  	"dominant-baseline",
  	"elevation",
  	"empty-cells",
  	"enable-background",
  	"epub-caption-side",
  	"epub-hyphens",
  	"epub-text-combine",
  	"epub-text-emphasis",
  	"epub-text-emphasis-color",
  	"epub-text-emphasis-style",
  	"epub-text-orientation",
  	"epub-text-transform",
  	"epub-word-break",
  	"epub-writing-mode",
  	"fallback",
  	"fill",
  	"fill-break",
  	"fill-color",
  	"fill-image",
  	"fill-opacity",
  	"fill-origin",
  	"fill-position",
  	"fill-repeat",
  	"fill-rule",
  	"fill-size",
  	"filter",
  	"-ms-filter",
  	"-webkit-filter",
  	"flex",
  	"-ms-flex-align",
  	"-webkit-flex-align",
  	"flex-basis",
  	"-webkit-flex-basis",
  	"flex-direction",
  	"-ms-flex-direction",
  	"-webkit-flex-direction",
  	"flex-flow",
  	"-ms-flex-flow",
  	"-webkit-flex-flow",
  	"flex-grow",
  	"-webkit-flex-grow",
  	"-ms-flex-item-align",
  	"-webkit-flex-item-align",
  	"-ms-flex-line-pack",
  	"-webkit-flex-line-pack",
  	"-ms-flex",
  	"-ms-flex-negative",
  	"-ms-flex-order",
  	"-webkit-flex-order",
  	"-ms-flex-pack",
  	"-webkit-flex-pack",
  	"-ms-flex-positive",
  	"-ms-flex-preferred-size",
  	"flex-shrink",
  	"-webkit-flex-shrink",
  	"-webkit-flex",
  	"flex-wrap",
  	"-ms-flex-wrap",
  	"-webkit-flex-wrap",
  	"float",
  	"float-defer",
  	"-moz-float-edge",
  	"float-offset",
  	"float-reference",
  	"flood-color",
  	"flood-opacity",
  	"flow",
  	"flow-from",
  	"-ms-flow-from",
  	"-webkit-flow-from",
  	"flow-into",
  	"-ms-flow-into",
  	"-webkit-flow-into",
  	"font",
  	"font-display",
  	"font-family",
  	"font-feature-settings",
  	"-moz-font-feature-settings",
  	"-ms-font-feature-settings",
  	"-webkit-font-feature-settings",
  	"font-kerning",
  	"-webkit-font-kerning",
  	"font-language-override",
  	"-moz-font-language-override",
  	"font-optical-sizing",
  	"font-palette",
  	"font-size",
  	"font-size-adjust",
  	"-webkit-font-size-delta",
  	"-webkit-font-smoothing",
  	"font-stretch",
  	"font-style",
  	"font-synthesis",
  	"font-synthesis-small-caps",
  	"font-synthesis-style",
  	"font-synthesis-weight",
  	"font-variant",
  	"font-variant-alternates",
  	"font-variant-caps",
  	"font-variant-east-asian",
  	"font-variant-emoji",
  	"font-variant-ligatures",
  	"-webkit-font-variant-ligatures",
  	"font-variant-numeric",
  	"font-variant-position",
  	"font-variation-settings",
  	"font-weight",
  	"footnote-display",
  	"footnote-policy",
  	"-moz-force-broken-image-icon",
  	"forced-color-adjust",
  	"gap",
  	"glyph-orientation-horizontal",
  	"glyph-orientation-vertical",
  	"grid",
  	"-webkit-grid-after",
  	"grid-area",
  	"grid-auto-columns",
  	"-webkit-grid-auto-columns",
  	"grid-auto-flow",
  	"-webkit-grid-auto-flow",
  	"grid-auto-rows",
  	"-webkit-grid-auto-rows",
  	"-webkit-grid-before",
  	"grid-column",
  	"-ms-grid-column-align",
  	"grid-column-end",
  	"grid-column-gap",
  	"-ms-grid-column",
  	"-ms-grid-column-span",
  	"grid-column-start",
  	"-webkit-grid-column",
  	"-ms-grid-columns",
  	"-webkit-grid-columns",
  	"-webkit-grid-end",
  	"grid-gap",
  	"grid-row",
  	"-ms-grid-row-align",
  	"grid-row-end",
  	"grid-row-gap",
  	"-ms-grid-row",
  	"-ms-grid-row-span",
  	"grid-row-start",
  	"-webkit-grid-row",
  	"-ms-grid-rows",
  	"-webkit-grid-rows",
  	"-webkit-grid-start",
  	"grid-template",
  	"grid-template-areas",
  	"grid-template-columns",
  	"grid-template-rows",
  	"hanging-punctuation",
  	"height",
  	"-ms-high-contrast-adjust",
  	"-webkit-highlight",
  	"hyphenate-character",
  	"-webkit-hyphenate-character",
  	"-webkit-hyphenate-limit-after",
  	"-webkit-hyphenate-limit-before",
  	"hyphenate-limit-chars",
  	"-ms-hyphenate-limit-chars",
  	"hyphenate-limit-last",
  	"hyphenate-limit-lines",
  	"-ms-hyphenate-limit-lines",
  	"-webkit-hyphenate-limit-lines",
  	"hyphenate-limit-zone",
  	"-ms-hyphenate-limit-zone",
  	"hyphens",
  	"-moz-hyphens",
  	"-ms-hyphens",
  	"-webkit-hyphens",
  	"image-orientation",
  	"-moz-image-region",
  	"image-rendering",
  	"image-resolution",
  	"-ms-ime-align",
  	"ime-mode",
  	"inherits",
  	"initial-letter",
  	"initial-letter-align",
  	"-webkit-initial-letter",
  	"initial-letter-wrap",
  	"initial-value",
  	"inline-size",
  	"inline-sizing",
  	"input-format",
  	"-wap-input-format",
  	"-wap-input-required",
  	"input-security",
  	"inset",
  	"inset-block",
  	"inset-block-end",
  	"inset-block-start",
  	"inset-inline",
  	"inset-inline-end",
  	"inset-inline-start",
  	"-ms-interpolation-mode",
  	"isolation",
  	"justify-content",
  	"-webkit-justify-content",
  	"justify-items",
  	"-webkit-justify-items",
  	"justify-self",
  	"-webkit-justify-self",
  	"kerning",
  	"layout-flow",
  	"layout-grid",
  	"layout-grid-char",
  	"layout-grid-line",
  	"layout-grid-mode",
  	"layout-grid-type",
  	"layout-order",
  	"leading-trim",
  	"left",
  	"letter-spacing",
  	"lighting-color",
  	"-webkit-line-align",
  	"-webkit-line-box-contain",
  	"line-break",
  	"-webkit-line-break",
  	"line-clamp",
  	"-webkit-line-clamp",
  	"line-gap-override",
  	"line-grid",
  	"-webkit-line-grid-snap",
  	"-webkit-line-grid",
  	"line-height",
  	"line-height-step",
  	"line-increment",
  	"line-padding",
  	"line-snap",
  	"-webkit-line-snap",
  	"-o-link",
  	"-o-link-source",
  	"list-style",
  	"list-style-image",
  	"list-style-position",
  	"list-style-type",
  	"-webkit-locale",
  	"-webkit-logical-height",
  	"-webkit-logical-width",
  	"margin",
  	"-webkit-margin-after-collapse",
  	"-webkit-margin-after",
  	"-webkit-margin-before-collapse",
  	"-webkit-margin-before",
  	"margin-block",
  	"margin-block-end",
  	"margin-block-start",
  	"margin-bottom",
  	"-webkit-margin-bottom-collapse",
  	"margin-break",
  	"-webkit-margin-collapse",
  	"-moz-margin-end",
  	"-webkit-margin-end",
  	"margin-inline",
  	"margin-inline-end",
  	"margin-inline-start",
  	"margin-left",
  	"margin-right",
  	"-moz-margin-start",
  	"-webkit-margin-start",
  	"margin-top",
  	"-webkit-margin-top-collapse",
  	"margin-trim",
  	"marker",
  	"marker-end",
  	"marker-knockout-left",
  	"marker-knockout-right",
  	"marker-mid",
  	"marker-offset",
  	"marker-pattern",
  	"marker-segment",
  	"marker-side",
  	"marker-start",
  	"marks",
  	"-wap-marquee-dir",
  	"-webkit-marquee-direction",
  	"-webkit-marquee-increment",
  	"-wap-marquee-loop",
  	"-webkit-marquee-repetition",
  	"-wap-marquee-speed",
  	"-webkit-marquee-speed",
  	"-wap-marquee-style",
  	"-webkit-marquee-style",
  	"-webkit-marquee",
  	"mask",
  	"-webkit-mask-attachment",
  	"mask-border",
  	"mask-border-mode",
  	"mask-border-outset",
  	"mask-border-repeat",
  	"mask-border-slice",
  	"mask-border-source",
  	"mask-border-width",
  	"-webkit-mask-box-image-outset",
  	"-webkit-mask-box-image-repeat",
  	"-webkit-mask-box-image-slice",
  	"-webkit-mask-box-image-source",
  	"-webkit-mask-box-image",
  	"-webkit-mask-box-image-width",
  	"mask-clip",
  	"-webkit-mask-clip",
  	"mask-composite",
  	"-webkit-mask-composite",
  	"mask-image",
  	"-webkit-mask-image",
  	"mask-mode",
  	"mask-origin",
  	"-webkit-mask-origin",
  	"mask-position",
  	"-webkit-mask-position",
  	"mask-position-x",
  	"-webkit-mask-position-x",
  	"mask-position-y",
  	"-webkit-mask-position-y",
  	"mask-repeat",
  	"-webkit-mask-repeat",
  	"-webkit-mask-repeat-x",
  	"-webkit-mask-repeat-y",
  	"mask-size",
  	"-webkit-mask-size",
  	"mask-source-type",
  	"-webkit-mask-source-type",
  	"mask-type",
  	"-webkit-mask",
  	"-webkit-match-nearest-mail-blockquote-color",
  	"math-depth",
  	"math-shift",
  	"math-style",
  	"max-block-size",
  	"max-height",
  	"max-inline-size",
  	"max-lines",
  	"-webkit-max-logical-height",
  	"-webkit-max-logical-width",
  	"max-width",
  	"max-zoom",
  	"min-block-size",
  	"min-height",
  	"min-inline-size",
  	"min-intrinsic-sizing",
  	"-webkit-min-logical-height",
  	"-webkit-min-logical-width",
  	"min-width",
  	"min-zoom",
  	"mix-blend-mode",
  	"motion",
  	"motion-offset",
  	"motion-path",
  	"motion-rotation",
  	"nav-down",
  	"nav-index",
  	"nav-left",
  	"nav-right",
  	"nav-up",
  	"-webkit-nbsp-mode",
  	"negative",
  	"object-fit",
  	"-o-object-fit",
  	"object-position",
  	"-o-object-position",
  	"object-view-box",
  	"offset",
  	"offset-anchor",
  	"offset-block-end",
  	"offset-block-start",
  	"offset-distance",
  	"offset-inline-end",
  	"offset-inline-start",
  	"offset-path",
  	"offset-position",
  	"offset-rotate",
  	"offset-rotation",
  	"opacity",
  	"-moz-opacity",
  	"-webkit-opacity",
  	"order",
  	"-webkit-order",
  	"-moz-orient",
  	"orientation",
  	"orphans",
  	"-moz-osx-font-smoothing",
  	"outline",
  	"outline-color",
  	"-moz-outline-color",
  	"-moz-outline",
  	"outline-offset",
  	"-moz-outline-offset",
  	"-moz-outline-radius-bottomleft",
  	"-moz-outline-radius-bottomright",
  	"-moz-outline-radius",
  	"-moz-outline-radius-topleft",
  	"-moz-outline-radius-topright",
  	"outline-style",
  	"-moz-outline-style",
  	"outline-width",
  	"-moz-outline-width",
  	"overflow",
  	"overflow-anchor",
  	"overflow-block",
  	"overflow-clip-margin",
  	"overflow-clip-margin-block",
  	"overflow-clip-margin-block-end",
  	"overflow-clip-margin-block-start",
  	"overflow-clip-margin-bottom",
  	"overflow-clip-margin-inline",
  	"overflow-clip-margin-inline-end",
  	"overflow-clip-margin-inline-start",
  	"overflow-clip-margin-left",
  	"overflow-clip-margin-right",
  	"overflow-clip-margin-top",
  	"overflow-inline",
  	"-webkit-overflow-scrolling",
  	"-ms-overflow-style",
  	"overflow-wrap",
  	"overflow-x",
  	"overflow-y",
  	"override-colors",
  	"overscroll-behavior",
  	"overscroll-behavior-block",
  	"overscroll-behavior-inline",
  	"overscroll-behavior-x",
  	"overscroll-behavior-y",
  	"pad",
  	"padding",
  	"-webkit-padding-after",
  	"-webkit-padding-before",
  	"padding-block",
  	"padding-block-end",
  	"padding-block-start",
  	"padding-bottom",
  	"-moz-padding-end",
  	"-webkit-padding-end",
  	"padding-inline",
  	"padding-inline-end",
  	"padding-inline-start",
  	"padding-left",
  	"padding-right",
  	"-moz-padding-start",
  	"-webkit-padding-start",
  	"padding-top",
  	"page",
  	"page-break-after",
  	"page-break-before",
  	"page-break-inside",
  	"page-orientation",
  	"paint-order",
  	"pause",
  	"pause-after",
  	"pause-before",
  	"-apple-pay-button-style",
  	"-apple-pay-button-type",
  	"pen-action",
  	"perspective",
  	"-moz-perspective",
  	"-ms-perspective",
  	"perspective-origin",
  	"-moz-perspective-origin",
  	"-ms-perspective-origin",
  	"-webkit-perspective-origin",
  	"perspective-origin-x",
  	"-webkit-perspective-origin-x",
  	"perspective-origin-y",
  	"-webkit-perspective-origin-y",
  	"-webkit-perspective",
  	"pitch",
  	"pitch-range",
  	"place-content",
  	"place-items",
  	"place-self",
  	"play-during",
  	"pointer-events",
  	"position",
  	"prefix",
  	"print-color-adjust",
  	"-webkit-print-color-adjust",
  	"property-name",
  	"quotes",
  	"r",
  	"range",
  	"reading-order",
  	"-webkit-region-break-after",
  	"-webkit-region-break-before",
  	"-webkit-region-break-inside",
  	"region-fragment",
  	"-webkit-region-fragment",
  	"-webkit-region-overflow",
  	"resize",
  	"rest",
  	"rest-after",
  	"rest-before",
  	"richness",
  	"right",
  	"rotate",
  	"row-gap",
  	"-webkit-rtl-ordering",
  	"ruby-align",
  	"ruby-merge",
  	"ruby-overhang",
  	"ruby-position",
  	"-webkit-ruby-position",
  	"running",
  	"rx",
  	"ry",
  	"scale",
  	"scroll-behavior",
  	"-ms-scroll-chaining",
  	"-ms-scroll-limit",
  	"-ms-scroll-limit-x-max",
  	"-ms-scroll-limit-x-min",
  	"-ms-scroll-limit-y-max",
  	"-ms-scroll-limit-y-min",
  	"scroll-margin",
  	"scroll-margin-block",
  	"scroll-margin-block-end",
  	"scroll-margin-block-start",
  	"scroll-margin-bottom",
  	"scroll-margin-inline",
  	"scroll-margin-inline-end",
  	"scroll-margin-inline-start",
  	"scroll-margin-left",
  	"scroll-margin-right",
  	"scroll-margin-top",
  	"scroll-padding",
  	"scroll-padding-block",
  	"scroll-padding-block-end",
  	"scroll-padding-block-start",
  	"scroll-padding-bottom",
  	"scroll-padding-inline",
  	"scroll-padding-inline-end",
  	"scroll-padding-inline-start",
  	"scroll-padding-left",
  	"scroll-padding-right",
  	"scroll-padding-top",
  	"-ms-scroll-rails",
  	"scroll-snap-align",
  	"scroll-snap-coordinate",
  	"-webkit-scroll-snap-coordinate",
  	"scroll-snap-destination",
  	"-webkit-scroll-snap-destination",
  	"scroll-snap-margin",
  	"scroll-snap-margin-bottom",
  	"scroll-snap-margin-left",
  	"scroll-snap-margin-right",
  	"scroll-snap-margin-top",
  	"scroll-snap-points-x",
  	"-ms-scroll-snap-points-x",
  	"-webkit-scroll-snap-points-x",
  	"scroll-snap-points-y",
  	"-ms-scroll-snap-points-y",
  	"-webkit-scroll-snap-points-y",
  	"scroll-snap-stop",
  	"scroll-snap-type",
  	"-ms-scroll-snap-type",
  	"-webkit-scroll-snap-type",
  	"scroll-snap-type-x",
  	"scroll-snap-type-y",
  	"-ms-scroll-snap-x",
  	"-ms-scroll-snap-y",
  	"scroll-timeline",
  	"scroll-timeline-axis",
  	"scroll-timeline-name",
  	"-ms-scroll-translation",
  	"scrollbar-arrow-color",
  	"scrollbar-base-color",
  	"scrollbar-color",
  	"scrollbar-dark-shadow-color",
  	"scrollbar-darkshadow-color",
  	"scrollbar-face-color",
  	"scrollbar-gutter",
  	"scrollbar-highlight-color",
  	"scrollbar-shadow-color",
  	"scrollbar-track-color",
  	"scrollbar-width",
  	"scrollbar3d-light-color",
  	"scrollbar3dlight-color",
  	"shape-image-threshold",
  	"-webkit-shape-image-threshold",
  	"shape-inside",
  	"-webkit-shape-inside",
  	"shape-margin",
  	"-webkit-shape-margin",
  	"shape-outside",
  	"-webkit-shape-outside",
  	"-webkit-shape-padding",
  	"shape-rendering",
  	"size",
  	"size-adjust",
  	"snap-height",
  	"solid-color",
  	"solid-opacity",
  	"spatial-navigation-action",
  	"spatial-navigation-contain",
  	"spatial-navigation-function",
  	"speak",
  	"speak-as",
  	"speak-header",
  	"speak-numeral",
  	"speak-punctuation",
  	"speech-rate",
  	"src",
  	"-moz-stack-sizing",
  	"stop-color",
  	"stop-opacity",
  	"stress",
  	"string-set",
  	"stroke",
  	"stroke-align",
  	"stroke-alignment",
  	"stroke-break",
  	"stroke-color",
  	"stroke-dash-corner",
  	"stroke-dash-justify",
  	"stroke-dashadjust",
  	"stroke-dasharray",
  	"stroke-dashcorner",
  	"stroke-dashoffset",
  	"stroke-image",
  	"stroke-linecap",
  	"stroke-linejoin",
  	"stroke-miterlimit",
  	"stroke-opacity",
  	"stroke-origin",
  	"stroke-position",
  	"stroke-repeat",
  	"stroke-size",
  	"stroke-width",
  	"suffix",
  	"supported-color-schemes",
  	"-webkit-svg-shadow",
  	"symbols",
  	"syntax",
  	"system",
  	"tab-size",
  	"-moz-tab-size",
  	"-o-tab-size",
  	"-o-table-baseline",
  	"table-layout",
  	"-webkit-tap-highlight-color",
  	"text-align",
  	"text-align-all",
  	"text-align-last",
  	"-moz-text-align-last",
  	"text-anchor",
  	"text-autospace",
  	"-moz-text-blink",
  	"-ms-text-combine-horizontal",
  	"text-combine-upright",
  	"-webkit-text-combine",
  	"text-decoration",
  	"text-decoration-blink",
  	"text-decoration-color",
  	"-moz-text-decoration-color",
  	"-webkit-text-decoration-color",
  	"text-decoration-line",
  	"-moz-text-decoration-line",
  	"text-decoration-line-through",
  	"-webkit-text-decoration-line",
  	"text-decoration-none",
  	"text-decoration-overline",
  	"text-decoration-skip",
  	"text-decoration-skip-box",
  	"text-decoration-skip-ink",
  	"text-decoration-skip-inset",
  	"text-decoration-skip-self",
  	"text-decoration-skip-spaces",
  	"-webkit-text-decoration-skip",
  	"text-decoration-style",
  	"-moz-text-decoration-style",
  	"-webkit-text-decoration-style",
  	"text-decoration-thickness",
  	"text-decoration-trim",
  	"text-decoration-underline",
  	"-webkit-text-decoration",
  	"-webkit-text-decorations-in-effect",
  	"text-edge",
  	"text-emphasis",
  	"text-emphasis-color",
  	"-webkit-text-emphasis-color",
  	"text-emphasis-position",
  	"-webkit-text-emphasis-position",
  	"text-emphasis-skip",
  	"text-emphasis-style",
  	"-webkit-text-emphasis-style",
  	"-webkit-text-emphasis",
  	"-webkit-text-fill-color",
  	"text-group-align",
  	"text-indent",
  	"text-justify",
  	"text-justify-trim",
  	"text-kashida",
  	"text-kashida-space",
  	"text-line-through",
  	"text-line-through-color",
  	"text-line-through-mode",
  	"text-line-through-style",
  	"text-line-through-width",
  	"text-orientation",
  	"-webkit-text-orientation",
  	"text-overflow",
  	"text-overline",
  	"text-overline-color",
  	"text-overline-mode",
  	"text-overline-style",
  	"text-overline-width",
  	"text-rendering",
  	"-webkit-text-security",
  	"text-shadow",
  	"text-size-adjust",
  	"-moz-text-size-adjust",
  	"-ms-text-size-adjust",
  	"-webkit-text-size-adjust",
  	"text-space-collapse",
  	"text-space-trim",
  	"text-spacing",
  	"-webkit-text-stroke-color",
  	"-webkit-text-stroke",
  	"-webkit-text-stroke-width",
  	"text-transform",
  	"text-underline",
  	"text-underline-color",
  	"text-underline-mode",
  	"text-underline-offset",
  	"text-underline-position",
  	"-webkit-text-underline-position",
  	"text-underline-style",
  	"text-underline-width",
  	"text-wrap",
  	"-webkit-text-zoom",
  	"top",
  	"touch-action",
  	"touch-action-delay",
  	"-ms-touch-action",
  	"-webkit-touch-callout",
  	"-ms-touch-select",
  	"-apple-trailing-word",
  	"transform",
  	"transform-box",
  	"-moz-transform",
  	"-ms-transform",
  	"-o-transform",
  	"transform-origin",
  	"-moz-transform-origin",
  	"-ms-transform-origin",
  	"-o-transform-origin",
  	"-webkit-transform-origin",
  	"transform-origin-x",
  	"-webkit-transform-origin-x",
  	"transform-origin-y",
  	"-webkit-transform-origin-y",
  	"transform-origin-z",
  	"-webkit-transform-origin-z",
  	"transform-style",
  	"-moz-transform-style",
  	"-ms-transform-style",
  	"-webkit-transform-style",
  	"-webkit-transform",
  	"transition",
  	"transition-delay",
  	"-moz-transition-delay",
  	"-ms-transition-delay",
  	"-o-transition-delay",
  	"-webkit-transition-delay",
  	"transition-duration",
  	"-moz-transition-duration",
  	"-ms-transition-duration",
  	"-o-transition-duration",
  	"-webkit-transition-duration",
  	"-moz-transition",
  	"-ms-transition",
  	"-o-transition",
  	"transition-property",
  	"-moz-transition-property",
  	"-ms-transition-property",
  	"-o-transition-property",
  	"-webkit-transition-property",
  	"transition-timing-function",
  	"-moz-transition-timing-function",
  	"-ms-transition-timing-function",
  	"-o-transition-timing-function",
  	"-webkit-transition-timing-function",
  	"-webkit-transition",
  	"translate",
  	"uc-alt-skin",
  	"uc-skin",
  	"unicode-bidi",
  	"unicode-range",
  	"-webkit-user-drag",
  	"-moz-user-focus",
  	"-moz-user-input",
  	"-moz-user-modify",
  	"-webkit-user-modify",
  	"user-select",
  	"-moz-user-select",
  	"-ms-user-select",
  	"-webkit-user-select",
  	"user-zoom",
  	"vector-effect",
  	"vertical-align",
  	"view-timeline",
  	"view-timeline-axis",
  	"view-timeline-inset",
  	"view-timeline-name",
  	"view-transition-name",
  	"viewport-fill",
  	"viewport-fill-opacity",
  	"viewport-fit",
  	"visibility",
  	"voice-balance",
  	"voice-duration",
  	"voice-family",
  	"voice-pitch",
  	"voice-range",
  	"voice-rate",
  	"voice-stress",
  	"voice-volume",
  	"volume",
  	"white-space",
  	"-webkit-widget-region",
  	"widows",
  	"width",
  	"will-change",
  	"-moz-window-dragging",
  	"-moz-window-shadow",
  	"word-boundary-detection",
  	"word-boundary-expansion",
  	"word-break",
  	"word-spacing",
  	"word-wrap",
  	"wrap-after",
  	"wrap-before",
  	"wrap-flow",
  	"-ms-wrap-flow",
  	"-webkit-wrap-flow",
  	"wrap-inside",
  	"-ms-wrap-margin",
  	"-webkit-wrap-margin",
  	"-webkit-wrap-padding",
  	"-webkit-wrap-shape-inside",
  	"-webkit-wrap-shape-outside",
  	"wrap-through",
  	"-ms-wrap-through",
  	"-webkit-wrap-through",
  	"-webkit-wrap",
  	"writing-mode",
  	"-webkit-writing-mode",
  	"x",
  	"y",
  	"z-index",
  	"zoom"
  ];
  var require$$0$3 = {
  	properties: properties$1
  };

  var all = require$$0$3.properties;

  var knownCssProperties = {
  	all: all
  };

  const properties = knownCssProperties.all;





  const {
    isAtRule: isAtRule$4,
    isRule: isRule$1
  } = typeGuards;





  const {
    isBoolean: isBoolean$7,
    isRegExp: isRegExp$p,
    isString: isString$y
  } = validateTypes;

  const ruleName$13 = 'property-no-unknown';
  const messages$13 = ruleMessages$1(ruleName$13, {
    rejected: property => `Unexpected unknown property "${property}"`
  });
  const meta$13 = {
    url: 'https://stylelint.io/user-guide/rules/property-no-unknown'
  };
  /** @type {import('stylelint').Rule} */

  const rule$12 = (primary, secondaryOptions) => {
    const allValidProperties = new Set(properties);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$13, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreProperties: [isString$y, isRegExp$p],
          checkPrefixed: [isBoolean$7],
          ignoreSelectors: [isString$y, isRegExp$p],
          ignoreAtRules: [isString$y, isRegExp$p]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const shouldCheckPrefixed = secondaryOptions && secondaryOptions.checkPrefixed;
      root.walkDecls(checkStatement);
      /**
       * @param {import('postcss').Declaration} decl
       */

      function checkStatement(decl) {
        const prop = decl.prop;

        if (!isStandardSyntaxProperty(prop)) {
          return;
        }

        if (!isStandardSyntaxDeclaration(decl)) {
          return;
        }

        if (isCustomProperty$2(prop)) {
          return;
        }

        if (!shouldCheckPrefixed && vendor.prefix(prop)) {
          return;
        }

        if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
          return;
        }

        const parent = decl.parent;

        if (parent && isRule$1(parent) && optionsMatches(secondaryOptions, 'ignoreSelectors', parent.selector)) {
          return;
        }
        /** @type {import('postcss').Node | undefined} */


        let node = parent;

        while (node && node.type !== 'root') {
          if (isAtRule$4(node) && optionsMatches(secondaryOptions, 'ignoreAtRules', node.name)) {
            return;
          }

          node = node.parent;
        }

        if (allValidProperties.has(prop.toLowerCase())) {
          return;
        }

        report$1({
          message: messages$13.rejected,
          messageArgs: [prop],
          node: decl,
          result,
          ruleName: ruleName$13,
          word: prop
        });
      }
    };
  };

  rule$12.ruleName = ruleName$13;
  rule$12.messages = messages$13;
  rule$12.meta = meta$13;
  var propertyNoUnknown = rule$12;

  const {
    isRegExp: isRegExp$o,
    isString: isString$x
  } = validateTypes;

  const ruleName$12 = 'property-no-vendor-prefix';
  const messages$12 = ruleMessages$1(ruleName$12, {
    rejected: property => `Unexpected vendor-prefix "${property}"`
  });
  const meta$12 = {
    url: 'https://stylelint.io/user-guide/rules/property-no-vendor-prefix',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$11 = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$12, {
        actual: primary
      }, {
        optional: true,
        actual: secondaryOptions,
        possible: {
          ignoreProperties: [isString$x, isRegExp$o]
        }
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;
        const unprefixedProp = vendor.unprefixed(prop); //return early if property is to be ignored

        if (optionsMatches(secondaryOptions, 'ignoreProperties', unprefixedProp)) {
          return;
        } // Make sure there's a vendor prefix,
        // but this isn't a custom property


        if (prop[0] !== '-' || prop[1] === '-') {
          return;
        }

        if (!isAutoprefixable.property(prop)) {
          return;
        }

        if (context.fix) {
          decl.prop = isAutoprefixable.unprefix(decl.prop);
          return;
        }

        report$1({
          message: messages$12.rejected,
          messageArgs: [prop],
          word: prop,
          node: decl,
          result,
          ruleName: ruleName$12
        });
      });
    };
  };

  rule$11.ruleName = ruleName$12;
  rule$11.messages = messages$12;
  rule$11.meta = meta$12;
  var propertyNoVendorPrefix = rule$11;

  /**
   * @param {import('postcss').Node} node
   */


  function isAfterSingleLineComment(node) {
    const prevNode = node.prev();
    return prevNode !== undefined && prevNode.type === 'comment' && !isSharedLineComment(prevNode) && prevNode.source && prevNode.source.start && prevNode.source.end && prevNode.source.start.line === prevNode.source.end.line;
  }

  var isAfterSingleLineComment_1 = isAfterSingleLineComment;

  const ruleName$11 = 'rule-empty-line-before';
  const messages$11 = ruleMessages$1(ruleName$11, {
    expected: 'Expected empty line before rule',
    rejected: 'Unexpected empty line before rule'
  });
  const meta$11 = {
    url: 'https://stylelint.io/user-guide/rules/rule-empty-line-before',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$10 = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$11, {
        actual: primary,
        possible: ['always', 'never', 'always-multi-line', 'never-multi-line']
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['after-comment', 'first-nested', 'inside-block'],
          except: ['after-rule', 'after-single-line-comment', 'first-nested', 'inside-block-and-after-rule', 'inside-block']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const expectation =
      /** @type {string} */
      primary;
      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        } // Ignore the first node


        if (isFirstNodeOfRoot(ruleNode)) {
          return;
        } // Optionally ignore the expectation if a comment precedes this node


        if (optionsMatches(secondaryOptions, 'ignore', 'after-comment')) {
          const prevNode = ruleNode.prev();

          if (prevNode && prevNode.type === 'comment') {
            return;
          }
        } // Optionally ignore the node if it is the first nested


        if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(ruleNode)) {
          return;
        }

        const isNested = ruleNode.parent && ruleNode.parent.type !== 'root'; // Optionally ignore the expectation if inside a block

        if (optionsMatches(secondaryOptions, 'ignore', 'inside-block') && isNested) {
          return;
        } // Ignore if the expectation is for multiple and the rule is single-line


        if (expectation.includes('multi-line') && isSingleLineString(ruleNode.toString())) {
          return;
        }

        let expectEmptyLineBefore = expectation.includes('always'); // Optionally reverse the expectation if any exceptions apply

        if (optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(ruleNode) || optionsMatches(secondaryOptions, 'except', 'after-rule') && isAfterRule(ruleNode) || optionsMatches(secondaryOptions, 'except', 'inside-block-and-after-rule') && isNested && isAfterRule(ruleNode) || optionsMatches(secondaryOptions, 'except', 'after-single-line-comment') && isAfterSingleLineComment_1(ruleNode) || optionsMatches(secondaryOptions, 'except', 'inside-block') && isNested) {
          expectEmptyLineBefore = !expectEmptyLineBefore;
        }

        const hasEmptyLineBefore = hasEmptyLine(ruleNode.raws.before); // Return if the expectation is met

        if (expectEmptyLineBefore === hasEmptyLineBefore) {
          return;
        } // Fix


        if (context.fix) {
          const newline = context.newline;

          if (typeof newline !== 'string') {
            throw new Error(`The "newline" property must be a string: ${newline}`);
          }

          if (expectEmptyLineBefore) {
            addEmptyLineBefore(ruleNode, newline);
          } else {
            removeEmptyLinesBefore(ruleNode, newline);
          }

          return;
        }

        const message = expectEmptyLineBefore ? messages$11.expected : messages$11.rejected;
        report$1({
          message,
          node: ruleNode,
          result,
          ruleName: ruleName$11
        });
      });
    };
  };
  /**
   * @param {import('postcss').Rule} ruleNode
   * @returns {boolean}
   */


  function isAfterRule(ruleNode) {
    const prevNode = getPreviousNonSharedLineCommentNode(ruleNode);
    return prevNode != null && prevNode.type === 'rule';
  }

  rule$10.ruleName = ruleName$11;
  rule$10.messages = messages$11;
  rule$10.meta = meta$11;
  var ruleEmptyLineBefore = rule$10;

  const {
    isString: isString$w,
    isRegExp: isRegExp$n
  } = validateTypes;

  const ruleName$10 = 'rule-selector-property-disallowed-list';
  const messages$10 = ruleMessages$1(ruleName$10, {
    rejected: (selector, property) => `Unexpected property "${property}" for selector "${selector}"`
  });
  const meta$10 = {
    url: 'https://stylelint.io/user-guide/rules/rule-selector-property-disallowed-list'
  };
  /** @type {import('stylelint').Rule<Record<string, string | RegExp | Array<string | RegExp>>>} */

  const rule$$ = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$10, {
        actual: primary,
        possible: [validateObjectWithArrayProps(isString$w, isRegExp$n)]
      });

      if (!validOptions) {
        return;
      }

      const selectors = Object.keys(primary);
      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selectorKey = selectors.find(selector => matchesStringOrRegExp(ruleNode.selector, selector));

        if (!selectorKey) {
          return;
        }

        const disallowedProperties = primary[selectorKey];

        if (!disallowedProperties) {
          return;
        }

        ruleNode.walkDecls(decl => {
          const {
            prop
          } = decl;

          if (matchesStringOrRegExp(prop, disallowedProperties)) {
            report$1({
              message: messages$10.rejected,
              messageArgs: [ruleNode.selector, prop],
              node: decl,
              result,
              ruleName: ruleName$10,
              word: prop
            });
          }
        });
      });
    };
  };

  rule$$.ruleName = ruleName$10;
  rule$$.messages = messages$10;
  rule$$.meta = meta$10;
  var ruleSelectorPropertyDisallowedList = rule$$;

  const {
    aNPlusBNotationPseudoClasses: aNPlusBNotationPseudoClasses$3,
    aNPlusBOfSNotationPseudoClasses: aNPlusBOfSNotationPseudoClasses$4
  } = selectors;

  const classes = [...aNPlusBNotationPseudoClasses$3.values(), ...aNPlusBOfSNotationPseudoClasses$4.values()].join('|');
  const HAS_A_N_PLUS_B_NOTATION_PSEUDO_CLASSES = new RegExp(`\\b:(?:${classes})\\(`, 'i');
  /**
   * Check if a selector contains any pseudo class function that might contain an An+B notation
   *
   * @param {string} selector
   * @returns {boolean}
   */

  var hasANPlusBNotationPseudoClasses = function hasANPlusBNotationPseudoClasses(selector) {
    return HAS_A_N_PLUS_B_NOTATION_PSEUDO_CLASSES.test(selector);
  };

  const {
    parse: parse$7
  } = cjs$3;

  const {
    aNPlusBNotationPseudoClasses: aNPlusBNotationPseudoClasses$2,
    aNPlusBOfSNotationPseudoClasses: aNPlusBOfSNotationPseudoClasses$3
  } = selectors;











  const ruleName$$ = 'selector-anb-no-unmatchable';
  const messages$$ = ruleMessages$1(ruleName$$, {
    rejected: pseudoClass => `Unexpected unmatchable An+B selector "${pseudoClass}"`
  });
  const meta$$ = {
    url: 'https://stylelint.io/user-guide/rules/selector-anb-no-unmatchable'
  };

  function isUnmatchableNth(
  /** @type {import('css-tree').AnPlusB} */
  nth) {
    const {
      a,
      b
    } = nth;

    if (a !== null && a !== '0' && a !== '-0') {
      return false;
    }

    if (b !== null && b !== '0' && b !== '-0') {
      return false;
    }

    return true;
  }
  /** @type {import('stylelint').Rule} */


  const rule$_ = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$$, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!hasANPlusBNotationPseudoClasses(ruleNode.selector)) return;
        if (!isStandardSyntaxRule(ruleNode)) return;
        ruleNode.selectors.forEach(selector => {
          let cssTreeSelector;

          try {
            cssTreeSelector = parse$7(selector, {
              context: 'selector',
              positions: true
            });
          } catch (e) {
            return;
          }

          checkSelector(cssTreeSelector);
        });

        function checkSelector(
        /** @type {import('css-tree').CssNode} */
        selector) {
          if (selector.type !== 'Selector') {
            return;
          }

          selector.children.forEach(selectorChild => {
            if (selectorChild.type !== 'PseudoClassSelector' || !aNPlusBNotationPseudoClasses$2.has(selectorChild.name) && !aNPlusBOfSNotationPseudoClasses$3.has(selectorChild.name)) {
              return;
            }

            const pseudoClassSelector = selectorChild;

            if (pseudoClassSelector.children === null) {
              return;
            }

            pseudoClassSelector.children.forEach(child => {
              if (child.type !== 'Nth' || child.nth.type !== 'AnPlusB') {
                return;
              }

              if (isUnmatchableNth(child.nth)) {
                report$1({
                  message: messages$$.rejected,
                  messageArgs: [`:${pseudoClassSelector.name}`],
                  node: ruleNode,
                  index: pseudoClassSelector.loc?.start.column,
                  endIndex: pseudoClassSelector.loc?.end.column,
                  result,
                  ruleName: ruleName$$
                });
              }
            });
          });
        }
      });
    };
  };

  rule$_.ruleName = ruleName$$;
  rule$_.messages = messages$$;
  rule$_.meta = meta$$;
  var selectorAnbNoUnmatchable = rule$_;

  const ruleName$_ = 'selector-attribute-brackets-space-inside';
  const messages$_ = ruleMessages$1(ruleName$_, {
    expectedOpening: 'Expected single space after "["',
    rejectedOpening: 'Unexpected whitespace after "["',
    expectedClosing: 'Expected single space before "]"',
    rejectedClosing: 'Unexpected whitespace before "]"'
  });
  const meta$_ = {
    url: 'https://stylelint.io/user-guide/rules/selector-attribute-brackets-space-inside',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$Z = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$_, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        if (!ruleNode.selector.includes('[')) {
          return;
        }

        const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;
        let hasFixed;
        const fixedSelector = parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkAttributes(attributeNode => {
            const attributeSelectorString = attributeNode.toString();
            styleSearch({
              source: attributeSelectorString,
              target: '['
            }, match => {
              const nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === ' ';
              const index = attributeNode.sourceIndex + match.startIndex + 1;

              if (nextCharIsSpace && primary === 'never') {
                if (context.fix) {
                  hasFixed = true;
                  fixBefore(attributeNode);
                  return;
                }

                complain(messages$_.rejectedOpening, index);
              }

              if (!nextCharIsSpace && primary === 'always') {
                if (context.fix) {
                  hasFixed = true;
                  fixBefore(attributeNode);
                  return;
                }

                complain(messages$_.expectedOpening, index);
              }
            });
            styleSearch({
              source: attributeSelectorString,
              target: ']'
            }, match => {
              const prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === ' ';
              const index = attributeNode.sourceIndex + match.startIndex - 1;

              if (prevCharIsSpace && primary === 'never') {
                if (context.fix) {
                  hasFixed = true;
                  fixAfter(attributeNode);
                  return;
                }

                complain(messages$_.rejectedClosing, index);
              }

              if (!prevCharIsSpace && primary === 'always') {
                if (context.fix) {
                  hasFixed = true;
                  fixAfter(attributeNode);
                  return;
                }

                complain(messages$_.expectedClosing, index);
              }
            });
          });
        });

        if (hasFixed && fixedSelector) {
          if (!ruleNode.raws.selector) {
            ruleNode.selector = fixedSelector;
          } else {
            ruleNode.raws.selector.raw = fixedSelector;
          }
        }
        /**
         * @param {string} message
         * @param {number} index
         */


        function complain(message, index) {
          report$1({
            message,
            index,
            result,
            ruleName: ruleName$_,
            node: ruleNode
          });
        }
      });
    };
    /**
     * @param {import('postcss-selector-parser').Attribute} attributeNode
     */

    function fixBefore(attributeNode) {
      const spacesAttribute = attributeNode.raws.spaces && attributeNode.raws.spaces.attribute;
      const rawAttrBefore = spacesAttribute && spacesAttribute.before;
      /** @type {{ attrBefore: string, setAttrBefore: (fixed: string) => void }} */

      const {
        attrBefore,
        setAttrBefore
      } = rawAttrBefore ? {
        attrBefore: rawAttrBefore,

        setAttrBefore(fixed) {
          spacesAttribute.before = fixed;
        }

      } : {
        attrBefore: attributeNode.spaces.attribute && attributeNode.spaces.attribute.before || '',

        setAttrBefore(fixed) {
          if (!attributeNode.spaces.attribute) attributeNode.spaces.attribute = {};
          attributeNode.spaces.attribute.before = fixed;
        }

      };

      if (primary === 'always') {
        setAttrBefore(attrBefore.replace(/^\s*/, ' '));
      } else if (primary === 'never') {
        setAttrBefore(attrBefore.replace(/^\s*/, ''));
      }
    }
    /**
     * @param {import('postcss-selector-parser').Attribute} attributeNode
     */


    function fixAfter(attributeNode) {
      const key = attributeNode.operator ? attributeNode.insensitive ? 'insensitive' : 'value' : 'attribute';
      const rawSpaces = attributeNode.raws.spaces && attributeNode.raws.spaces[key];
      const rawAfter = rawSpaces && rawSpaces.after;
      const spaces = attributeNode.spaces[key];
      /** @type {{ after: string, setAfter: (fixed: string) => void }} */

      const {
        after,
        setAfter
      } = rawAfter ? {
        after: rawAfter,

        setAfter(fixed) {
          rawSpaces.after = fixed;
        }

      } : {
        after: spaces && spaces.after || '',

        setAfter(fixed) {
          if (!attributeNode.spaces[key]) attributeNode.spaces[key] = {}; // @ts-expect-error -- TS2532: Object is possibly 'undefined'.

          attributeNode.spaces[key].after = fixed;
        }

      };

      if (primary === 'always') {
        setAfter(after.replace(/\s*$/, ' '));
      } else if (primary === 'never') {
        setAfter(after.replace(/\s*$/, ''));
      }
    }
  };

  rule$Z.ruleName = ruleName$_;
  rule$Z.messages = messages$_;
  rule$Z.meta = meta$_;
  var selectorAttributeBracketsSpaceInside = rule$Z;

  const {
    isRegExp: isRegExp$m,
    isString: isString$v
  } = validateTypes;

  const ruleName$Z = 'selector-attribute-name-disallowed-list';
  const messages$Z = ruleMessages$1(ruleName$Z, {
    rejected: name => `Unexpected name "${name}"`
  });
  const meta$Z = {
    url: 'https://stylelint.io/user-guide/rules/selector-attribute-name-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$Y = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$Z, {
        actual: primary,
        possible: [isString$v, isRegExp$m]
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        if (!ruleNode.selector.includes('[')) {
          return;
        }

        parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
          selectorTree.walkAttributes(attributeNode => {
            const attributeName = attributeNode.qualifiedAttribute;

            if (!matchesStringOrRegExp(attributeName, primary)) {
              return;
            }

            const index = attributeNode.sourceIndex + attributeNode.offsetOf('attribute');
            const endIndex = index + attributeName.length;
            report$1({
              message: messages$Z.rejected,
              messageArgs: [attributeName],
              node: ruleNode,
              index,
              endIndex,
              result,
              ruleName: ruleName$Z
            });
          });
        });
      });
    };
  };

  rule$Y.primaryOptionArray = true;
  rule$Y.ruleName = ruleName$Z;
  rule$Y.messages = messages$Z;
  rule$Y.meta = meta$Z;
  var selectorAttributeNameDisallowedList = rule$Y;

  const {
    isString: isString$u
  } = validateTypes;

  const ruleName$Y = 'selector-attribute-operator-allowed-list';
  const messages$Y = ruleMessages$1(ruleName$Y, {
    rejected: operator => `Unexpected operator "${operator}"`
  });
  const meta$Y = {
    url: 'https://stylelint.io/user-guide/rules/selector-attribute-operator-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | string[]>} */

  const rule$X = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$Y, {
        actual: primary,
        possible: [isString$u]
      });

      if (!validOptions) {
        return;
      }

      const primaryValues = new Set([primary].flat());
      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const {
          selector
        } = ruleNode;

        if (!selector.includes('[') || !selector.includes('=')) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkAttributes(attributeNode => {
            const {
              operator
            } = attributeNode;

            if (!operator || primaryValues.has(operator)) {
              return;
            }

            const index = attributeNode.sourceIndex + attributeNode.offsetOf('operator');
            const endIndex = index + operator.length;
            report$1({
              message: messages$Y.rejected,
              messageArgs: [operator],
              node: ruleNode,
              index,
              endIndex,
              result,
              ruleName: ruleName$Y
            });
          });
        });
      });
    };
  };

  rule$X.primaryOptionArray = true;
  rule$X.ruleName = ruleName$Y;
  rule$X.messages = messages$Y;
  rule$X.meta = meta$Y;
  var selectorAttributeOperatorAllowedList = rule$X;

  const {
    isString: isString$t
  } = validateTypes;

  const ruleName$X = 'selector-attribute-operator-disallowed-list';
  const messages$X = ruleMessages$1(ruleName$X, {
    rejected: operator => `Unexpected operator "${operator}"`
  });
  const meta$X = {
    url: 'https://stylelint.io/user-guide/rules/selector-attribute-operator-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | string[]>} */

  const rule$W = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$X, {
        actual: primary,
        possible: [isString$t]
      });

      if (!validOptions) {
        return;
      }

      const primaryValues = new Set([primary].flat());
      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const {
          selector
        } = ruleNode;

        if (!selector.includes('[') || !selector.includes('=')) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkAttributes(attributeNode => {
            const {
              operator
            } = attributeNode;

            if (!operator || !primaryValues.has(operator)) {
              return;
            }

            const index = attributeNode.sourceIndex + attributeNode.offsetOf('operator');
            const endIndex = index + operator.length;
            report$1({
              message: messages$X.rejected,
              messageArgs: [operator],
              node: ruleNode,
              index,
              endIndex,
              result,
              ruleName: ruleName$X
            });
          });
        });
      });
    };
  };

  rule$W.primaryOptionArray = true;
  rule$W.ruleName = ruleName$X;
  rule$W.messages = messages$X;
  rule$W.meta = meta$X;
  var selectorAttributeOperatorDisallowedList = rule$W;

  /**
   * @param {{
   *   root: import('postcss').Root,
   *   result: import('stylelint').PostcssResult,
   *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void }) => void,
   *   checkedRuleName: string,
   *   checkBeforeOperator: boolean,
   *   fix: ((attributeNode: import('postcss-selector-parser').Attribute) => boolean) | null,
   * }} options
   * @returns {void}
   */


  var selectorAttributeOperatorSpaceChecker = function selectorAttributeOperatorSpaceChecker(options) {
    options.root.walkRules(rule => {
      if (!isStandardSyntaxRule(rule)) {
        return;
      }

      if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
        return;
      }

      let hasFixed = false;
      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;
      const fixedSelector = parseSelector(selector, options.result, rule, selectorTree => {
        selectorTree.walkAttributes(attributeNode => {
          const operator = attributeNode.operator;

          if (!operator) {
            return;
          }

          const attributeNodeString = attributeNode.toString();
          styleSearch({
            source: attributeNodeString,
            target: operator
          }, match => {
            const index = options.checkBeforeOperator ? match.startIndex : match.endIndex - 1;
            checkOperator(attributeNodeString, index, rule, attributeNode, operator);
          });
        });
      });

      if (hasFixed && fixedSelector) {
        if (!rule.raws.selector) {
          rule.selector = fixedSelector;
        } else {
          rule.raws.selector.raw = fixedSelector;
        }
      }
      /**
       * @param {string} source
       * @param {number} index
       * @param {import('postcss').Node} node
       * @param {import('postcss-selector-parser').Attribute} attributeNode
       * @param {string} operator
       */


      function checkOperator(source, index, node, attributeNode, operator) {
        options.locationChecker({
          source,
          index,
          err: msg => {
            if (options.fix && options.fix(attributeNode)) {
              hasFixed = true;
              return;
            }

            report$1({
              message: msg.replace(options.checkBeforeOperator ? operator.charAt(0) : operator.charAt(operator.length - 1), operator),
              node,
              index: attributeNode.sourceIndex + index,
              result: options.result,
              ruleName: options.checkedRuleName
            });
          }
        });
      }
    });
  };

  const ruleName$W = 'selector-attribute-operator-space-after';
  const messages$W = ruleMessages$1(ruleName$W, {
    expectedAfter: operator => `Expected single space after "${operator}"`,
    rejectedAfter: operator => `Unexpected whitespace after "${operator}"`
  });
  const meta$W = {
    url: 'https://stylelint.io/user-guide/rules/selector-attribute-operator-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$V = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const checker = whitespaceChecker('space', primary, messages$W);
      const validOptions = validateOptions$1(result, ruleName$W, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      selectorAttributeOperatorSpaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$W,
        checkBeforeOperator: false,
        fix: context.fix ? attributeNode => {
          /** @type {{ operatorAfter: string, setOperatorAfter: (fixed: string) => void }} */
          const {
            operatorAfter,
            setOperatorAfter
          } = (() => {
            const rawOperator = attributeNode.raws.operator;

            if (rawOperator) {
              return {
                operatorAfter: rawOperator.slice(attributeNode.operator ? attributeNode.operator.length : 0),

                setOperatorAfter(fixed) {
                  delete attributeNode.raws.operator;
                  if (!attributeNode.raws.spaces) attributeNode.raws.spaces = {};
                  if (!attributeNode.raws.spaces.operator) attributeNode.raws.spaces.operator = {};
                  attributeNode.raws.spaces.operator.after = fixed;
                }

              };
            }

            const rawSpacesOperator = attributeNode.raws.spaces && attributeNode.raws.spaces.operator;
            const rawOperatorAfter = rawSpacesOperator && rawSpacesOperator.after;

            if (rawOperatorAfter) {
              return {
                operatorAfter: rawOperatorAfter,

                setOperatorAfter(fixed) {
                  rawSpacesOperator.after = fixed;
                }

              };
            }

            return {
              operatorAfter: attributeNode.spaces.operator && attributeNode.spaces.operator.after || '',

              setOperatorAfter(fixed) {
                if (!attributeNode.spaces.operator) attributeNode.spaces.operator = {};
                attributeNode.spaces.operator.after = fixed;
              }

            };
          })();

          if (primary === 'always') {
            setOperatorAfter(operatorAfter.replace(/^\s*/, ' '));
            return true;
          }

          if (primary === 'never') {
            setOperatorAfter(operatorAfter.replace(/^\s*/, ''));
            return true;
          }

          return false;
        } : null
      });
    };
  };

  rule$V.ruleName = ruleName$W;
  rule$V.messages = messages$W;
  rule$V.meta = meta$W;
  var selectorAttributeOperatorSpaceAfter = rule$V;

  const ruleName$V = 'selector-attribute-operator-space-before';
  const messages$V = ruleMessages$1(ruleName$V, {
    expectedBefore: operator => `Expected single space before "${operator}"`,
    rejectedBefore: operator => `Unexpected whitespace before "${operator}"`
  });
  const meta$V = {
    url: 'https://stylelint.io/user-guide/rules/selector-attribute-operator-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$U = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$V);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$V, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      selectorAttributeOperatorSpaceChecker({
        root,
        result,
        locationChecker: checker.before,
        checkedRuleName: ruleName$V,
        checkBeforeOperator: true,
        fix: context.fix ? attributeNode => {
          const rawAttr = attributeNode.raws.spaces && attributeNode.raws.spaces.attribute;
          const rawAttrAfter = rawAttr && rawAttr.after;
          /** @type {{ attrAfter: string, setAttrAfter: (fixed: string) => void }} */

          const {
            attrAfter,
            setAttrAfter
          } = rawAttrAfter ? {
            attrAfter: rawAttrAfter,

            setAttrAfter(fixed) {
              rawAttr.after = fixed;
            }

          } : {
            attrAfter: attributeNode.spaces.attribute && attributeNode.spaces.attribute.after || '',

            setAttrAfter(fixed) {
              if (!attributeNode.spaces.attribute) attributeNode.spaces.attribute = {};
              attributeNode.spaces.attribute.after = fixed;
            }

          };

          if (primary === 'always') {
            setAttrAfter(attrAfter.replace(/\s*$/, ' '));
            return true;
          }

          if (primary === 'never') {
            setAttrAfter(attrAfter.replace(/\s*$/, ''));
            return true;
          }

          return false;
        } : null
      });
    };
  };

  rule$U.ruleName = ruleName$V;
  rule$U.messages = messages$V;
  rule$U.meta = meta$V;
  var selectorAttributeOperatorSpaceBefore = rule$U;

  /**
   * @param {import('postcss').Rule} ruleNode
   * @returns {string}
   */

  var getRuleSelector = function getRuleSelector(ruleNode) {
    const raws = ruleNode.raws;
    return raws.selector && raws.selector.raw || ruleNode.selector;
  };

  const ISO_10646_CHARACTERS = /\\[0-9a-f]{1,6}(\\r\\n|[ \t\r\n\f])?/gi;
  const SINGLE_ESCAPED_CHARACTERS = /\\./g;
  const NON_WORD_OR_DASH = /[^\w-]/;
  const DIGIT = /\d/;
  /**
   * Returns whether a string is a valid CSS identifier
   * (i.e. only alphanumeric characters, `-`, and `_`;
   * does not have a leading digit, leading dash followed by digit, or two leading dashes)
   * furthermore, any escaped or ISO 10646 characters are allowed.
   * @see https://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
   * @param {string} ident
   * @returns {boolean}
   */

  var isValidIdentifier = function isValidIdentifier(ident) {
    if (!ident || ident.trim() === '') {
      return false;
    } // trims, removes ISO 10646 characters, and singly-escaped characters


    const trimmedIdent = ident.trim().replace(ISO_10646_CHARACTERS, '').replace(SINGLE_ESCAPED_CHARACTERS, '');

    if (NON_WORD_OR_DASH.test(trimmedIdent)) {
      return false;
    }

    if (DIGIT.test(trimmedIdent.charAt(0))) {
      return false;
    }

    if (trimmedIdent.charAt(0) === '-' && DIGIT.test(trimmedIdent.charAt(1))) {
      return false;
    }

    return true;
  };

  const ruleName$U = 'selector-attribute-quotes';
  const messages$U = ruleMessages$1(ruleName$U, {
    expected: value => `Expected quotes around "${value}"`,
    rejected: value => `Unexpected quotes around "${value}"`
  });
  const meta$U = {
    url: 'https://stylelint.io/user-guide/rules/selector-attribute-quotes',
    fixable: true
  };
  const acceptedQuoteMark = '"';
  /** @type {import('stylelint').Rule<'always' | 'never'>} */

  const rule$T = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$U, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const {
          selector
        } = ruleNode;

        if (!selector.includes('[') || !selector.includes('=')) {
          return;
        }

        parseSelector(getRuleSelector(ruleNode), result, ruleNode, selectorTree => {
          let selectorFixed = false;
          selectorTree.walkAttributes(attributeNode => {
            const {
              operator,
              value,
              quoted
            } = attributeNode;

            if (!operator || !value) {
              return;
            }

            if (!quoted && primary === 'always') {
              if (context.fix) {
                selectorFixed = true;
                attributeNode.quoteMark = acceptedQuoteMark;
              } else {
                complain(messages$U.expected(value), attributeNode);
              }
            }

            if (quoted && primary === 'never') {
              // some selectors require quotes to be valid;
              // we pass in the raw string value, which contains the escape characters
              // necessary to check if escaped characters are valid
              // see: https://github.com/stylelint/stylelint/issues/4300
              if (!attributeNode.raws.value || !isValidIdentifier(attributeNode.raws.value.slice(1, -1))) {
                return;
              }

              if (context.fix) {
                selectorFixed = true;
                attributeNode.quoteMark = null;
              } else {
                complain(messages$U.rejected(value), attributeNode);
              }
            }
          });

          if (selectorFixed) {
            ruleNode.selector = selectorTree.toString();
          }
        });
        /**
         * @param {string} message
         * @param {import('postcss-selector-parser').Attribute} attrNode
         */

        function complain(message, attrNode) {
          const index = attrNode.sourceIndex + attrNode.offsetOf('value');
          const value = attrNode.raws.value || attrNode.value || '';
          const endIndex = index + value.length;
          report$1({
            message,
            index,
            endIndex,
            result,
            ruleName: ruleName$U,
            node: ruleNode
          });
        }
      });
    };
  };

  rule$T.ruleName = ruleName$U;
  rule$T.messages = messages$U;
  rule$T.meta = meta$U;
  var selectorAttributeQuotes = rule$T;

  const {
    keyframeSelectorKeywords
  } = keywords$4;
  /**
   * Check whether a string is a keyframe selector.
   *
   * @param {string} selector
   * @returns {boolean}
   */


  var isKeyframeSelector = function isKeyframeSelector(selector) {
    if (keyframeSelectorKeywords.has(selector)) {
      return true;
    } // Percentages


    if (/^(?:\d+|\d*\.\d+)%$/.test(selector)) {
      return true;
    }

    return false;
  };

  const {
    isBoolean: isBoolean$6,
    isRegExp: isRegExp$l,
    isString: isString$s
  } = validateTypes;

  const ruleName$T = 'selector-class-pattern';
  const messages$T = ruleMessages$1(ruleName$T, {
    expected: (selector, pattern) => `Expected "${selector}" to match pattern "${pattern}"`
  });
  const meta$T = {
    url: 'https://stylelint.io/user-guide/rules/selector-class-pattern'
  };
  /** @type {import('stylelint').Rule<string | RegExp, { resolveNestedSelector: boolean }>} */

  const rule$S = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$T, {
        actual: primary,
        possible: [isRegExp$l, isString$s]
      }, {
        actual: secondaryOptions,
        possible: {
          resolveNestedSelectors: [isBoolean$6]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const shouldResolveNestedSelectors = Boolean(secondaryOptions && secondaryOptions.resolveNestedSelectors);
      const normalizedPattern = isString$s(primary) ? new RegExp(primary) : primary;
      root.walkRules(ruleNode => {
        const {
          selector,
          selectors
        } = ruleNode;

        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        if (selectors.some(s => isKeyframeSelector(s))) {
          return;
        } // Only bother resolving selectors that have an interpolating &


        if (shouldResolveNestedSelectors && hasInterpolatingAmpersand(selector)) {
          for (const nestedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            if (!isStandardSyntaxSelector(nestedSelector)) {
              continue;
            }

            parseSelector(nestedSelector, result, ruleNode, s => checkSelector(s, ruleNode));
          }
        } else {
          parseSelector(selector, result, ruleNode, s => checkSelector(s, ruleNode));
        }
      });
      /**
       * @param {import('postcss-selector-parser').Root} selectorNode
       * @param {import('postcss').Rule} ruleNode
       */

      function checkSelector(selectorNode, ruleNode) {
        selectorNode.walkClasses(classNode => {
          const {
            value,
            sourceIndex: index
          } = classNode;

          if (normalizedPattern.test(value)) {
            return;
          }

          const selector = String(classNode); // TODO: `selector` may be resolved. So, getting its raw value may be pretty hard.
          //       It means `endIndex` may be inaccurate (though non-standard selectors).
          //
          //       For example, given ".abc { &_x {} }".
          //       Then, an expected raw `selector` is "&_x",
          //       but, an actual `selector` is ".abc_x".

          const endIndex = index + selector.length;
          report$1({
            result,
            ruleName: ruleName$T,
            message: messages$T.expected,
            messageArgs: [selector, primary],
            node: ruleNode,
            index,
            endIndex
          });
        });
      }
    };
  };
  /**
   * An "interpolating ampersand" means an "&" used to interpolate
   * within another simple selector, rather than an "&" that
   * stands on its own as a simple selector.
   *
   * @param {string} selector
   * @returns {boolean}
   */


  function hasInterpolatingAmpersand(selector) {
    for (const [i, char] of Array.from(selector).entries()) {
      if (char !== '&') {
        continue;
      }

      const prevChar = selector.charAt(i - 1);

      if (prevChar && !isCombinator$1(prevChar)) {
        return true;
      }

      const nextChar = selector.charAt(i + 1);

      if (nextChar && !isCombinator$1(nextChar)) {
        return true;
      }
    }

    return false;
  }
  /**
   * @param {string} x
   * @returns {boolean}
   */


  function isCombinator$1(x) {
    return /[\s+>~]/.test(x);
  }

  rule$S.ruleName = ruleName$T;
  rule$S.messages = messages$T;
  rule$S.meta = meta$T;
  var selectorClassPattern = rule$S;

  /**
   * Check whether a combinator is standard
   *
   * @param {import('postcss-selector-parser').Combinator} node postcss-selector-parser node (of type combinator)
   * @return {boolean} If `true`, the combinator is standard
   */

  var isStandardSyntaxCombinator = function isStandardSyntaxCombinator(node) {
    // if it's not a combinator, then it's not a standard combinator
    if (node.type !== 'combinator') {
      return false;
    } // Ignore reference combinators like `/deep/`


    if (node.value.startsWith('/') || node.value.endsWith('/')) {
      return false;
    } // ignore the combinators that are the first or last node in their container


    if (node.parent !== undefined && node.parent !== null) {
      const parent = node.parent;

      if (node === parent.first) {
        return false;
      }

      if (node === parent.last) {
        return false;
      }
    }

    return true;
  };

  const {
    isString: isString$r
  } = validateTypes;

  const ruleName$S = 'selector-combinator-allowed-list';
  const messages$S = ruleMessages$1(ruleName$S, {
    rejected: combinator => `Unexpected combinator "${combinator}"`
  });
  const meta$S = {
    url: 'https://stylelint.io/user-guide/rules/selector-combinator-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | string[]>} */

  const rule$R = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$S, {
        actual: primary,
        possible: [isString$r]
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;
        parseSelector(selector, result, ruleNode, fullSelector => {
          fullSelector.walkCombinators(combinatorNode => {
            if (!isStandardSyntaxCombinator(combinatorNode)) {
              return;
            }

            const {
              value
            } = combinatorNode;
            const normalizedValue = normalizeCombinator$1(value);

            if (primary.includes(normalizedValue)) {
              return;
            }

            const {
              sourceIndex: index,
              raws
            } = combinatorNode;
            const endIndex = index + (raws && raws.value || value).length;
            report$1({
              result,
              ruleName: ruleName$S,
              message: messages$S.rejected,
              messageArgs: [normalizedValue],
              node: ruleNode,
              index,
              endIndex
            });
          });
        });
      });
    };
  };
  /**
   * @param {string} value
   * @returns {string}
   */


  function normalizeCombinator$1(value) {
    return value.replace(/\s+/g, ' ');
  }

  rule$R.primaryOptionArray = true;
  rule$R.ruleName = ruleName$S;
  rule$R.messages = messages$S;
  rule$R.meta = meta$S;
  var selectorCombinatorAllowedList = rule$R;

  const {
    isString: isString$q
  } = validateTypes;

  const ruleName$R = 'selector-combinator-disallowed-list';
  const messages$R = ruleMessages$1(ruleName$R, {
    rejected: combinator => `Unexpected combinator "${combinator}"`
  });
  const meta$R = {
    url: 'https://stylelint.io/user-guide/rules/selector-combinator-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | string[]>} */

  const rule$Q = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$R, {
        actual: primary,
        possible: [isString$q]
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;
        parseSelector(selector, result, ruleNode, fullSelector => {
          fullSelector.walkCombinators(combinatorNode => {
            if (!isStandardSyntaxCombinator(combinatorNode)) {
              return;
            }

            const {
              value
            } = combinatorNode;
            const normalizedValue = normalizeCombinator(value);

            if (!primary.includes(normalizedValue)) {
              return;
            }

            const {
              sourceIndex: index,
              raws
            } = combinatorNode;
            const endIndex = index + (raws && raws.value || value).length;
            report$1({
              result,
              ruleName: ruleName$R,
              message: messages$R.rejected,
              messageArgs: [normalizedValue],
              node: ruleNode,
              index,
              endIndex
            });
          });
        });
      });
    };
  };
  /**
   * @param {string} value
   * @returns {string}
   */


  function normalizeCombinator(value) {
    return value.replace(/\s+/g, ' ');
  }

  rule$Q.primaryOptionArray = true;
  rule$Q.ruleName = ruleName$R;
  rule$Q.messages = messages$R;
  rule$Q.meta = meta$R;
  var selectorCombinatorDisallowedList = rule$Q;

  /**
   * @typedef {(args: { source: string, index: number, errTarget: string, err: (message: string) => void }) => void} LocationChecker
   *
   * @param {{
   *   root: import('postcss').Root,
   *   result: import('stylelint').PostcssResult,
   *   locationChecker: LocationChecker,
   *   locationType: 'before' | 'after',
   *   checkedRuleName: string,
   *   fix: ((combinator: import('postcss-selector-parser').Combinator) => boolean) | null,
   * }} opts
   * @returns {void}
   */


  var selectorCombinatorSpaceChecker = function selectorCombinatorSpaceChecker(opts) {
    let hasFixed;
    opts.root.walkRules(rule => {
      if (!isStandardSyntaxRule(rule)) {
        return;
      }

      hasFixed = false;
      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;
      const fixedSelector = parseSelector(selector, opts.result, rule, selectorTree => {
        selectorTree.walkCombinators(node => {
          // Ignore non-standard combinators
          if (!isStandardSyntaxCombinator(node)) {
            return;
          } // Ignore spaced descendant combinator


          if (/\s/.test(node.value)) {
            return;
          } // Check the exist of node in prev of the combinator.
          // in case some that aren't the first begin with combinators (nesting syntax)


          if (opts.locationType === 'before' && !node.prev()) {
            return;
          }

          const parentParentNode = node.parent && node.parent.parent; // Ignore pseudo-classes selector like `.foo:nth-child(2n + 1) {}`

          if (parentParentNode && parentParentNode.type === 'pseudo') {
            return;
          }

          const sourceIndex = node.sourceIndex;
          const index = node.value.length > 1 && opts.locationType === 'before' ? sourceIndex : sourceIndex + node.value.length - 1;
          check(selector, node, index, rule, sourceIndex);
        });
      });

      if (hasFixed && fixedSelector) {
        if (!rule.raws.selector) {
          rule.selector = fixedSelector;
        } else {
          rule.raws.selector.raw = fixedSelector;
        }
      }
    });
    /**
     * @param {string} source
     * @param {import('postcss-selector-parser').Combinator} combinator
     * @param {number} index
     * @param {import('postcss').Node} node
     * @param {number} sourceIndex
     */

    function check(source, combinator, index, node, sourceIndex) {
      opts.locationChecker({
        source,
        index,
        errTarget: combinator.value,
        err: message => {
          if (opts.fix && opts.fix(combinator)) {
            hasFixed = true;
            return;
          }

          report$1({
            message,
            node,
            index: sourceIndex,
            result: opts.result,
            ruleName: opts.checkedRuleName
          });
        }
      });
    }
  };

  const ruleName$Q = 'selector-combinator-space-after';
  const messages$Q = ruleMessages$1(ruleName$Q, {
    expectedAfter: combinator => `Expected single space after "${combinator}"`,
    rejectedAfter: combinator => `Unexpected whitespace after "${combinator}"`
  });
  const meta$Q = {
    url: 'https://stylelint.io/user-guide/rules/selector-combinator-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$P = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$Q);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$Q, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      selectorCombinatorSpaceChecker({
        root,
        result,
        locationChecker: checker.after,
        locationType: 'after',
        checkedRuleName: ruleName$Q,
        fix: context.fix ? combinator => {
          if (primary === 'always') {
            combinator.spaces.after = ' ';
            return true;
          }

          if (primary === 'never') {
            combinator.spaces.after = '';
            return true;
          }

          return false;
        } : null
      });
    };
  };

  rule$P.ruleName = ruleName$Q;
  rule$P.messages = messages$Q;
  rule$P.meta = meta$Q;
  var selectorCombinatorSpaceAfter = rule$P;

  const ruleName$P = 'selector-combinator-space-before';
  const messages$P = ruleMessages$1(ruleName$P, {
    expectedBefore: combinator => `Expected single space before "${combinator}"`,
    rejectedBefore: combinator => `Unexpected whitespace before "${combinator}"`
  });
  const meta$P = {
    url: 'https://stylelint.io/user-guide/rules/selector-combinator-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$O = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$P);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$P, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      selectorCombinatorSpaceChecker({
        root,
        result,
        locationChecker: checker.before,
        locationType: 'before',
        checkedRuleName: ruleName$P,
        fix: context.fix ? combinator => {
          if (primary === 'always') {
            combinator.spaces.before = ' ';
            return true;
          }

          if (primary === 'never') {
            combinator.spaces.before = '';
            return true;
          }

          return false;
        } : null
      });
    };
  };

  rule$O.ruleName = ruleName$P;
  rule$O.messages = messages$P;
  rule$O.meta = meta$P;
  var selectorCombinatorSpaceBefore = rule$O;

  const ruleName$O = 'selector-descendant-combinator-no-non-space';
  const messages$O = ruleMessages$1(ruleName$O, {
    rejected: nonSpaceCharacter => `Unexpected "${nonSpaceCharacter}"`
  });
  const meta$O = {
    url: 'https://stylelint.io/user-guide/rules/selector-descendant-combinator-no-non-space',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$N = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$O, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        let hasFixed = false;
        const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector; // Return early for selectors containing comments
        // TODO: re-enable when parser and stylelint are compatible

        if (selector.includes('/*')) return;
        const fixedSelector = parseSelector(selector, result, ruleNode, fullSelector => {
          fullSelector.walkCombinators(combinatorNode => {
            if (combinatorNode.value !== ' ') {
              return;
            }

            const value = combinatorNode.toString();

            if (value.includes('  ') || value.includes('\t') || value.includes('\n') || value.includes('\r')) {
              if (context.fix && /^\s+$/.test(value)) {
                hasFixed = true;
                if (!combinatorNode.raws) combinatorNode.raws = {};
                combinatorNode.raws.value = ' ';
                combinatorNode.rawSpaceBefore = combinatorNode.rawSpaceBefore.replace(/^\s+/, '');
                combinatorNode.rawSpaceAfter = combinatorNode.rawSpaceAfter.replace(/\s+$/, '');
                return;
              }

              report$1({
                result,
                ruleName: ruleName$O,
                message: messages$O.rejected(value),
                node: ruleNode,
                index: combinatorNode.sourceIndex
              });
            }
          });
        });

        if (hasFixed && fixedSelector) {
          if (!ruleNode.raws.selector) {
            ruleNode.selector = fixedSelector;
          } else {
            ruleNode.raws.selector.raw = fixedSelector;
          }
        }
      });
    };
  };

  rule$N.ruleName = ruleName$O;
  rule$N.messages = messages$O;
  rule$N.meta = meta$O;
  var selectorDescendantCombinatorNoNonSpace = rule$N;

  const {
    isRegExp: isRegExp$k,
    isString: isString$p,
    isBoolean: isBoolean$5
  } = validateTypes;

  const ruleName$N = 'selector-disallowed-list';
  const messages$N = ruleMessages$1(ruleName$N, {
    rejected: selector => `Unexpected selector "${selector}"`
  });
  const meta$N = {
    url: 'https://stylelint.io/user-guide/rules/selector-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>, { splitList: boolean, ignore: string[] }>} */

  const rule$M = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$N, {
        actual: primary,
        possible: [isString$p, isRegExp$k]
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['inside-block'],
          splitList: [isBoolean$5]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const ignoreInsideBlock = optionsMatches(secondaryOptions, 'ignore', 'inside-block');
      const splitList = secondaryOptions && secondaryOptions.splitList;
      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        if (ignoreInsideBlock) {
          const {
            parent
          } = ruleNode;
          const isInsideBlock = parent && parent.type !== 'root';

          if (isInsideBlock) {
            return;
          }
        }

        if (splitList) {
          ruleNode.selectors.forEach(selector => {
            if (matchesStringOrRegExp(selector, primary)) {
              report$1({
                result,
                ruleName: ruleName$N,
                message: messages$N.rejected,
                messageArgs: [selector],
                node: ruleNode,
                word: selector
              });
            }
          });
        } else {
          const {
            selector,
            raws
          } = ruleNode;

          if (matchesStringOrRegExp(selector, primary)) {
            const word = raws.selector && raws.selector.raw || selector;
            report$1({
              result,
              ruleName: ruleName$N,
              message: messages$N.rejected,
              messageArgs: [selector],
              node: ruleNode,
              word
            });
          }
        }
      });
    };
  };

  rule$M.primaryOptionArray = true;
  rule$M.ruleName = ruleName$N;
  rule$M.messages = messages$N;
  rule$M.meta = meta$N;
  var selectorDisallowedList = rule$M;

  const {
    isRegExp: isRegExp$j,
    isString: isString$o
  } = validateTypes;

  const ruleName$M = 'selector-id-pattern';
  const messages$M = ruleMessages$1(ruleName$M, {
    expected: (selector, pattern) => `Expected "${selector}" to match pattern "${pattern}"`
  });
  const meta$M = {
    url: 'https://stylelint.io/user-guide/rules/selector-id-pattern'
  };
  /** @type {import('stylelint').Rule<string | RegExp>} */

  const rule$L = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$M, {
        actual: primary,
        possible: [isRegExp$j, isString$o]
      });

      if (!validOptions) {
        return;
      }

      const normalizedPattern = isString$o(primary) ? new RegExp(primary) : primary;
      root.walkRules(/#/, ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        parseSelector(ruleNode.selector, result, ruleNode, fullSelector => {
          fullSelector.walkIds(selectorNode => {
            if (normalizedPattern.test(selectorNode.value)) {
              return;
            }

            const selector = String(selectorNode);
            report$1({
              result,
              ruleName: ruleName$M,
              message: messages$M.expected,
              messageArgs: [selector, primary],
              node: ruleNode,
              word: selector
            });
          });
        });
      });
    };
  };

  rule$L.ruleName = ruleName$M;
  rule$L.messages = messages$M;
  rule$L.meta = meta$M;
  var selectorIdPattern = rule$L;

  const ruleName$L = 'selector-list-comma-newline-after';
  const messages$L = ruleMessages$1(ruleName$L, {
    expectedAfter: () => 'Expected newline after ","',
    expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
    rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list'
  });
  const meta$L = {
    url: 'https://stylelint.io/user-guide/rules/selector-list-comma-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$K = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$L);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$L, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        } // Get raw selector so we can allow end-of-line comments, e.g.
        // a, /* comment */
        // b {}


        const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;
        /** @type {number[]} */

        const fixIndices = [];
        styleSearch({
          source: selector,
          target: ',',
          functionArguments: 'skip'
        }, match => {
          const nextChars = selector.slice(match.endIndex); // If there's a // comment, that means there has to be a newline
          // ending the comment so we're fine

          if (/^\s+\/\//.test(nextChars)) {
            return;
          } // If there are spaces and then a comment begins, look for the newline


          const indextoCheckAfter = /^\s+\/\*/.test(nextChars) ? selector.indexOf('*/', match.endIndex) + 1 : match.startIndex;
          checker.afterOneOnly({
            source: selector,
            index: indextoCheckAfter,
            err: m => {
              if (context.fix) {
                fixIndices.push(indextoCheckAfter + 1);
                return;
              }

              report$1({
                message: m,
                node: ruleNode,
                index: match.startIndex,
                result,
                ruleName: ruleName$L
              });
            }
          });
        });

        if (fixIndices.length) {
          let fixedSelector = selector;

          for (const index of fixIndices.sort((a, b) => b - a)) {
            const beforeSelector = fixedSelector.slice(0, index);
            let afterSelector = fixedSelector.slice(index);

            if (primary.startsWith('always')) {
              afterSelector = context.newline + afterSelector;
            } else if (primary.startsWith('never-multi-line')) {
              afterSelector = afterSelector.replace(/^\s*/, '');
            }

            fixedSelector = beforeSelector + afterSelector;
          }

          if (ruleNode.raws.selector) {
            ruleNode.raws.selector.raw = fixedSelector;
          } else {
            ruleNode.selector = fixedSelector;
          }
        }
      });
    };
  };

  rule$K.ruleName = ruleName$L;
  rule$K.messages = messages$L;
  rule$K.meta = meta$L;
  var selectorListCommaNewlineAfter = rule$K;

  /**
   * @param {{
   *   root: import('postcss').Root,
   *   result: import('stylelint').PostcssResult,
   *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void }) => void,
   *   checkedRuleName: string,
   *   fix: ((rule: import('postcss').Rule, index: number) => boolean) | null,
   * }} opts
   * @returns {void}
   */


  var selectorListCommaWhitespaceChecker = function selectorListCommaWhitespaceChecker(opts) {
    opts.root.walkRules(rule => {
      if (!isStandardSyntaxRule(rule)) {
        return;
      }

      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;
      styleSearch({
        source: selector,
        target: ',',
        functionArguments: 'skip'
      }, match => {
        checkDelimiter(selector, match.startIndex, rule);
      });
    });
    /**
     * @param {string} source
     * @param {number} index
     * @param {import('postcss').Rule} node
     */

    function checkDelimiter(source, index, node) {
      opts.locationChecker({
        source,
        index,
        err: message => {
          if (opts.fix && opts.fix(node, index)) {
            return;
          }

          report$1({
            message,
            node,
            index,
            result: opts.result,
            ruleName: opts.checkedRuleName
          });
        }
      });
    }
  };

  const ruleName$K = 'selector-list-comma-newline-before';
  const messages$K = ruleMessages$1(ruleName$K, {
    expectedBefore: () => 'Expected newline before ","',
    expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
    rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list'
  });
  const meta$K = {
    url: 'https://stylelint.io/user-guide/rules/selector-list-comma-newline-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$J = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$K);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$K, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').Rule, number[]> | undefined} */


      let fixData;
      selectorListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.beforeAllowingIndentation,
        checkedRuleName: ruleName$K,
        fix: context.fix ? (ruleNode, index) => {
          fixData = fixData || new Map();
          const commaIndices = fixData.get(ruleNode) || [];
          commaIndices.push(index);
          fixData.set(ruleNode, commaIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [ruleNode, commaIndices] of fixData.entries()) {
          let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

          for (const index of commaIndices.sort((a, b) => b - a)) {
            let beforeSelector = selector.slice(0, index);
            const afterSelector = selector.slice(index);

            if (primary.startsWith('always')) {
              const spaceIndex = beforeSelector.search(/\s+$/);

              if (spaceIndex >= 0) {
                beforeSelector = beforeSelector.slice(0, spaceIndex) + context.newline + beforeSelector.slice(spaceIndex);
              } else {
                beforeSelector += context.newline;
              }
            } else if (primary === 'never-multi-line') {
              beforeSelector = beforeSelector.replace(/\s*$/, '');
            }

            selector = beforeSelector + afterSelector;
          }

          if (ruleNode.raws.selector) {
            ruleNode.raws.selector.raw = selector;
          } else {
            ruleNode.selector = selector;
          }
        }
      }
    };
  };

  rule$J.ruleName = ruleName$K;
  rule$J.messages = messages$K;
  rule$J.meta = meta$K;
  var selectorListCommaNewlineBefore = rule$J;

  const ruleName$J = 'selector-list-comma-space-after';
  const messages$J = ruleMessages$1(ruleName$J, {
    expectedAfter: () => 'Expected single space after ","',
    rejectedAfter: () => 'Unexpected whitespace after ","',
    expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
    rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list'
  });
  const meta$J = {
    url: 'https://stylelint.io/user-guide/rules/selector-list-comma-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$I = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$J);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$J, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').Rule, number[]> | undefined} */


      let fixData;
      selectorListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$J,
        fix: context.fix ? (ruleNode, index) => {
          fixData = fixData || new Map();
          const commaIndices = fixData.get(ruleNode) || [];
          commaIndices.push(index);
          fixData.set(ruleNode, commaIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [ruleNode, commaIndices] of fixData.entries()) {
          let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

          for (const index of commaIndices.sort((a, b) => b - a)) {
            const beforeSelector = selector.slice(0, index + 1);
            let afterSelector = selector.slice(index + 1);

            if (primary.startsWith('always')) {
              afterSelector = afterSelector.replace(/^\s*/, ' ');
            } else if (primary.startsWith('never')) {
              afterSelector = afterSelector.replace(/^\s*/, '');
            }

            selector = beforeSelector + afterSelector;
          }

          if (ruleNode.raws.selector) {
            ruleNode.raws.selector.raw = selector;
          } else {
            ruleNode.selector = selector;
          }
        }
      }
    };
  };

  rule$I.ruleName = ruleName$J;
  rule$I.messages = messages$J;
  rule$I.meta = meta$J;
  var selectorListCommaSpaceAfter = rule$I;

  const ruleName$I = 'selector-list-comma-space-before';
  const messages$I = ruleMessages$1(ruleName$I, {
    expectedBefore: () => 'Expected single space before ","',
    rejectedBefore: () => 'Unexpected whitespace before ","',
    expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line list',
    rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list'
  });
  const meta$I = {
    url: 'https://stylelint.io/user-guide/rules/selector-list-comma-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$H = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$I);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$I, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').Rule, number[]> | undefined} */


      let fixData;
      selectorListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.before,
        checkedRuleName: ruleName$I,
        fix: context.fix ? (ruleNode, index) => {
          fixData = fixData || new Map();
          const commaIndices = fixData.get(ruleNode) || [];
          commaIndices.push(index);
          fixData.set(ruleNode, commaIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [ruleNode, commaIndices] of fixData.entries()) {
          let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

          for (const index of commaIndices.sort((a, b) => b - a)) {
            let beforeSelector = selector.slice(0, index);
            const afterSelector = selector.slice(index);

            if (primary.includes('always')) {
              beforeSelector = beforeSelector.replace(/\s*$/, ' ');
            } else if (primary.includes('never')) {
              beforeSelector = beforeSelector.replace(/\s*$/, '');
            }

            selector = beforeSelector + afterSelector;
          }

          if (ruleNode.raws.selector) {
            ruleNode.raws.selector.raw = selector;
          } else {
            ruleNode.selector = selector;
          }
        }
      }
    };
  };

  rule$H.ruleName = ruleName$I;
  rule$H.messages = messages$I;
  rule$H.meta = meta$I;
  var selectorListCommaSpaceBefore = rule$H;

  const {
    aNPlusBOfSNotationPseudoClasses: aNPlusBOfSNotationPseudoClasses$2,
    logicalCombinationsPseudoClasses
  } = selectors;
  /**
   * Check whether a node is a context-functional pseudo-class (i.e. either a logical combination
   * or a 'aNPlusBOfSNotationPseudoClasses' / tree-structural pseudo-class)
   *
   * @param {import('postcss-selector-parser').Node} node - postcss-selector-parser node (of type pseudo)
   * @return {node is import('postcss-selector-parser').Pseudo} If `true`, the node is a context-functional pseudo-class
   */


  var isContextFunctionalPseudoClass = function isContextFunctionalPseudoClass(node) {
    if (node.type === 'pseudo') {
      const normalisedParentName = node.value.toLowerCase().replace(/:+/, '');
      return logicalCombinationsPseudoClasses.has(normalisedParentName) || aNPlusBOfSNotationPseudoClasses$2.has(normalisedParentName);
    }

    return false;
  };

  /**
   * @param {unknown} value
   */

  var isNonNegativeInteger = function isNonNegativeInteger(value) {
    return Number.isInteger(value) && typeof value === 'number' && value >= 0;
  };

  const {
    isRegExp: isRegExp$i,
    isString: isString$n
  } = validateTypes;

  const ruleName$H = 'selector-max-attribute';
  const messages$H = ruleMessages$1(ruleName$H, {
    expected: (selector, max) => `Expected "${selector}" to have no more than ${max} attribute ${max === 1 ? 'selector' : 'selectors'}`
  });
  const meta$H = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-attribute'
  };
  /** @type {import('stylelint').Rule} */

  const rule$G = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$H, {
        actual: primary,
        possible: isNonNegativeInteger
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreAttributes: [isString$n, isRegExp$i]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {import('postcss-selector-parser').Container<string | undefined>} selectorNode
       * @param {import('postcss').Rule} ruleNode
       */


      function checkSelector(selectorNode, ruleNode) {
        const count = selectorNode.reduce((total, childNode) => {
          // Only traverse inside actual selectors and context functional pseudo-classes
          if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
            checkSelector(childNode, ruleNode);
          }

          if (childNode.type !== 'attribute') {
            // Not an attribute node -> ignore
            return total;
          }

          if (optionsMatches(secondaryOptions, 'ignoreAttributes', childNode.attribute)) {
            // it's an attribute that is supposed to be ignored
            return total;
          }

          total += 1;
          return total;
        }, 0);

        if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
          const selector = selectorNode.toString();
          report$1({
            ruleName: ruleName$H,
            result,
            node: ruleNode,
            message: messages$H.expected,
            messageArgs: [selector, primary],
            word: selector
          });
        }
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        for (const selector of ruleNode.selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            parseSelector(resolvedSelector, result, ruleNode, container => checkSelector(container, ruleNode));
          }
        }
      });
    };
  };

  rule$G.ruleName = ruleName$H;
  rule$G.messages = messages$H;
  rule$G.meta = meta$H;
  var selectorMaxAttribute = rule$G;

  const ruleName$G = 'selector-max-class';
  const messages$G = ruleMessages$1(ruleName$G, {
    expected: (selector, max) => `Expected "${selector}" to have no more than ${max} ${max === 1 ? 'class' : 'classes'}`
  });
  const meta$G = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-class'
  };
  /** @type {import('stylelint').Rule} */

  const rule$F = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$G, {
        actual: primary,
        possible: isNonNegativeInteger
      });

      if (!validOptions) {
        return;
      }
      /**
       *  @param {import('postcss-selector-parser').Container<string | undefined>} selectorNode
       *  @param {import('postcss').Rule} ruleNode
       */


      function checkSelector(selectorNode, ruleNode) {
        const count = selectorNode.reduce((total, childNode) => {
          // Only traverse inside actual selectors and context functional pseudo-classes
          if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
            checkSelector(childNode, ruleNode);
          }

          if (childNode.type === 'class') total += 1;
          return total;
        }, 0);

        if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
          const selector = selectorNode.toString();
          report$1({
            ruleName: ruleName$G,
            result,
            node: ruleNode,
            message: messages$G.expected,
            messageArgs: [selector, primary],
            word: selector
          });
        }
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        for (const selector of ruleNode.selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            parseSelector(resolvedSelector, result, ruleNode, container => checkSelector(container, ruleNode));
          }
        }
      });
    };
  };

  rule$F.ruleName = ruleName$G;
  rule$F.messages = messages$G;
  rule$F.meta = meta$G;
  var selectorMaxClass = rule$F;

  const ruleName$F = 'selector-max-combinators';
  const messages$F = ruleMessages$1(ruleName$F, {
    expected: (selector, max) => `Expected "${selector}" to have no more than ${max} ${max === 1 ? 'combinator' : 'combinators'}`
  });
  const meta$F = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-combinators'
  };
  /** @type {import('stylelint').Rule} */

  const rule$E = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$F, {
        actual: primary,
        possible: isNonNegativeInteger
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {import('postcss-selector-parser').Container<string | undefined>} selectorNode
       * @param {import('postcss').Rule} ruleNode
       */


      function checkSelector(selectorNode, ruleNode) {
        const count = selectorNode.reduce((total, childNode) => {
          // Only traverse inside actual selectors
          if (childNode.type === 'selector') {
            checkSelector(childNode, ruleNode);
          }

          if (childNode.type === 'combinator') total += 1;
          return total;
        }, 0);

        if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
          const selector = selectorNode.toString();
          report$1({
            ruleName: ruleName$F,
            result,
            node: ruleNode,
            message: messages$F.expected,
            messageArgs: [selector, primary],
            word: selector
          });
        }
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        for (const selector of ruleNode.selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            parseSelector(resolvedSelector, result, ruleNode, container => checkSelector(container, ruleNode));
          }
        }
      });
    };
  };

  rule$E.ruleName = ruleName$F;
  rule$E.messages = messages$F;
  rule$E.meta = meta$F;
  var selectorMaxCombinators = rule$E;

  const ruleName$E = 'selector-max-compound-selectors';
  const messages$E = ruleMessages$1(ruleName$E, {
    expected: (selector, max) => `Expected "${selector}" to have no more than ${max} compound ${max === 1 ? 'selector' : 'selectors'}`
  });
  const meta$E = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-compound-selectors'
  };
  /** @type {import('stylelint').Rule} */

  const rule$D = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$E, {
        actual: primary,
        possible: isNonNegativeInteger
      });

      if (!validOptions) {
        return;
      }
      /**
       * Finds actual selectors in selectorNode object and checks them.
       *
       * @param {import('postcss-selector-parser').Container<string | undefined>} selectorNode
       * @param {import('postcss').Rule} ruleNode
       */


      function checkSelector(selectorNode, ruleNode) {
        let compoundCount = 1;
        selectorNode.each(childNode => {
          // Only traverse inside actual selectors and context functional pseudo-classes
          if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
            checkSelector(childNode, ruleNode);
          } // Compound selectors are separated by combinators, so increase count when meeting one


          if (childNode.type === 'combinator') {
            compoundCount++;
          }
        });

        if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && compoundCount > primary) {
          const selector = selectorNode.toString();
          report$1({
            ruleName: ruleName$E,
            result,
            node: ruleNode,
            message: messages$E.expected,
            messageArgs: [selector, primary],
            word: selector
          });
        }
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        } // Using `.selectors` gets us each selector if there is a comma separated set


        for (const selector of ruleNode.selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            // Process each resolved selector with `checkSelector` via postcss-selector-parser
            parseSelector(resolvedSelector, result, ruleNode, s => checkSelector(s, ruleNode));
          }
        }
      });
    };
  };

  rule$D.ruleName = ruleName$E;
  rule$D.messages = messages$E;
  rule$D.meta = meta$E;
  var selectorMaxCompoundSelectors = rule$D;

  const {
    isNumber: isNumber$5
  } = validateTypes;

  const ruleName$D = 'selector-max-empty-lines';
  const messages$D = ruleMessages$1(ruleName$D, {
    expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`
  });
  const meta$D = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-empty-lines',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$C = (primary, _secondaryOptions, context) => {
    const maxAdjacentNewlines = primary + 1;
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$D, {
        actual: primary,
        possible: isNumber$5
      });

      if (!validOptions) {
        return;
      }

      const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
      const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
      const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
      const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';
      root.walkRules(ruleNode => {
        const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

        if (context.fix) {
          const newSelectorString = selector.replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

          if (ruleNode.raws.selector) {
            ruleNode.raws.selector.raw = newSelectorString;
          } else {
            ruleNode.selector = newSelectorString;
          }
        } else if (violatedLFNewLinesRegex.test(selector) || violatedCRLFNewLinesRegex.test(selector)) {
          report$1({
            message: messages$D.expected(primary),
            node: ruleNode,
            index: 0,
            result,
            ruleName: ruleName$D
          });
        }
      });
    };
  };

  rule$C.ruleName = ruleName$D;
  rule$C.messages = messages$D;
  rule$C.meta = meta$D;
  var selectorMaxEmptyLines = rule$C;

  const {
    isRegExp: isRegExp$h,
    isString: isString$m
  } = validateTypes;

  const ruleName$C = 'selector-max-id';
  const messages$C = ruleMessages$1(ruleName$C, {
    expected: (selector, max) => `Expected "${selector}" to have no more than ${max} ID ${max === 1 ? 'selector' : 'selectors'}`
  });
  const meta$C = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-id'
  };
  /** @type {import('stylelint').Rule} */

  const rule$B = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$C, {
        actual: primary,
        possible: isNonNegativeInteger
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreContextFunctionalPseudoClasses: [isString$m, isRegExp$h]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {import('postcss-selector-parser').Container<string | undefined>} selectorNode
       * @param {import('postcss').Rule} ruleNode
       */


      function checkSelector(selectorNode, ruleNode) {
        const count = selectorNode.reduce((total, childNode) => {
          // Only traverse inside actual selectors and context functional pseudo-classes that are not part of ignored functional pseudo-classes
          if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode) && !isIgnoredContextFunctionalPseudoClass(childNode)) {
            checkSelector(childNode, ruleNode);
          }

          if (childNode.type === 'id') total += 1;
          return total;
        }, 0);

        if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
          const selector = selectorNode.toString();
          report$1({
            ruleName: ruleName$C,
            result,
            node: ruleNode,
            message: messages$C.expected,
            messageArgs: [selector, primary],
            word: selector
          });
        }
      }
      /**
       * @param {import('postcss-selector-parser').Node} node
       * @returns {boolean}
       */


      function isIgnoredContextFunctionalPseudoClass(node) {
        return node.type === 'pseudo' && optionsMatches(secondaryOptions, 'ignoreContextFunctionalPseudoClasses', node.value);
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        for (const selector of ruleNode.selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            parseSelector(resolvedSelector, result, ruleNode, container => checkSelector(container, ruleNode));
          }
        }
      });
    };
  };

  rule$B.ruleName = ruleName$C;
  rule$B.messages = messages$C;
  rule$B.meta = meta$C;
  var selectorMaxId = rule$B;

  const {
    levelOneAndTwoPseudoElements: levelOneAndTwoPseudoElements$4
  } = selectors;











  const ruleName$B = 'selector-max-pseudo-class';
  const messages$B = ruleMessages$1(ruleName$B, {
    expected: (selector, max) => `Expected "${selector}" to have no more than ${max} pseudo-${max === 1 ? 'class' : 'classes'}`
  });
  const meta$B = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-pseudo-class'
  };
  /** @type {import('stylelint').Rule} */

  const rule$A = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$B, {
        actual: primary,
        possible: isNonNegativeInteger
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {import('postcss-selector-parser').Container<string | undefined>} selectorNode
       * @param {import('postcss').Rule} ruleNode
       */


      function checkSelector(selectorNode, ruleNode) {
        const count = selectorNode.reduce((total, childNode) => {
          // Only traverse inside actual selectors and context functional pseudo-classes
          if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
            checkSelector(childNode, ruleNode);
          } // Exclude pseudo elements from the count


          if (childNode.type === 'pseudo' && (childNode.value.includes('::') || levelOneAndTwoPseudoElements$4.has(childNode.value.toLowerCase().slice(1)))) {
            return total;
          }

          if (childNode.type === 'pseudo') {
            total += 1;
          }

          return total;
        }, 0);

        if (count > primary) {
          const selector = selectorNode.toString();
          report$1({
            ruleName: ruleName$B,
            result,
            node: ruleNode,
            message: messages$B.expected,
            messageArgs: [selector, primary],
            word: selector
          });
        }
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        for (const selector of ruleNode.selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            parseSelector(resolvedSelector, result, ruleNode, selectorTree => {
              checkSelector(selectorTree, ruleNode);
            });
          }
        }
      });
    };
  };

  rule$A.ruleName = ruleName$B;
  rule$A.messages = messages$B;
  rule$A.meta = meta$B;
  var selectorMaxPseudoClass = rule$A;

  const {
    selectorSpecificity,
    compare: compare$1
  } = dist$2;





  const {
    aNPlusBOfSNotationPseudoClasses: aNPlusBOfSNotationPseudoClasses$1,
    aNPlusBNotationPseudoClasses: aNPlusBNotationPseudoClasses$1,
    linguisticPseudoClasses: linguisticPseudoClasses$1
  } = selectors;











  const {
    isRegExp: isRegExp$g,
    isString: isString$l,
    assertNumber: assertNumber$2
  } = validateTypes;

  const ruleName$A = 'selector-max-specificity';
  const messages$A = ruleMessages$1(ruleName$A, {
    expected: (selector, max) => `Expected "${selector}" to have a specificity no more than "${max}"`
  });
  const meta$A = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-specificity'
  };
  /** @typedef {import('@csstools/selector-specificity').Specificity} Specificity */

  /**
   * Return a zero specificity. We need a new instance each time so that it can mutated.
   *
   * @returns {Specificity}
   */

  const zeroSpecificity = () => ({
    a: 0,
    b: 0,
    c: 0
  });
  /**
   * Calculate the sum of given specificities.
   *
   * @param {Specificity[]} specificities
   * @returns {Specificity}
   */


  const specificitySum = specificities => {
    const sum = zeroSpecificity();

    for (const {
      a,
      b,
      c
    } of specificities) {
      sum.a += a;
      sum.b += b;
      sum.c += c;
    }

    return sum;
  };
  /** @type {import('stylelint').Rule<string>} */


  const rule$z = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$A, {
        actual: primary,
        possible: [// Check that the max specificity is in the form "a,b,c"
        spec => isString$l(spec) && /^\d+,\d+,\d+$/.test(spec)]
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreSelectors: [isString$l, isRegExp$g]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }
      /**
       * Calculate the specificity of a simple selector (type, attribute, class, ID, or pseudos's own value).
       *
       * @param {import('postcss-selector-parser').Node} node
       * @returns {Specificity}
       */


      const simpleSpecificity = node => {
        if (optionsMatches(secondaryOptions, 'ignoreSelectors', node.toString())) {
          return zeroSpecificity();
        }

        return selectorSpecificity(node);
      };
      /**
       * Calculate the specificity of the most specific direct child.
       *
       * @param {import('postcss-selector-parser').Container<string | undefined>} node
       * @returns {Specificity}
       */


      const maxChildSpecificity = node => node.reduce((maxSpec, child) => {
        const childSpecificity = nodeSpecificity(child); // eslint-disable-line no-use-before-define

        return compare$1(childSpecificity, maxSpec) > 0 ? childSpecificity : maxSpec;
      }, zeroSpecificity());
      /**
       * Calculate the specificity of a pseudo selector including own value and children.
       *
       * @param {import('postcss-selector-parser').Pseudo} node
       * @returns {Specificity}
       */


      const pseudoSpecificity = node => {
        // `node.toString()` includes children which should be processed separately,
        // so use `node.value` instead
        const ownValue = node.value.toLowerCase();

        if (ownValue === ':where') {
          return zeroSpecificity();
        }

        let ownSpecificity;

        if (optionsMatches(secondaryOptions, 'ignoreSelectors', ownValue)) {
          ownSpecificity = zeroSpecificity();
        } else if (aNPlusBOfSNotationPseudoClasses$1.has(ownValue.replace(/^:/, ''))) {
          // TODO: We need to support `<complex-selector-list>` in `ignoreSelectors`. E.g. `:nth-child(even of .foo)`.
          return selectorSpecificity(node);
        } else {
          ownSpecificity = selectorSpecificity(node.clone({
            nodes: []
          }));
        }

        return specificitySum([ownSpecificity, maxChildSpecificity(node)]);
      };
      /**
       * @param {import('postcss-selector-parser').Node} node
       * @returns {boolean}
       */


      const shouldSkipPseudoClassArgument = node => {
        // postcss-selector-parser includes the arguments to nth-child() functions
        // as "tags", so we need to ignore them ourselves.
        // The fake-tag's "parent" is actually a selector node, whose parent
        // should be the :nth-child pseudo node.
        const parentNode = node.parent && node.parent.parent;

        if (parentNode && parentNode.type === 'pseudo' && parentNode.value) {
          const pseudoClass = parentNode.value.toLowerCase().replace(/^:/, '');
          return aNPlusBNotationPseudoClasses$1.has(pseudoClass) || linguisticPseudoClasses$1.has(pseudoClass);
        }

        return false;
      };
      /**
       * Calculate the specificity of a node parsed by `postcss-selector-parser`.
       *
       * @param {import('postcss-selector-parser').Node} node
       * @returns {Specificity}
       */


      const nodeSpecificity = node => {
        if (shouldSkipPseudoClassArgument(node)) {
          return zeroSpecificity();
        }

        switch (node.type) {
          case 'attribute':
          case 'class':
          case 'id':
          case 'tag':
            return simpleSpecificity(node);

          case 'pseudo':
            return pseudoSpecificity(node);

          case 'selector':
            // Calculate the sum of all the direct children
            return specificitySum(node.map(n => nodeSpecificity(n)));

          default:
            return zeroSpecificity();
        }
      };

      const [a, b, c] = primary.split(',').map(s => Number.parseFloat(s));
      assertNumber$2(a);
      assertNumber$2(b);
      assertNumber$2(c);
      const maxSpecificity = {
        a,
        b,
        c
      };
      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        } // Using `.selectors` gets us each selector in the eventuality we have a comma separated set


        for (const selector of ruleNode.selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            // Skip non-standard syntax selectors
            if (!isStandardSyntaxSelector(resolvedSelector)) {
              continue;
            }

            parseSelector(resolvedSelector, result, ruleNode, selectorTree => {
              // Check if the selector specificity exceeds the allowed maximum
              if (compare$1(maxChildSpecificity(selectorTree), maxSpecificity) > 0) {
                report$1({
                  ruleName: ruleName$A,
                  result,
                  node: ruleNode,
                  message: messages$A.expected,
                  messageArgs: [resolvedSelector, primary],
                  word: selector
                });
              }
            });
          }
        }
      });
    };
  };

  rule$z.ruleName = ruleName$A;
  rule$z.messages = messages$A;
  rule$z.meta = meta$A;
  var selectorMaxSpecificity = rule$z;

  const {
    aNPlusBNotationPseudoClasses,
    aNPlusBOfSNotationPseudoClasses,
    linguisticPseudoClasses,
    shadowTreePseudoElements
  } = selectors;
  /**
   * Check whether a type selector is standard
   *
   * @param {import('postcss-selector-parser').Tag} node postcss-selector-parser node (of type tag)
   * @return {boolean} If `true`, the type selector is standard
   */


  var isStandardSyntaxTypeSelector = function isStandardSyntaxTypeSelector(node) {
    // postcss-selector-parser includes the arguments to nth-child() functions
    // as "tags", so we need to ignore them ourselves.
    // The fake-tag's "parent" is actually a selector node, whose parent
    // should be the :nth-child pseudo node.
    if (!node.parent || !node.parent.parent) {
      return false;
    }

    const _node$parent$parent = node.parent.parent;
    const parentType = _node$parent$parent.type;
    const parentValue = _node$parent$parent.value;

    if (parentValue) {
      const normalisedParentName = parentValue.toLowerCase().replace(/:+/, '');

      if (parentType === 'pseudo' && (aNPlusBNotationPseudoClasses.has(normalisedParentName) || aNPlusBOfSNotationPseudoClasses.has(normalisedParentName) || linguisticPseudoClasses.has(normalisedParentName) || shadowTreePseudoElements.has(normalisedParentName))) {
        return false;
      }
    } // &-bar is a nesting selector combined with a suffix


    if (node.prev() && node.prev().type === 'nesting') {
      return false;
    }

    if (node.value.startsWith('%')) {
      return false;
    } // Reference combinators like `/deep/`


    if (node.value.startsWith('/') && node.value.endsWith('/')) {
      return false;
    }

    return true;
  };

  var mathMLTags = [
  	"abs",
  	"and",
  	"annotation",
  	"annotation-xml",
  	"apply",
  	"approx",
  	"arccos",
  	"arccosh",
  	"arccot",
  	"arccoth",
  	"arccsc",
  	"arccsch",
  	"arcsec",
  	"arcsech",
  	"arcsin",
  	"arcsinh",
  	"arctan",
  	"arctanh",
  	"arg",
  	"bind",
  	"bvar",
  	"card",
  	"cartesianproduct",
  	"cbytes",
  	"ceiling",
  	"cerror",
  	"ci",
  	"cn",
  	"codomain",
  	"complexes",
  	"compose",
  	"condition",
  	"conjugate",
  	"cos",
  	"cosh",
  	"cot",
  	"coth",
  	"cs",
  	"csc",
  	"csch",
  	"csymbol",
  	"curl",
  	"declare",
  	"degree",
  	"determinant",
  	"diff",
  	"divergence",
  	"divide",
  	"domain",
  	"domainofapplication",
  	"emptyset",
  	"encoding",
  	"eq",
  	"equivalent",
  	"eulergamma",
  	"exists",
  	"exp",
  	"exponentiale",
  	"factorial",
  	"factorof",
  	"false",
  	"floor",
  	"fn",
  	"forall",
  	"function",
  	"gcd",
  	"geq",
  	"grad",
  	"gt",
  	"ident",
  	"image",
  	"imaginary",
  	"imaginaryi",
  	"implies",
  	"in",
  	"infinity",
  	"int",
  	"integers",
  	"intersect",
  	"interval",
  	"inverse",
  	"lambda",
  	"laplacian",
  	"lcm",
  	"leq",
  	"limit",
  	"list",
  	"ln",
  	"log",
  	"logbase",
  	"lowlimit",
  	"lt",
  	"maction",
  	"malign",
  	"maligngroup",
  	"malignmark",
  	"malignscope",
  	"math",
  	"matrix",
  	"matrixrow",
  	"max",
  	"mean",
  	"median",
  	"menclose",
  	"merror",
  	"mfenced",
  	"mfrac",
  	"mfraction",
  	"mglyph",
  	"mi",
  	"min",
  	"minus",
  	"mlabeledtr",
  	"mlongdiv",
  	"mmultiscripts",
  	"mn",
  	"mo",
  	"mode",
  	"moment",
  	"momentabout",
  	"mover",
  	"mpadded",
  	"mphantom",
  	"mprescripts",
  	"mroot",
  	"mrow",
  	"ms",
  	"mscarries",
  	"mscarry",
  	"msgroup",
  	"msline",
  	"mspace",
  	"msqrt",
  	"msrow",
  	"mstack",
  	"mstyle",
  	"msub",
  	"msubsup",
  	"msup",
  	"mtable",
  	"mtd",
  	"mtext",
  	"mtr",
  	"munder",
  	"munderover",
  	"naturalnumbers",
  	"neq",
  	"none",
  	"not",
  	"notanumber",
  	"notin",
  	"notprsubset",
  	"notsubset",
  	"or",
  	"otherwise",
  	"outerproduct",
  	"partialdiff",
  	"pi",
  	"piece",
  	"piecewice",
  	"piecewise",
  	"plus",
  	"power",
  	"primes",
  	"product",
  	"prsubset",
  	"quotient",
  	"rationals",
  	"real",
  	"reals",
  	"reln",
  	"rem",
  	"root",
  	"scalarproduct",
  	"sdev",
  	"sec",
  	"sech",
  	"select",
  	"selector",
  	"semantics",
  	"sep",
  	"set",
  	"setdiff",
  	"share",
  	"sin",
  	"sinh",
  	"span",
  	"subset",
  	"sum",
  	"tan",
  	"tanh",
  	"tendsto",
  	"times",
  	"transpose",
  	"true",
  	"union",
  	"uplimit",
  	"var",
  	"variance",
  	"vector",
  	"vectorproduct",
  	"xor"
  ];

  var require$$0$2 = [
  	"a",
  	"altGlyph",
  	"altGlyphDef",
  	"altGlyphItem",
  	"animate",
  	"animateColor",
  	"animateMotion",
  	"animateTransform",
  	"circle",
  	"clipPath",
  	"color-profile",
  	"cursor",
  	"defs",
  	"desc",
  	"ellipse",
  	"feBlend",
  	"feColorMatrix",
  	"feComponentTransfer",
  	"feComposite",
  	"feConvolveMatrix",
  	"feDiffuseLighting",
  	"feDisplacementMap",
  	"feDistantLight",
  	"feFlood",
  	"feFuncA",
  	"feFuncB",
  	"feFuncG",
  	"feFuncR",
  	"feGaussianBlur",
  	"feImage",
  	"feMerge",
  	"feMergeNode",
  	"feMorphology",
  	"feOffset",
  	"fePointLight",
  	"feSpecularLighting",
  	"feSpotLight",
  	"feTile",
  	"feTurbulence",
  	"filter",
  	"font",
  	"font-face",
  	"font-face-format",
  	"font-face-name",
  	"font-face-src",
  	"font-face-uri",
  	"foreignObject",
  	"g",
  	"glyph",
  	"glyphRef",
  	"hkern",
  	"image",
  	"line",
  	"linearGradient",
  	"marker",
  	"mask",
  	"metadata",
  	"missing-glyph",
  	"mpath",
  	"path",
  	"pattern",
  	"polygon",
  	"polyline",
  	"radialGradient",
  	"rect",
  	"script",
  	"set",
  	"stop",
  	"style",
  	"svg",
  	"switch",
  	"symbol",
  	"text",
  	"textPath",
  	"title",
  	"tref",
  	"tspan",
  	"use",
  	"view",
  	"vkern"
  ];

  var lib$5 = require$$0$2;

  const {
    htmlTypeSelectors: htmlTypeSelectors$1
  } = selectors;




  /**
   * Check whether a type selector is a custom element
   *
   * @param {string} selector
   * @returns {boolean}
   */


  var isCustomElement = function isCustomElement(selector) {
    if (!/^[a-z]/.test(selector)) {
      return false;
    }

    if (!selector.includes('-')) {
      return false;
    }

    const selectorLowerCase = selector.toLowerCase();

    if (selectorLowerCase !== selector) {
      return false;
    }

    if (lib$5.includes(selectorLowerCase)) {
      return false;
    }

    if (htmlTypeSelectors$1.has(selectorLowerCase)) {
      return false;
    }

    if (mathMLTags.includes(selectorLowerCase)) {
      return false;
    }

    return true;
  };

  const {
    isRegExp: isRegExp$f,
    isString: isString$k
  } = validateTypes;



  const ruleName$z = 'selector-max-type';
  const messages$z = ruleMessages$1(ruleName$z, {
    expected: (selector, max) => `Expected "${selector}" to have no more than ${max} type ${max === 1 ? 'selector' : 'selectors'}`
  });
  const meta$z = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-type'
  };
  /** @type {import('stylelint').Rule} */

  const rule$y = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$z, {
        actual: primary,
        possible: isNonNegativeInteger
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['descendant', 'child', 'compounded', 'next-sibling', 'custom-elements'],
          ignoreTypes: [isString$k, isRegExp$f]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const ignoreDescendant = optionsMatches(secondaryOptions, 'ignore', 'descendant');
      const ignoreChild = optionsMatches(secondaryOptions, 'ignore', 'child');
      const ignoreCompounded = optionsMatches(secondaryOptions, 'ignore', 'compounded');
      const ignoreNextSibling = optionsMatches(secondaryOptions, 'ignore', 'next-sibling');
      const ignoreCustomElements = optionsMatches(secondaryOptions, 'ignore', 'custom-elements');
      /**
       * @param {import('postcss-selector-parser').Container<string | undefined>} selectorNode
       * @param {import('postcss').Rule} ruleNode
       */

      function checkSelector(selectorNode, ruleNode) {
        const count = selectorNode.reduce((total, childNode) => {
          // Only traverse inside actual selectors and context functional pseudo-classes
          if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
            checkSelector(childNode, ruleNode);
          }

          if (optionsMatches(secondaryOptions, 'ignoreTypes', childNode.value)) {
            return total;
          }

          if (ignoreDescendant && hasDescendantCombinatorBefore(childNode)) {
            return total;
          }

          if (ignoreChild && hasChildCombinatorBefore(childNode)) {
            return total;
          }

          if (ignoreCompounded && hasCompoundSelector(childNode)) {
            return total;
          }

          if (ignoreNextSibling && hasNextSiblingCombinator(childNode)) {
            return total;
          }

          if (ignoreCustomElements && childNode.value && isCustomElement(childNode.value)) {
            return total;
          }

          if (childNode.type === 'tag' && !isStandardSyntaxTypeSelector(childNode)) {
            return total;
          }

          return childNode.type === 'tag' ? total + 1 : total;
        }, 0);

        if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
          const selector = selectorNode.toString();
          report$1({
            ruleName: ruleName$z,
            result,
            node: ruleNode,
            message: messages$z.expected,
            messageArgs: [selector, primary],
            word: selector
          });
        }
      }

      root.walkRules(ruleNode => {
        const selectors = ruleNode.selectors;

        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        if (selectors.some(s => isKeyframeSelector(s))) {
          return;
        }

        for (const selector of ruleNode.selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            if (!isStandardSyntaxSelector(resolvedSelector)) {
              continue;
            }

            parseSelector(resolvedSelector, result, ruleNode, container => checkSelector(container, ruleNode));
          }
        }
      });
    };
  };
  /** @typedef {import('postcss-selector-parser').Node} SelectorNode */

  /**
   * @param {SelectorNode} node
   * @returns {boolean}
   */


  function hasDescendantCombinatorBefore(node) {
    if (!node.parent) return false;
    const nodeIndex = node.parent.nodes.indexOf(node);
    return node.parent.nodes.slice(0, nodeIndex).some(n => isDescendantCombinator(n));
  }
  /**
   * @param {SelectorNode} node
   * @returns {boolean}
   */


  function hasChildCombinatorBefore(node) {
    if (!node.parent) return false;
    const nodeIndex = node.parent.nodes.indexOf(node);
    return node.parent.nodes.slice(0, nodeIndex).some(n => isChildCombinator(n));
  }
  /**
   * @param {SelectorNode} node
   * @returns {boolean}
   */


  function hasCompoundSelector(node) {
    if (node.prev() && !isCombinator(node.prev())) {
      return true;
    }

    return node.next() && !isCombinator(node.next());
  }
  /**
   * @param {SelectorNode} node
   * @returns {boolean}
   */


  function hasNextSiblingCombinator(node) {
    return node.prev() && isNextSiblingCombinator(node.prev());
  }
  /**
   * @param {SelectorNode} node
   * @returns {boolean}
   */


  function isCombinator(node) {
    if (!node) return false;
    return node.type === 'combinator';
  }
  /**
   * @param {SelectorNode} node
   * @returns {boolean}
   */


  function isDescendantCombinator(node) {
    if (!node) return false;
    return isCombinator(node) && isString$k(node.value) && isOnlyWhitespace(node.value);
  }
  /**
   * @param {SelectorNode} node
   * @returns {boolean}
   */


  function isChildCombinator(node) {
    if (!node) return false;
    return isCombinator(node) && node.value === '>';
  }
  /**
   * @param {SelectorNode} node
   * @returns {boolean}
   */


  function isNextSiblingCombinator(node) {
    return isCombinator(node) && node.value === '+';
  }

  rule$y.ruleName = ruleName$z;
  rule$y.messages = messages$z;
  rule$y.meta = meta$z;
  var selectorMaxType = rule$y;

  const {
    isString: isString$j
  } = validateTypes;

  const ruleName$y = 'selector-max-universal';
  const messages$y = ruleMessages$1(ruleName$y, {
    expected: (selector, max) => `Expected "${selector}" to have no more than ${max} universal ${max === 1 ? 'selector' : 'selectors'}`
  });
  const meta$y = {
    url: 'https://stylelint.io/user-guide/rules/selector-max-universal'
  };
  /** @type {import('stylelint').Rule} */

  const rule$x = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$y, {
        actual: primary,
        possible: isNonNegativeInteger
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreAfterCombinators: [isString$j]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {import('postcss-selector-parser').Container<string | undefined>} selectorNode
       * @param {import('postcss').Rule} ruleNode
       */


      function checkSelector(selectorNode, ruleNode) {
        const count = selectorNode.reduce((total, childNode) => {
          // Only traverse inside actual selectors
          // All logical combinations will be resolved as nested selector in `postcss-resolve-nested-selector`
          if (childNode.type === 'selector') {
            checkSelector(childNode, ruleNode);
          }

          const prevChildNode = childNode.prev();
          const prevChildNodeValue = prevChildNode && prevChildNode.value;

          if (childNode.type === 'universal') {
            if (!optionsMatches(secondaryOptions, 'ignoreAfterCombinators', prevChildNodeValue)) {
              total += 1;
            }
          }

          return total;
        }, 0);

        if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
          const selector = selectorNode.toString();
          report$1({
            ruleName: ruleName$y,
            result,
            node: ruleNode,
            message: messages$y.expected,
            messageArgs: [selector, primary],
            word: selector
          });
        }
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }
        /** @type {string[]} */


        const selectors = [];
        dist$4().astSync(ruleNode.selector).walk(node => {
          if (node.type === 'selector') {
            selectors.push(String(node).trim());
          }
        });

        for (const selector of selectors) {
          for (const resolvedSelector of postcssResolveNestedSelector(selector, ruleNode)) {
            parseSelector(resolvedSelector, result, ruleNode, container => checkSelector(container, ruleNode));
          }
        }
      });
    };
  };

  rule$x.ruleName = ruleName$y;
  rule$x.messages = messages$y;
  rule$x.meta = meta$y;
  var selectorMaxUniversal = rule$x;

  const {
    isBoolean: isBoolean$4,
    isRegExp: isRegExp$e,
    isString: isString$i
  } = validateTypes;

  const ruleName$x = 'selector-nested-pattern';
  const messages$x = ruleMessages$1(ruleName$x, {
    expected: (selector, pattern) => `Expected "${selector}" to match pattern "${pattern}"`
  });
  const meta$x = {
    url: 'https://stylelint.io/user-guide/rules/selector-nested-pattern'
  };
  /** @type {import('stylelint').Rule} */

  const rule$w = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$x, {
        actual: primary,
        possible: [isRegExp$e, isString$i]
      }, {
        actual: secondaryOptions,
        possible: {
          splitList: [isBoolean$4]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const normalizedPattern = isString$i(primary) ? new RegExp(primary) : primary;
      const splitList = secondaryOptions && secondaryOptions.splitList;
      root.walkRules(ruleNode => {
        if (ruleNode.parent && ruleNode.parent.type !== 'rule') {
          return;
        }

        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selectors = splitList ? ruleNode.selectors : [ruleNode.selector];

        for (const selector of selectors) {
          if (normalizedPattern.test(selector)) {
            continue;
          }

          report$1({
            result,
            ruleName: ruleName$x,
            message: messages$x.expected,
            messageArgs: [selector, primary],
            node: ruleNode,
            word: selector
          });
        }
      });
    };
  };

  rule$w.ruleName = ruleName$x;
  rule$w.messages = messages$x;
  rule$w.meta = meta$x;
  var selectorNestedPattern = rule$w;

  const ruleName$w = 'selector-no-qualifying-type';
  const messages$w = ruleMessages$1(ruleName$w, {
    rejected: selector => `Unexpected qualifying type selector "${selector}"`
  });
  const meta$w = {
    url: 'https://stylelint.io/user-guide/rules/selector-no-qualifying-type'
  };
  const selectorCharacters = ['#', '.', '['];
  /**
   * @param {string} value
   * @returns {boolean}
   */

  function isSelectorCharacters(value) {
    return selectorCharacters.some(char => value.includes(char));
  }
  /**
   * @param {import('postcss-selector-parser').Tag} node
   * @returns {Array<import('postcss-selector-parser').Node>}
   */


  function getRightNodes(node) {
    const result = [];
    /** @type {import('postcss-selector-parser').Node} */

    let rightNode = node;

    while (rightNode = rightNode.next()) {
      if (rightNode.type === 'combinator') {
        break;
      }

      if (rightNode.type !== 'id' && rightNode.type !== 'class' && rightNode.type !== 'attribute') {
        continue;
      }

      result.push(rightNode);
    }

    return result;
  }
  /** @type {import('stylelint').Rule} */


  const rule$v = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$w, {
        actual: primary,
        possible: [true]
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['attribute', 'class', 'id']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const ignoreId = optionsMatches(secondaryOptions, 'ignore', 'id');
      const ignoreClass = optionsMatches(secondaryOptions, 'ignore', 'class');
      const ignoreAttribute = optionsMatches(secondaryOptions, 'ignore', 'attribute');
      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        if (isKeyframeRule(ruleNode)) {
          return;
        }

        if (!isSelectorCharacters(ruleNode.selector)) {
          return;
        }
        /**
         * @param {import('postcss-selector-parser').Root} selectorAST
         */


        function checkSelector(selectorAST) {
          selectorAST.walkTags(tagNode => {
            if (!isStandardSyntaxTypeSelector(tagNode)) return;
            const selectorParent = tagNode.parent;

            if (selectorParent && selectorParent.nodes.length === 1) {
              return;
            }

            const selectorNodes = getRightNodes(tagNode);

            for (const selectorNode of selectorNodes) {
              if (selectorNode.type === 'id' && !ignoreId || selectorNode.type === 'class' && !ignoreClass || selectorNode.type === 'attribute' && !ignoreAttribute) {
                const selector = [tagNode, ...selectorNodes].join('').trimStart();
                complain(selector);
              }
            }
          });
        }

        for (const resolvedSelector of postcssResolveNestedSelector(ruleNode.selector, ruleNode)) {
          if (!isStandardSyntaxSelector(resolvedSelector)) {
            continue;
          }

          parseSelector(resolvedSelector, result, ruleNode, checkSelector);
        }
        /**
         * @param {string} selector
         */


        function complain(selector) {
          report$1({
            ruleName: ruleName$w,
            result,
            node: ruleNode,
            message: messages$w.rejected,
            messageArgs: [selector],
            word: selector
          });
        }
      });
    };
  };

  rule$v.ruleName = ruleName$w;
  rule$v.messages = messages$w;
  rule$v.meta = meta$w;
  var selectorNoQualifyingType = rule$v;

  const prefixes$1 = new Set(['-webkit-', '-moz-', '-ms-', '-o-']);
  var prefixes_1 = {
    prefixes: prefixes$1
  };

  const {
    prefixes
  } = prefixes_1;

  const HAS_PREFIX_REGEX = new RegExp(`(?:${[...prefixes].join('|')})`, 'i');
  /**
   * Check if a string contains any prefix
   *
   * @param {string} string
   * @returns {boolean}
   */

  var hasPrefix = function hasPrefix(string) {
    return HAS_PREFIX_REGEX.test(string);
  };

  const {
    isString: isString$h,
    isRegExp: isRegExp$d
  } = validateTypes;

  const ruleName$v = 'selector-no-vendor-prefix';
  const messages$v = ruleMessages$1(ruleName$v, {
    rejected: selector => `Unexpected vendor-prefix "${selector}"`
  });
  const meta$v = {
    url: 'https://stylelint.io/user-guide/rules/selector-no-vendor-prefix',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$u = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$v, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreSelectors: [isString$h, isRegExp$d]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!hasPrefix(ruleNode.selector)) return;

        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;
        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const {
              value
            } = pseudoNode;

            if (!isAutoprefixable.selector(value)) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignoreSelectors', value)) {
              return;
            }

            if (context.fix) {
              ruleNode.selector = isAutoprefixable.unprefix(selector);
              return;
            }

            report$1({
              result,
              ruleName: ruleName$v,
              message: messages$v.rejected,
              messageArgs: [value],
              node: ruleNode,
              word: value
            });
          });
        });
      });
    };
  };

  rule$u.ruleName = ruleName$v;
  rule$u.messages = messages$v;
  rule$u.meta = meta$v;
  var selectorNoVendorPrefix = rule$u;

  const {
    isPseudoClass,
    isAttribute,
    isClassName,
    isUniversal,
    isIdentifier,
    isTag
  } = dist$4;

  const {
    assert: assert$2
  } = validateTypes;

  const ruleName$u = 'selector-not-notation';
  const messages$u = ruleMessages$1(ruleName$u, {
    expected: type => `Expected ${type} :not() pseudo-class notation`
  });
  const meta$u = {
    url: 'https://stylelint.io/user-guide/rules/selector-not-notation',
    fixable: true
  };
  /** @typedef {import('postcss-selector-parser').Node} Node */

  /** @typedef {import('postcss-selector-parser').Selector} Selector */

  /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */

  /**
   * @param {Node} node
   * @returns {boolean}
   */

  const isSimpleSelector = node => isPseudoClass(node) || isAttribute(node) || isClassName(node) || isUniversal(node) || isIdentifier(node) || isTag(node);
  /**
   * @param {Node} node
   * @returns {node is Pseudo}
   */


  const isNot = node => isPseudoClass(node) && node.value !== undefined && node.value.toLowerCase() === ':not';
  /**
   * @param {Selector[]} list
   * @returns {boolean}
   */


  const isSimple = list => {
    if (list.length > 1) return false;
    assert$2(list[0], 'list is never empty');
    const [first, second] = list[0].nodes;
    if (!first) return true;
    if (second) return false;
    return isSimpleSelector(first) && !isNot(first);
  };
  /** @type {import('stylelint').Rule} */


  const rule$t = (primary, _, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$u, {
        actual: primary,
        possible: ['simple', 'complex']
      });
      if (!validOptions) return;
      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) return;
        const selector = ruleNode.selector;
        if (!selector.includes(':not(')) return;
        if (!isStandardSyntaxSelector(selector)) return;
        const fixedSelector = parseSelector(selector, result, ruleNode, container => {
          container.walkPseudos(pseudo => {
            if (!isNot(pseudo)) return;

            if (primary === 'complex') {
              const prev = pseudo.prev();
              const hasConsecutiveNot = prev && isNot(prev);
              if (!hasConsecutiveNot) return;
              if (context.fix) return fixComplex(prev);
            } else {
              const selectors = pseudo.nodes;
              if (isSimple(selectors)) return;
              const mustFix = context.fix && selectors.length > 1 && selectors[1] && (selectors[1].nodes.length === 0 || selectors.every(({
                nodes
              }) => nodes.length === 1));
              if (mustFix) return fixSimple(pseudo);
            }

            assert$2(pseudo.source && pseudo.source.end);
            report$1({
              message: messages$u.expected,
              messageArgs: [primary],
              node: ruleNode,
              index: pseudo.sourceIndex,
              endIndex: pseudo.source.end.column,
              result,
              ruleName: ruleName$u
            });
          });
        });

        if (context.fix && fixedSelector) {
          ruleNode.selector = fixedSelector;
        }
      });
    };
  };
  /**
   * @param {Pseudo} not
   * @returns {Node}
   */


  const getLastConsecutiveNot = ({
    parent,
    sourceIndex
  }) => {
    assert$2(parent);
    const nodes = parent.nodes;
    const index = nodes.findIndex(node => node.sourceIndex >= sourceIndex && !isNot(node));
    const node = index === -1 ? nodes[nodes.length - 1] : nodes[index - 1];
    assert$2(node);
    return node;
  };
  /**
   * @param {Pseudo} not
   */


  function fixSimple(not) {
    const simpleSelectors = not.nodes.filter(({
      nodes
    }) => nodes[0] && isSimpleSelector(nodes[0])).map(s => {
      assert$2(s.nodes[0]);
      s.nodes[0].rawSpaceBefore = '';
      s.nodes[0].rawSpaceAfter = '';
      return s;
    });
    const firstSelector = simpleSelectors.shift();
    assert$2(firstSelector);
    assert$2(not.parent);
    not.empty();
    not.nodes.push(firstSelector);

    for (const s of simpleSelectors) {
      const last = getLastConsecutiveNot(not);
      not.parent.insertAfter(last, last.clone({
        nodes: [s]
      }));
    }
  }
  /**
   * @param {Pseudo} previousNot
   */


  function fixComplex(previousNot) {
    const indentAndTrimRight =
    /** @type {Selector[]} */
    selectors => {
      for (const s of selectors) {
        assert$2(s.nodes[0]);
        s.nodes[0].rawSpaceBefore = ' ';
        s.nodes[0].rawSpaceAfter = '';
      }
    };

    const [head, ...tail] = previousNot.nodes;
    let node = previousNot.next();
    if (head == null || head.nodes.length === 0) return;
    assert$2(head.nodes[0]);
    head.nodes[0].rawSpaceBefore = '';
    head.nodes[0].rawSpaceAfter = '';
    indentAndTrimRight(tail);

    while (isNot(node)) {
      const selectors = node.nodes;
      const prev = node;
      indentAndTrimRight(selectors);
      previousNot.nodes = previousNot.nodes.concat(selectors);
      node = node.next();
      prev.remove();
    }
  }

  rule$t.ruleName = ruleName$u;
  rule$t.messages = messages$u;
  rule$t.meta = meta$u;
  var selectorNotNotation = rule$t;

  const {
    isRegExp: isRegExp$c,
    isString: isString$g
  } = validateTypes;

  const ruleName$t = 'selector-pseudo-class-allowed-list';
  const messages$t = ruleMessages$1(ruleName$t, {
    rejected: selector => `Unexpected pseudo-class "${selector}"`
  });
  const meta$t = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-class-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$s = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$t, {
        actual: primary,
        possible: [isString$g, isRegExp$c]
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;

        if (!selector.includes(':')) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const value = pseudoNode.value; // Ignore pseudo-elements

            if (value.slice(0, 2) === '::') {
              return;
            }

            const name = value.slice(1);

            if (matchesStringOrRegExp(vendor.unprefixed(name), primary)) {
              return;
            }

            report$1({
              word: value,
              message: messages$t.rejected,
              messageArgs: [value],
              node: ruleNode,
              result,
              ruleName: ruleName$t
            });
          });
        });
      });
    };
  };

  rule$s.primaryOptionArray = true;
  rule$s.ruleName = ruleName$t;
  rule$s.messages = messages$t;
  rule$s.meta = meta$t;
  var selectorPseudoClassAllowedList = rule$s;

  const {
    levelOneAndTwoPseudoElements: levelOneAndTwoPseudoElements$3
  } = selectors;









  const ruleName$s = 'selector-pseudo-class-case';
  const messages$s = ruleMessages$1(ruleName$s, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$s = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-class-case',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$r = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$s, {
        actual: primary,
        possible: ['lower', 'upper']
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;

        if (!selector.includes(':')) {
          return;
        }

        const fixedSelector = parseSelector(ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector, result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const pseudo = pseudoNode.value;

            if (!isStandardSyntaxSelector(pseudo)) {
              return;
            }

            if (pseudo.includes('::') || levelOneAndTwoPseudoElements$3.has(pseudo.toLowerCase().slice(1))) {
              return;
            }

            const expectedPseudo = primary === 'lower' ? pseudo.toLowerCase() : pseudo.toUpperCase();

            if (pseudo === expectedPseudo) {
              return;
            }

            if (context.fix) {
              pseudoNode.value = expectedPseudo;
              return;
            }

            report$1({
              message: messages$s.expected(pseudo, expectedPseudo),
              node: ruleNode,
              index: pseudoNode.sourceIndex,
              ruleName: ruleName$s,
              result
            });
          });
        });

        if (context.fix && fixedSelector) {
          if (ruleNode.raws.selector) {
            ruleNode.raws.selector.raw = fixedSelector;
          } else {
            ruleNode.selector = fixedSelector;
          }
        }
      });
    };
  };

  rule$r.ruleName = ruleName$s;
  rule$r.messages = messages$s;
  rule$r.meta = meta$s;
  var selectorPseudoClassCase = rule$r;

  const {
    isRegExp: isRegExp$b,
    isString: isString$f
  } = validateTypes;

  const ruleName$r = 'selector-pseudo-class-disallowed-list';
  const messages$r = ruleMessages$1(ruleName$r, {
    rejected: selector => `Unexpected pseudo-class "${selector}"`
  });
  const meta$r = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-class-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$q = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$r, {
        actual: primary,
        possible: [isString$f, isRegExp$b]
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;

        if (!selector.includes(':')) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const value = pseudoNode.value; // Ignore pseudo-elements

            if (value.slice(0, 2) === '::') {
              return;
            }

            const name = value.slice(1);

            if (!matchesStringOrRegExp(vendor.unprefixed(name), primary)) {
              return;
            }

            report$1({
              word: value,
              message: messages$r.rejected,
              messageArgs: [value],
              node: ruleNode,
              result,
              ruleName: ruleName$r
            });
          });
        });
      });
    };
  };

  rule$q.primaryOptionArray = true;
  rule$q.ruleName = ruleName$r;
  rule$q.messages = messages$r;
  rule$q.meta = meta$r;
  var selectorPseudoClassDisallowedList = rule$q;

  /**
   * Check whether a selector is a custom one
   *
   * @param {string} selector
   * @returns {boolean}
   */

  var isCustomSelector = function isCustomSelector(selector) {
    return selector.startsWith(':--');
  };

  const {
    atRulePagePseudoClasses,
    levelOneAndTwoPseudoElements: levelOneAndTwoPseudoElements$2,
    pseudoClasses,
    pseudoElements: pseudoElements$1,
    webkitScrollbarPseudoClasses,
    webkitScrollbarPseudoElements
  } = selectors;













  const {
    isString: isString$e,
    isRegExp: isRegExp$a
  } = validateTypes;

  const {
    isAtRule: isAtRule$3
  } = typeGuards;

  const ruleName$q = 'selector-pseudo-class-no-unknown';
  const messages$q = ruleMessages$1(ruleName$q, {
    rejected: selector => `Unexpected unknown pseudo-class selector "${selector}"`
  });
  const meta$q = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-class-no-unknown'
  };
  /** @type {import('stylelint').Rule} */

  const rule$p = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$q, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignorePseudoClasses: [isString$e, isRegExp$a]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {string} selector
       * @param {import('postcss').ChildNode} node
       */


      function check(selector, node) {
        parseSelector(selector, result, node, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const value = pseudoNode.value;

            if (!isStandardSyntaxSelector(value)) {
              return;
            }

            if (isCustomSelector(value)) {
              return;
            }

            if (value.startsWith('::')) {
              return;
            }

            const name = value.replace(/^:*/, '').toLowerCase();

            if (levelOneAndTwoPseudoElements$2.has(name)) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignorePseudoClasses', pseudoNode.value.slice(1))) {
              return;
            }

            const hasVendorPrefix = vendor.prefix(name);
            let index = null;

            if (isAtRule$3(node) && node.name === 'page') {
              if (atRulePagePseudoClasses.has(name)) {
                return;
              }

              index = atRuleParamIndex(node) + pseudoNode.sourceIndex;
            } else if (pseudoElements$1.has(name) && !hasVendorPrefix) {
              index = pseudoNode.sourceIndex;
            } else {
              if (hasVendorPrefix || pseudoClasses.has(name)) {
                return;
              }
              /** @type {import('postcss-selector-parser').Base} */


              let prevPseudoElement = pseudoNode;

              do {
                prevPseudoElement =
                /** @type {import('postcss-selector-parser').Base} */
                prevPseudoElement.prev();

                if (prevPseudoElement && prevPseudoElement.value.slice(0, 2) === '::') {
                  break;
                }
              } while (prevPseudoElement);

              if (prevPseudoElement) {
                const prevPseudoElementValue = prevPseudoElement.value.toLowerCase().slice(2);

                if (webkitScrollbarPseudoElements.has(prevPseudoElementValue) && webkitScrollbarPseudoClasses.has(name)) {
                  return;
                }
              }

              index = pseudoNode.sourceIndex;
            }

            report$1({
              message: messages$q.rejected,
              messageArgs: [value],
              node,
              index,
              ruleName: ruleName$q,
              result,
              word: value
            });
          });
        });
      }

      root.walk(node => {
        let selector = null;

        if (node.type === 'rule') {
          if (!isStandardSyntaxRule(node)) {
            return;
          }

          selector = node.selector;
        } else if (isAtRule$3(node) && node.name === 'page' && node.params) {
          if (!isStandardSyntaxAtRule(node)) {
            return;
          }

          selector = node.params;
        } // Return if selector empty, it is meaning node type is not a rule or a at-rule


        if (!selector) {
          return;
        } // Return early before parse if no pseudos for performance


        if (!selector.includes(':')) {
          return;
        }

        check(selector, node);
      });
    };
  };

  rule$p.ruleName = ruleName$q;
  rule$p.messages = messages$q;
  rule$p.meta = meta$q;
  var selectorPseudoClassNoUnknown = rule$p;

  const ruleName$p = 'selector-pseudo-class-parentheses-space-inside';
  const messages$p = ruleMessages$1(ruleName$p, {
    expectedOpening: 'Expected single space after "("',
    rejectedOpening: 'Unexpected whitespace after "("',
    expectedClosing: 'Expected single space before ")"',
    rejectedClosing: 'Unexpected whitespace before ")"'
  });
  const meta$p = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-class-parentheses-space-inside',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$o = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$p, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        if (!ruleNode.selector.includes('(')) {
          return;
        }

        let hasFixed = false;
        const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;
        const fixedSelector = parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            if (!pseudoNode.length) {
              return;
            }

            const paramString = pseudoNode.map(node => String(node)).join(',');
            const nextCharIsSpace = paramString.startsWith(' ');
            const openIndex = pseudoNode.sourceIndex + pseudoNode.value.length + 1;

            if (nextCharIsSpace && primary === 'never') {
              if (context.fix) {
                hasFixed = true;
                setFirstNodeSpaceBefore(pseudoNode, '');
              } else {
                complain(messages$p.rejectedOpening, openIndex);
              }
            }

            if (!nextCharIsSpace && primary === 'always') {
              if (context.fix) {
                hasFixed = true;
                setFirstNodeSpaceBefore(pseudoNode, ' ');
              } else {
                complain(messages$p.expectedOpening, openIndex);
              }
            }

            const prevCharIsSpace = paramString.endsWith(' ');
            const closeIndex = openIndex + paramString.length - 1;

            if (prevCharIsSpace && primary === 'never') {
              if (context.fix) {
                hasFixed = true;
                setLastNodeSpaceAfter(pseudoNode, '');
              } else {
                complain(messages$p.rejectedClosing, closeIndex);
              }
            }

            if (!prevCharIsSpace && primary === 'always') {
              if (context.fix) {
                hasFixed = true;
                setLastNodeSpaceAfter(pseudoNode, ' ');
              } else {
                complain(messages$p.expectedClosing, closeIndex);
              }
            }
          });
        });

        if (hasFixed && fixedSelector) {
          if (!ruleNode.raws.selector) {
            ruleNode.selector = fixedSelector;
          } else {
            ruleNode.raws.selector.raw = fixedSelector;
          }
        }
        /**
         * @param {string} message
         * @param {number} index
         */


        function complain(message, index) {
          report$1({
            message,
            index,
            result,
            ruleName: ruleName$p,
            node: ruleNode
          });
        }
      });
    };
  };
  /**
   * @param {import('postcss-selector-parser').Container} node
   * @param {string} value
   * @returns {void}
   */


  function setFirstNodeSpaceBefore(node, value) {
    const target = node.first;

    if (target.type === 'selector') {
      setFirstNodeSpaceBefore(target, value);
    } else {
      target.spaces.before = value;
    }
  }
  /**
   * @param {import('postcss-selector-parser').Container} node
   * @param {string} value
   * @returns {void}
   */


  function setLastNodeSpaceAfter(node, value) {
    const target = node.last;

    if (target.type === 'selector') {
      setLastNodeSpaceAfter(target, value);
    } else {
      target.spaces.after = value;
    }
  }

  rule$o.ruleName = ruleName$p;
  rule$o.messages = messages$p;
  rule$o.meta = meta$p;
  var selectorPseudoClassParenthesesSpaceInside = rule$o;

  const {
    isRegExp: isRegExp$9,
    isString: isString$d
  } = validateTypes;

  const ruleName$o = 'selector-pseudo-element-allowed-list';
  const messages$o = ruleMessages$1(ruleName$o, {
    rejected: selector => `Unexpected pseudo-element "${selector}"`
  });
  const meta$o = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-element-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$n = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$o, {
        actual: primary,
        possible: [isString$d, isRegExp$9]
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;

        if (!selector.includes('::')) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const value = pseudoNode.value; // Ignore pseudo-classes

            if (value.charAt(1) !== ':') {
              return;
            }

            const name = value.slice(2);

            if (matchesStringOrRegExp(vendor.unprefixed(name), primary)) {
              return;
            }

            report$1({
              index: pseudoNode.sourceIndex,
              message: messages$o.rejected,
              messageArgs: [value],
              node: ruleNode,
              word: value,
              result,
              ruleName: ruleName$o
            });
          });
        });
      });
    };
  };

  rule$n.primaryOptionArray = true;
  rule$n.ruleName = ruleName$o;
  rule$n.messages = messages$o;
  rule$n.meta = meta$o;
  var selectorPseudoElementAllowedList = rule$n;

  const {
    levelOneAndTwoPseudoElements: levelOneAndTwoPseudoElements$1
  } = selectors;









  const ruleName$n = 'selector-pseudo-element-case';
  const messages$n = ruleMessages$1(ruleName$n, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$n = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-element-case',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$m = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$n, {
        actual: primary,
        possible: ['lower', 'upper']
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;

        if (!selector.includes(':')) {
          return;
        }

        transformSelector(result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const pseudoElement = pseudoNode.value;

            if (!isStandardSyntaxSelector(pseudoElement)) {
              return;
            }

            if (!pseudoElement.includes('::') && !levelOneAndTwoPseudoElements$1.has(pseudoElement.toLowerCase().slice(1))) {
              return;
            }

            const expectedPseudoElement = primary === 'lower' ? pseudoElement.toLowerCase() : pseudoElement.toUpperCase();

            if (pseudoElement === expectedPseudoElement) {
              return;
            }

            if (context.fix) {
              pseudoNode.value = expectedPseudoElement;
              return;
            }

            report$1({
              message: messages$n.expected(pseudoElement, expectedPseudoElement),
              node: ruleNode,
              index: pseudoNode.sourceIndex,
              ruleName: ruleName$n,
              result
            });
          });
        });
      });
    };
  };

  rule$m.ruleName = ruleName$n;
  rule$m.messages = messages$n;
  rule$m.meta = meta$n;
  var selectorPseudoElementCase = rule$m;

  const {
    levelOneAndTwoPseudoElements
  } = selectors;









  const ruleName$m = 'selector-pseudo-element-colon-notation';
  const messages$m = ruleMessages$1(ruleName$m, {
    expected: q => `Expected ${q} colon pseudo-element notation`
  });
  const meta$m = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-element-colon-notation',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$l = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$m, {
        actual: primary,
        possible: ['single', 'double']
      });

      if (!validOptions) {
        return;
      }

      let fixedColon = '';

      if (primary === 'single') {
        fixedColon = ':';
      } else if (primary === 'double') {
        fixedColon = '::';
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector; // get out early if no pseudo elements or classes

        if (!selector.includes(':')) {
          return;
        }

        const fixedSelector = parseSelector(selector, result, ruleNode, selectors => {
          selectors.walkPseudos(pseudo => {
            const pseudoElement = pseudo.value.replace(/:/g, '');

            if (!levelOneAndTwoPseudoElements.has(pseudoElement.toLowerCase())) {
              return;
            }

            const isDouble = pseudo.value.startsWith('::');

            if (primary === 'single' && !isDouble) {
              return;
            }

            if (primary === 'double' && isDouble) {
              return;
            }

            if (context.fix) {
              pseudo.replaceWith(pseudo.clone({
                value: fixedColon + pseudoElement
              }));
              return;
            }

            report$1({
              message: messages$m.expected(primary),
              node: ruleNode,
              index: pseudo.sourceIndex,
              endIndex: pseudo.sourceIndex + (isDouble ? 2 : 1),
              result,
              ruleName: ruleName$m
            });
          });
        });

        if (context.fix && fixedSelector) {
          ruleNode.selector = fixedSelector;
        }
      });
    };
  };

  rule$l.ruleName = ruleName$m;
  rule$l.messages = messages$m;
  rule$l.meta = meta$m;
  var selectorPseudoElementColonNotation = rule$l;

  const {
    isRegExp: isRegExp$8,
    isString: isString$c
  } = validateTypes;

  const ruleName$l = 'selector-pseudo-element-disallowed-list';
  const messages$l = ruleMessages$1(ruleName$l, {
    rejected: selector => `Unexpected pseudo-element "${selector}"`
  });
  const meta$l = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-element-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */

  const rule$k = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$l, {
        actual: primary,
        possible: [isString$c, isRegExp$8]
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        const selector = ruleNode.selector;

        if (!selector.includes('::')) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const value = pseudoNode.value; // Ignore pseudo-classes

            if (value.charAt(1) !== ':') {
              return;
            }

            const name = value.slice(2);

            if (!matchesStringOrRegExp(vendor.unprefixed(name), primary)) {
              return;
            }

            report$1({
              index: pseudoNode.sourceIndex,
              message: messages$l.rejected,
              messageArgs: [value],
              node: ruleNode,
              word: value,
              result,
              ruleName: ruleName$l
            });
          });
        });
      });
    };
  };

  rule$k.primaryOptionArray = true;
  rule$k.ruleName = ruleName$l;
  rule$k.messages = messages$l;
  rule$k.meta = meta$l;
  var selectorPseudoElementDisallowedList = rule$k;

  const {
    pseudoElements
  } = selectors;













  const {
    isString: isString$b,
    isRegExp: isRegExp$7
  } = validateTypes;

  const ruleName$k = 'selector-pseudo-element-no-unknown';
  const messages$k = ruleMessages$1(ruleName$k, {
    rejected: selector => `Unexpected unknown pseudo-element selector "${selector}"`
  });
  const meta$k = {
    url: 'https://stylelint.io/user-guide/rules/selector-pseudo-element-no-unknown'
  };
  /** @type {import('stylelint').Rule} */

  const rule$j = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$k, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignorePseudoElements: [isString$b, isRegExp$7]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        const selector = ruleNode.selector; // Return early before parse if no pseudos for performance

        if (!selector.includes(':')) {
          return;
        }

        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkPseudos(pseudoNode => {
            const value = pseudoNode.value;

            if (!isStandardSyntaxSelector(value)) {
              return;
            } // Ignore pseudo-classes


            if (value.slice(0, 2) !== '::') {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignorePseudoElements', pseudoNode.value.slice(2))) {
              return;
            }

            const name = value.slice(2);

            if (vendor.prefix(name) || pseudoElements.has(name.toLowerCase())) {
              return;
            }

            report$1({
              message: messages$k.rejected,
              messageArgs: [value],
              node: ruleNode,
              index: pseudoNode.sourceIndex,
              ruleName: ruleName$k,
              result,
              word: value
            });
          });
        });
      });
    };
  };

  rule$j.ruleName = ruleName$k;
  rule$j.messages = messages$k;
  rule$j.meta = meta$k;
  var selectorPseudoElementNoUnknown = rule$j;

  const {
    isString: isString$a,
    isRegExp: isRegExp$6
  } = validateTypes;

  const {
    mixedCaseSvgTypeSelectors
  } = selectors;

  const ruleName$j = 'selector-type-case';
  const messages$j = ruleMessages$1(ruleName$j, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$j = {
    url: 'https://stylelint.io/user-guide/rules/selector-type-case',
    fixable: true
  };
  const STARTS_A_TAG_NAME_REGEX$1 = /(?:[^.#[:a-zA-Z-]|^)[a-zA-Z]/;
  const ANY_UPPER_CASE_REGEX = /[A-Z]/;
  const ANY_LOWER_CASE_REGEX = /[a-z]/;
  /** @type {import('stylelint').Rule} */

  const rule$i = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$j, {
        actual: primary,
        possible: ['lower', 'upper']
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreTypes: [isString$a, isRegExp$6]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        let hasComments = ruleNode.raws.selector && ruleNode.raws.selector.raw;
        const selector = hasComments ? hasComments : ruleNode.selector;
        if (!STARTS_A_TAG_NAME_REGEX$1.test(selector)) return;
        if (primary === 'lower' && !ANY_UPPER_CASE_REGEX.test(selector)) return;
        if (primary === 'upper' && !ANY_LOWER_CASE_REGEX.test(selector)) return;
        if (!isStandardSyntaxRule(ruleNode)) return;
        const {
          selectors
        } = ruleNode;

        if (selectors.some(s => isKeyframeSelector(s))) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorAST => {
          selectorAST.walkTags(tag => {
            if (!isStandardSyntaxTypeSelector(tag)) {
              return;
            }

            if (mixedCaseSvgTypeSelectors.has(tag.value)) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignoreTypes', tag.value)) {
              return;
            }

            const sourceIndex = tag.sourceIndex;
            const value = tag.value;
            const expectedValue = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();

            if (value === expectedValue) {
              return;
            }

            if (context.fix) {
              if (hasComments) {
                hasComments = hasComments.slice(0, sourceIndex) + expectedValue + hasComments.slice(sourceIndex + value.length);

                if (ruleNode.raws.selector == null) {
                  throw new Error('The `raw` property must be present');
                }

                ruleNode.raws.selector.raw = hasComments;
              } else {
                ruleNode.selector = ruleNode.selector.slice(0, sourceIndex) + expectedValue + ruleNode.selector.slice(sourceIndex + value.length);
              }

              return;
            }

            report$1({
              message: messages$j.expected,
              messageArgs: [value, expectedValue],
              node: ruleNode,
              index: sourceIndex,
              ruleName: ruleName$j,
              result
            });
          });
        });
      });
    };
  };

  rule$i.ruleName = ruleName$j;
  rule$i.messages = messages$j;
  rule$i.meta = meta$j;
  var selectorTypeCase = rule$i;

  const {
    htmlTypeSelectors
  } = selectors;















  const {
    isRegExp: isRegExp$5,
    isString: isString$9
  } = validateTypes;

  const ruleName$i = 'selector-type-no-unknown';
  const messages$i = ruleMessages$1(ruleName$i, {
    rejected: selector => `Unexpected unknown type selector "${selector}"`
  });
  const meta$i = {
    url: 'https://stylelint.io/user-guide/rules/selector-type-no-unknown'
  };
  const STARTS_A_TAG_NAME_REGEX = /(?:[^.#[:a-zA-Z-]|^)[a-zA-Z]/;
  /** @type {import('stylelint').Rule} */

  const rule$h = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$i, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['custom-elements', 'default-namespace'],
          ignoreNamespaces: [isString$9, isRegExp$5],
          ignoreTypes: [isString$9, isRegExp$5]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkRules(ruleNode => {
        const {
          selector
        } = ruleNode;
        if (!STARTS_A_TAG_NAME_REGEX.test(selector)) return;
        if (!isStandardSyntaxRule(ruleNode)) return;
        const {
          selectors
        } = ruleNode;

        if (selectors.some(s => isKeyframeSelector(s))) {
          return;
        }

        parseSelector(selector, result, ruleNode, selectorTree => {
          selectorTree.walkTags(tagNode => {
            if (!isStandardSyntaxTypeSelector(tagNode)) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignore', 'custom-elements') && isCustomElement(tagNode.value)) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignore', 'default-namespace') && !(typeof tagNode.namespace === 'string')) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignoreNamespaces', tagNode.namespace)) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignoreTypes', tagNode.value)) {
              return;
            }

            const tagName = tagNode.value;
            const tagNameLowerCase = tagName.toLowerCase();

            if (htmlTypeSelectors.has(tagNameLowerCase) || // SVG tags are case-sensitive
            lib$5.includes(tagName) || mathMLTags.includes(tagNameLowerCase)) {
              return;
            }

            report$1({
              message: messages$i.rejected,
              messageArgs: [tagName],
              node: ruleNode,
              index: tagNode.sourceIndex,
              ruleName: ruleName$i,
              result,
              word: tagName
            });
          });
        });
      });
    };
  };

  rule$h.ruleName = ruleName$i;
  rule$h.messages = messages$i;
  rule$h.meta = meta$i;
  var selectorTypeNoUnknown = rule$h;

  const ruleName$h = 'shorthand-property-no-redundant-values';
  const messages$h = ruleMessages$1(ruleName$h, {
    rejected: (unexpected, expected) => `Expected "${unexpected}" to be "${expected}"`
  });
  const meta$h = {
    url: 'https://stylelint.io/user-guide/rules/shorthand-property-no-redundant-values',
    fixable: true
  };
  const propertiesWithShorthandNotation = new Set(['margin', 'padding', 'border-color', 'border-radius', 'border-style', 'border-width', 'grid-gap', 'inset']);
  const ignoredCharacters$1 = ['+', '*', '/', '(', ')', '$', '@', '--', 'var('];
  /**
   * @param {string} value
   * @returns {boolean}
   */

  function hasIgnoredCharacters(value) {
    return ignoredCharacters$1.some(char => value.includes(char));
  }
  /**
   * @param {string} property
   * @returns {boolean}
   */


  function isShorthandProperty(property) {
    return propertiesWithShorthandNotation.has(property);
  }
  /**
   * @param {string} top
   * @param {string} right
   * @param {string} bottom
   * @param {string} left
   * @returns {string[]}
   */


  function canCondense(top, right, bottom, left) {
    const lowerTop = top.toLowerCase();
    const lowerRight = right.toLowerCase();
    const lowerBottom = bottom && bottom.toLowerCase();
    const lowerLeft = left && left.toLowerCase();

    if (canCondenseToOneValue(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
      return [top];
    }

    if (canCondenseToTwoValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
      return [top, right];
    }

    if (canCondenseToThreeValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
      return [top, right, bottom];
    }

    return [top, right, bottom, left];
  }
  /**
   * @param {string} top
   * @param {string} right
   * @param {string} bottom
   * @param {string} left
   * @returns {boolean}
   */


  function canCondenseToOneValue(top, right, bottom, left) {
    if (top !== right) {
      return false;
    }

    return top === bottom && (bottom === left || !left) || !bottom && !left;
  }
  /**
   * @param {string} top
   * @param {string} right
   * @param {string} bottom
   * @param {string} left
   * @returns {boolean}
   */


  function canCondenseToTwoValues(top, right, bottom, left) {
    return top === bottom && right === left || top === bottom && !left && top !== right;
  }
  /**
   * @param {string} _top
   * @param {string} right
   * @param {string} _bottom
   * @param {string} left
   * @returns {boolean}
   */


  function canCondenseToThreeValues(_top, right, _bottom, left) {
    return right === left;
  }
  /** @type {import('stylelint').Rule} */


  const rule$g = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$h, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
          return;
        }

        const prop = decl.prop;
        const value = decl.value;
        const normalizedProp = vendor.unprefixed(prop.toLowerCase());

        if (hasIgnoredCharacters(value) || !isShorthandProperty(normalizedProp)) {
          return;
        }
        /** @type {string[]} */


        const valuesToShorthand = [];
        lib$6(value).walk(valueNode => {
          if (valueNode.type !== 'word') {
            return;
          }

          valuesToShorthand.push(lib$6.stringify(valueNode));
        });

        if (valuesToShorthand.length <= 1 || valuesToShorthand.length > 4) {
          return;
        }

        const shortestForm = canCondense(valuesToShorthand[0] || '', valuesToShorthand[1] || '', valuesToShorthand[2] || '', valuesToShorthand[3] || '');
        const shortestFormString = shortestForm.filter(Boolean).join(' ');
        const valuesFormString = valuesToShorthand.join(' ');

        if (shortestFormString.toLowerCase() === valuesFormString.toLowerCase()) {
          return;
        }

        if (context.fix) {
          decl.value = decl.value.replace(value, shortestFormString);
        } else {
          report$1({
            message: messages$h.rejected,
            messageArgs: [value, shortestFormString],
            node: decl,
            result,
            ruleName: ruleName$h
          });
        }
      });
    };
  };

  rule$g.ruleName = ruleName$h;
  rule$g.messages = messages$h;
  rule$g.meta = meta$h;
  var shorthandPropertyNoRedundantValues = rule$g;

  const ruleName$g = 'string-no-newline';
  const reNewLine = /\r?\n/;
  const messages$g = ruleMessages$1(ruleName$g, {
    rejected: 'Unexpected newline in string'
  });
  const meta$g = {
    url: 'https://stylelint.io/user-guide/rules/string-no-newline'
  };
  /** @type {import('stylelint').Rule} */

  const rule$f = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$g, {
        actual: primary
      });

      if (!validOptions) {
        return;
      }

      root.walk(node => {
        switch (node.type) {
          case 'atrule':
            checkDeclOrAtRule(node, node.params, atRuleParamIndex);
            break;

          case 'decl':
            checkDeclOrAtRule(node, node.value, declarationValueIndex);
            break;

          case 'rule':
            checkRule(node);
            break;
        }
      });
      /**
       * @param {import('postcss').Rule} ruleNode
       * @returns {void}
       */

      function checkRule(ruleNode) {
        // Get out quickly if there are no new line
        if (!reNewLine.test(ruleNode.selector)) {
          return;
        }

        if (!isStandardSyntaxSelector(ruleNode.selector)) {
          return;
        }

        parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
          selectorTree.walkAttributes(attributeNode => {
            const {
              value,
              quoteMark
            } = attributeNode;

            if (!value || !reNewLine.test(value)) {
              return;
            }

            const openIndex = [// length of our attribute
            attributeNode.attribute, // length of our operator , ie '='
            attributeNode.operator || ''].reduce((index, str) => index + str.length, // index of the start of our attribute node in our source
            // plus 1 for the opening quotation mark
            attributeNode.sourceIndex + 1);
            const valueLength = value.length + (quoteMark || '').length * 2;
            report$1({
              message: messages$g.rejected,
              node: ruleNode,
              index: openIndex,
              endIndex: openIndex + valueLength,
              result,
              ruleName: ruleName$g
            });
          });
        });
      }
      /**
       * @template {import('postcss').AtRule | import('postcss').Declaration} T
       * @param {T} node
       * @param {string} value
       * @param {(node: T) => number} getIndex
       * @returns {void}
       */


      function checkDeclOrAtRule(node, value, getIndex) {
        // Get out quickly if there are no new line
        if (!reNewLine.test(value)) {
          return;
        }

        lib$6(value).walk(valueNode => {
          if (valueNode.type !== 'string') {
            return;
          }

          if (!reNewLine.test(valueNode.value)) {
            return;
          }

          const nodeIndex = getIndex(node);
          report$1({
            message: messages$g.rejected,
            node,
            index: nodeIndex + valueNode.sourceIndex,
            endIndex: nodeIndex + valueNode.sourceEndIndex,
            result,
            ruleName: ruleName$g
          });
        });
      }
    };
  };

  rule$f.ruleName = ruleName$g;
  rule$f.messages = messages$g;
  rule$f.meta = meta$g;
  var stringNoNewline = rule$f;

  const {
    isBoolean: isBoolean$3,
    assertString: assertString$2
  } = validateTypes;

  const {
    isAtRule: isAtRule$2
  } = typeGuards;

  const ruleName$f = 'string-quotes';
  const messages$f = ruleMessages$1(ruleName$f, {
    expected: q => `Expected ${q} quotes`
  });
  const meta$f = {
    url: 'https://stylelint.io/user-guide/rules/string-quotes',
    fixable: true,
    deprecated: true
  };
  const singleQuote = `'`;
  const doubleQuote = `"`;
  /** @type {import('stylelint').Rule} */

  const rule$e = (primary, secondaryOptions, context) => {
    const correctQuote = primary === 'single' ? singleQuote : doubleQuote;
    const erroneousQuote = primary === 'single' ? doubleQuote : singleQuote;
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$f, {
        actual: primary,
        possible: ['single', 'double']
      }, {
        actual: secondaryOptions,
        possible: {
          avoidEscape: [isBoolean$3]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const avoidEscape = secondaryOptions && secondaryOptions.avoidEscape !== undefined ? secondaryOptions.avoidEscape : true;
      root.walk(node => {
        switch (node.type) {
          case 'atrule':
            checkDeclOrAtRule(node, node.params, atRuleParamIndex);
            break;

          case 'decl':
            checkDeclOrAtRule(node, node.value, declarationValueIndex);
            break;

          case 'rule':
            checkRule(node);
            break;
        }
      });
      /**
       * @param {import('postcss').Rule} ruleNode
       * @returns {void}
       */

      function checkRule(ruleNode) {
        if (!isStandardSyntaxRule(ruleNode)) {
          return;
        }

        if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
          return;
        }
        /** @type {number[]} */


        const fixPositions = [];
        parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
          let selectorFixed = false;
          selectorTree.walkAttributes(attributeNode => {
            if (!attributeNode.quoted) {
              return;
            }

            if (attributeNode.quoteMark === correctQuote && avoidEscape) {
              assertString$2(attributeNode.value);
              const needsCorrectEscape = attributeNode.value.includes(correctQuote);
              const needsOtherEscape = attributeNode.value.includes(erroneousQuote);

              if (needsOtherEscape) {
                return;
              }

              if (needsCorrectEscape) {
                if (context.fix) {
                  selectorFixed = true;
                  attributeNode.quoteMark = erroneousQuote;
                } else {
                  report$1({
                    message: messages$f.expected(primary === 'single' ? 'double' : primary),
                    node: ruleNode,
                    index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                    result,
                    ruleName: ruleName$f
                  });
                }
              }
            }

            if (attributeNode.quoteMark === erroneousQuote) {
              if (avoidEscape) {
                assertString$2(attributeNode.value);
                const needsCorrectEscape = attributeNode.value.includes(correctQuote);
                const needsOtherEscape = attributeNode.value.includes(erroneousQuote);

                if (needsOtherEscape) {
                  if (context.fix) {
                    selectorFixed = true;
                    attributeNode.quoteMark = correctQuote;
                  } else {
                    report$1({
                      message: messages$f.expected(primary),
                      node: ruleNode,
                      index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                      result,
                      ruleName: ruleName$f
                    });
                  }

                  return;
                }

                if (needsCorrectEscape) {
                  return;
                }
              }

              if (context.fix) {
                selectorFixed = true;
                attributeNode.quoteMark = correctQuote;
              } else {
                report$1({
                  message: messages$f.expected(primary),
                  node: ruleNode,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                  result,
                  ruleName: ruleName$f
                });
              }
            }
          });

          if (selectorFixed) {
            ruleNode.selector = selectorTree.toString();
          }
        });

        for (const fixIndex of fixPositions) {
          ruleNode.selector = replaceQuote(ruleNode.selector, fixIndex, correctQuote);
        }
      }
      /**
       * @template {import('postcss').AtRule | import('postcss').Declaration} T
       * @param {T} node
       * @param {string} value
       * @param {(node: T) => number} getIndex
       * @returns {void}
       */


      function checkDeclOrAtRule(node, value, getIndex) {
        /** @type {number[]} */
        const fixPositions = []; // Get out quickly if there are no erroneous quotes

        if (!value.includes(erroneousQuote)) {
          return;
        }

        if (isAtRule$2(node) && node.name === 'charset') {
          // allow @charset rules to have double quotes, in spite of the configuration
          // TODO: @charset should always use double-quotes, see https://github.com/stylelint/stylelint/issues/2788
          return;
        }

        lib$6(value).walk(valueNode => {
          if (valueNode.type === 'string' && valueNode.quote === erroneousQuote) {
            const needsEscape = valueNode.value.includes(correctQuote);

            if (avoidEscape && needsEscape) {
              // don't consider this an error
              return;
            }

            const openIndex = valueNode.sourceIndex; // we currently don't fix escapes

            if (context.fix && !needsEscape) {
              const closeIndex = openIndex + valueNode.value.length + erroneousQuote.length;
              fixPositions.push(openIndex, closeIndex);
            } else {
              report$1({
                message: messages$f.expected(primary),
                node,
                index: getIndex(node) + openIndex,
                result,
                ruleName: ruleName$f
              });
            }
          }
        });

        for (const fixIndex of fixPositions) {
          if (isAtRule$2(node)) {
            node.params = replaceQuote(node.params, fixIndex, correctQuote);
          } else {
            node.value = replaceQuote(node.value, fixIndex, correctQuote);
          }
        }
      }
    };
  };
  /**
   * @param {string} string
   * @param {number} index
   * @param {string} replace
   * @returns {string}
   */


  function replaceQuote(string, index, replace) {
    return string.substring(0, index) + replace + string.substring(index + replace.length);
  }

  rule$e.ruleName = ruleName$f;
  rule$e.messages = messages$f;
  rule$e.meta = meta$f;
  var stringQuotes = rule$e;

  const {
    longhandTimeProperties,
    shorthandTimeProperties
  } = properties$4;













  const {
    isNumber: isNumber$4
  } = validateTypes;





  const ruleName$e = 'time-min-milliseconds';
  const messages$e = ruleMessages$1(ruleName$e, {
    expected: time => `Expected a minimum of ${time} milliseconds`
  });
  const meta$e = {
    url: 'https://stylelint.io/user-guide/rules/time-min-milliseconds'
  };
  const DELAY_PROPERTIES = new Set(['animation-delay', 'transition-delay']);
  /** @type {import('stylelint').Rule<number>} */

  const rule$d = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$e, {
        actual: primary,
        possible: isNumber$4
      }, {
        actual: secondaryOptions,
        possible: {
          ignore: ['delay']
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const minimum = primary;
      const ignoreDelay = optionsMatches(secondaryOptions, 'ignore', 'delay');
      root.walkDecls(decl => {
        const propertyName = vendor.unprefixed(decl.prop.toLowerCase());
        const propertyValue = decl.value;
        const parsedValue = lib$6(getDeclarationValue(decl));
        let timeValueCount = 0;
        parsedValue.walk(node => {
          const {
            value,
            sourceIndex
          } = node;
          const dimension = getDimension(node);

          if (longhandTimeProperties.has(propertyName) && !isIgnoredProperty(propertyName) && !isAcceptableTime(dimension)) {
            complain(decl, 0, propertyValue.length);
          }

          if (!shorthandTimeProperties.has(propertyName)) return;
          timeValueCount = calcTimeValueCount(dimension, value, timeValueCount);
          if (isAcceptableTime(dimension) || ignoreDelay && timeValueCount !== 1) return;
          complain(decl, sourceIndex, value.length);
        });
      });
      /**
       * @param {{unit: string | null, number: string | null}} dimension
       * @param {string} value
       * @param {number} valueTimeCount
       * @returns {number}
       */

      function calcTimeValueCount(dimension, value, valueTimeCount) {
        const {
          unit
        } = dimension;
        if (unit !== null) valueTimeCount++;
        if (value === ',') valueTimeCount = 0;
        return valueTimeCount;
      }
      /**
       * @param {string} propertyName
       * @returns {boolean}
       */


      function isIgnoredProperty(propertyName) {
        if (ignoreDelay && DELAY_PROPERTIES.has(propertyName)) {
          return true;
        }

        return false;
      }
      /**
       * @param {import('postcss-value-parser').Dimension | {unit: null, number: null}} dimension
       * @returns {boolean}
       */


      function isAcceptableTime(dimension) {
        const {
          unit,
          number
        } = dimension;
        if (unit === null || number === null) return true;
        const numTime = Number(number);

        if (numTime <= 0) {
          return true;
        }

        const timeUnit = unit.toLowerCase();

        if (timeUnit === 'ms' && numTime < minimum) {
          return false;
        }

        if (timeUnit === 's' && numTime * 1000 < minimum) {
          return false;
        }

        return true;
      }
      /**
       * @param {import('postcss').Declaration} decl
       * @param {number} offset
       * @param {number} length
       * @returns {void}
       */


      function complain(decl, offset, length) {
        const index = declarationValueIndex(decl) + offset;
        const endIndex = index + length;
        report$1({
          result,
          ruleName: ruleName$e,
          message: messages$e.expected,
          messageArgs: [minimum],
          index,
          endIndex,
          node: decl
        });
      }
    };
  };

  rule$d.ruleName = ruleName$e;
  rule$d.messages = messages$e;
  rule$d.meta = meta$e;
  var timeMinMilliseconds = rule$d;

  const ruleName$d = 'unicode-bom';
  const messages$d = ruleMessages$1(ruleName$d, {
    expected: 'Expected Unicode BOM',
    rejected: 'Unexpected Unicode BOM'
  });
  const meta$d = {
    url: 'https://stylelint.io/user-guide/rules/unicode-bom',
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$c = primary => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$d, {
        actual: primary,
        possible: ['always', 'never']
      });

      if (!validOptions || !root.source || // @ts-expect-error -- TS2339: Property 'inline' does not exist on type 'Source'.
      root.source.inline || // @ts-expect-error -- TS2339: Property 'lang' does not exist on type 'Source'.
      root.source.lang === 'object-literal' || // Ignore HTML documents
      // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Root'.
      root.document !== undefined) {
        return;
      }

      const {
        hasBOM
      } = root.source.input;

      if (primary === 'always' && !hasBOM) {
        report$1({
          result,
          ruleName: ruleName$d,
          message: messages$d.expected,
          node: root,
          line: 1
        });
      }

      if (primary === 'never' && hasBOM) {
        report$1({
          result,
          ruleName: ruleName$d,
          message: messages$d.rejected,
          node: root,
          line: 1
        });
      }
    };
  };

  rule$c.ruleName = ruleName$d;
  rule$c.messages = messages$d;
  rule$c.meta = meta$d;
  var unicodeBom = rule$c;

  const {
    isRegExp: isRegExp$4,
    isString: isString$8
  } = validateTypes;

  const ruleName$c = 'unit-allowed-list';
  const messages$c = ruleMessages$1(ruleName$c, {
    rejected: unit => `Unexpected unit "${unit}"`
  });
  const meta$c = {
    url: 'https://stylelint.io/user-guide/rules/unit-allowed-list'
  };
  /** @type {import('stylelint').Rule<string | string[]>} */

  const rule$b = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$c, {
        actual: primary,
        possible: [isString$8]
      }, {
        optional: true,
        actual: secondaryOptions,
        possible: {
          ignoreFunctions: [isString$8, isRegExp$4],
          ignoreProperties: [validateObjectWithArrayProps(isString$8, isRegExp$4)]
        }
      });

      if (!validOptions) {
        return;
      }

      const primaryValues = [primary].flat();
      /**
       * @template {import('postcss').AtRule | import('postcss').Declaration} T
       * @param {T} node
       * @param {string} value
       * @param {(node: T) => number} getIndex
       * @returns {void}
       */

      function check(node, value, getIndex) {
        // make sure multiplication operations (*) are divided - not handled
        // by postcss-value-parser
        value = value.replace(/\*/g, ',');
        lib$6(value).walk(valueNode => {
          if (valueNode.type === 'function') {
            const valueLowerCase = valueNode.value.toLowerCase(); // Ignore wrong units within `url` function

            if (valueLowerCase === 'url') {
              return false;
            }

            if (optionsMatches(secondaryOptions, 'ignoreFunctions', valueLowerCase)) {
              return false;
            }
          }

          const {
            number,
            unit
          } = getDimension(valueNode);

          if (!number || !unit || primaryValues.includes(unit.toLowerCase())) {
            return;
          }

          if ('prop' in node && secondaryOptions && optionsMatches(secondaryOptions.ignoreProperties, unit.toLowerCase(), node.prop)) {
            return;
          }

          const index = getIndex(node);
          report$1({
            index: index + valueNode.sourceIndex + number.length,
            endIndex: index + valueNode.sourceEndIndex,
            message: messages$c.rejected,
            messageArgs: [unit],
            node,
            result,
            ruleName: ruleName$c
          });
        });
      }

      root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex));
      root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
    };
  };

  rule$b.primaryOptionArray = true;
  rule$b.ruleName = ruleName$c;
  rule$b.messages = messages$c;
  rule$b.meta = meta$c;
  var unitAllowedList = rule$b;

  const ruleName$b = 'unit-case';
  const messages$b = ruleMessages$1(ruleName$b, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$b = {
    url: 'https://stylelint.io/user-guide/rules/unit-case',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$a = (primary, _secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$b, {
        actual: primary,
        possible: ['lower', 'upper']
      });

      if (!validOptions) {
        return;
      }
      /**
       * @template {import('postcss').AtRule | import('postcss').Declaration} T
       * @param {T} node
       * @param {string} checkedValue
       * @param {(node: T) => number} getIndex
       * @returns {void}
       */


      function check(node, checkedValue, getIndex) {
        /** @type {Array<{ index: number, endIndex: number, message: string }>} */
        const problems = [];
        /**
         * @param {import('postcss-value-parser').Node} valueNode
         * @returns {boolean}
         */

        function processValue(valueNode) {
          const {
            number,
            unit
          } = getDimension(valueNode);
          if (!number || !unit) return false;
          const expectedUnit = primary === 'lower' ? unit.toLowerCase() : unit.toUpperCase();

          if (unit === expectedUnit) {
            return false;
          }

          const index = getIndex(node);
          problems.push({
            index: index + valueNode.sourceIndex + number.length,
            endIndex: index + valueNode.sourceEndIndex,
            message: messages$b.expected(unit, expectedUnit)
          });
          return true;
        }

        const parsedValue = lib$6(checkedValue).walk(valueNode => {
          // Ignore wrong units within `url` function
          let needFix = false;
          const value = valueNode.value;

          if (valueNode.type === 'function' && value.toLowerCase() === 'url') {
            return false;
          }

          if (value.includes('*')) {
            value.split('*').some(val => {
              return processValue({ ...valueNode,
                sourceIndex: value.indexOf(val) + val.length + 1,
                value: val
              });
            });
          }

          needFix = processValue(valueNode);

          if (needFix && context.fix) {
            valueNode.value = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();
          }
        });

        if (problems.length) {
          if (context.fix) {
            if ('name' in node && node.name === 'media') {
              node.params = parsedValue.toString();
            } else if ('value' in node) {
              node.value = parsedValue.toString();
            }
          } else {
            for (const err of problems) {
              report$1({
                index: err.index,
                endIndex: err.endIndex,
                message: err.message,
                node,
                result,
                ruleName: ruleName$b
              });
            }
          }
        }
      }

      root.walkAtRules(atRule => {
        if (!/^media$/i.test(atRule.name) && !('variable' in atRule)) {
          return;
        }

        check(atRule, atRule.params, atRuleParamIndex);
      });
      root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
    };
  };

  rule$a.ruleName = ruleName$b;
  rule$a.messages = messages$b;
  rule$a.meta = meta$b;
  var unitCase = rule$a;

  const HAS_DIMENSION_LIKE_VALUES = /\d[%\w-]/;
  /**
   * Check if a value contains any dimension-like values.
   *
   * @param {string} value
   * @returns {boolean}
   */

  var hasDimension = function hasDimension(value) {
    return HAS_DIMENSION_LIKE_VALUES.test(value);
  };

  const {
    isAtRule: isAtRule$1
  } = typeGuards;

  const IS_UNICODE_RANGE = /^unicode-range$/i;
  const IS_AT_FONT_FACE = /^font-face$/i;
  /**
   * Check whether a declaration is the `unicode-range` descriptor of an `@font-face` rule.
   *
   * @param {import('postcss').Declaration} decl
   * @returns {boolean}
   */

  var isUnicodeRangeDescriptor = function isUnicodeRangeDescriptor(decl) {
    if (!IS_UNICODE_RANGE.test(decl.prop)) {
      return false;
    }

    const parent = decl.parent;

    if (!parent || !isAtRule$1(parent)) {
      return false;
    }

    return IS_AT_FONT_FACE.test(parent.name);
  };

  const {
    TokenType: TokenType$1,
    tokenize: tokenize$2,
    NumberType
  } = require$$0$5;

  const {
    isFunctionNode: isFunctionNode$1,
    isSimpleBlockNode: isSimpleBlockNode$1,
    isTokenNode: isTokenNode$1,
    parseListOfComponentValues: parseListOfComponentValues$1
  } = require$$1;

  const {
    parseFromTokens: parseFromTokens$1,
    isMediaFeature: isMediaFeature$1
  } = require$$2;





















  const {
    isRegExp: isRegExp$3,
    isString: isString$7
  } = validateTypes;



  const ruleName$a = 'unit-disallowed-list';
  const messages$a = ruleMessages$1(ruleName$a, {
    rejected: unit => `Unexpected unit "${unit}"`
  });
  const meta$a = {
    url: 'https://stylelint.io/user-guide/rules/unit-disallowed-list'
  };
  /** @type {import('stylelint').Rule<string | string[]>} */

  const rule$9 = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$a, {
        actual: primary,
        possible: [isString$7]
      }, {
        optional: true,
        actual: secondaryOptions,
        possible: {
          ignoreFunctions: [isString$7, isRegExp$3],
          ignoreProperties: [validateObjectWithArrayProps(isString$7, isRegExp$3)],
          ignoreMediaFeatureNames: [validateObjectWithArrayProps(isString$7, isRegExp$3)]
        }
      });

      if (!validOptions) {
        return;
      }

      const primaryValues = [primary].flat();
      /**
       * Ignore wrong units within `url` function
       * Ignore units within function that match `ignoreFunctions` option
       *
       * @param {import('@csstools/css-parser-algorithms').ComponentValue} componentValue
       * @returns {boolean}
       */

      function componentValueIsIgnored(componentValue) {
        if (!isFunctionNode$1(componentValue)) {
          return false;
        }

        const name = componentValue.getName().toLowerCase();
        return name === 'url' || optionsMatches(secondaryOptions, 'ignoreFunctions', name);
      }
      /**
       * @template {import('postcss').AtRule | import('postcss').Declaration} T
       * @param {T} node
       * @param {(node: T) => number} getIndex
       * @param {import('@csstools/css-parser-algorithms').ComponentValue} componentValue
       * @param {string} input
       * @param {Record<string, unknown> | undefined} options
       * @returns {void}
       */


      function check(node, getIndex, componentValue, input, options) {
        if (!isTokenNode$1(componentValue)) return;
        if (componentValue.value[0] !== TokenType$1.Dimension) return;
        const [,,, endIndex, {
          unit
        }] = componentValue.value;
        const lowerCaseUnit = unit.toLowerCase();

        if (!primaryValues.includes(lowerCaseUnit)) {
          return;
        } // The unit has an ignore option for the specific input


        if (options && optionsMatches(options, lowerCaseUnit, input)) return;
        const startIndex = getIndex(node) + (endIndex + 1) - unit.length;
        report$1({
          index: startIndex,
          endIndex: startIndex + unit.length,
          message: messages$a.rejected,
          messageArgs: [unit],
          node,
          result,
          ruleName: ruleName$a
        });
      }

      root.walkAtRules(/^media$/i, atRule => {
        const params = getAtRuleParams(atRule);
        if (!hasDimension(params)) return;
        parseFromTokens$1(tokenizeWithoutPercentages(params)).forEach(mediaQuery => {
          /** @type {{ mediaFeatureName: string | undefined }} */
          const initialState = {
            mediaFeatureName: undefined
          };
          mediaQuery.walk(({
            node,
            state
          }) => {
            if (!state) return;

            if (isMediaFeature$1(node)) {
              state.mediaFeatureName = node.getName().toLowerCase();
            }

            if (!state.mediaFeatureName) return;
            if (!isTokenNode$1(node)) return;
            check(atRule, atRuleParamIndex, node, state.mediaFeatureName, secondaryOptions?.ignoreMediaFeatureNames);
          }, initialState);
        });
      });
      root.walkDecls(decl => {
        if (isUnicodeRangeDescriptor(decl)) return;
        const value = getDeclarationValue(decl);
        if (!hasDimension(value)) return;
        parseListOfComponentValues$1(tokenizeWithoutPercentages(value)).forEach(componentValue => {
          if (isTokenNode$1(componentValue)) {
            check(decl, declarationValueIndex, componentValue, decl.prop, secondaryOptions?.ignoreProperties);
            return;
          }

          if (!isFunctionNode$1(componentValue) && !isSimpleBlockNode$1(componentValue)) return;
          const initialState = {
            ignored: componentValueIsIgnored(componentValue)
          };
          componentValue.walk(({
            node,
            state
          }) => {
            if (!state) return;
            if (state.ignored) return;

            if (isTokenNode$1(node)) {
              check(decl, declarationValueIndex, node, decl.prop, secondaryOptions?.ignoreProperties);
              return;
            }

            if (componentValueIsIgnored(node)) {
              state.ignored = true;
            }
          }, initialState);
        });
      });
    };
  };
  /**
   * In the CSS syntax percentages are a different token type than dimensions.
   * For CSS authors however this distinction doesn't make sense, so we convert
   * percentage tokens to dimension tokens with a unit of "%".
   *
   * Percentage tokens also aren't valid in media queries.
   * Converting percentage tokens to dimension tokens simplifies any code checking for units.
   *
   * @param {string} css
   * @returns {Array<import('@csstools/css-tokenizer').CSSToken>}
   */


  function tokenizeWithoutPercentages(css) {
    return tokenize$2({
      css
    }).map(x => {
      if (x[0] !== TokenType$1.Percentage) return x;
      return [TokenType$1.Dimension, x[1], x[2], x[3], {
        value: x[4].value,
        unit: '%',
        type: NumberType.Number
      }];
    });
  }

  rule$9.primaryOptionArray = true;
  rule$9.ruleName = ruleName$a;
  rule$9.messages = messages$a;
  rule$9.meta = meta$a;
  var unitDisallowedList = rule$9;

  const {
    tokenize: tokenize$1,
    TokenType
  } = require$$0$5;

  const {
    isFunctionNode,
    isSimpleBlockNode,
    isTokenNode,
    parseListOfComponentValues
  } = require$$1;

  const {
    isMediaFeature,
    parseFromTokens
  } = require$$2;





























  const {
    isRegExp: isRegExp$2,
    isString: isString$6
  } = validateTypes;

  const units = new Set(units_1.units); // a copy that is safe to mutate
  // `x` as a resolution unit is very often a typo for `px`.
  // By removing it from the set of known units, we can catch those typos.
  // Intentional `x` units are supported by manually checking these in specific functions or properties.

  units.delete('x');
  const ruleName$9 = 'unit-no-unknown';
  const messages$9 = ruleMessages$1(ruleName$9, {
    rejected: unit => `Unexpected unknown unit "${unit}"`
  });
  const meta$9 = {
    url: 'https://stylelint.io/user-guide/rules/unit-no-unknown'
  };
  const RESOLUTION_MEDIA_FEATURE_NAME = /^(?:min-|max-)?resolution$/i;
  /** @type {import('stylelint').Rule} */

  const rule$8 = (primary, secondaryOptions) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$9, {
        actual: primary
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreUnits: [isString$6, isRegExp$2],
          ignoreFunctions: [isString$6, isRegExp$2]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }
      /**
       * @param {string} value
       */


      const tokenizeIfValueMightContainUnknownUnits = value => {
        if (!hasDimension(value)) return;
        const tokens = tokenize$1({
          css: value
        });
        const hasUnknownUnits = tokens.some(token => {
          return token[0] === TokenType.Dimension && !units.has(token[4].unit.toLowerCase());
        });
        if (!hasUnknownUnits) return;
        return tokens;
      };
      /**
       * @template {import('postcss').AtRule | import('postcss').Declaration} T
       * @param {T} node
       * @param {(node: T) => number} getIndex
       * @param {import('@csstools/css-parser-algorithms').FunctionNode | import('@csstools/css-parser-algorithms').TokenNode} componentValue
       * @param {{ ignored: boolean, allowX: boolean }} state
       */


      const check = (node, getIndex, componentValue, state) => {
        if (isFunctionNode(componentValue)) {
          const name = componentValue.getName();
          const nameLowerCase = name.toLowerCase();

          if (nameLowerCase === 'url' || optionsMatches(secondaryOptions, 'ignoreFunctions', name)) {
            state.ignored = true;
            return;
          }

          if (vendor.unprefixed(nameLowerCase) === 'image-set') {
            state.allowX = true;
            return;
          }

          return;
        }

        const [tokenType,,, endIndex, tokenValue] = componentValue.value;
        if (tokenType !== TokenType.Dimension) return;
        if (optionsMatches(secondaryOptions, 'ignoreUnits', tokenValue.unit)) return;
        const unit = tokenValue.unit.toLowerCase();
        if (unit === 'x' && state.allowX) return;
        if (units.has(unit) && unit !== 'x') return;
        const startIndex = getIndex(node) + (endIndex + 1) - unit.length;
        report$1({
          message: messages$9.rejected,
          messageArgs: [tokenValue.unit],
          node,
          index: startIndex,
          endIndex: startIndex + unit.length,
          result,
          ruleName: ruleName$9
        });
      };

      root.walkAtRules(/^media$/i, atRule => {
        if (!isStandardSyntaxAtRule(atRule)) return;
        const params = getAtRuleParams(atRule);
        const tokens = tokenizeIfValueMightContainUnknownUnits(params);
        if (!tokens) return;
        parseFromTokens(tokens).forEach(mediaQuery => {
          const initialState = {
            ignored: false,
            allowX: false
          };
          mediaQuery.walk(({
            node,
            state
          }) => {
            if (!state) return;
            if (state.ignored) return;

            if (isMediaFeature(node)) {
              const name = node.getName();

              if (RESOLUTION_MEDIA_FEATURE_NAME.test(name)) {
                state.allowX = true;
              }
            } else if (isFunctionNode(node) || isTokenNode(node)) {
              check(atRule, atRuleParamIndex, node, state);
            }
          }, initialState);
        });
      });
      root.walkDecls(decl => {
        if (!isStandardSyntaxDeclaration(decl)) return;
        if (isUnicodeRangeDescriptor(decl)) return;
        const value = getDeclarationValue(decl);
        if (!isStandardSyntaxValue(value)) return;
        const tokens = tokenizeIfValueMightContainUnknownUnits(value);
        if (!tokens) return;
        const isImageResolutionProp = decl.prop.toLowerCase() === 'image-resolution';
        parseListOfComponentValues(tokens).forEach(componentValue => {
          const initialState = {
            ignored: false,
            allowX: isImageResolutionProp
          };

          if (isFunctionNode(componentValue) || isTokenNode(componentValue)) {
            check(decl, declarationValueIndex, componentValue, initialState);
          }

          if (!isFunctionNode(componentValue) && !isSimpleBlockNode(componentValue)) {
            return;
          }

          componentValue.walk(({
            node,
            state
          }) => {
            if (!state) return;
            if (state.ignored) return;

            if (isFunctionNode(node) || isTokenNode(node)) {
              check(decl, declarationValueIndex, node, state);
            }
          }, initialState);
        });
      });
    };
  };

  rule$8.ruleName = ruleName$9;
  rule$8.messages = messages$9;
  rule$8.meta = meta$9;
  var unitNoUnknown = rule$8;

  const {
    counterIncrementKeywords
  } = keywords$4;
  /**
   * Check value is a custom ident
   *
   * @param {string} value
   */


  var isCounterIncrementCustomIdentValue = function isCounterIncrementCustomIdentValue(value) {
    const valueLowerCase = value.toLowerCase();

    if (counterIncrementKeywords.has(valueLowerCase) || Number.isFinite(Number.parseInt(valueLowerCase, 10))) {
      return false;
    }

    return true;
  };

  const {
    counterResetKeywords
  } = keywords$4;
  /**
   * Check value is a custom ident
   *
   * @param {string} value
   */


  var isCounterResetCustomIdentValue = function isCounterResetCustomIdentValue(value) {
    const valueLowerCase = value.toLowerCase();

    if (counterResetKeywords.has(valueLowerCase) || Number.isFinite(Number.parseInt(valueLowerCase, 10))) {
      return false;
    }

    return true;
  };

  const {
    animationNameKeywords,
    animationShorthandKeywords,
    camelCaseKeywords,
    fontFamilyKeywords,
    fontShorthandKeywords,
    gridAreaKeywords,
    gridColumnKeywords,
    gridRowKeywords,
    listStyleShorthandKeywords,
    listStyleTypeKeywords,
    systemColorsKeywords
  } = keywords$4;











  const {
    isBoolean: isBoolean$2,
    isRegExp: isRegExp$1,
    isString: isString$5
  } = validateTypes;

  const ruleName$8 = 'value-keyword-case';
  const messages$8 = ruleMessages$1(ruleName$8, {
    expected: (actual, expected) => `Expected "${actual}" to be "${expected}"`
  });
  const meta$8 = {
    url: 'https://stylelint.io/user-guide/rules/value-keyword-case',
    fixable: true
  }; // Operators are interpreted as "words" by the value parser, so we want to make sure to ignore them.

  const ignoredCharacters = new Set(['+', '-', '/', '*', '%']);
  const gridRowProps = new Set(['grid-row', 'grid-row-start', 'grid-row-end']);
  const gridColumnProps = new Set(['grid-column', 'grid-column-start', 'grid-column-end']);
  const mapLowercaseKeywordsToCamelCase = new Map();

  for (const func of camelCaseKeywords) {
    mapLowercaseKeywordsToCamelCase.set(func.toLowerCase(), func);
  }
  /** @type {import('stylelint').Rule} */


  const rule$7 = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$8, {
        actual: primary,
        possible: ['lower', 'upper']
      }, {
        actual: secondaryOptions,
        possible: {
          ignoreProperties: [isString$5, isRegExp$1],
          ignoreKeywords: [isString$5, isRegExp$1],
          ignoreFunctions: [isString$5, isRegExp$1],
          camelCaseSvgKeywords: [isBoolean$2]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const prop = decl.prop;
        const propLowerCase = decl.prop.toLowerCase();
        const value = decl.value;
        if (!isStandardSyntaxValue(value)) return;
        const parsed = lib$6(getDeclarationValue(decl));
        let needFix = false;
        parsed.walk(node => {
          const keyword = node.value;
          const valueLowerCase = keyword.toLowerCase(); // Ignore system colors

          if (systemColorsKeywords.has(valueLowerCase)) {
            return;
          } // Ignore keywords within `url` and `var` function


          if (node.type === 'function' && (valueLowerCase === 'url' || valueLowerCase === 'var' || valueLowerCase === 'counter' || valueLowerCase === 'counters' || valueLowerCase === 'attr')) {
            return false;
          } // ignore keywords within ignoreFunctions functions


          if (node.type === 'function' && optionsMatches(secondaryOptions, 'ignoreFunctions', keyword)) {
            return false;
          }

          const {
            unit
          } = getDimension(node); // Ignore css variables, and hex values, and math operators, and sass interpolation

          if (node.type !== 'word' || !isStandardSyntaxValue(keyword) || value.includes('#') || ignoredCharacters.has(keyword) || unit) {
            return;
          }

          if (propLowerCase === 'animation' && !animationShorthandKeywords.has(valueLowerCase) && !animationNameKeywords.has(valueLowerCase)) {
            return;
          }

          if (propLowerCase === 'animation-name' && !animationNameKeywords.has(valueLowerCase)) {
            return;
          }

          if (propLowerCase === 'font' && !fontShorthandKeywords.has(valueLowerCase) && !fontFamilyKeywords.has(valueLowerCase)) {
            return;
          }

          if (propLowerCase === 'font-family' && !fontFamilyKeywords.has(valueLowerCase)) {
            return;
          }

          if (propLowerCase === 'counter-increment' && isCounterIncrementCustomIdentValue(valueLowerCase)) {
            return;
          }

          if (propLowerCase === 'counter-reset' && isCounterResetCustomIdentValue(valueLowerCase)) {
            return;
          }

          if (gridRowProps.has(propLowerCase) && !gridRowKeywords.has(valueLowerCase)) {
            return;
          }

          if (gridColumnProps.has(propLowerCase) && !gridColumnKeywords.has(valueLowerCase)) {
            return;
          }

          if (propLowerCase === 'grid-area' && !gridAreaKeywords.has(valueLowerCase)) {
            return;
          }

          if (propLowerCase === 'list-style' && !listStyleShorthandKeywords.has(valueLowerCase) && !listStyleTypeKeywords.has(valueLowerCase)) {
            return;
          }

          if (propLowerCase === 'list-style-type' && !listStyleTypeKeywords.has(valueLowerCase)) {
            return;
          }

          if (optionsMatches(secondaryOptions, 'ignoreKeywords', keyword)) {
            return;
          }

          if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
            return;
          }

          const keywordLowerCase = keyword.toLocaleLowerCase();
          let expectedKeyword = null;
          /** @type {boolean} */

          const camelCaseSvgKeywords = secondaryOptions && secondaryOptions.camelCaseSvgKeywords || false;

          if (primary === 'lower' && mapLowercaseKeywordsToCamelCase.has(keywordLowerCase) && camelCaseSvgKeywords) {
            expectedKeyword = mapLowercaseKeywordsToCamelCase.get(keywordLowerCase);
          } else if (primary === 'lower') {
            expectedKeyword = keyword.toLowerCase();
          } else {
            expectedKeyword = keyword.toUpperCase();
          }

          if (keyword === expectedKeyword) {
            return;
          }

          if (context.fix) {
            needFix = true;
            node.value = expectedKeyword;
            return;
          }

          report$1({
            message: messages$8.expected,
            messageArgs: [keyword, expectedKeyword],
            node: decl,
            index: declarationValueIndex(decl) + node.sourceIndex,
            result,
            ruleName: ruleName$8
          });
        });

        if (context.fix && needFix) {
          decl.value = parsed.toString();
        }
      });
    };
  };

  rule$7.ruleName = ruleName$8;
  rule$7.messages = messages$8;
  rule$7.meta = meta$8;
  var valueKeywordCase = rule$7;

  /**
   * @param {{
   *   root: import('postcss').Root,
   *   result: import('stylelint').PostcssResult,
   *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void }) => void,
   *   checkedRuleName: string,
   *   fix?: ((node: import('postcss').Declaration, index: number) => boolean) | null,
   *   determineIndex?: (declString: string, match: import('style-search').StyleSearchMatch) => number | false,
   * }} opts
   */


  var valueListCommaWhitespaceChecker = function valueListCommaWhitespaceChecker(opts) {
    opts.root.walkDecls(decl => {
      if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
        return;
      }

      const declString = decl.toString();
      styleSearch({
        source: declString,
        target: ',',
        functionArguments: 'skip'
      }, match => {
        const indexToCheckAfter = opts.determineIndex ? opts.determineIndex(declString, match) : match.startIndex;

        if (indexToCheckAfter === false) {
          return;
        }

        checkComma(declString, indexToCheckAfter, decl);
      });
    });
    /**
     * @param {string} source
     * @param {number} index
     * @param {import('postcss').Declaration} node
     * @returns {void}
     */

    function checkComma(source, index, node) {
      opts.locationChecker({
        source,
        index,
        err: message => {
          if (opts.fix && opts.fix(node, index)) {
            return;
          }

          report$1({
            message,
            node,
            index,
            result: opts.result,
            ruleName: opts.checkedRuleName
          });
        }
      });
    }
  };

  const ruleName$7 = 'value-list-comma-newline-after';
  const messages$7 = ruleMessages$1(ruleName$7, {
    expectedAfter: () => 'Expected newline after ","',
    expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
    rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list'
  });
  const meta$7 = {
    url: 'https://stylelint.io/user-guide/rules/value-list-comma-newline-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$6 = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('newline', primary, messages$7);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$7, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').Declaration, number[]> | undefined} */


      let fixData;
      valueListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.afterOneOnly,
        checkedRuleName: ruleName$7,
        fix: context.fix ? (declNode, index) => {
          const valueIndex = declarationValueIndex(declNode);

          if (index <= valueIndex) {
            return false;
          }

          fixData = fixData || new Map();
          const commaIndices = fixData.get(declNode) || [];
          commaIndices.push(index);
          fixData.set(declNode, commaIndices);
          return true;
        } : null,
        determineIndex: (declString, match) => {
          const nextChars = declString.substring(match.endIndex, declString.length); // If there's a // comment, that means there has to be a newline
          // ending the comment so we're fine

          if (/^[ \t]*\/\//.test(nextChars)) {
            return false;
          } // If there are spaces and then a comment begins, look for the newline


          return /^[ \t]*\/\*/.test(nextChars) ? declString.indexOf('*/', match.endIndex) + 1 : match.startIndex;
        }
      });

      if (fixData) {
        for (const [decl, commaIndices] of fixData.entries()) {
          for (const index of commaIndices.sort((a, b) => a - b).reverse()) {
            const value = getDeclarationValue(decl);
            const valueIndex = index - declarationValueIndex(decl);
            const beforeValue = value.slice(0, valueIndex + 1);
            let afterValue = value.slice(valueIndex + 1);

            if (primary.startsWith('always')) {
              afterValue = context.newline + afterValue;
            } else if (primary.startsWith('never-multi-line')) {
              afterValue = afterValue.replace(/^\s*/, '');
            }

            setDeclarationValue(decl, beforeValue + afterValue);
          }
        }
      }
    };
  };

  rule$6.ruleName = ruleName$7;
  rule$6.messages = messages$7;
  rule$6.meta = meta$7;
  var valueListCommaNewlineAfter = rule$6;

  const ruleName$6 = 'value-list-comma-newline-before';
  const messages$6 = ruleMessages$1(ruleName$6, {
    expectedBefore: () => 'Expected newline before ","',
    expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
    rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list'
  });
  const meta$6 = {
    url: 'https://stylelint.io/user-guide/rules/value-list-comma-newline-before',
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$5 = primary => {
    const checker = whitespaceChecker('newline', primary, messages$6);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$6, {
        actual: primary,
        possible: ['always', 'always-multi-line', 'never-multi-line']
      });

      if (!validOptions) {
        return;
      }

      valueListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.beforeAllowingIndentation,
        checkedRuleName: ruleName$6
      });
    };
  };

  rule$5.ruleName = ruleName$6;
  rule$5.messages = messages$6;
  rule$5.meta = meta$6;
  var valueListCommaNewlineBefore = rule$5;

  const ruleName$5 = 'value-list-comma-space-after';
  const messages$5 = ruleMessages$1(ruleName$5, {
    expectedAfter: () => 'Expected single space after ","',
    rejectedAfter: () => 'Unexpected whitespace after ","',
    expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
    rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list'
  });
  const meta$5 = {
    url: 'https://stylelint.io/user-guide/rules/value-list-comma-space-after',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$4 = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$5);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$5, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').Declaration, number[]> | undefined} */


      let fixData;
      valueListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.after,
        checkedRuleName: ruleName$5,
        fix: context.fix ? (declNode, index) => {
          const valueIndex = declarationValueIndex(declNode);

          if (index <= valueIndex) {
            return false;
          }

          fixData = fixData || new Map();
          const commaIndices = fixData.get(declNode) || [];
          commaIndices.push(index);
          fixData.set(declNode, commaIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [decl, commaIndices] of fixData.entries()) {
          for (const index of commaIndices.sort((a, b) => b - a)) {
            const value = getDeclarationValue(decl);
            const valueIndex = index - declarationValueIndex(decl);
            const beforeValue = value.slice(0, valueIndex + 1);
            let afterValue = value.slice(valueIndex + 1);

            if (primary.startsWith('always')) {
              afterValue = afterValue.replace(/^\s*/, ' ');
            } else if (primary.startsWith('never')) {
              afterValue = afterValue.replace(/^\s*/, '');
            }

            setDeclarationValue(decl, beforeValue + afterValue);
          }
        }
      }
    };
  };

  rule$4.ruleName = ruleName$5;
  rule$4.messages = messages$5;
  rule$4.meta = meta$5;
  var valueListCommaSpaceAfter = rule$4;

  const ruleName$4 = 'value-list-comma-space-before';
  const messages$4 = ruleMessages$1(ruleName$4, {
    expectedBefore: () => 'Expected single space before ","',
    rejectedBefore: () => 'Unexpected whitespace before ","',
    expectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list',
    rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list'
  });
  const meta$4 = {
    url: 'https://stylelint.io/user-guide/rules/value-list-comma-space-before',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$3 = (primary, _secondaryOptions, context) => {
    const checker = whitespaceChecker('space', primary, messages$4);
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$4, {
        actual: primary,
        possible: ['always', 'never', 'always-single-line', 'never-single-line']
      });

      if (!validOptions) {
        return;
      }
      /** @type {Map<import('postcss').Declaration, number[]> | undefined} */


      let fixData;
      valueListCommaWhitespaceChecker({
        root,
        result,
        locationChecker: checker.before,
        checkedRuleName: ruleName$4,
        fix: context.fix ? (declNode, index) => {
          const valueIndex = declarationValueIndex(declNode);

          if (index <= valueIndex) {
            return false;
          }

          fixData = fixData || new Map();
          const commaIndices = fixData.get(declNode) || [];
          commaIndices.push(index);
          fixData.set(declNode, commaIndices);
          return true;
        } : null
      });

      if (fixData) {
        for (const [decl, commaIndices] of fixData.entries()) {
          for (const index of commaIndices.sort((a, b) => b - a)) {
            const value = getDeclarationValue(decl);
            const valueIndex = index - declarationValueIndex(decl);
            let beforeValue = value.slice(0, valueIndex);
            const afterValue = value.slice(valueIndex);

            if (primary.startsWith('always')) {
              beforeValue = beforeValue.replace(/\s*$/, ' ');
            } else if (primary.startsWith('never')) {
              beforeValue = beforeValue.replace(/\s*$/, '');
            }

            setDeclarationValue(decl, beforeValue + afterValue);
          }
        }
      }
    };
  };

  rule$3.ruleName = ruleName$4;
  rule$3.messages = messages$4;
  rule$3.meta = meta$4;
  var valueListCommaSpaceBefore = rule$3;

  const {
    isNumber: isNumber$3
  } = validateTypes;

  const ruleName$3 = 'value-list-max-empty-lines';
  const messages$3 = ruleMessages$1(ruleName$3, {
    expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}`
  });
  const meta$3 = {
    url: 'https://stylelint.io/user-guide/rules/value-list-max-empty-lines',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$2 = (primary, _secondaryOptions, context) => {
    const maxAdjacentNewlines = primary + 1;
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$3, {
        actual: primary,
        possible: isNumber$3
      });

      if (!validOptions) {
        return;
      }

      const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
      const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
      const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
      const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';
      root.walkDecls(decl => {
        const value = getDeclarationValue(decl);

        if (context.fix) {
          const newValueString = value.replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);
          setDeclarationValue(decl, newValueString);
        } else if (violatedLFNewLinesRegex.test(value) || violatedCRLFNewLinesRegex.test(value)) {
          report$1({
            message: messages$3.expected(primary),
            node: decl,
            index: 0,
            result,
            ruleName: ruleName$3
          });
        }
      });
    };
  };

  rule$2.ruleName = ruleName$3;
  rule$2.messages = messages$3;
  rule$2.meta = meta$3;
  var valueListMaxEmptyLines = rule$2;

  const {
    isString: isString$4
  } = validateTypes;

  const ruleName$2 = 'value-no-vendor-prefix';
  const messages$2 = ruleMessages$1(ruleName$2, {
    rejected: value => `Unexpected vendor-prefix "${value}"`
  });
  const meta$2 = {
    url: 'https://stylelint.io/user-guide/rules/value-no-vendor-prefix',
    fixable: true
  };
  /** @type {import('stylelint').Rule} */

  const rule$1 = (primary, secondaryOptions, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$2, {
        actual: primary
      }, {
        optional: true,
        actual: secondaryOptions,
        possible: {
          ignoreValues: [isString$4]
        }
      });

      if (!validOptions) {
        return;
      }

      root.walkDecls(decl => {
        const {
          value
        } = decl;
        if (!hasPrefix(value)) return;

        if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
          return;
        }

        if (optionsMatches(secondaryOptions, 'ignoreValues', vendor.unprefixed(value))) {
          return;
        }

        const parsedValue = lib$6(value);
        parsedValue.walk(node => {
          if (!isAutoprefixable.propertyValue(node.value)) {
            return;
          }

          if (context.fix) {
            node.value = isAutoprefixable.unprefix(node.value);
            return;
          }

          const startIndex = decl.prop.length + (decl.raws.between || '').length + node.sourceIndex;
          report$1({
            message: messages$2.rejected,
            messageArgs: [node.value],
            node: decl,
            index: startIndex,
            endIndex: startIndex + node.value.length,
            result,
            ruleName: ruleName$2
          });
        });
        setDeclarationValue(decl, parsedValue.toString());
      });
    };
  };

  rule$1.ruleName = ruleName$2;
  rule$1.messages = messages$2;
  rule$1.meta = meta$2;
  var valueNoVendorPrefix = rule$1;

  const {
    isAtRule,
    isDeclaration,
    isRoot,
    isRule
  } = typeGuards;

  const {
    isBoolean: isBoolean$1,
    isNumber: isNumber$2,
    isString: isString$3,
    assertString: assertString$1
  } = validateTypes;

  const ruleName$1 = 'indentation';
  const messages$1 = ruleMessages$1(ruleName$1, {
    expected: x => `Expected indentation of ${x}`
  });
  const meta$1 = {
    url: 'https://stylelint.io/user-guide/rules/indentation',
    fixable: true,
    deprecated: true
  };
  /** @type {import('stylelint').Rule} */

  const rule = (primary, secondaryOptions = {}, context) => {
    return (root, result) => {
      const validOptions = validateOptions$1(result, ruleName$1, {
        actual: primary,
        possible: [isNumber$2, 'tab']
      }, {
        actual: secondaryOptions,
        possible: {
          baseIndentLevel: [isNumber$2, 'auto'],
          except: ['block', 'value', 'param'],
          ignore: ['value', 'param', 'inside-parens'],
          indentInsideParens: ['twice', 'once-at-root-twice-in-block'],
          indentClosingBrace: [isBoolean$1]
        },
        optional: true
      });

      if (!validOptions) {
        return;
      }

      const spaceCount = isNumber$2(primary) ? primary : null;
      const indentChar = spaceCount == null ? '\t' : ' '.repeat(spaceCount);
      const warningWord = primary === 'tab' ? 'tab' : 'space';
      /** @type {number | 'auto'} */

      const baseIndentLevel = secondaryOptions.baseIndentLevel;
      /** @type {boolean} */

      const indentClosingBrace = secondaryOptions.indentClosingBrace;
      /**
       * @param {number} level
       */

      const legibleExpectation = level => {
        const count = spaceCount == null ? level : level * spaceCount;
        const quantifiedWarningWord = count === 1 ? warningWord : `${warningWord}s`;
        return `${count} ${quantifiedWarningWord}`;
      }; // Cycle through all nodes using walk.


      root.walk(node => {
        if (isRoot(node)) {
          // Ignore nested template literals root in css-in-js lang
          return;
        }

        const nodeLevel = indentationLevel(node); // Cut out any * and _ hacks from `before`

        const before = (node.raws.before || '').replace(/[*_]$/, '');
        const after = typeof node.raws.after === 'string' ? node.raws.after : '';
        const parent = node.parent;
        if (!parent) throw new Error('A parent node must be present');
        const expectedOpeningBraceIndentation = indentChar.repeat(nodeLevel); // Only inspect the spaces before the node
        // if this is the first node in root
        // or there is a newline in the `before` string.
        // (If there is no newline before a node,
        // there is no "indentation" to check.)

        const isFirstChild = parent.type === 'root' && parent.first === node;
        const lastIndexOfNewline = before.lastIndexOf('\n'); // Inspect whitespace in the `before` string that is
        // *after* the *last* newline character,
        // because anything besides that is not indentation for this node:
        // it is some other kind of separation, checked by some separate rule

        if ((lastIndexOfNewline !== -1 || isFirstChild && (!getDocument(parent) || parent.raws.codeBefore && parent.raws.codeBefore.endsWith('\n'))) && before.slice(lastIndexOfNewline + 1) !== expectedOpeningBraceIndentation) {
          if (context.fix) {
            if (isFirstChild && isString$3(node.raws.before)) {
              node.raws.before = node.raws.before.replace(/^[ \t]*(?=\S|$)/, expectedOpeningBraceIndentation);
            }

            node.raws.before = fixIndentation(node.raws.before, expectedOpeningBraceIndentation);
          } else {
            report$1({
              message: messages$1.expected(legibleExpectation(nodeLevel)),
              node,
              result,
              ruleName: ruleName$1
            });
          }
        } // Only blocks have the `after` string to check.
        // Only inspect `after` strings that start with a newline;
        // otherwise there's no indentation involved.
        // And check `indentClosingBrace` to see if it should be indented an extra level.


        const closingBraceLevel = indentClosingBrace ? nodeLevel + 1 : nodeLevel;
        const expectedClosingBraceIndentation = indentChar.repeat(closingBraceLevel);

        if ((isRule(node) || isAtRule(node)) && hasBlock(node) && after && after.includes('\n') && after.slice(after.lastIndexOf('\n') + 1) !== expectedClosingBraceIndentation) {
          if (context.fix) {
            node.raws.after = fixIndentation(node.raws.after, expectedClosingBraceIndentation);
          } else {
            report$1({
              message: messages$1.expected(legibleExpectation(closingBraceLevel)),
              node,
              index: node.toString().length - 1,
              result,
              ruleName: ruleName$1
            });
          }
        } // If this is a declaration, check the value


        if (isDeclaration(node)) {
          checkValue(node, nodeLevel);
        } // If this is a rule, check the selector


        if (isRule(node)) {
          checkSelector(node, nodeLevel);
        } // If this is an at rule, check the params


        if (isAtRule(node)) {
          checkAtRuleParams(node, nodeLevel);
        }
      });
      /**
       * @param {import('postcss').Node} node
       * @param {number} level
       * @returns {number}
       */

      function indentationLevel(node, level = 0) {
        if (!node.parent) throw new Error('A parent node must be present');

        if (isRoot(node.parent)) {
          return level + getRootBaseIndentLevel(node.parent, baseIndentLevel, primary);
        }

        let calculatedLevel; // Indentation level equals the ancestor nodes
        // separating this node from root; so recursively
        // run this operation

        calculatedLevel = indentationLevel(node.parent, level + 1); // If `secondaryOptions.except` includes "block",
        // blocks are taken down one from their calculated level
        // (all blocks are the same level as their parents)

        if (optionsMatches(secondaryOptions, 'except', 'block') && (isRule(node) || isAtRule(node)) && hasBlock(node)) {
          calculatedLevel--;
        }

        return calculatedLevel;
      }
      /**
       * @param {import('postcss').Declaration} decl
       * @param {number} declLevel
       */


      function checkValue(decl, declLevel) {
        if (!decl.value.includes('\n')) {
          return;
        }

        if (optionsMatches(secondaryOptions, 'ignore', 'value')) {
          return;
        }

        const declString = decl.toString();
        const valueLevel = optionsMatches(secondaryOptions, 'except', 'value') ? declLevel : declLevel + 1;
        checkMultilineBit(declString, valueLevel, decl);
      }
      /**
       * @param {import('postcss').Rule} ruleNode
       * @param {number} ruleLevel
       */


      function checkSelector(ruleNode, ruleLevel) {
        const selector = ruleNode.selector; // Less mixins have params, and they should be indented extra
        // @ts-expect-error -- TS2339: Property 'params' does not exist on type 'Rule'.

        if (ruleNode.params) {
          ruleLevel += 1;
        }

        checkMultilineBit(selector, ruleLevel, ruleNode);
      }
      /**
       * @param {import('postcss').AtRule} atRule
       * @param {number} ruleLevel
       */


      function checkAtRuleParams(atRule, ruleLevel) {
        if (optionsMatches(secondaryOptions, 'ignore', 'param')) {
          return;
        } // @nest and SCSS's @at-root rules should be treated like regular rules, not expected
        // to have their params (selectors) indented


        const paramLevel = optionsMatches(secondaryOptions, 'except', 'param') || atRule.name === 'nest' || atRule.name === 'at-root' ? ruleLevel : ruleLevel + 1;
        checkMultilineBit(beforeBlockString(atRule).trim(), paramLevel, atRule);
      }
      /**
       * @param {string} source
       * @param {number} newlineIndentLevel
       * @param {import('postcss').Node} node
       */


      function checkMultilineBit(source, newlineIndentLevel, node) {
        if (!source.includes('\n')) {
          return;
        } // Data for current node fixing

        /** @type {Array<{ expectedIndentation: string, currentIndentation: string, startIndex: number }>} */


        const fixPositions = []; // `outsideParens` because function arguments and also non-standard parenthesized stuff like
        // Sass maps are ignored to allow for arbitrary indentation

        let parentheticalDepth = 0;
        const ignoreInsideParans = optionsMatches(secondaryOptions, 'ignore', 'inside-parens');
        styleSearch({
          source,
          target: '\n',
          // @ts-expect-error -- The `outsideParens` option is unsupported. Why?
          outsideParens: ignoreInsideParans
        }, (match, matchCount) => {
          const precedesClosingParenthesis = /^[ \t]*\)/.test(source.slice(match.startIndex + 1));

          if (ignoreInsideParans && (precedesClosingParenthesis || match.insideParens)) {
            return;
          }

          let expectedIndentLevel = newlineIndentLevel; // Modififications for parenthetical content

          if (!ignoreInsideParans && match.insideParens) {
            // If the first match in is within parentheses, reduce the parenthesis penalty
            if (matchCount === 1) parentheticalDepth -= 1; // Account for windows line endings

            let newlineIndex = match.startIndex;

            if (source[match.startIndex - 1] === '\r') {
              newlineIndex--;
            }

            const followsOpeningParenthesis = /\([ \t]*$/.test(source.slice(0, newlineIndex));

            if (followsOpeningParenthesis) {
              parentheticalDepth += 1;
            }

            const followsOpeningBrace = /\{[ \t]*$/.test(source.slice(0, newlineIndex));

            if (followsOpeningBrace) {
              parentheticalDepth += 1;
            }

            const startingClosingBrace = /^[ \t]*\}/.test(source.slice(match.startIndex + 1));

            if (startingClosingBrace) {
              parentheticalDepth -= 1;
            }

            expectedIndentLevel += parentheticalDepth; // Past this point, adjustments to parentheticalDepth affect next line

            if (precedesClosingParenthesis) {
              parentheticalDepth -= 1;
            }

            switch (secondaryOptions.indentInsideParens) {
              case 'twice':
                if (!precedesClosingParenthesis || indentClosingBrace) {
                  expectedIndentLevel += 1;
                }

                break;

              case 'once-at-root-twice-in-block':
                if (node.parent === node.root()) {
                  if (precedesClosingParenthesis && !indentClosingBrace) {
                    expectedIndentLevel -= 1;
                  }

                  break;
                }

                if (!precedesClosingParenthesis || indentClosingBrace) {
                  expectedIndentLevel += 1;
                }

                break;

              default:
                if (precedesClosingParenthesis && !indentClosingBrace) {
                  expectedIndentLevel -= 1;
                }

            }
          } // Starting at the index after the newline, we want to
          // check that the whitespace characters (excluding newlines) before the first
          // non-whitespace character equal the expected indentation


          const afterNewlineSpaceMatches = /^([ \t]*)\S/.exec(source.slice(match.startIndex + 1));

          if (!afterNewlineSpaceMatches) {
            return;
          }

          const afterNewlineSpace = afterNewlineSpaceMatches[1] || '';
          const expectedIndentation = indentChar.repeat(expectedIndentLevel > 0 ? expectedIndentLevel : 0);

          if (afterNewlineSpace !== expectedIndentation) {
            if (context.fix) {
              // Adding fixes position in reverse order, because if we change indent in the beginning of the string it will break all following fixes for that string
              fixPositions.unshift({
                expectedIndentation,
                currentIndentation: afterNewlineSpace,
                startIndex: match.startIndex
              });
            } else {
              report$1({
                message: messages$1.expected(legibleExpectation(expectedIndentLevel)),
                node,
                index: match.startIndex + afterNewlineSpace.length + 1,
                result,
                ruleName: ruleName$1
              });
            }
          }
        });

        if (fixPositions.length) {
          if (isRule(node)) {
            for (const fixPosition of fixPositions) {
              node.selector = replaceIndentation(node.selector, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex);
            }
          }

          if (isDeclaration(node)) {
            const declProp = node.prop;
            const declBetween = node.raws.between;

            if (!isString$3(declBetween)) {
              throw new TypeError('The `between` property must be a string');
            }

            for (const fixPosition of fixPositions) {
              if (fixPosition.startIndex < declProp.length + declBetween.length) {
                node.raws.between = replaceIndentation(declBetween, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex - declProp.length);
              } else {
                node.value = replaceIndentation(node.value, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex - declProp.length - declBetween.length);
              }
            }
          }

          if (isAtRule(node)) {
            const atRuleName = node.name;
            const atRuleAfterName = node.raws.afterName;
            const atRuleParams = node.params;

            if (!isString$3(atRuleAfterName)) {
              throw new TypeError('The `afterName` property must be a string');
            }

            for (const fixPosition of fixPositions) {
              // 1 — it's a @ length
              if (fixPosition.startIndex < 1 + atRuleName.length + atRuleAfterName.length) {
                node.raws.afterName = replaceIndentation(atRuleAfterName, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex - atRuleName.length - 1);
              } else {
                node.params = replaceIndentation(atRuleParams, fixPosition.currentIndentation, fixPosition.expectedIndentation, fixPosition.startIndex - atRuleName.length - atRuleAfterName.length - 1);
              }
            }
          }
        }
      }
    };
  };
  /**
   * @param {import('postcss').Root} root
   * @param {number | 'auto'} baseIndentLevel
   * @param {string} space
   * @returns {number}
   */


  function getRootBaseIndentLevel(root, baseIndentLevel, space) {
    const document = getDocument(root);

    if (!document) {
      return 0;
    }

    if (!root.source) {
      throw new Error('The root node must have a source');
    }
    /** @type {import('postcss').Source & { baseIndentLevel?: number }} */


    const source = root.source;
    const indentLevel = source.baseIndentLevel;

    if (isNumber$2(indentLevel) && Number.isSafeInteger(indentLevel)) {
      return indentLevel;
    }

    const newIndentLevel = inferRootIndentLevel(root, baseIndentLevel, () => inferDocIndentSize(document, space));
    source.baseIndentLevel = newIndentLevel;
    return newIndentLevel;
  }
  /**
   * @param {import('postcss').Node} node
   */


  function getDocument(node) {
    // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Node'.
    const document = node.document;

    if (document) {
      return document;
    }

    const root = node.root(); // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Node'.

    return root && root.document;
  }
  /**
   * @param {import('postcss').Document} document
   * @param {string} space
   * returns {number}
   */


  function inferDocIndentSize(document, space) {
    if (!document.source) throw new Error('The document node must have a source');
    /** @type {import('postcss').Source & { indentSize?: number }} */

    const docSource = document.source;
    let indentSize = docSource.indentSize;

    if (isNumber$2(indentSize) && Number.isSafeInteger(indentSize)) {
      return indentSize;
    }

    const source = document.source.input.css;
    const indents = source.match(/^ *(?=\S)/gm);

    if (indents) {
      /** @type {Map<number, number>} */
      const scores = new Map();
      let lastIndentSize = 0;
      let lastLeadingSpacesLength = 0;
      /**
       * @param {number} leadingSpacesLength
       */

      const vote = leadingSpacesLength => {
        if (leadingSpacesLength) {
          lastIndentSize = Math.abs(leadingSpacesLength - lastLeadingSpacesLength) || lastIndentSize;

          if (lastIndentSize > 1) {
            const score = scores.get(lastIndentSize);

            if (score) {
              scores.set(lastIndentSize, score + 1);
            } else {
              scores.set(lastIndentSize, 1);
            }
          }
        } else {
          lastIndentSize = 0;
        }

        lastLeadingSpacesLength = leadingSpacesLength;
      };

      for (const leadingSpaces of indents) {
        vote(leadingSpaces.length);
      }

      let bestScore = 0;

      for (const [indentSizeDate, score] of scores.entries()) {
        if (score > bestScore) {
          bestScore = score;
          indentSize = indentSizeDate;
        }
      }
    }

    indentSize = Number(indentSize) || indents && indents[0] && indents[0].length || Number(space) || 2;
    docSource.indentSize = indentSize;
    return indentSize;
  }
  /**
   * @param {import('postcss').Root} root
   * @param {number | 'auto'} baseIndentLevel
   * @param {() => number} indentSize
   * @returns {number}
   */


  function inferRootIndentLevel(root, baseIndentLevel, indentSize) {
    /**
     * @param {string} indent
     */
    function getIndentLevel(indent) {
      const tabMatch = indent.match(/\t/g);
      const tabCount = tabMatch ? tabMatch.length : 0;
      const spaceMatch = indent.match(/ /g);
      const spaceCount = spaceMatch ? Math.round(spaceMatch.length / indentSize()) : 0;
      return tabCount + spaceCount;
    }

    let newBaseIndentLevel = 0;

    if (!isNumber$2(baseIndentLevel) || !Number.isSafeInteger(baseIndentLevel)) {
      if (!root.source) throw new Error('The root node must have a source');
      let source = root.source.input.css;
      source = source.replace(/^[^\r\n]+/, firstLine => {
        const match = root.raws.codeBefore && /(?:^|\n)([ \t]*)$/.exec(root.raws.codeBefore);

        if (match) {
          return match[1] + firstLine;
        }

        return '';
      });
      const indents = source.match(/^[ \t]*(?=\S)/gm);

      if (indents) {
        return Math.min(...indents.map(indent => getIndentLevel(indent)));
      }

      newBaseIndentLevel = 1;
    } else {
      newBaseIndentLevel = baseIndentLevel;
    }

    const indents = [];
    const foundIndents = root.raws.codeBefore && /(?:^|\n)([ \t]*)\S/m.exec(root.raws.codeBefore); // The indent level of the CSS code block in non-CSS-like files is determined by the shortest indent of non-empty line.

    if (foundIndents) {
      let shortest = Number.MAX_SAFE_INTEGER;
      let i = 0;

      while (++i < foundIndents.length) {
        const foundIndent = foundIndents[i];
        assertString$1(foundIndent);
        const current = getIndentLevel(foundIndent);

        if (current < shortest) {
          shortest = current;

          if (shortest === 0) {
            break;
          }
        }
      }

      if (shortest !== Number.MAX_SAFE_INTEGER) {
        indents.push(new Array(shortest).fill(' ').join(''));
      }
    }

    const after = root.raws.after;

    if (after) {
      let afterEnd;

      if (after.endsWith('\n')) {
        // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Root'.
        const document = root.document;

        if (document) {
          const nextRoot = document.nodes[document.nodes.indexOf(root) + 1];
          afterEnd = nextRoot ? nextRoot.raws.codeBefore : document.raws.codeAfter;
        } else {
          // Nested root node in css-in-js lang
          const parent = root.parent;
          if (!parent) throw new Error('The root node must have a parent');
          const nextRoot = parent.nodes[parent.nodes.indexOf(root) + 1];
          afterEnd = nextRoot ? nextRoot.raws.codeBefore : root.raws.codeAfter;
        }
      } else {
        afterEnd = after;
      }

      if (afterEnd) indents.push(afterEnd.match(/^[ \t]*/)[0]);
    }

    if (indents.length) {
      return Math.max(...indents.map(indent => getIndentLevel(indent))) + newBaseIndentLevel;
    }

    return newBaseIndentLevel;
  }
  /**
   * @param {string | undefined} str
   * @param {string} whitespace
   */


  function fixIndentation(str, whitespace) {
    if (!isString$3(str)) {
      return str;
    }

    return str.replace(/\n[ \t]*(?=\S|$)/g, `\n${whitespace}`);
  }
  /**
   * @param {string} input
   * @param {string} searchString
   * @param {string} replaceString
   * @param {number} startIndex
   */


  function replaceIndentation(input, searchString, replaceString, startIndex) {
    const offset = startIndex + 1;
    const stringStart = input.slice(0, offset);
    const stringEnd = input.slice(offset + searchString.length);
    return stringStart + replaceString + stringEnd;
  }

  rule.ruleName = ruleName$1;
  rule.messages = messages$1;
  rule.meta = meta$1;
  var indentation = rule;

  /** @type {import('stylelint')['rules']} */


  const rules = {
    'alpha-value-notation': importLazy(() => alphaValueNotation)(),
    'annotation-no-unknown': importLazy(() => annotationNoUnknown)(),
    'at-rule-allowed-list': importLazy(() => atRuleAllowedList)(),
    'at-rule-disallowed-list': importLazy(() => atRuleDisallowedList)(),
    'at-rule-empty-line-before': importLazy(() => atRuleEmptyLineBefore)(),
    'at-rule-name-case': importLazy(() => atRuleNameCase)(),
    'at-rule-name-newline-after': importLazy(() => atRuleNameNewlineAfter)(),
    'at-rule-semicolon-space-before': importLazy(() => atRuleSemicolonSpaceBefore)(),
    'at-rule-name-space-after': importLazy(() => atRuleNameSpaceAfter)(),
    'at-rule-no-unknown': importLazy(() => atRuleNoUnknown)(),
    'at-rule-no-vendor-prefix': importLazy(() => atRuleNoVendorPrefix)(),
    'at-rule-property-required-list': importLazy(() => atRulePropertyRequiredList)(),
    'at-rule-semicolon-newline-after': importLazy(() => atRuleSemicolonNewlineAfter)(),
    'block-closing-brace-empty-line-before': importLazy(() => blockClosingBraceEmptyLineBefore)(),
    'block-closing-brace-newline-after': importLazy(() => blockClosingBraceNewlineAfter)(),
    'block-closing-brace-newline-before': importLazy(() => blockClosingBraceNewlineBefore)(),
    'block-closing-brace-space-after': importLazy(() => blockClosingBraceSpaceAfter)(),
    'block-closing-brace-space-before': importLazy(() => blockClosingBraceSpaceBefore)(),
    'block-no-empty': importLazy(() => blockNoEmpty)(),
    'block-opening-brace-newline-after': importLazy(() => blockOpeningBraceNewlineAfter)(),
    'block-opening-brace-newline-before': importLazy(() => blockOpeningBraceNewlineBefore)(),
    'block-opening-brace-space-after': importLazy(() => blockOpeningBraceSpaceAfter)(),
    'block-opening-brace-space-before': importLazy(() => blockOpeningBraceSpaceBefore)(),
    'color-function-notation': importLazy(() => colorFunctionNotation)(),
    'color-hex-alpha': importLazy(() => colorHexAlpha)(),
    'color-hex-case': importLazy(() => colorHexCase)(),
    'color-hex-length': importLazy(() => colorHexLength)(),
    'color-named': importLazy(() => colorNamed)(),
    'color-no-hex': importLazy(() => colorNoHex)(),
    'color-no-invalid-hex': importLazy(() => colorNoInvalidHex)(),
    'comment-empty-line-before': importLazy(() => commentEmptyLineBefore)(),
    'comment-no-empty': importLazy(() => commentNoEmpty)(),
    'comment-pattern': importLazy(() => commentPattern)(),
    'comment-whitespace-inside': importLazy(() => commentWhitespaceInside)(),
    'comment-word-disallowed-list': importLazy(() => commentWordDisallowedList)(),
    'custom-media-pattern': importLazy(() => customMediaPattern)(),
    'custom-property-empty-line-before': importLazy(() => customPropertyEmptyLineBefore)(),
    'custom-property-no-missing-var-function': importLazy(() => customPropertyNoMissingVarFunction)(),
    'custom-property-pattern': importLazy(() => customPropertyPattern)(),
    'declaration-bang-space-after': importLazy(() => declarationBangSpaceAfter)(),
    'declaration-bang-space-before': importLazy(() => declarationBangSpaceBefore)(),
    'declaration-block-no-duplicate-custom-properties': importLazy(() => declarationBlockNoDuplicateCustomProperties)(),
    'declaration-block-no-duplicate-properties': importLazy(() => declarationBlockNoDuplicateProperties)(),
    'declaration-block-no-redundant-longhand-properties': importLazy(() => declarationBlockNoRedundantLonghandProperties)(),
    'declaration-block-no-shorthand-property-overrides': importLazy(() => declarationBlockNoShorthandPropertyOverrides)(),
    'declaration-block-semicolon-newline-after': importLazy(() => declarationBlockSemicolonNewlineAfter)(),
    'declaration-block-semicolon-newline-before': importLazy(() => declarationBlockSemicolonNewlineBefore)(),
    'declaration-block-semicolon-space-after': importLazy(() => declarationBlockSemicolonSpaceAfter)(),
    'declaration-block-semicolon-space-before': importLazy(() => declarationBlockSemicolonSpaceBefore)(),
    'declaration-block-single-line-max-declarations': importLazy(() => declarationBlockSingleLineMaxDeclarations)(),
    'declaration-block-trailing-semicolon': importLazy(() => declarationBlockTrailingSemicolon)(),
    'declaration-colon-newline-after': importLazy(() => declarationColonNewlineAfter)(),
    'declaration-colon-space-after': importLazy(() => declarationColonSpaceAfter)(),
    'declaration-colon-space-before': importLazy(() => declarationColonSpaceBefore)(),
    'declaration-empty-line-before': importLazy(() => declarationEmptyLineBefore)(),
    'declaration-no-important': importLazy(() => declarationNoImportant)(),
    'declaration-property-max-values': importLazy(() => declarationPropertyMaxValues)(),
    'declaration-property-unit-allowed-list': importLazy(() => declarationPropertyUnitAllowedList)(),
    'declaration-property-unit-disallowed-list': importLazy(() => declarationPropertyUnitDisallowedList)(),
    'declaration-property-value-allowed-list': importLazy(() => declarationPropertyValueAllowedList)(),
    'declaration-property-value-disallowed-list': importLazy(() => declarationPropertyValueDisallowedList)(),
    'declaration-property-value-no-unknown': importLazy(() => declarationPropertyValueNoUnknown)(),
    'font-family-no-missing-generic-family-keyword': importLazy(() => fontFamilyNoMissingGenericFamilyKeyword)(),
    'font-family-name-quotes': importLazy(() => fontFamilyNameQuotes)(),
    'font-family-no-duplicate-names': importLazy(() => fontFamilyNoDuplicateNames)(),
    'font-weight-notation': importLazy(() => fontWeightNotation)(),
    'function-allowed-list': importLazy(() => functionAllowedList)(),
    'function-calc-no-unspaced-operator': importLazy(() => functionCalcNoUnspacedOperator)(),
    'function-comma-newline-after': importLazy(() => functionCommaNewlineAfter)(),
    'function-comma-newline-before': importLazy(() => functionCommaNewlineBefore)(),
    'function-comma-space-after': importLazy(() => functionCommaSpaceAfter)(),
    'function-comma-space-before': importLazy(() => functionCommaSpaceBefore)(),
    'function-disallowed-list': importLazy(() => functionDisallowedList)(),
    'function-linear-gradient-no-nonstandard-direction': importLazy(() => functionLinearGradientNoNonstandardDirection)(),
    'function-max-empty-lines': importLazy(() => functionMaxEmptyLines)(),
    'function-name-case': importLazy(() => functionNameCase)(),
    'function-no-unknown': importLazy(() => functionNoUnknown)(),
    'function-parentheses-newline-inside': importLazy(() => functionParenthesesNewlineInside)(),
    'function-parentheses-space-inside': importLazy(() => functionParenthesesSpaceInside)(),
    'function-url-no-scheme-relative': importLazy(() => functionUrlNoSchemeRelative)(),
    'function-url-quotes': importLazy(() => functionUrlQuotes)(),
    'function-url-scheme-allowed-list': importLazy(() => functionUrlSchemeAllowedList)(),
    'function-url-scheme-disallowed-list': importLazy(() => functionUrlSchemeDisallowedList)(),
    'function-whitespace-after': importLazy(() => functionWhitespaceAfter)(),
    'hue-degree-notation': importLazy(() => hueDegreeNotation)(),
    'import-notation': importLazy(() => importNotation)(),
    'keyframe-block-no-duplicate-selectors': importLazy(() => keyframeBlockNoDuplicateSelectors)(),
    'keyframe-declaration-no-important': importLazy(() => keyframeDeclarationNoImportant)(),
    'keyframe-selector-notation': importLazy(() => keyframeSelectorNotation)(),
    'keyframes-name-pattern': importLazy(() => keyframesNamePattern)(),
    'length-zero-no-unit': importLazy(() => lengthZeroNoUnit)(),
    linebreaks: importLazy(() => linebreaks)(),
    'max-empty-lines': importLazy(() => maxEmptyLines)(),
    'max-line-length': importLazy(() => maxLineLength)(),
    'max-nesting-depth': importLazy(() => maxNestingDepth)(),
    'media-feature-colon-space-after': importLazy(() => mediaFeatureColonSpaceAfter)(),
    'media-feature-colon-space-before': importLazy(() => mediaFeatureColonSpaceBefore)(),
    'media-feature-name-allowed-list': importLazy(() => mediaFeatureNameAllowedList)(),
    'media-feature-name-case': importLazy(() => mediaFeatureNameCase)(),
    'media-feature-name-disallowed-list': importLazy(() => mediaFeatureNameDisallowedList)(),
    'media-feature-name-no-unknown': importLazy(() => mediaFeatureNameNoUnknown)(),
    'media-feature-name-no-vendor-prefix': importLazy(() => mediaFeatureNameNoVendorPrefix)(),
    'media-feature-name-unit-allowed-list': importLazy(() => mediaFeatureNameUnitAllowedList)(),
    'media-feature-name-value-allowed-list': importLazy(() => mediaFeatureNameValueAllowedList)(),
    'media-feature-name-value-no-unknown': importLazy(() => mediaFeatureNameValueNoUnknown)(),
    'media-feature-parentheses-space-inside': importLazy(() => mediaFeatureParenthesesSpaceInside)(),
    'media-feature-range-notation': importLazy(() => mediaFeatureRangeNotation)(),
    'media-feature-range-operator-space-after': importLazy(() => mediaFeatureRangeOperatorSpaceAfter)(),
    'media-feature-range-operator-space-before': importLazy(() => mediaFeatureRangeOperatorSpaceBefore)(),
    'media-query-list-comma-newline-after': importLazy(() => mediaQueryListCommaNewlineAfter)(),
    'media-query-list-comma-newline-before': importLazy(() => mediaQueryListCommaNewlineBefore)(),
    'media-query-list-comma-space-after': importLazy(() => mediaQueryListCommaSpaceAfter)(),
    'media-query-list-comma-space-before': importLazy(() => mediaQueryListCommaSpaceBefore)(),
    'media-query-no-invalid': importLazy(() => mediaQueryNoInvalid)(),
    'named-grid-areas-no-invalid': importLazy(() => namedGridAreasNoInvalid)(),
    'no-descending-specificity': importLazy(() => noDescendingSpecificity)(),
    'no-duplicate-at-import-rules': importLazy(() => noDuplicateAtImportRules)(),
    'no-duplicate-selectors': importLazy(() => noDuplicateSelectors)(),
    'no-empty-source': importLazy(() => noEmptySource)(),
    'no-empty-first-line': importLazy(() => noEmptyFirstLine)(),
    'no-eol-whitespace': importLazy(() => noEolWhitespace)(),
    'no-extra-semicolons': importLazy(() => noExtraSemicolons)(),
    'no-invalid-double-slash-comments': importLazy(() => noInvalidDoubleSlashComments)(),
    'no-invalid-position-at-import-rule': importLazy(() => noInvalidPositionAtImportRule)(),
    'no-irregular-whitespace': importLazy(() => noIrregularWhitespace)(),
    'no-missing-end-of-source-newline': importLazy(() => noMissingEndOfSourceNewline)(),
    'no-unknown-animations': importLazy(() => noUnknownAnimations)(),
    'no-unknown-custom-properties': importLazy(() => noUnknownCustomProperties)(),
    'number-leading-zero': importLazy(() => numberLeadingZero)(),
    'number-max-precision': importLazy(() => numberMaxPrecision)(),
    'number-no-trailing-zeros': importLazy(() => numberNoTrailingZeros)(),
    'property-allowed-list': importLazy(() => propertyAllowedList)(),
    'property-case': importLazy(() => propertyCase)(),
    'property-disallowed-list': importLazy(() => propertyDisallowedList)(),
    'property-no-unknown': importLazy(() => propertyNoUnknown)(),
    'property-no-vendor-prefix': importLazy(() => propertyNoVendorPrefix)(),
    'rule-empty-line-before': importLazy(() => ruleEmptyLineBefore)(),
    'rule-selector-property-disallowed-list': importLazy(() => ruleSelectorPropertyDisallowedList)(),
    'selector-anb-no-unmatchable': importLazy(() => selectorAnbNoUnmatchable)(),
    'selector-attribute-brackets-space-inside': importLazy(() => selectorAttributeBracketsSpaceInside)(),
    'selector-attribute-name-disallowed-list': importLazy(() => selectorAttributeNameDisallowedList)(),
    'selector-attribute-operator-allowed-list': importLazy(() => selectorAttributeOperatorAllowedList)(),
    'selector-attribute-operator-disallowed-list': importLazy(() => selectorAttributeOperatorDisallowedList)(),
    'selector-attribute-operator-space-after': importLazy(() => selectorAttributeOperatorSpaceAfter)(),
    'selector-attribute-operator-space-before': importLazy(() => selectorAttributeOperatorSpaceBefore)(),
    'selector-attribute-quotes': importLazy(() => selectorAttributeQuotes)(),
    'selector-class-pattern': importLazy(() => selectorClassPattern)(),
    'selector-combinator-allowed-list': importLazy(() => selectorCombinatorAllowedList)(),
    'selector-combinator-disallowed-list': importLazy(() => selectorCombinatorDisallowedList)(),
    'selector-combinator-space-after': importLazy(() => selectorCombinatorSpaceAfter)(),
    'selector-combinator-space-before': importLazy(() => selectorCombinatorSpaceBefore)(),
    'selector-descendant-combinator-no-non-space': importLazy(() => selectorDescendantCombinatorNoNonSpace)(),
    'selector-disallowed-list': importLazy(() => selectorDisallowedList)(),
    'selector-id-pattern': importLazy(() => selectorIdPattern)(),
    'selector-list-comma-newline-after': importLazy(() => selectorListCommaNewlineAfter)(),
    'selector-list-comma-newline-before': importLazy(() => selectorListCommaNewlineBefore)(),
    'selector-list-comma-space-after': importLazy(() => selectorListCommaSpaceAfter)(),
    'selector-list-comma-space-before': importLazy(() => selectorListCommaSpaceBefore)(),
    'selector-max-attribute': importLazy(() => selectorMaxAttribute)(),
    'selector-max-class': importLazy(() => selectorMaxClass)(),
    'selector-max-combinators': importLazy(() => selectorMaxCombinators)(),
    'selector-max-compound-selectors': importLazy(() => selectorMaxCompoundSelectors)(),
    'selector-max-empty-lines': importLazy(() => selectorMaxEmptyLines)(),
    'selector-max-id': importLazy(() => selectorMaxId)(),
    'selector-max-pseudo-class': importLazy(() => selectorMaxPseudoClass)(),
    'selector-max-specificity': importLazy(() => selectorMaxSpecificity)(),
    'selector-max-type': importLazy(() => selectorMaxType)(),
    'selector-max-universal': importLazy(() => selectorMaxUniversal)(),
    'selector-nested-pattern': importLazy(() => selectorNestedPattern)(),
    'selector-no-qualifying-type': importLazy(() => selectorNoQualifyingType)(),
    'selector-no-vendor-prefix': importLazy(() => selectorNoVendorPrefix)(),
    'selector-not-notation': importLazy(() => selectorNotNotation)(),
    'selector-pseudo-class-allowed-list': importLazy(() => selectorPseudoClassAllowedList)(),
    'selector-pseudo-class-case': importLazy(() => selectorPseudoClassCase)(),
    'selector-pseudo-class-disallowed-list': importLazy(() => selectorPseudoClassDisallowedList)(),
    'selector-pseudo-class-no-unknown': importLazy(() => selectorPseudoClassNoUnknown)(),
    'selector-pseudo-class-parentheses-space-inside': importLazy(() => selectorPseudoClassParenthesesSpaceInside)(),
    'selector-pseudo-element-allowed-list': importLazy(() => selectorPseudoElementAllowedList)(),
    'selector-pseudo-element-case': importLazy(() => selectorPseudoElementCase)(),
    'selector-pseudo-element-colon-notation': importLazy(() => selectorPseudoElementColonNotation)(),
    'selector-pseudo-element-disallowed-list': importLazy(() => selectorPseudoElementDisallowedList)(),
    'selector-pseudo-element-no-unknown': importLazy(() => selectorPseudoElementNoUnknown)(),
    'selector-type-case': importLazy(() => selectorTypeCase)(),
    'selector-type-no-unknown': importLazy(() => selectorTypeNoUnknown)(),
    'shorthand-property-no-redundant-values': importLazy(() => shorthandPropertyNoRedundantValues)(),
    'string-no-newline': importLazy(() => stringNoNewline)(),
    'string-quotes': importLazy(() => stringQuotes)(),
    'time-min-milliseconds': importLazy(() => timeMinMilliseconds)(),
    'unicode-bom': importLazy(() => unicodeBom)(),
    'unit-allowed-list': importLazy(() => unitAllowedList)(),
    'unit-case': importLazy(() => unitCase)(),
    'unit-disallowed-list': importLazy(() => unitDisallowedList)(),
    'unit-no-unknown': importLazy(() => unitNoUnknown)(),
    'value-keyword-case': importLazy(() => valueKeywordCase)(),
    'value-list-comma-newline-after': importLazy(() => valueListCommaNewlineAfter)(),
    'value-list-comma-newline-before': importLazy(() => valueListCommaNewlineBefore)(),
    'value-list-comma-space-after': importLazy(() => valueListCommaSpaceAfter)(),
    'value-list-comma-space-before': importLazy(() => valueListCommaSpaceBefore)(),
    'value-list-max-empty-lines': importLazy(() => valueListMaxEmptyLines)(),
    'value-no-vendor-prefix': importLazy(() => valueNoVendorPrefix)(),
    indentation: importLazy(() => indentation)()
  };
  var rules_1 = rules;

  /**
   * @param {string} ruleName
   * @param {import('stylelint').Config | undefined} [config]
   * @returns {import('stylelint').Rule | undefined}
   */


  var getStylelintRule = function getStylelintRule(ruleName, config) {
    return rules_1[ruleName] || config && config.pluginFunctions && config.pluginFunctions[ruleName];
  };

  const Result = result.default;



  const {
    isPlainObject
  } = validateTypes;


  /**
   * @type {import('stylelint').Utils['checkAgainstRule']}
   */


  var checkAgainstRule = function checkAgainstRule(options, callback) {
    if (!isPlainObject(options)) throw new Error('Expected an options object');
    if (!callback) throw new Error('Expected a callback function');
    const {
      ruleName,
      ruleSettings,
      root,
      result,
      context = {}
    } = options;
    if (!ruleName) throw new Error('Expected a "ruleName" option');
    const rule = getStylelintRule(ruleName, result && result.stylelint.config);
    if (!rule) throw new Error(`Rule "${ruleName}" does not exist`);
    if (!ruleSettings) throw new Error('Expected a "ruleSettings" option');
    if (!root) throw new Error('Expected a "root" option');
    const settings = normalizeRuleSettings(ruleSettings, rule);

    if (!settings) {
      return;
    }

    const tmpPostcssResult = new Result( // NOTE: The first argument is unused, so passing `undefined` raises no problems.
    //       But this PostCSS's behavior may change in the future.
    // @ts-expect-error -- TS2345: Argument of type 'undefined' is not assignable to parameter of type 'Processor'.
    undefined, undefined, undefined);
    const [primary, secondary] = settings;
    const ruleFunc = rule(primary, secondary || {}, context);
    ruleFunc(root, // NOTE: This temporary PostCSS result doesn't have a property for Stylelint use.
    //       Problems may occur if some rules use the property.
    // @ts-expect-error -- TS2345: Argument of type 'Result' is not assignable to parameter of type 'PostcssResult'.
    tmpPostcssResult);

    for (const warning of tmpPostcssResult.warnings()) callback(warning);
  };

  /**
   * @type {import('stylelint')['createPlugin']}
   */

  var createPlugin$1 = function createPlugin(ruleName, rule) {
    return {
      ruleName,
      rule
    };
  };

  var cacheWrapper_2 = cacheWrapper;
  var cacheWrapperSync_1 = cacheWrapperSync;

  async function cacheWrapper(cache, key, fn) {
    const cached = cache.get(key);

    if (cached !== undefined) {
      return cached;
    }

    const result = await fn();
    cache.set(key, result);
    return result;
  }

  function cacheWrapperSync(cache, key, fn) {
    const cached = cache.get(key);

    if (cached !== undefined) {
      return cached;
    }

    const result = fn();
    cache.set(key, result);
    return result;
  }

  var cacheWrapper_1 = /*#__PURE__*/Object.defineProperty({
  	cacheWrapper: cacheWrapper_2,
  	cacheWrapperSync: cacheWrapperSync_1
  }, '__esModule', {value: true});

  var getPropertyByPath_2 = getPropertyByPath; // Resolves property names or property paths defined with period-delimited
  // strings or arrays of strings. Property names that are found on the source
  // object are used directly (even if they include a period).
  // Nested property names that include periods, within a path, are only
  // understood in array paths.

  function getPropertyByPath(source, path) {
    if (typeof path === 'string' && Object.prototype.hasOwnProperty.call(source, path)) {
      return source[path];
    }

    const parsedPath = typeof path === 'string' ? path.split('.') : path; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    return parsedPath.reduce((previous, key) => {
      if (previous === undefined) {
        return previous;
      }

      return previous[key];
    }, source);
  }

  var getPropertyByPath_1 = /*#__PURE__*/Object.defineProperty({
  	getPropertyByPath: getPropertyByPath_2
  }, '__esModule', {value: true});

  const resolveFrom$1 = (fromDir, moduleId, silent) => {
    if (typeof fromDir !== 'string') {
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
    }

    if (typeof moduleId !== 'string') {
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }

    try {
      fromDir = fs__default['default'].realpathSync(fromDir);
    } catch (err) {
      if (err.code === 'ENOENT') {
        fromDir = path__default['default'].resolve(fromDir);
      } else if (silent) {
        return null;
      } else {
        throw err;
      }
    }

    const fromFile = path__default['default'].join(fromDir, 'noop.js');

    const resolveFileName = () => Module__default['default']._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module__default['default']._nodeModulePaths(fromDir)
    });

    if (silent) {
      try {
        return resolveFileName();
      } catch (err) {
        return null;
      }
    }

    return resolveFileName();
  };

  var resolveFrom_1$1 = (fromDir, moduleId) => resolveFrom$1(fromDir, moduleId);

  var silent$1 = (fromDir, moduleId) => resolveFrom$1(fromDir, moduleId, true);
  resolveFrom_1$1.silent = silent$1;

  const callsites = () => {
    const _prepareStackTrace = Error.prepareStackTrace;

    Error.prepareStackTrace = (_, stack) => stack;

    const stack = new Error().stack.slice(1);
    Error.prepareStackTrace = _prepareStackTrace;
    return stack;
  };

  var callsites_1 = callsites; // TODO: Remove this for the next major release

  var _default$J = callsites;
  callsites_1.default = _default$J;

  var parentModule = filepath => {
    const stacks = callsites_1();

    if (!filepath) {
      return stacks[2].getFileName();
    }

    let seenVal = false; // Skip the first stack as it's this function

    stacks.shift();

    for (const stack of stacks) {
      const parentFilepath = stack.getFileName();

      if (typeof parentFilepath !== 'string') {
        continue;
      }

      if (parentFilepath === filepath) {
        seenVal = true;
        continue;
      } // Skip native modules


      if (parentFilepath === 'module.js') {
        continue;
      }

      if (seenVal && parentFilepath !== filepath) {
        return parentFilepath;
      }
    }
  };

  var importFresh = moduleId => {
    if (typeof moduleId !== 'string') {
      throw new TypeError('Expected a string');
    }

    const parentPath = parentModule(__filename);
    const filePath = resolveFrom_1$1(path__default['default'].dirname(parentPath), moduleId);
    const oldModule = require.cache[filePath]; // Delete itself from module parent

    if (oldModule && oldModule.parent) {
      let i = oldModule.parent.children.length;

      while (i--) {
        if (oldModule.parent.children[i].id === filePath) {
          oldModule.parent.children.splice(i, 1);
        }
      }
    }

    delete require.cache[filePath]; // Delete module from cache

    const parent = require.cache[parentPath]; // If `filePath` and `parentPath` are the same, cache will already be deleted so we won't get a memory leak in next step

    return parent === undefined ? commonjsRequire(filePath) : parent.require(filePath); // In case cache doesn't have parent, fall back to normal require
  };

  var isArrayish = function isArrayish(obj) {
    if (!obj) {
      return false;
    }

    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
  };

  var errorEx = function errorEx(name, properties) {
    if (!name || name.constructor !== String) {
      properties = name || {};
      name = Error.name;
    }

    var errorExError = function ErrorEXError(message) {
      if (!this) {
        return new ErrorEXError(message);
      }

      message = message instanceof Error ? message.message : message || this.message;
      Error.call(this, message);
      Error.captureStackTrace(this, errorExError);
      this.name = name;
      Object.defineProperty(this, 'message', {
        configurable: true,
        enumerable: false,
        get: function () {
          var newMessage = message.split(/\r?\n/g);

          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }

            var modifier = properties[key];

            if ('message' in modifier) {
              newMessage = modifier.message(this[key], newMessage) || newMessage;

              if (!isArrayish(newMessage)) {
                newMessage = [newMessage];
              }
            }
          }

          return newMessage.join('\n');
        },
        set: function (v) {
          message = v;
        }
      });
      var overwrittenStack = null;
      var stackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');
      var stackGetter = stackDescriptor.get;
      var stackValue = stackDescriptor.value;
      delete stackDescriptor.value;
      delete stackDescriptor.writable;

      stackDescriptor.set = function (newstack) {
        overwrittenStack = newstack;
      };

      stackDescriptor.get = function () {
        var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g); // starting in Node 7, the stack builder caches the message.
        // just replace it.

        if (!overwrittenStack) {
          stack[0] = this.name + ': ' + this.message;
        }

        var lineCount = 1;

        for (var key in properties) {
          if (!properties.hasOwnProperty(key)) {
            continue;
          }

          var modifier = properties[key];

          if ('line' in modifier) {
            var line = modifier.line(this[key]);

            if (line) {
              stack.splice(lineCount++, 0, '    ' + line);
            }
          }

          if ('stack' in modifier) {
            modifier.stack(this[key], stack);
          }
        }

        return stack.join('\n');
      };

      Object.defineProperty(this, 'stack', stackDescriptor);
    };

    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(errorExError.prototype, Error.prototype);
      Object.setPrototypeOf(errorExError, Error);
    } else {
      util__default['default'].inherits(errorExError, Error);
    }

    return errorExError;
  };

  errorEx.append = function (str, def) {
    return {
      message: function (v, message) {
        v = v || def;

        if (v) {
          message[0] += ' ' + str.replace('%s', v.toString());
        }

        return message;
      }
    };
  };

  errorEx.line = function (str, def) {
    return {
      line: function (v) {
        v = v || def;

        if (v) {
          return str.replace('%s', v.toString());
        }

        return null;
      }
    };
  };

  var errorEx_1 = errorEx;

  var jsonParseBetterErrors = parseJson$1;

  function parseJson$1(txt, reviver, context) {
    context = context || 20;

    try {
      return JSON.parse(txt, reviver);
    } catch (e) {
      if (typeof txt !== 'string') {
        const isEmptyArray = Array.isArray(txt) && txt.length === 0;
        const errorMessage = 'Cannot parse ' + (isEmptyArray ? 'an empty array' : String(txt));
        throw new TypeError(errorMessage);
      }

      const syntaxErr = e.message.match(/^Unexpected token.*position\s+(\d+)/i);
      const errIdx = syntaxErr ? +syntaxErr[1] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;

      if (errIdx != null) {
        const start = errIdx <= context ? 0 : errIdx - context;
        const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
        e.message += ` while parsing near '${start === 0 ? '' : '...'}${txt.slice(start, end)}${end === txt.length ? '' : '...'}'`;
      } else {
        e.message += ` while parsing '${txt.slice(0, context * 2)}'`;
      }

      throw e;
    }
  }

  var LF = '\n';
  var CR = '\r';

  var LinesAndColumns$1 = function () {
    function LinesAndColumns(string) {
      this.string = string;
      var offsets = [0];

      for (var offset = 0; offset < string.length;) {
        switch (string[offset]) {
          case LF:
            offset += LF.length;
            offsets.push(offset);
            break;

          case CR:
            offset += CR.length;

            if (string[offset] === LF) {
              offset += LF.length;
            }

            offsets.push(offset);
            break;

          default:
            offset++;
            break;
        }
      }

      this.offsets = offsets;
    }

    LinesAndColumns.prototype.locationForIndex = function (index) {
      if (index < 0 || index > this.string.length) {
        return null;
      }

      var line = 0;
      var offsets = this.offsets;

      while (offsets[line + 1] <= index) {
        line++;
      }

      var column = index - offsets[line];
      return {
        line: line,
        column: column
      };
    };

    LinesAndColumns.prototype.indexForLocation = function (location) {
      var line = location.line,
          column = location.column;

      if (line < 0 || line >= this.offsets.length) {
        return null;
      }

      if (column < 0 || column > this.lengthOfLine(line)) {
        return null;
      }

      return this.offsets[line] + column;
    };

    LinesAndColumns.prototype.lengthOfLine = function (line) {
      var offset = this.offsets[line];
      var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
      return nextOffset - offset;
    };

    return LinesAndColumns;
  }();

  var dist$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': LinesAndColumns$1
  });

  var isIdentifierStart_1 = isIdentifierStart;
  var isIdentifierChar_1 = isIdentifierChar;
  var isIdentifierName_1 = isIdentifierName;
  let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  function isInAstralSet(code, set) {
    let pos = 0x10000;

    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes);
  }

  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }

  function isIdentifierName(name) {
    let isFirst = true;

    for (let _i = 0, _Array$from = Array.from(name); _i < _Array$from.length; _i++) {
      const char = _Array$from[_i];
      const cp = char.codePointAt(0);

      if (isFirst) {
        if (!isIdentifierStart(cp)) {
          return false;
        }

        isFirst = false;
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }

    return !isFirst;
  }

  var identifier = /*#__PURE__*/Object.defineProperty({
  	isIdentifierStart: isIdentifierStart_1,
  	isIdentifierChar: isIdentifierChar_1,
  	isIdentifierName: isIdentifierName_1
  }, '__esModule', {value: true});

  var isReservedWord_1 = isReservedWord;
  var isStrictReservedWord_1 = isStrictReservedWord;
  var isStrictBindOnlyReservedWord_1 = isStrictBindOnlyReservedWord;
  var isStrictBindReservedWord_1 = isStrictBindReservedWord;
  var isKeyword_1 = isKeyword;
  const reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  const keywords$1 = new Set(reservedWords.keyword);
  const reservedWordsStrictSet = new Set(reservedWords.strict);
  const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }

  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }

  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }

  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }

  function isKeyword(word) {
    return keywords$1.has(word);
  }

  var keyword = /*#__PURE__*/Object.defineProperty({
  	isReservedWord: isReservedWord_1,
  	isStrictReservedWord: isStrictReservedWord_1,
  	isStrictBindOnlyReservedWord: isStrictBindOnlyReservedWord_1,
  	isStrictBindReservedWord: isStrictBindReservedWord_1,
  	isKeyword: isKeyword_1
  }, '__esModule', {value: true});

  var lib$4 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function () {
      return identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function () {
      return identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function () {
      return identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function () {
      return keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function () {
      return keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function () {
      return keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function () {
      return keyword.isStrictReservedWord;
    }
  });
  Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function () {
      return keyword.isKeyword;
    }
  });
  });

  // Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
  // License: MIT. (See LICENSE.)
   // This regex comes from regex.coffee, and is inserted here by generate-index.js
  // (run `npm run build`).

  var _default$I = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

  var matchToToken = function (match) {
    var token = {
      type: "invalid",
      value: match[0],
      closed: undefined
    };
    if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
    return token;
  };

  var jsTokens = /*#__PURE__*/Object.defineProperty({
  	default: _default$I,
  	matchToToken: matchToToken
  }, '__esModule', {value: true});

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  var escapeStringRegexp = function (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    return str.replace(matchOperatorsRe, '\\$&');
  };

  var colorName$1 = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  /* MIT license */

  var conversions$1 = createCommonjsModule(function (module) {
  // NOTE: conversions should only return primitive values (i.e. arrays, or
  //       values that give correct `typeof` results).
  //       do not use box values types (i.e. Number(), String(), etc.)


  var reverseKeywords = {};

  for (var key in colorName$1) {
    if (colorName$1.hasOwnProperty(key)) {
      reverseKeywords[colorName$1[key]] = key;
    }
  }

  var convert = module.exports = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  }; // hide .channels and .labels properties

  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!('channels' in convert[model])) {
        throw new Error('missing channels property: ' + model);
      }

      if (!('labels' in convert[model])) {
        throw new Error('missing channel labels property: ' + model);
      }

      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error('channel and label counts mismatch: ' + model);
      }

      var channels = convert[model].channels;
      var labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], 'channels', {
        value: channels
      });
      Object.defineProperty(convert[model], 'labels', {
        value: labels
      });
    }
  }

  convert.rgb.hsl = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  convert.rgb.hsv = function (rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);

    var diffc = function (c) {
      return (v - c) / 6 / diff + 1 / 2;
    };

    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);

      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }

      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }

    return [h * 360, s * 100, v * 100];
  };

  convert.rgb.hwb = function (rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };

  convert.rgb.cmyk = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  /**
   * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
   * */


  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }

  convert.rgb.keyword = function (rgb) {
    var reversed = reverseKeywords[rgb];

    if (reversed) {
      return reversed;
    }

    var currentClosestDistance = Infinity;
    var currentClosestKeyword;

    for (var keyword in colorName$1) {
      if (colorName$1.hasOwnProperty(keyword)) {
        var value = colorName$1[keyword]; // Compute comparative distance

        var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }

    return currentClosestKeyword;
  };

  convert.keyword.rgb = function (keyword) {
    return colorName$1[keyword];
  };

  convert.rgb.xyz = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255; // assume sRGB

    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };

  convert.rgb.lab = function (rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.hsl.rgb = function (hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;

    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }

    t1 = 2 * l - t2;
    rgb = [0, 0, 0];

    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);

      if (t3 < 0) {
        t3++;
      }

      if (t3 > 1) {
        t3--;
      }

      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }

      rgb[i] = val * 255;
    }

    return rgb;
  };

  convert.hsl.hsv = function (hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };

  convert.hsv.rgb = function (hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;

    switch (hi) {
      case 0:
        return [v, t, p];

      case 1:
        return [q, v, p];

      case 2:
        return [p, v, t];

      case 3:
        return [p, q, v];

      case 4:
        return [t, p, v];

      case 5:
        return [v, p, q];
    }
  };

  convert.hsv.hsl = function (hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


  convert.hwb.rgb = function (hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n; // wh + bl cant be > 1

    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;

    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }

    n = wh + f * (v - wh); // linear interpolation

    var r;
    var g;
    var b;

    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;

      case 1:
        r = n;
        g = v;
        b = wh;
        break;

      case 2:
        r = wh;
        g = v;
        b = n;
        break;

      case 3:
        r = wh;
        g = n;
        b = v;
        break;

      case 4:
        r = n;
        g = wh;
        b = v;
        break;

      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }

    return [r * 255, g * 255, b * 255];
  };

  convert.cmyk.rgb = function (cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.rgb = function (xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.lab = function (xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.lab.xyz = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };

  convert.lab.lch = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;

    if (h < 0) {
      h += 360;
    }

    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };

  convert.lch.lab = function (lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };

  convert.rgb.ansi16 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

    value = Math.round(value / 50);

    if (value === 0) {
      return 30;
    }

    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

    if (value === 2) {
      ansi += 60;
    }

    return ansi;
  };

  convert.hsv.ansi16 = function (args) {
    // optimization here; we already know the value and don't need to get
    // it converted for us.
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };

  convert.rgb.ansi256 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2]; // we use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.

    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }

      if (r > 248) {
        return 231;
      }

      return Math.round((r - 8) / 247 * 24) + 232;
    }

    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };

  convert.ansi16.rgb = function (args) {
    var color = args % 10; // handle greyscale

    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }

      color = color / 10.5 * 255;
      return [color, color, color];
    }

    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };

  convert.ansi256.rgb = function (args) {
    // handle greyscale
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }

    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };

  convert.rgb.hex = function (args) {
    var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.hex.rgb = function (args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

    if (!match) {
      return [0, 0, 0];
    }

    var colorString = match[0];

    if (match[0].length === 3) {
      colorString = colorString.split('').map(function (char) {
        return char + char;
      }).join('');
    }

    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 0xFF;
    var g = integer >> 8 & 0xFF;
    var b = integer & 0xFF;
    return [r, g, b];
  };

  convert.rgb.hcg = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;

    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }

    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }

    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };

  convert.hsl.hcg = function (hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;

    if (l < 0.5) {
      c = 2.0 * s * l;
    } else {
      c = 2.0 * s * (1.0 - l);
    }

    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }

    return [hsl[0], c * 100, f * 100];
  };

  convert.hsv.hcg = function (hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;

    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }

    return [hsv[0], c * 100, f * 100];
  };

  convert.hcg.rgb = function (hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;

    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }

    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;

    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;

      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;

      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;

      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;

      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;

      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }

    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };

  convert.hcg.hsv = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    var f = 0;

    if (v > 0.0) {
      f = c / v;
    }

    return [hcg[0], f * 100, v * 100];
  };

  convert.hcg.hsl = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1.0 - c) + 0.5 * c;
    var s = 0;

    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }

    return [hcg[0], s * 100, l * 100];
  };

  convert.hcg.hwb = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  convert.hwb.hcg = function (hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;

    if (c < 1) {
      g = (v - c) / (1 - c);
    }

    return [hwb[0], c * 100, g * 100];
  };

  convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };

  convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };

  convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  convert.gray.hsl = convert.gray.hsv = function (args) {
    return [0, 0, args[0]];
  };

  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };

  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };

  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };

  convert.gray.hex = function (gray) {
    var val = Math.round(gray[0] / 100 * 255) & 0xFF;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.rgb.gray = function (rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  });

  /*
  	this function routes a model to all other models.

  	all functions that are routed have a property `.conversion` attached
  	to the returned synthetic function. This property is an array
  	of strings, each with the steps in between the 'from' and 'to'
  	color models (inclusive).

  	conversions that are not possible simply are not included.
  */


  function buildGraph$1() {
    var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

    var models = Object.keys(conversions$1);

    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }

    return graph;
  } // https://en.wikipedia.org/wiki/Breadth-first_search


  function deriveBFS$1(fromModel) {
    var graph = buildGraph$1();
    var queue = [fromModel]; // unshift -> queue -> pop

    graph[fromModel].distance = 0;

    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions$1[current]);

      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link$1(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion$1(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions$1[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link$1(conversions$1[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  var route$1 = function (fromModel) {
    var graph = deriveBFS$1(fromModel);
    var conversion = {};
    var models = Object.keys(graph);

    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];

      if (node.parent === null) {
        // no possible conversion, or this node is the source model.
        continue;
      }

      conversion[toModel] = wrapConversion$1(toModel, graph);
    }

    return conversion;
  };

  var convert$2 = {};
  var models$1 = Object.keys(conversions$1);

  function wrapRaw$1(fn) {
    var wrappedFn = function (args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      return fn(args);
    }; // preserve .conversion property if there is one


    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded$1(fn) {
    var wrappedFn = function (args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      var result = fn(args); // we're assuming the result is an array here.
      // see notice in conversions.js; don't use box types
      // in conversion functions.

      if (typeof result === 'object') {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    }; // preserve .conversion property if there is one


    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models$1.forEach(function (fromModel) {
    convert$2[fromModel] = {};
    Object.defineProperty(convert$2[fromModel], 'channels', {
      value: conversions$1[fromModel].channels
    });
    Object.defineProperty(convert$2[fromModel], 'labels', {
      value: conversions$1[fromModel].labels
    });
    var routes = route$1(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function (toModel) {
      var fn = routes[toModel];
      convert$2[fromModel][toModel] = wrapRounded$1(fn);
      convert$2[fromModel][toModel].raw = wrapRaw$1(fn);
    });
  });
  var colorConvert$1 = convert$2;

  var ansiStyles$1 = createCommonjsModule(function (module) {



  const wrapAnsi16 = (fn, offset) => function () {
    const code = fn.apply(colorConvert$1, arguments);
    return `\u001B[${code + offset}m`;
  };

  const wrapAnsi256 = (fn, offset) => function () {
    const code = fn.apply(colorConvert$1, arguments);
    return `\u001B[${38 + offset};5;${code}m`;
  };

  const wrapAnsi16m = (fn, offset) => function () {
    const rgb = fn.apply(colorConvert$1, arguments);
    return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };

  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    }; // Fix humans

    styles.color.grey = styles.color.gray;

    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];

      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `\u001B[${style[0]}m`,
          close: `\u001B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }

      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
      });
    }

    const ansi2ansi = n => n;

    const rgb2rgb = (r, g, b) => [r, g, b];

    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };

    for (let key of Object.keys(colorConvert$1)) {
      if (typeof colorConvert$1[key] !== 'object') {
        continue;
      }

      const suite = colorConvert$1[key];

      if (key === 'ansi16') {
        key = 'ansi';
      }

      if ('ansi16' in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }

      if ('ansi256' in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }

      if ('rgb' in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }

    return styles;
  } // Make the export immutable


  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
  });

  var hasFlag$1 = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf('--');
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };

  const env$1 = process.env;
  let forceColor$1;

  if (hasFlag$1('no-color') || hasFlag$1('no-colors') || hasFlag$1('color=false')) {
    forceColor$1 = false;
  } else if (hasFlag$1('color') || hasFlag$1('colors') || hasFlag$1('color=true') || hasFlag$1('color=always')) {
    forceColor$1 = true;
  }

  if ('FORCE_COLOR' in env$1) {
    forceColor$1 = env$1.FORCE_COLOR.length === 0 || parseInt(env$1.FORCE_COLOR, 10) !== 0;
  }

  function translateLevel$1(level) {
    if (level === 0) {
      return false;
    }

    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }

  function supportsColor$1(stream) {
    if (forceColor$1 === false) {
      return 0;
    }

    if (hasFlag$1('color=16m') || hasFlag$1('color=full') || hasFlag$1('color=truecolor')) {
      return 3;
    }

    if (hasFlag$1('color=256')) {
      return 2;
    }

    if (stream && !stream.isTTY && forceColor$1 !== true) {
      return 0;
    }

    const min = forceColor$1 ? 1 : 0;

    if (process.platform === 'win32') {
      // Node.js 7.5.0 is the first version of Node.js to include a patch to
      // libuv that enables 256 color output on Windows. Anything earlier and it
      // won't work. However, here we target Node.js 8 at minimum as it is an LTS
      // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
      // release that supports 256 colors. Windows 10 build 14931 is the first release
      // that supports 16m/TrueColor.
      const osRelease = os__default['default'].release().split('.');

      if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }

      return 1;
    }

    if ('CI' in env$1) {
      if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env$1) || env$1.CI_NAME === 'codeship') {
        return 1;
      }

      return min;
    }

    if ('TEAMCITY_VERSION' in env$1) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;
    }

    if (env$1.COLORTERM === 'truecolor') {
      return 3;
    }

    if ('TERM_PROGRAM' in env$1) {
      const version = parseInt((env$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

      switch (env$1.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;

        case 'Apple_Terminal':
          return 2;
        // No default
      }
    }

    if (/-256(color)?$/i.test(env$1.TERM)) {
      return 2;
    }

    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {
      return 1;
    }

    if ('COLORTERM' in env$1) {
      return 1;
    }

    if (env$1.TERM === 'dumb') {
      return min;
    }

    return min;
  }

  function getSupportLevel$1(stream) {
    const level = supportsColor$1(stream);
    return translateLevel$1(level);
  }

  var supportsColor_1$1 = {
    supportsColor: getSupportLevel$1,
    stdout: getSupportLevel$1(process.stdout),
    stderr: getSupportLevel$1(process.stderr)
  };

  const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES$1 = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', '\u001B'], ['a', '\u0007']]);

  function unescape$1(c) {
    if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }

    return ESCAPES$1.get(c) || c;
  }

  function parseArguments(name, args) {
    const results = [];
    const chunks = args.trim().split(/\s*,\s*/g);
    let matches;

    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape$1(escape) : chr));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }

    return results;
  }

  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;

    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];

      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }

    return results;
  }

  function buildStyle(chalk, styles) {
    const enabled = {};

    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }

    let current = chalk;

    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }

        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }

    return current;
  }

  var templates = (chalk, tmp) => {
    const styles = [];
    const chunks = [];
    let chunk = []; // eslint-disable-next-line max-params

    tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
      if (escapeChar) {
        chunk.push(unescape$1(escapeChar));
      } else if (style) {
        const str = chunk.join('');
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({
          inverse,
          styles: parseStyle(style)
        });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error('Found extraneous } in Chalk template literal');
        }

        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(''));

    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
      throw new Error(errMsg);
    }

    return chunks.join('');
  };

  var chalk = createCommonjsModule(function (module) {





  const stdoutColor = supportsColor_1$1.stdout;



  const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm'); // `supportsColor.level` → `ansiStyles.color[name]` mapping

  const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']; // `color-convert` models to exclude from the Chalk API due to conflicts and such

  const skipModels = new Set(['gray']);
  const styles = Object.create(null);

  function applyOptions(obj, options) {
    options = options || {}; // Detect level if not set manually

    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === undefined ? scLevel : options.level;
    obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
  }

  function Chalk(options) {
    // We check for this.template here since calling `chalk.constructor()`
    // by itself will have a `this` of a previously constructed chalk object
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk = {};
      applyOptions(chalk, options);

      chalk.template = function () {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };

      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }

    applyOptions(this, options);
  } // Use bright blue on Windows as the normal blue color is illegible


  if (isSimpleWindowsTerm) {
    ansiStyles$1.blue.open = '\u001B[94m';
  }

  for (const key of Object.keys(ansiStyles$1)) {
    ansiStyles$1[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles$1[key].close), 'g');
    styles[key] = {
      get() {
        const codes = ansiStyles$1[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }

    };
  }

  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, 'visible');
    }

  };
  ansiStyles$1.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles$1.color.close), 'g');

  for (const model of Object.keys(ansiStyles$1.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }

    styles[model] = {
      get() {
        const level = this.level;
        return function () {
          const open = ansiStyles$1.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles$1.color.close,
            closeRe: ansiStyles$1.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }

    };
  }

  ansiStyles$1.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles$1.bgColor.close), 'g');

  for (const model of Object.keys(ansiStyles$1.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }

    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function () {
          const open = ansiStyles$1.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles$1.bgColor.close,
            closeRe: ansiStyles$1.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }

    };
  }

  const proto = Object.defineProperties(() => {}, styles);

  function build(_styles, _empty, key) {
    const builder = function () {
      return applyStyle.apply(builder, arguments);
    };

    builder._styles = _styles;
    builder._empty = _empty;
    const self = this;
    Object.defineProperty(builder, 'level', {
      enumerable: true,

      get() {
        return self.level;
      },

      set(level) {
        self.level = level;
      }

    });
    Object.defineProperty(builder, 'enabled', {
      enumerable: true,

      get() {
        return self.enabled;
      },

      set(enabled) {
        self.enabled = enabled;
      }

    }); // See below for fix regarding invisible grey/dim combination on Windows

    builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'; // `__proto__` is used because we must return a function, but there is
    // no way to create a function with a different prototype

    builder.__proto__ = proto; // eslint-disable-line no-proto

    return builder;
  }

  function applyStyle() {
    // Support varags, but simply cast to string in case there's only one arg
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);

    if (argsLen === 0) {
      return '';
    }

    if (argsLen > 1) {
      // Don't slice `arguments`, it prevents V8 optimizations
      for (let a = 1; a < argsLen; a++) {
        str += ' ' + args[a];
      }
    }

    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? '' : str;
    } // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
    // see https://github.com/chalk/chalk/issues/58
    // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.


    const originalDim = ansiStyles$1.dim.open;

    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles$1.dim.open = '';
    }

    for (const code of this._styles.slice().reverse()) {
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      str = code.open + str.replace(code.closeRe, code.open) + code.close; // Close the styling before a linebreak and reopen
      // after next line to fix a bleed issue on macOS
      // https://github.com/chalk/chalk/pull/92

      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    } // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue


    ansiStyles$1.dim.open = originalDim;
    return str;
  }

  function chalkTag(chalk, strings) {
    if (!Array.isArray(strings)) {
      // If chalk() was called by itself or with a string,
      // return the string itself as a string.
      return [].slice.call(arguments, 1).join(' ');
    }

    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];

    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
      parts.push(String(strings.raw[i]));
    }

    return templates(chalk, parts.join(''));
  }

  Object.defineProperties(Chalk.prototype, styles);
  module.exports = Chalk(); // eslint-disable-line new-cap

  module.exports.supportsColor = stdoutColor;
  module.exports.default = module.exports; // For TypeScript
  });

  var shouldHighlight_1 = shouldHighlight;
  var getChalk_1 = getChalk;
  var _default$H = highlight;







  const sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);

  function getDefs$1(chalk) {
    return {
      keyword: chalk.cyan,
      capitalized: chalk.yellow,
      jsxIdentifier: chalk.yellow,
      punctuator: chalk.yellow,
      number: chalk.magenta,
      string: chalk.green,
      regex: chalk.magenta,
      comment: chalk.grey,
      invalid: chalk.white.bgRed.bold
    };
  }

  const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
  const BRACKET = /^[()[\]{}]$/;
  let tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;

    const getTokenType = function (token, offset, text) {
      if (token.type === "name") {
        if ((0, lib$4.isKeyword)(token.value) || (0, lib$4.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }

        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsxIdentifier";
        }

        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }

      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }

      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }

      return token.type;
    };

    tokenize = function* (text) {
      let match;

      while (match = jsTokens.default.exec(text)) {
        const token = jsTokens.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text),
          value: token.value
        };
      }
    };
  }

  function highlightTokens(defs, text) {
    let highlighted = "";

    for (const {
      type,
      value
    } of tokenize(text)) {
      const colorize = defs[type];

      if (colorize) {
        highlighted += value.split(NEWLINE$1).map(str => colorize(str)).join("\n");
      } else {
        highlighted += value;
      }
    }

    return highlighted;
  }

  function shouldHighlight(options) {
    return !!chalk.supportsColor || options.forceColor;
  }

  function getChalk(options) {
    return options.forceColor ? new chalk.constructor({
      enabled: true,
      level: 1
    }) : chalk;
  }

  function highlight(code, options = {}) {
    if (shouldHighlight(options)) {
      const chalk = getChalk(options);
      const defs = getDefs$1(chalk);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }

  var lib$3 = /*#__PURE__*/Object.defineProperty({
  	shouldHighlight: shouldHighlight_1,
  	getChalk: getChalk_1,
  	default: _default$H
  }, '__esModule', {value: true});

  var codeFrameColumns_1 = codeFrameColumns$1;
  var default_1 = _default$G;

  var _highlight = _interopRequireWildcard(lib$3);

  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  let deprecationWarningShown = false;

  function getDefs(chalk) {
    return {
      gutter: chalk.grey,
      marker: chalk.red.bold,
      message: chalk.red.bold
    };
  }

  const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);

    if (startLine === -1) {
      start = 0;
    }

    if (endLine === -1) {
      end = source.length;
    }

    const lineDiff = endLine - startLine;
    const markerLines = {};

    if (lineDiff) {
      for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;

        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }

    return {
      start,
      end,
      markerLines
    };
  }

  function codeFrameColumns$1(rawLines, loc, opts = {}) {
    const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
    const chalk = (0, _highlight.getChalk)(opts);
    const defs = getDefs(chalk);

    const maybeHighlight = (chalkFn, string) => {
      return highlighted ? chalkFn(string) : string;
    };

    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
    let frame = highlightedLines.split(NEWLINE).slice(start, end).map((line, index) => {
      const number = start + 1 + index;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} |`;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];

      if (hasMarker) {
        let markerLine = "";

        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }

        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
      } else {
        return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }
    }).join("\n");

    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
    }

    if (highlighted) {
      return chalk.reset(frame);
    } else {
      return frame;
    }
  }

  function _default$G(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";

      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }

    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns$1(rawLines, location, opts);
  }

  var lib$2 = /*#__PURE__*/Object.defineProperty({
  	codeFrameColumns: codeFrameColumns_1,
  	default: default_1
  }, '__esModule', {value: true});

  var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(dist$1);

  const {
    default: LinesAndColumns
  } = require$$0$1;

  const {
    codeFrameColumns
  } = lib$2;

  const JSONError = errorEx_1('JSONError', {
    fileName: errorEx_1.append('in %s'),
    codeFrame: errorEx_1.append('\n\n%s\n')
  });

  var parseJson = (string, reviver, filename) => {
    if (typeof reviver === 'string') {
      filename = reviver;
      reviver = null;
    }

    try {
      try {
        return JSON.parse(string, reviver);
      } catch (error) {
        jsonParseBetterErrors(string, reviver);
        throw error;
      }
    } catch (error) {
      error.message = error.message.replace(/\n/g, '');
      const indexMatch = error.message.match(/in JSON at position (\d+) while parsing near/);
      const jsonError = new JSONError(error);

      if (filename) {
        jsonError.fileName = filename;
      }

      if (indexMatch && indexMatch.length > 0) {
        const lines = new LinesAndColumns(string);
        const index = Number(indexMatch[1]);
        const location = lines.locationForIndex(index);
        const codeFrame = codeFrameColumns(string, {
          start: {
            line: location.line + 1,
            column: location.column + 1
          }
        }, {
          highlightCode: true
        });
        jsonError.codeFrame = codeFrame;
      }

      throw jsonError;
    }
  };

  function isNothing(subject) {
    return typeof subject === 'undefined' || subject === null;
  }

  function isObject$4(subject) {
    return typeof subject === 'object' && subject !== null;
  }

  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
    return [sequence];
  }

  function extend$1(target, source) {
    var index, length, key, sourceKeys;

    if (source) {
      sourceKeys = Object.keys(source);

      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }

    return target;
  }

  function repeat(string, count) {
    var result = '',
        cycle;

    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }

    return result;
  }

  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }

  var isNothing_1 = isNothing;
  var isObject_1 = isObject$4;
  var toArray_1 = toArray;
  var repeat_1 = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend$1;

  var common$4 = {
  	isNothing: isNothing_1,
  	isObject: isObject_1,
  	toArray: toArray_1,
  	repeat: repeat_1,
  	isNegativeZero: isNegativeZero_1,
  	extend: extend_1
  };

  // YAML error class. http://stackoverflow.com/questions/8458984

  function formatError(exception, compact) {
    var where = '',
        message = exception.reason || '(unknown reason)';
    if (!exception.mark) return message;

    if (exception.mark.name) {
      where += 'in "' + exception.mark.name + '" ';
    }

    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

    if (!compact && exception.mark.snippet) {
      where += '\n\n' + exception.mark.snippet;
    }

    return message + ' ' + where;
  }

  function YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);
    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false); // Include stack trace in error object

    if (Error.captureStackTrace) {
      // Chrome and NodeJS
      Error.captureStackTrace(this, this.constructor);
    } else {
      // FF, IE 10+ and Safari 6+. Fallback for others
      this.stack = new Error().stack || '';
    }
  } // Inherit from Error


  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;

  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ': ' + formatError(this, compact);
  };

  var exception = YAMLException$1;

  // get snippet for a single line, respecting maxLength


  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = '';
    var tail = '';
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

    if (position - lineStart > maxHalfLength) {
      head = ' ... ';
      lineStart = position - maxHalfLength + head.length;
    }

    if (lineEnd - position > maxHalfLength) {
      tail = ' ...';
      lineEnd = position + maxHalfLength - tail.length;
    }

    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '→') + tail,
      pos: position - lineStart + head.length // relative position

    };
  }

  function padStart(string, max) {
    return common$4.repeat(' ', max - string.length) + string;
  }

  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== 'number') options.indent = 1;
    if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
    if (typeof options.linesAfter !== 'number') options.linesAfter = 2;
    var re = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;

    while (match = re.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);

      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }

    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = '',
        i,
        line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

    for (i = 1; i <= options.linesBefore; i++) {
      if (foundLineNo - i < 0) break;
      line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
      result = common$4.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + ' | ' + line.str + '\n' + result;
    }

    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common$4.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + ' | ' + line.str + '\n';
    result += common$4.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

    for (i = 1; i <= options.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length) break;
      line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
      result += common$4.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + ' | ' + line.str + '\n';
    }

    return result.replace(/\n$/, '');
  }

  var snippet = makeSnippet;

  var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'multi', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'representName', 'defaultStyle', 'styleAliases'];
  var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

  function compileStyleAliases(map) {
    var result = {};

    if (map !== null) {
      Object.keys(map).forEach(function (style) {
        map[style].forEach(function (alias) {
          result[String(alias)] = style;
        });
      });
    }

    return result;
  }

  function Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function (name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    }); // TODO: Add tag format check.

    this.options = options; // keep original options in case user wants to extend this type later

    this.tag = tag;
    this.kind = options['kind'] || null;

    this.resolve = options['resolve'] || function () {
      return true;
    };

    this.construct = options['construct'] || function (data) {
      return data;
    };

    this.instanceOf = options['instanceOf'] || null;
    this.predicate = options['predicate'] || null;
    this.represent = options['represent'] || null;
    this.representName = options['representName'] || null;
    this.defaultStyle = options['defaultStyle'] || null;
    this.multi = options['multi'] || false;
    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }

  var type = Type$1;

  /*eslint-disable max-len*/





  function compileList(schema, name) {
    var result = [];
    schema[name].forEach(function (currentType) {
      var newIndex = result.length;
      result.forEach(function (previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }

  function compileMap()
  /* lists... */
  {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    },
        index,
        length;

    function collectType(type) {
      if (type.multi) {
        result.multi[type.kind].push(type);
        result.multi['fallback'].push(type);
      } else {
        result[type.kind][type.tag] = result['fallback'][type.tag] = type;
      }
    }

    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }

    return result;
  }

  function Schema$1(definition) {
    return this.extend(definition);
  }

  Schema$1.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];

    if (definition instanceof type) {
      // Schema.extend(type)
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      // Schema.extend([ type1, type2, ... ])
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
      throw new exception('Schema.extend argument should be a Type, [ Type ], ' + 'or a schema definition ({ implicit: [...], explicit: [...] })');
    }

    implicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }

      if (type$1.loadKind && type$1.loadKind !== 'scalar') {
        throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
      }

      if (type$1.multi) {
        throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
      }
    });
    explicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }
    });
    var result = Object.create(Schema$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, 'implicit');
    result.compiledExplicit = compileList(result, 'explicit');
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };

  var schema = Schema$1;

  var str = new type('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function (data) {
      return data !== null ? data : '';
    }
  });

  var seq = new type('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function (data) {
      return data !== null ? data : [];
    }
  });

  var map = new type('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function (data) {
      return data !== null ? data : {};
    }
  });

  var failsafe = new schema({
    explicit: [str, seq, map]
  });

  function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
  }

  function constructYamlNull() {
    return null;
  }

  function isNull(object) {
    return object === null;
  }

  var _null = new type('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function () {
        return '~';
      },
      lowercase: function () {
        return 'null';
      },
      uppercase: function () {
        return 'NULL';
      },
      camelcase: function () {
        return 'Null';
      },
      empty: function () {
        return '';
      }
    },
    defaultStyle: 'lowercase'
  });

  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
  }

  function constructYamlBoolean(data) {
    return data === 'true' || data === 'True' || data === 'TRUE';
  }

  function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
  }

  var bool = new type('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function (object) {
        return object ? 'true' : 'false';
      },
      uppercase: function (object) {
        return object ? 'TRUE' : 'FALSE';
      },
      camelcase: function (object) {
        return object ? 'True' : 'False';
      }
    },
    defaultStyle: 'lowercase'
  });

  function isHexCode(c) {
    return 0x30
    /* 0 */
    <= c && c <= 0x39
    /* 9 */
    || 0x41
    /* A */
    <= c && c <= 0x46
    /* F */
    || 0x61
    /* a */
    <= c && c <= 0x66
    /* f */
    ;
  }

  function isOctCode(c) {
    return 0x30
    /* 0 */
    <= c && c <= 0x37
    /* 7 */
    ;
  }

  function isDecCode(c) {
    return 0x30
    /* 0 */
    <= c && c <= 0x39
    /* 9 */
    ;
  }

  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;
    if (!max) return false;
    ch = data[index]; // sign

    if (ch === '-' || ch === '+') {
      ch = data[++index];
    }

    if (ch === '0') {
      // 0
      if (index + 1 === max) return true;
      ch = data[++index]; // base 2, base 8, base 16

      if (ch === 'b') {
        // base 2
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (ch !== '0' && ch !== '1') return false;
          hasDigits = true;
        }

        return hasDigits && ch !== '_';
      }

      if (ch === 'x') {
        // base 16
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }

        return hasDigits && ch !== '_';
      }

      if (ch === 'o') {
        // base 8
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }

        return hasDigits && ch !== '_';
      }
    } // base 10 (except 0)
    // value should not start with `_`;


    if (ch === '_') return false;

    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;

      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }

      hasDigits = true;
    } // Should have digits and should not end with `_`


    if (!hasDigits || ch === '_') return false;
    return true;
  }

  function constructYamlInteger(data) {
    var value = data,
        sign = 1,
        ch;

    if (value.indexOf('_') !== -1) {
      value = value.replace(/_/g, '');
    }

    ch = value[0];

    if (ch === '-' || ch === '+') {
      if (ch === '-') sign = -1;
      value = value.slice(1);
      ch = value[0];
    }

    if (value === '0') return 0;

    if (ch === '0') {
      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
      if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
      if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
    }

    return sign * parseInt(value, 10);
  }

  function isInteger(object) {
    return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common$4.isNegativeZero(object);
  }

  var int = new type('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function (obj) {
        return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
      },
      octal: function (obj) {
        return obj >= 0 ? '0o' + obj.toString(8) : '-0o' + obj.toString(8).slice(1);
      },
      decimal: function (obj) {
        return obj.toString(10);
      },

      /* eslint-disable max-len */
      hexadecimal: function (obj) {
        return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary: [2, 'bin'],
      octal: [8, 'oct'],
      decimal: [10, 'dec'],
      hexadecimal: [16, 'hex']
    }
  });

  var YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' + // .nan
  '|\\.(?:nan|NaN|NAN))$');

  function resolveYamlFloat(data) {
    if (data === null) return false;

    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === '_') {
      return false;
    }

    return true;
  }

  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, '').toLowerCase();
    sign = value[0] === '-' ? -1 : 1;

    if ('+-'.indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }

    if (value === '.inf') {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === '.nan') {
      return NaN;
    }

    return sign * parseFloat(value, 10);
  }

  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

  function representYamlFloat(object, style) {
    var res;

    if (isNaN(object)) {
      switch (style) {
        case 'lowercase':
          return '.nan';

        case 'uppercase':
          return '.NAN';

        case 'camelcase':
          return '.NaN';
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase':
          return '.inf';

        case 'uppercase':
          return '.INF';

        case 'camelcase':
          return '.Inf';
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase':
          return '-.inf';

        case 'uppercase':
          return '-.INF';

        case 'camelcase':
          return '-.Inf';
      }
    } else if (common$4.isNegativeZero(object)) {
      return '-0.0';
    }

    res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack

    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
  }

  function isFloat(object) {
    return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common$4.isNegativeZero(object));
  }

  var float = new type('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
  });

  var json = failsafe.extend({
    implicit: [_null, bool, int, float]
  });

  var core$1 = json;

  var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
  '-([0-9][0-9])' + // [2] month
  '-([0-9][0-9])$'); // [3] day

  var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
  '-([0-9][0-9]?)' + // [2] month
  '-([0-9][0-9]?)' + // [3] day
  '(?:[Tt]|[ \\t]+)' + // ...
  '([0-9][0-9]?)' + // [4] hour
  ':([0-9][0-9])' + // [5] minute
  ':([0-9][0-9])' + // [6] second
  '(?:\\.([0-9]*))?' + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$'); // [11] tz_minute

  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }

  function constructYamlTimestamp(data) {
    var match,
        year,
        month,
        day,
        hour,
        minute,
        second,
        fraction = 0,
        delta = null,
        tz_hour,
        tz_minute,
        date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day

    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0

    day = +match[3];

    if (!match[4]) {
      // no hour
      return new Date(Date.UTC(year, month, day));
    } // match: [4] hour [5] minute [6] second [7] fraction


    hour = +match[4];
    minute = +match[5];
    second = +match[6];

    if (match[7]) {
      fraction = match[7].slice(0, 3);

      while (fraction.length < 3) {
        // milli-seconds
        fraction += '0';
      }

      fraction = +fraction;
    } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute


    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds

      if (match[9] === '-') delta = -delta;
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }

  function representYamlTimestamp(object
  /*, style*/
  ) {
    return object.toISOString();
  }

  var timestamp = new type('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });

  function resolveYamlMerge(data) {
    return data === '<<' || data === null;
  }

  var merge = new type('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
  });

  /*eslint-disable no-bitwise*/

   // [ 64, 65, 66 ] -> [ padding, CR, LF ]


  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code,
        idx,
        bitlen = 0,
        max = data.length,
        map = BASE64_MAP; // Convert one by one.

    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx)); // Skip CR/LF

      if (code > 64) continue; // Fail on illegal characters

      if (code < 0) return false;
      bitlen += 6;
    } // If there are any bits left, source was corrupted


    return bitlen % 8 === 0;
  }

  function constructYamlBinary(data) {
    var idx,
        tailbits,
        input = data.replace(/[\r\n=]/g, ''),
        // remove CR/LF & padding to simplify scan
    max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = []; // Collect by 6*4 bits (3 bytes)

    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
      }

      bits = bits << 6 | map.indexOf(input.charAt(idx));
    } // Dump tail


    tailbits = max % 4 * 6;

    if (tailbits === 0) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 0xFF);
      result.push(bits >> 2 & 0xFF);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 0xFF);
    }

    return new Uint8Array(result);
  }

  function representYamlBinary(object
  /*, style*/
  ) {
    var result = '',
        bits = 0,
        idx,
        tail,
        max = object.length,
        map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.

    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
      }

      bits = (bits << 8) + object[idx];
    } // Dump tail


    tail = max % 3;

    if (tail === 0) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    } else if (tail === 2) {
      result += map[bits >> 10 & 0x3F];
      result += map[bits >> 4 & 0x3F];
      result += map[bits << 2 & 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[bits >> 2 & 0x3F];
      result += map[bits << 4 & 0x3F];
      result += map[64];
      result += map[64];
    }

    return result;
  }

  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === '[object Uint8Array]';
  }

  var binary = new type('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });

  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2 = Object.prototype.toString;

  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [],
        index,
        length,
        pair,
        pairKey,
        pairHasKey,
        object = data;

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString$2.call(pair) !== '[object Object]') return false;

      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;else return false;
        }
      }

      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
    }

    return true;
  }

  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }

  var omap = new type('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });

  var _toString$1 = Object.prototype.toString;

  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index,
        length,
        pair,
        keys,
        result,
        object = data;
    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString$1.call(pair) !== '[object Object]') return false;
      keys = Object.keys(pair);
      if (keys.length !== 1) return false;
      result[index] = [keys[0], pair[keys[0]]];
    }

    return true;
  }

  function constructYamlPairs(data) {
    if (data === null) return [];
    var index,
        length,
        pair,
        keys,
        result,
        object = data;
    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }

    return result;
  }

  var pairs = new type('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });

  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

  function resolveYamlSet(data) {
    if (data === null) return true;
    var key,
        object = data;

    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }

    return true;
  }

  function constructYamlSet(data) {
    return data !== null ? data : {};
  }

  var set$1 = new type('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });

  var _default$F = core$1.extend({
    implicit: [timestamp, merge],
    explicit: [binary, omap, pairs, set$1]
  });

  /*eslint-disable max-len,no-use-before-define*/









  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }

  function is_EOL(c) {
    return c === 0x0A
    /* LF */
    || c === 0x0D
    /* CR */
    ;
  }

  function is_WHITE_SPACE(c) {
    return c === 0x09
    /* Tab */
    || c === 0x20
    /* Space */
    ;
  }

  function is_WS_OR_EOL(c) {
    return c === 0x09
    /* Tab */
    || c === 0x20
    /* Space */
    || c === 0x0A
    /* LF */
    || c === 0x0D
    /* CR */
    ;
  }

  function is_FLOW_INDICATOR(c) {
    return c === 0x2C
    /* , */
    || c === 0x5B
    /* [ */
    || c === 0x5D
    /* ] */
    || c === 0x7B
    /* { */
    || c === 0x7D
    /* } */
    ;
  }

  function fromHexCode(c) {
    var lc;

    if (0x30
    /* 0 */
    <= c && c <= 0x39
    /* 9 */
    ) {
      return c - 0x30;
    }
    /*eslint-disable no-bitwise*/


    lc = c | 0x20;

    if (0x61
    /* a */
    <= lc && lc <= 0x66
    /* f */
    ) {
      return lc - 0x61 + 10;
    }

    return -1;
  }

  function escapedHexLen(c) {
    if (c === 0x78
    /* x */
    ) {
        return 2;
      }

    if (c === 0x75
    /* u */
    ) {
        return 4;
      }

    if (c === 0x55
    /* U */
    ) {
        return 8;
      }

    return 0;
  }

  function fromDecimalCode(c) {
    if (0x30
    /* 0 */
    <= c && c <= 0x39
    /* 9 */
    ) {
      return c - 0x30;
    }

    return -1;
  }

  function simpleEscapeSequence(c) {
    /* eslint-disable indent */
    return c === 0x30
    /* 0 */
    ? '\x00' : c === 0x61
    /* a */
    ? '\x07' : c === 0x62
    /* b */
    ? '\x08' : c === 0x74
    /* t */
    ? '\x09' : c === 0x09
    /* Tab */
    ? '\x09' : c === 0x6E
    /* n */
    ? '\x0A' : c === 0x76
    /* v */
    ? '\x0B' : c === 0x66
    /* f */
    ? '\x0C' : c === 0x72
    /* r */
    ? '\x0D' : c === 0x65
    /* e */
    ? '\x1B' : c === 0x20
    /* Space */
    ? ' ' : c === 0x22
    /* " */
    ? '\x22' : c === 0x2F
    /* / */
    ? '/' : c === 0x5C
    /* \ */
    ? '\x5C' : c === 0x4E
    /* N */
    ? '\x85' : c === 0x5F
    /* _ */
    ? '\xA0' : c === 0x4C
    /* L */
    ? '\u2028' : c === 0x50
    /* P */
    ? '\u2029' : '';
  }

  function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
      return String.fromCharCode(c);
    } // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF


    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
  }

  var simpleEscapeCheck = new Array(256); // integer, for fast access

  var simpleEscapeMap = new Array(256);

  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }

  function State$1(input, options) {
    this.input = input;
    this.filename = options['filename'] || null;
    this.schema = options['schema'] || _default$F;
    this.onWarning = options['onWarning'] || null; // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
    // if such documents have no explicit %YAML directive

    this.legacy = options['legacy'] || false;
    this.json = options['json'] || false;
    this.listener = options['listener'] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0; // position of first leading tab in the current line,
    // used to make sure there are no tabs in the indentation

    this.firstTabInLine = -1;
    this.documents = [];
    /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/
  }

  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
  }

  function throwError$2(state, message) {
    throw generateError(state, message);
  }

  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }

  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;

      if (state.version !== null) {
        throwError$2(state, 'duplication of %YAML directive');
      }

      if (args.length !== 1) {
        throwError$2(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (match === null) {
        throwError$2(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (major !== 1) {
        throwError$2(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = minor < 2;

      if (minor !== 1 && minor !== 2) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;

      if (args.length !== 2) {
        throwError$2(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError$2(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError$2(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError$2(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError$2(state, 'tag prefix is malformed: ' + prefix);
      }

      state.tagMap[handle] = prefix;
    }
  };

  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start < end) {
      _result = state.input.slice(start, end);

      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);

          if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
            throwError$2(state, 'expected valid JSON character');
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError$2(state, 'the stream contains non-printable characters');
      }

      state.result += _result;
    }
  }

  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;

    if (!common$4.isObject(source)) {
      throwError$2(state, 'cannot merge mappings; the provided source object is unacceptable');
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }

  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity; // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).

    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);

      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError$2(state, 'nested arrays are not supported inside keys');
        }

        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
          keyNode[index] = '[object Object]';
        }
      }
    } // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)


    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
      keyNode = '[object Object]';
    }

    keyNode = String(keyNode);

    if (_result === null) {
      _result = {};
    }

    if (keyTag === 'tag:yaml.org,2002:merge') {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError$2(state, 'duplicated mapping key');
      } // used for this specific key only because Object.defineProperty is slow


      if (keyNode === '__proto__') {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }

      delete overridableKeys[keyNode];
    }

    return _result;
  }

  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);

    if (ch === 0x0A
    /* LF */
    ) {
        state.position++;
      } else if (ch === 0x0D
    /* CR */
    ) {
        state.position++;

        if (state.input.charCodeAt(state.position) === 0x0A
        /* LF */
        ) {
            state.position++;
          }
      } else {
      throwError$2(state, 'a line break is expected');
    }

    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }

  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 0x09
        /* Tab */
        && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }

        ch = state.input.charCodeAt(++state.position);
      }

      if (allowComments && ch === 0x23
      /* # */
      ) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0x0A
          /* LF */
          && ch !== 0x0D
          /* CR */
          && ch !== 0);
        }

      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;

        while (ch === 0x20
        /* Space */
        ) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }

    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, 'deficient indentation');
    }

    return lineBreaks;
  }

  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;
    ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.

    if ((ch === 0x2D
    /* - */
    || ch === 0x2E
    /* . */
    ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);

      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += ' ';
    } else if (count > 1) {
      state.result += common$4.repeat('\n', count - 1);
    }
  }

  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23
    /* # */
    || ch === 0x26
    /* & */
    || ch === 0x2A
    /* * */
    || ch === 0x21
    /* ! */
    || ch === 0x7C
    /* | */
    || ch === 0x3E
    /* > */
    || ch === 0x27
    /* ' */
    || ch === 0x22
    /* " */
    || ch === 0x25
    /* % */
    || ch === 0x40
    /* @ */
    || ch === 0x60
    /* ` */
    ) {
        return false;
      }

    if (ch === 0x3F
    /* ? */
    || ch === 0x2D
    /* - */
    ) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }

    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;

    while (ch !== 0) {
      if (ch === 0x3A
      /* : */
      ) {
          following = state.input.charCodeAt(state.position + 1);

          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 0x23
      /* # */
      ) {
          preceding = state.input.charCodeAt(state.position - 1);

          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);

        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }

      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, captureEnd, false);

    if (state.result) {
      return true;
    }

    state.kind = _kind;
    state.result = _result;
    return false;
  }

  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x27
    /* ' */
    ) {
        return false;
      }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27
      /* ' */
      ) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);

          if (ch === 0x27
          /* ' */
          ) {
              captureStart = state.position;
              state.position++;
              captureEnd = state.position;
            } else {
            return true;
          }
        } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError$2(state, 'unexpected end of the document within a single quoted scalar');
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError$2(state, 'unexpected end of the stream within a single quoted scalar');
  }

  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x22
    /* " */
    ) {
        return false;
      }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22
      /* " */
      ) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 0x5C
      /* \ */
      ) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);

          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;

            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);

              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError$2(state, 'expected hexadecimal character');
              }
            }

            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError$2(state, 'unknown escape sequence');
          }

          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError$2(state, 'unexpected end of the document within a double quoted scalar');
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError$2(state, 'unexpected end of the stream within a double quoted scalar');
  }

  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _lineStart,
        _pos,
        _tag = state.tag,
        _result,
        _anchor = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = Object.create(null),
        keyNode,
        keyTag,
        valueNode,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x5B
    /* [ */
    ) {
        terminator = 0x5D;
        /* ] */

        isMapping = false;
        _result = [];
      } else if (ch === 0x7B
    /* { */
    ) {
        terminator = 0x7D;
        /* } */

        isMapping = true;
        _result = {};
      } else {
      return false;
    }

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(++state.position);

    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);

      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? 'mapping' : 'sequence';
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError$2(state, 'missed comma between flow collection entries');
      } else if (ch === 0x2C
      /* , */
      ) {
          // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
          throwError$2(state, "expected the node content, but found ','");
        }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (ch === 0x3F
      /* ? */
      ) {
          following = state.input.charCodeAt(state.position + 1);

          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }

      _line = state.line; // Save the current line.

      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);

      if ((isExplicitPair || state.line === _line) && ch === 0x3A
      /* : */
      ) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }

      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);

      if (ch === 0x2C
      /* , */
      ) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
        readNext = false;
      }
    }

    throwError$2(state, 'unexpected end of the stream within a flow collection');
  }

  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent = nodeIndent,
        emptyLines = 0,
        atMoreIndented = false,
        tmp,
        ch;
    ch = state.input.charCodeAt(state.position);

    if (ch === 0x7C
    /* | */
    ) {
        folding = false;
      } else if (ch === 0x3E
    /* > */
    ) {
        folding = true;
      } else {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';

    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x2B
      /* + */
      || ch === 0x2D
      /* - */
      ) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 0x2B
            /* + */
            ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError$2(state, 'repeat of a chomping mode identifier');
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError$2(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError$2(state, 'repeat of an indentation width identifier');
        }
      } else {
        break;
      }
    }

    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));

      if (ch === 0x23
      /* # */
      ) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
    }

    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);

      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20
      /* Space */
      ) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }

      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      } // End of the scalar.


      if (state.lineIndent < textIndent) {
        // Perform the chomping.
        if (chomping === CHOMPING_KEEP) {
          state.result += common$4.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            // i.e. only if the scalar is not empty.
            state.result += '\n';
          }
        } // Break this `while` cycle and go to the funciton's epilogue.


        break;
      } // Folded style: use fancy rules to handle line breaks.


      if (folding) {
        // Lines starting with white space characters (more-indented lines) are not folded.
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true; // except for the first content line (cf. Example 8.1)

          state.result += common$4.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common$4.repeat('\n', emptyLines + 1); // Just one line break - perceive as the same line.
        } else if (emptyLines === 0) {
          if (didReadContent) {
            // i.e. only if we have already read some scalar content.
            state.result += ' ';
          } // Several line breaks - perceive as different lines.

        } else {
          state.result += common$4.repeat('\n', emptyLines);
        } // Literal style: just add exact number of line breaks between content lines.

      } else {
        // Keep all line breaks except the header line break.
        state.result += common$4.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      }

      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;

      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }

      captureSegment(state, captureStart, state.position, false);
    }

    return true;
  }

  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = [],
        following,
        detected = false,
        ch; // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar


    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError$2(state, 'tab characters must not be used in indentation');
      }

      if (ch !== 0x2D
      /* - */
      ) {
          break;
        }

      following = state.input.charCodeAt(state.position + 1);

      if (!is_WS_OR_EOL(following)) {
        break;
      }

      detected = true;
      state.position++;

      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);

          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);

      _result.push(state.result);

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);

      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError$2(state, 'bad indentation of a sequence entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'sequence';
      state.result = _result;
      return true;
    }

    return false;
  }

  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _keyLine,
        _keyLineStart,
        _keyPos,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = {},
        overridableKeys = Object.create(null),
        keyTag = null,
        keyNode = null,
        valueNode = null,
        atExplicitKey = false,
        detected = false,
        ch; // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar


    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError$2(state, 'tab characters must not be used in indentation');
      }

      following = state.input.charCodeAt(state.position + 1);
      _line = state.line; // Save the current line.
      //
      // Explicit notation case. There are two separate blocks:
      // first for the key (denoted by "?") and second for the value (denoted by ":")
      //

      if ((ch === 0x3F
      /* ? */
      || ch === 0x3A
      /* : */
      ) && is_WS_OR_EOL(following)) {
        if (ch === 0x3F
        /* ? */
        ) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
          // i.e. 0x3A/* : */ === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError$2(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
        }

        state.position += 1;
        ch = following; //
        // Implicit notation case. Flow-style node as the key first, then ":", and the value.
        //
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;

        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          // Neither implicit nor explicit notation.
          // Reading is done. Go to the epilogue.
          break;
        }

        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);

          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (ch === 0x3A
          /* : */
          ) {
              ch = state.input.charCodeAt(++state.position);

              if (!is_WS_OR_EOL(ch)) {
                throwError$2(state, 'a whitespace character is expected after the key-value separator within a block mapping');
              }

              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }

              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
            throwError$2(state, 'can not read an implicit mapping pair; a colon is missed');
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }
        } else if (detected) {
          throwError$2(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      } //
      // Common reading code for both explicit and implicit notations.
      //


      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }

        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }

      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError$2(state, 'bad indentation of a mapping entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    } //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.


    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    } // Expose the resulting mapping.


    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'mapping';
      state.result = _result;
    }

    return detected;
  }

  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed = false,
        tagHandle,
        tagName,
        ch;

    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21
    /* ! */
    ) return false;

    if (state.tag !== null) {
      throwError$2(state, 'duplication of a tag property');
    }

    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x3C
    /* < */
    ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 0x21
    /* ! */
    ) {
        isNamed = true;
        tagHandle = '!!';
        ch = state.input.charCodeAt(++state.position);
      } else {
      tagHandle = '!';
    }

    _position = state.position;

    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 0x3E
      /* > */
      );

      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError$2(state, 'unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 0x21
        /* ! */
        ) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);

              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError$2(state, 'named tag handle cannot contain such characters');
              }

              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError$2(state, 'tag suffix cannot contain exclamation marks');
            }
          }

        ch = state.input.charCodeAt(++state.position);
      }

      tagName = state.input.slice(_position, state.position);

      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError$2(state, 'tag suffix cannot contain flow indicator characters');
      }
    }

    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError$2(state, 'tag name cannot contain such characters: ' + tagName);
    }

    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError$2(state, 'tag name is malformed: ' + tagName);
    }

    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === '!') {
      state.tag = '!' + tagName;
    } else if (tagHandle === '!!') {
      state.tag = 'tag:yaml.org,2002:' + tagName;
    } else {
      throwError$2(state, 'undeclared tag handle "' + tagHandle + '"');
    }

    return true;
  }

  function readAnchorProperty(state) {
    var _position, ch;

    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26
    /* & */
    ) return false;

    if (state.anchor !== null) {
      throwError$2(state, 'duplication of an anchor property');
    }

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError$2(state, 'name of an anchor node must contain at least one character');
    }

    state.anchor = state.input.slice(_position, state.position);
    return true;
  }

  function readAlias(state) {
    var _position, alias, ch;

    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A
    /* * */
    ) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError$2(state, 'name of an alias node must contain at least one character');
    }

    alias = state.input.slice(_position, state.position);

    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError$2(state, 'unidentified alias "' + alias + '"');
    }

    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }

  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1,
        // 1: this>parent, 0: this=parent, -1: this<parent
    atNewLine = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        typeList,
        type,
        flowIndent,
        blockIndent;

    if (state.listener !== null) {
      state.listener('open', state);
    }

    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }

    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;

          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = state.position - state.lineStart;

      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;

            if (state.tag !== null || state.anchor !== null) {
              throwError$2(state, 'alias node should not have any properties');
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (state.tag === null) {
              state.tag = '?';
            }
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }

    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError$2(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) {
          // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }

          break;
        }
      }
    } else if (state.tag !== '!') {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
        type = state.typeMap[state.kind || 'fallback'][state.tag];
      } else {
        // looking for multi type
        type = null;
        typeList = state.typeMap.multi[state.kind || 'fallback'];

        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type = typeList[typeIndex];
            break;
          }
        }
      }

      if (!type) {
        throwError$2(state, 'unknown tag !<' + state.tag + '>');
      }

      if (state.result !== null && type.kind !== state.kind) {
        throwError$2(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result, state.tag)) {
        // `state.result` updated in resolver if matched
        throwError$2(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result, state.tag);

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }

    if (state.listener !== null) {
      state.listener('close', state);
    }

    return state.tag !== null || state.anchor !== null || hasContent;
  }

  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;

    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);

      if (state.lineIndent > 0 || ch !== 0x25
      /* % */
      ) {
          break;
        }

      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];

      if (directiveName.length < 1) {
        throwError$2(state, 'directive name must not be less than one character in length');
      }

      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x23
        /* # */
        ) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));

            break;
          }

        if (is_EOL(ch)) break;
        _position = state.position;

        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        directiveArgs.push(state.input.slice(_position, state.position));
      }

      if (ch !== 0) readLineBreak(state);

      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }

    skipSeparationSpace(state, true, -1);

    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D
    /* - */
    && state.input.charCodeAt(state.position + 1) === 0x2D
    /* - */
    && state.input.charCodeAt(state.position + 2) === 0x2D
    /* - */
    ) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
      throwError$2(state, 'directives end mark is expected');
    }

    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);

    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }

    state.documents.push(state.result);

    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 0x2E
      /* . */
      ) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }

      return;
    }

    if (state.position < state.length - 1) {
      throwError$2(state, 'end of the stream or a document separator is expected');
    } else {
      return;
    }
  }

  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};

    if (input.length !== 0) {
      // Add tailing `\n` if not exists
      if (input.charCodeAt(input.length - 1) !== 0x0A
      /* LF */
      && input.charCodeAt(input.length - 1) !== 0x0D
      /* CR */
      ) {
          input += '\n';
        } // Strip BOM


      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }

    var state = new State$1(input, options);
    var nullpos = input.indexOf('\0');

    if (nullpos !== -1) {
      state.position = nullpos;
      throwError$2(state, 'null byte is not allowed in input');
    } // Use 0 as string terminator. That significantly simplifies bounds check.


    state.input += '\0';

    while (state.input.charCodeAt(state.position) === 0x20
    /* Space */
    ) {
      state.lineIndent += 1;
      state.position += 1;
    }

    while (state.position < state.length - 1) {
      readDocument(state);
    }

    return state.documents;
  }

  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
      options = iterator;
      iterator = null;
    }

    var documents = loadDocuments(input, options);

    if (typeof iterator !== 'function') {
      return documents;
    }

    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }

  function load$1(input, options) {
    var documents = loadDocuments(input, options);

    if (documents.length === 0) {
      /*eslint-disable no-undefined*/
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }

    throw new exception('expected a single document in the stream, but found more');
  }

  var loadAll_1 = loadAll$1;
  var load_1 = load$1;

  var loader = {
  	loadAll: loadAll_1,
  	load: load_1
  };

  /*eslint-disable no-use-before-define*/







  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 0xFEFF;
  var CHAR_TAB = 0x09;
  /* Tab */

  var CHAR_LINE_FEED = 0x0A;
  /* LF */

  var CHAR_CARRIAGE_RETURN = 0x0D;
  /* CR */

  var CHAR_SPACE = 0x20;
  /* Space */

  var CHAR_EXCLAMATION = 0x21;
  /* ! */

  var CHAR_DOUBLE_QUOTE$1 = 0x22;
  /* " */

  var CHAR_SHARP = 0x23;
  /* # */

  var CHAR_PERCENT = 0x25;
  /* % */

  var CHAR_AMPERSAND = 0x26;
  /* & */

  var CHAR_SINGLE_QUOTE$1 = 0x27;
  /* ' */

  var CHAR_ASTERISK$3 = 0x2A;
  /* * */

  var CHAR_COMMA$4 = 0x2C;
  /* , */

  var CHAR_MINUS = 0x2D;
  /* - */

  var CHAR_COLON = 0x3A;
  /* : */

  var CHAR_EQUALS = 0x3D;
  /* = */

  var CHAR_GREATER_THAN = 0x3E;
  /* > */

  var CHAR_QUESTION = 0x3F;
  /* ? */

  var CHAR_COMMERCIAL_AT = 0x40;
  /* @ */

  var CHAR_LEFT_SQUARE_BRACKET$4 = 0x5B;
  /* [ */

  var CHAR_RIGHT_SQUARE_BRACKET$4 = 0x5D;
  /* ] */

  var CHAR_GRAVE_ACCENT = 0x60;
  /* ` */

  var CHAR_LEFT_CURLY_BRACKET = 0x7B;
  /* { */

  var CHAR_VERTICAL_LINE = 0x7C;
  /* | */

  var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
  /* } */

  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0x00] = '\\0';
  ESCAPE_SEQUENCES[0x07] = '\\a';
  ESCAPE_SEQUENCES[0x08] = '\\b';
  ESCAPE_SEQUENCES[0x09] = '\\t';
  ESCAPE_SEQUENCES[0x0A] = '\\n';
  ESCAPE_SEQUENCES[0x0B] = '\\v';
  ESCAPE_SEQUENCES[0x0C] = '\\f';
  ESCAPE_SEQUENCES[0x0D] = '\\r';
  ESCAPE_SEQUENCES[0x1B] = '\\e';
  ESCAPE_SEQUENCES[0x22] = '\\"';
  ESCAPE_SEQUENCES[0x5C] = '\\\\';
  ESCAPE_SEQUENCES[0x85] = '\\N';
  ESCAPE_SEQUENCES[0xA0] = '\\_';
  ESCAPE_SEQUENCES[0x2028] = '\\L';
  ESCAPE_SEQUENCES[0x2029] = '\\P';
  var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null) return {};
    result = {};
    keys = Object.keys(map);

    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);

      if (tag.slice(0, 2) === '!!') {
        tag = 'tag:yaml.org,2002:' + tag.slice(2);
      }

      type = schema.compiledTypeMap['fallback'][tag];

      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }

      result[tag] = style;
    }

    return result;
  }

  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();

    if (character <= 0xFF) {
      handle = 'x';
      length = 2;
    } else if (character <= 0xFFFF) {
      handle = 'u';
      length = 4;
    } else if (character <= 0xFFFFFFFF) {
      handle = 'U';
      length = 8;
    } else {
      throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
    }

    return '\\' + handle + common$4.repeat('0', length - string.length) + string;
  }

  var QUOTING_TYPE_SINGLE = 1,
      QUOTING_TYPE_DOUBLE = 2;

  function State(options) {
    this.schema = options['schema'] || _default$F;
    this.indent = Math.max(1, options['indent'] || 2);
    this.noArrayIndent = options['noArrayIndent'] || false;
    this.skipInvalid = options['skipInvalid'] || false;
    this.flowLevel = common$4.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys = options['sortKeys'] || false;
    this.lineWidth = options['lineWidth'] || 80;
    this.noRefs = options['noRefs'] || false;
    this.noCompatMode = options['noCompatMode'] || false;
    this.condenseFlow = options['condenseFlow'] || false;
    this.quotingType = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options['forceQuotes'] || false;
    this.replacer = typeof options['replacer'] === 'function' ? options['replacer'] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = '';
    this.duplicates = [];
    this.usedDuplicates = null;
  } // Indents every line in a string. Empty lines (\n only) are not indented.


  function indentString(string, spaces) {
    var ind = common$4.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;

    while (position < length) {
      next = string.indexOf('\n', position);

      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }

      if (line.length && line !== '\n') result += ind;
      result += line;
    }

    return result;
  }

  function generateNextLine(state, level) {
    return '\n' + common$4.repeat(' ', state.indent * level);
  }

  function testImplicitResolving(state, str) {
    var index, length, type;

    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];

      if (type.resolve(str)) {
        return true;
      }
    }

    return false;
  } // [33] s-white ::= s-space | s-tab


  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  } // Returns true if the character can be printed without escaping.
  // From YAML 1.2: "any allowed characters known to be non-printable
  // should also be escaped. [However,] This isn’t mandatory"
  // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.


  function isPrintable(c) {
    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;
  } // [34] ns-char ::= nb-char - s-white
  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
  // [26] b-char  ::= b-line-feed | b-carriage-return
  // Including s-white (for some reason, examples doesn't match specs in this aspect)
  // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark


  function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM // - b-char
    && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  } // [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out
  //                             c = flow-in   ⇒ ns-plain-safe-in
  //                             c = block-key ⇒ ns-plain-safe-out
  //                             c = flow-key  ⇒ ns-plain-safe-in
  // [128] ns-plain-safe-out ::= ns-char
  // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
  // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )
  //                            | ( /* An ns-char preceding */ “#” )
  //                            | ( “:” /* Followed by an ns-plain-safe(c) */ )


  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return ( // ns-plain-safe
    inblock ? // c = flow-in
    cIsNsCharOrWhitespace : cIsNsCharOrWhitespace // - c-flow-indicator
    && c !== CHAR_COMMA$4 && c !== CHAR_LEFT_SQUARE_BRACKET$4 && c !== CHAR_RIGHT_SQUARE_BRACKET$4 && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && // ns-plain-char
    c !== CHAR_SHARP // false on '#'
    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
    || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP // change to true on '[^ ]#'
    || prev === CHAR_COLON && cIsNsChar; // change to true on ':[^ ]'
  } // Simplified test for values allowed as the first character in plain style.


  function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA$4 && c !== CHAR_LEFT_SQUARE_BRACKET$4 && c !== CHAR_RIGHT_SQUARE_BRACKET$4 && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
    && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK$3 && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE$1 && c !== CHAR_DOUBLE_QUOTE$1 // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  } // Simplified test for values allowed as the last character in plain style.


  function isPlainSafeLast(c) {
    // just not whitespace or colon, it will be checked to be plain character later
    return !isWhitespace(c) && c !== CHAR_COLON;
  } // Same as 'string'.codePointAt(pos), but works in older browsers.


  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos),
        second;

    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);

      if (second >= 0xDC00 && second <= 0xDFFF) {
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }

    return first;
  } // Determines whether block indentation indicator is required.


  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }

  var STYLE_PLAIN = 1,
      STYLE_SINGLE = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED = 4,
      STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.
  // lineWidth = -1 => no limit.
  // Pre-conditions: str.length > 0.
  // Post-conditions:
  //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).

  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth

    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly

    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));

    if (singleLineOnly || forceQuotes) {
      // Case: no block styles.
      // Check for disallowed characters to rule out plain and single.
      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);

        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }

        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      // Case: block styles permitted.
      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);

        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true; // Check if any line can be folded.

          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }

        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      } // in case the end is missing a \n


      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
    } // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.


    if (!hasLineBreak && !hasFoldableLine) {
      // Strings interpretable as another type have to be quoted;
      // e.g. the string 'true' vs. the boolean true.
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }

      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    } // Edge case: block indentation indicator can only have one digit.


    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    } // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.


    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }

    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  } // Note: line breaking/folding is implemented for only the folded style.
  // NB. We drop the last trailing newline (if any) of a returned block scalar
  //  since the dumper adds its own newline. This always works:
  //    • No ending newline => unaffected; already using strip "-" chomping.
  //    • Ending newline    => removed then restored.
  //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.


  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function () {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }

      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }

      var indent = state.indent * Math.max(1, level); // no 0-indent scalars
      // As indentation gets deeper, let the width decrease monotonically
      // to the lower bound min(state.lineWidth, 40).
      // Note that this implies
      //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
      // This behaves better than a constant minimum width which disallows narrower options,
      // or an indent threshold which causes the width to suddenly increase.

      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.

      var singleLineOnly = iskey // No block styles in flow mode.
      || state.flowLevel > -1 && level >= state.flowLevel;

      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }

      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
        case STYLE_PLAIN:
          return string;

        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";

        case STYLE_LITERAL:
          return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));

        case STYLE_FOLDED:
          return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));

        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';

        default:
          throw new exception('impossible error: invalid scalar style');
      }
    }();
  } // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.


  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\n' counts as a "trailing" empty line.

    var clip = string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : clip ? '' : '-';
    return indentIndicator + chomp + '\n';
  } // (See the note for writeScalar.)


  function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
  } // Note: a long line without a suitable break point will exceed the width limit.
  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.


  function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g; // first line (possibly an empty line)

    var result = function () {
      var nextLF = string.indexOf('\n');
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }(); // If we haven't reached the first content line yet, don't add an extra \n.


    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented; // rest of the lines

    var match;

    while (match = lineRe.exec(string)) {
      var prefix = match[1],
          line = match[2];
      moreIndented = line[0] === ' ';
      result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }

    return result;
  } // Greedy line breaking.
  // Picks the longest line under the limit each time,
  // otherwise settles for the shortest line over the limit.
  // NB. More-indented lines *cannot* be folded, as that would add an extra \n.


  function foldLine(line, width) {
    if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \n, breaks can't be followed by a space.

    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.

    var match; // start is an inclusive index. end, curr, and next are exclusive.

    var start = 0,
        end,
        curr = 0,
        next = 0;
    var result = ''; // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.

    while (match = breakRe.exec(line)) {
      next = match.index; // maintain invariant: curr - start <= width

      if (next - start > width) {
        end = curr > start ? curr : next; // derive end <= length-2

        result += '\n' + line.slice(start, end); // skip the space that was output as \n

        start = end + 1; // derive start <= length-1
      }

      curr = next;
    } // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.


    result += '\n'; // Insert a break if the remainder is too long and there is a break available.

    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }

    return result.slice(1); // drop extra \n joiner
  } // Escapes a double-quoted string.


  function escapeString(string) {
    var result = '';
    var char = 0;
    var escapeSeq;

    for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];

      if (!escapeSeq && isPrintable(char)) {
        result += string[i];
        if (char >= 0x10000) result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }

    return result;
  }

  function writeFlowSequence(state, level, object) {
    var _result = '',
        _tag = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      } // Write only valid elements, put null instead of invalid elements.


      if (writeNode(state, level, value, false, false) || typeof value === 'undefined' && writeNode(state, level, null, false, false)) {
        if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = '[' + _result + ']';
  }

  function writeBlockSequence(state, level, object, compact) {
    var _result = '',
        _tag = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      } // Write only valid elements, put null instead of invalid elements.


      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === 'undefined' && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== '') {
          _result += generateNextLine(state, level);
        }

        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += '-';
        } else {
          _result += '- ';
        }

        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
  }

  function writeFlowMapping(state, level, object) {
    var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';
      if (_result !== '') pairBuffer += ', ';
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (state.dump.length > 1024) pairBuffer += '? ';
      pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

      if (!writeNode(state, level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += state.dump; // Both key and value are valid.

      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = '{' + _result + '}';
  }

  function writeBlockMapping(state, level, object, compact) {
    var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer; // Allow sorting keys so that the output file is deterministic

    if (state.sortKeys === true) {
      // Default sorting
      objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
      // Custom sort function
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      // Something is wrong
      throw new exception('sortKeys must be a boolean or a function');
    }

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (!compact || _result !== '') {
        pairBuffer += generateNextLine(state, level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;

      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += '?';
        } else {
          pairBuffer += '? ';
        }
      }

      pairBuffer += state.dump;

      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }

      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ':';
      } else {
        pairBuffer += ': ';
      }

      pairBuffer += state.dump; // Both key and value are valid.

      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
  }

  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? state.explicitTypes : state.implicitTypes;

    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];

      if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
        if (explicit) {
          if (type.multi && type.representName) {
            state.tag = type.representName(object);
          } else {
            state.tag = type.tag;
          }
        } else {
          state.tag = '?';
        }

        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;

          if (_toString.call(type.represent) === '[object Function]') {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }

          state.dump = _result;
        }

        return true;
      }
    }

    return false;
  } // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //


  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;

    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }

    var type = _toString.call(state.dump);

    var inblock = block;
    var tagStr;

    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }

    var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;

    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }

    if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }

    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = '*ref_' + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }

      if (type === '[object Object]') {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);

          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);

          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object Array]') {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }

          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);

          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object String]') {
        if (state.tag !== '?') {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type === '[object Undefined]') {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception('unacceptable kind of an object to dump ' + type);
      }

      if (state.tag !== null && state.tag !== '?') {
        // Need to encode all characters except those allowed by the spec:
        //
        // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
        // [36] ns-hex-digit    ::=  ns-dec-digit
        //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
        // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
        // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”
        // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”
        //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”
        //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”
        //
        // Also need to encode '!' because it has special meaning (end of tag prefix).
        //
        tagStr = encodeURI(state.tag[0] === '!' ? state.tag.slice(1) : state.tag).replace(/!/g, '%21');

        if (state.tag[0] === '!') {
          tagStr = '!' + tagStr;
        } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
          tagStr = '!!' + tagStr.slice(18);
        } else {
          tagStr = '!<' + tagStr + '>';
        }

        state.dump = tagStr + ' ' + state.dump;
      }
    }

    return true;
  }

  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;
    inspectNode(object, objects, duplicatesIndexes);

    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }

    state.usedDuplicates = new Array(length);
  }

  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;

    if (object !== null && typeof object === 'object') {
      index = objects.indexOf(object);

      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);

        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }

  function dump$1(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;

    if (state.replacer) {
      value = state.replacer.call({
        '': value
      }, '', value);
    }

    if (writeNode(state, 0, value, true, true)) return state.dump + '\n';
    return '';
  }

  var dump_1 = dump$1;

  var dumper = {
  	dump: dump_1
  };

  function renamed(from, to) {
    return function () {
      throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' + 'Use yaml.' + to + ' instead, which is now safe by default.');
    };
  }

  var Type = type;
  var Schema = schema;
  var FAILSAFE_SCHEMA = failsafe;
  var JSON_SCHEMA = json;
  var CORE_SCHEMA = core$1;
  var DEFAULT_SCHEMA = _default$F;
  var load = loader.load;
  var loadAll = loader.loadAll;
  var dump = dumper.dump;
  var YAMLException = exception; // Re-export all types in case user wants to create custom schema

  var types$1 = {
    binary: binary,
    float: float,
    map: map,
    null: _null,
    pairs: pairs,
    set: set$1,
    timestamp: timestamp,
    bool: bool,
    int: int,
    merge: merge,
    omap: omap,
    seq: seq,
    str: str
  }; // Removed functions from JS-YAML 3.0.x

  var safeLoad = renamed('safeLoad', 'load');
  var safeLoadAll = renamed('safeLoadAll', 'loadAll');
  var safeDump = renamed('safeDump', 'dump');

  var jsYaml = {
  	Type: Type,
  	Schema: Schema,
  	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
  	JSON_SCHEMA: JSON_SCHEMA,
  	CORE_SCHEMA: CORE_SCHEMA,
  	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
  	load: load,
  	loadAll: loadAll,
  	dump: dump,
  	YAMLException: YAMLException,
  	types: types$1,
  	safeLoad: safeLoad,
  	safeLoadAll: safeLoadAll,
  	safeDump: safeDump
  };

  var loaders_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.loaders = void 0;


  /* eslint-disable @typescript-eslint/no-require-imports */


  let importFresh$1;

  const loadJsSync = function loadJsSync(filepath) {
    if (importFresh$1 === undefined) {
      importFresh$1 = importFresh;
    }

    const result = importFresh$1(filepath);
    return result;
  };

  const loadJs = async function loadJs(filepath) {
    try {
      const {
        href
      } = (0, url__default['default'].pathToFileURL)(filepath);
      return (await import(href)).default;
    } catch (error) {
      return loadJsSync(filepath);
    }
  };

  let parseJson$1;

  const loadJson = function loadJson(filepath, content) {
    if (parseJson$1 === undefined) {
      parseJson$1 = parseJson;
    }

    try {
      const result = parseJson$1(content);
      return result;
    } catch (error) {
      error.message = `JSON Error in ${filepath}:\n${error.message}`;
      throw error;
    }
  };

  let yaml;

  const loadYaml = function loadYaml(filepath, content) {
    if (yaml === undefined) {
      yaml = jsYaml;
    }

    try {
      const result = yaml.load(content);
      return result;
    } catch (error) {
      error.message = `YAML Error in ${filepath}:\n${error.message}`;
      throw error;
    }
  };

  const loaders = {
    loadJs,
    loadJsSync,
    loadJson,
    loadYaml
  };
  exports.loaders = loaders;
  });

  var ExplorerBase_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExplorerBase = void 0;
  exports.getExtensionDescription = getExtensionDescription;

  var _path = _interopRequireDefault(path__default['default']);





  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  class ExplorerBase {
    constructor(options) {
      if (options.cache) {
        this.loadCache = new Map();
        this.searchCache = new Map();
      }

      this.config = options;
      this.validateConfig();
    }

    clearLoadCache() {
      if (this.loadCache) {
        this.loadCache.clear();
      }
    }

    clearSearchCache() {
      if (this.searchCache) {
        this.searchCache.clear();
      }
    }

    clearCaches() {
      this.clearLoadCache();
      this.clearSearchCache();
    }

    validateConfig() {
      const config = this.config;
      config.searchPlaces.forEach(place => {
        const loaderKey = _path.default.extname(place) || 'noExt';
        const loader = config.loaders[loaderKey];

        if (!loader) {
          throw new Error(`No loader specified for ${getExtensionDescription(place)}, so searchPlaces item "${place}" is invalid`);
        }

        if (typeof loader !== 'function') {
          throw new Error(`loader for ${getExtensionDescription(place)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
        }
      });
    }

    shouldSearchStopWithResult(result) {
      if (result === null) return false;
      return !(result.isEmpty && this.config.ignoreEmptySearchPlaces);
    }

    nextDirectoryToSearch(currentDir, currentResult) {
      if (this.shouldSearchStopWithResult(currentResult)) {
        return null;
      }

      const nextDir = nextDirUp(currentDir);

      if (nextDir === currentDir || currentDir === this.config.stopDir) {
        return null;
      }

      return nextDir;
    }

    loadPackageProp(filepath, content) {
      const parsedContent = loaders_1.loaders.loadJson(filepath, content);

      const packagePropValue = (0, getPropertyByPath_1.getPropertyByPath)(parsedContent, this.config.packageProp);
      return packagePropValue || null;
    }

    getLoaderEntryForFile(filepath) {
      if (_path.default.basename(filepath) === 'package.json') {
        return this.loadPackageProp.bind(this);
      }

      const loaderKey = _path.default.extname(filepath) || 'noExt';
      const loader = this.config.loaders[loaderKey];

      if (!loader) {
        throw new Error(`No loader specified for ${getExtensionDescription(filepath)}`);
      }

      return loader;
    }

    loadedContentToCosmiconfigResult(filepath, loadedContent, forceProp) {
      if (loadedContent === null) {
        return null;
      }

      if (loadedContent === undefined) {
        return {
          filepath,
          config: undefined,
          isEmpty: true
        };
      }

      if (this.config.usePackagePropInConfigFiles || forceProp) {
        loadedContent = (0, getPropertyByPath_1.getPropertyByPath)(loadedContent, this.config.packageProp);
      }

      if (loadedContent === undefined) {
        return {
          filepath,
          config: undefined,
          isEmpty: true
        };
      }

      return {
        config: loadedContent,
        filepath
      };
    }

    validateFilePath(filepath) {
      if (!filepath) {
        throw new Error('load must pass a non-empty string');
      }
    }

  }

  exports.ExplorerBase = ExplorerBase;

  function nextDirUp(dir) {
    return _path.default.dirname(dir);
  }

  function getExtensionDescription(filepath) {
    const ext = _path.default.extname(filepath);

    return ext ? `extension "${ext}"` : 'files without extensions';
  }
  });

  const {
    promisify: promisify$2
  } = util__default['default'];



  async function isType(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== 'string') {
      throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }

    try {
      const stats = await promisify$2(fs__default['default'][fsStatType])(filePath);
      return stats[statsMethodName]();
    } catch (error) {
      if (error.code === 'ENOENT') {
        return false;
      }

      throw error;
    }
  }

  function isTypeSync(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== 'string') {
      throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }

    try {
      return fs__default['default'][fsStatType](filePath)[statsMethodName]();
    } catch (error) {
      if (error.code === 'ENOENT') {
        return false;
      }

      throw error;
    }
  }

  var isFile = isType.bind(null, 'stat', 'isFile');
  var isDirectory = isType.bind(null, 'stat', 'isDirectory');
  var isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');
  var isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');
  var isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');
  var isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');

  var pathType = {
  	isFile: isFile,
  	isDirectory: isDirectory,
  	isSymlink: isSymlink,
  	isFileSync: isFileSync,
  	isDirectorySync: isDirectorySync,
  	isSymlinkSync: isSymlinkSync
  };

  var getDirectory_2 = getDirectory;
  var getDirectorySync_1 = getDirectorySync;

  var _path = _interopRequireDefault$1(path__default['default']);



  function _interopRequireDefault$1(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  async function getDirectory(filepath) {
    const filePathIsDirectory = await (0, pathType.isDirectory)(filepath);

    if (filePathIsDirectory === true) {
      return filepath;
    }

    const directory = _path.default.dirname(filepath);

    return directory;
  }

  function getDirectorySync(filepath) {
    const filePathIsDirectory = (0, pathType.isDirectorySync)(filepath);

    if (filePathIsDirectory === true) {
      return filepath;
    }

    const directory = _path.default.dirname(filepath);

    return directory;
  }

  var getDirectory_1 = /*#__PURE__*/Object.defineProperty({
  	getDirectory: getDirectory_2,
  	getDirectorySync: getDirectorySync_1
  }, '__esModule', {value: true});

  var readFile_2 = readFile;
  var readFileSync_1 = readFileSync;

  var _fs = _interopRequireDefault(fs__default['default']);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  async function fsReadFileAsync(pathname, encoding) {
    return new Promise((resolve, reject) => {
      _fs.default.readFile(pathname, encoding, (error, contents) => {
        if (error) {
          reject(error);
          return;
        }

        resolve(contents);
      });
    });
  }

  async function readFile(filepath, options = {}) {
    const throwNotFound = options.throwNotFound === true;

    try {
      const content = await fsReadFileAsync(filepath, 'utf8');
      return content;
    } catch (error) {
      if (throwNotFound === false && (error.code === 'ENOENT' || error.code === 'EISDIR')) {
        return null;
      }

      throw error;
    }
  }

  function readFileSync(filepath, options = {}) {
    const throwNotFound = options.throwNotFound === true;

    try {
      const content = _fs.default.readFileSync(filepath, 'utf8');

      return content;
    } catch (error) {
      if (throwNotFound === false && (error.code === 'ENOENT' || error.code === 'EISDIR')) {
        return null;
      }

      throw error;
    }
  }

  var readFile_1 = /*#__PURE__*/Object.defineProperty({
  	readFile: readFile_2,
  	readFileSync: readFileSync_1
  }, '__esModule', {value: true});

  var Explorer_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Explorer = void 0;

  var _path = _interopRequireDefault(path__default['default']);









  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  class Explorer extends ExplorerBase_1.ExplorerBase {
    constructor(options) {
      super(options);
    }

    async search(searchFrom = process.cwd()) {
      if (this.config.metaConfigFilePath) {
        const config = await this._loadFile(this.config.metaConfigFilePath, true);

        if (config && !config.isEmpty) {
          return config;
        }
      }

      return await this.searchFromDirectory(await (0, getDirectory_1.getDirectory)(searchFrom));
    }

    async searchFromDirectory(dir) {
      const absoluteDir = _path.default.resolve(process.cwd(), dir);

      const run = async () => {
        const result = await this.searchDirectory(absoluteDir);
        const nextDir = this.nextDirectoryToSearch(absoluteDir, result);

        if (nextDir) {
          return this.searchFromDirectory(nextDir);
        }

        return await this.config.transform(result);
      };

      if (this.searchCache) {
        return (0, cacheWrapper_1.cacheWrapper)(this.searchCache, absoluteDir, run);
      }

      return run();
    }

    async searchDirectory(dir) {
      for await (const place of this.config.searchPlaces) {
        const placeResult = await this.loadSearchPlace(dir, place);

        if (this.shouldSearchStopWithResult(placeResult)) {
          return placeResult;
        }
      } // config not found


      return null;
    }

    async loadSearchPlace(dir, place) {
      const filepath = _path.default.join(dir, place);

      const fileContents = await (0, readFile_1.readFile)(filepath);
      return await this.createCosmiconfigResult(filepath, fileContents, false);
    }

    async loadFileContent(filepath, content) {
      if (content === null) {
        return null;
      }

      if (content.trim() === '') {
        return undefined;
      }

      const loader = this.getLoaderEntryForFile(filepath);

      try {
        return await loader(filepath, content);
      } catch (e) {
        e.filepath = filepath;
        throw e;
      }
    }

    async createCosmiconfigResult(filepath, content, forceProp) {
      const fileContent = await this.loadFileContent(filepath, content);
      return this.loadedContentToCosmiconfigResult(filepath, fileContent, forceProp);
    }

    async load(filepath) {
      return this._loadFile(filepath, false);
    }

    async _loadFile(filepath, forceProp) {
      this.validateFilePath(filepath);

      const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);

      const runLoad = async () => {
        const fileContents = await (0, readFile_1.readFile)(absoluteFilePath, {
          throwNotFound: true
        });
        const result = await this.createCosmiconfigResult(absoluteFilePath, fileContents, forceProp);
        return await this.config.transform(result);
      };

      if (this.loadCache) {
        return (0, cacheWrapper_1.cacheWrapper)(this.loadCache, absoluteFilePath, runLoad);
      }

      return runLoad();
    }

  }

  exports.Explorer = Explorer;
  });

  var ExplorerSync_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExplorerSync = void 0;

  var _path = _interopRequireDefault(path__default['default']);









  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  class ExplorerSync extends ExplorerBase_1.ExplorerBase {
    constructor(options) {
      super(options);
    }

    searchSync(searchFrom = process.cwd()) {
      if (this.config.metaConfigFilePath) {
        const config = this._loadFileSync(this.config.metaConfigFilePath, true);

        if (config && !config.isEmpty) {
          return config;
        }
      }

      return this.searchFromDirectorySync((0, getDirectory_1.getDirectorySync)(searchFrom));
    }

    searchFromDirectorySync(dir) {
      const absoluteDir = _path.default.resolve(process.cwd(), dir);

      const run = () => {
        const result = this.searchDirectorySync(absoluteDir);
        const nextDir = this.nextDirectoryToSearch(absoluteDir, result);

        if (nextDir) {
          return this.searchFromDirectorySync(nextDir);
        }

        return this.config.transform(result);
      };

      if (this.searchCache) {
        return (0, cacheWrapper_1.cacheWrapperSync)(this.searchCache, absoluteDir, run);
      }

      return run();
    }

    searchDirectorySync(dir) {
      for (const place of this.config.searchPlaces) {
        const placeResult = this.loadSearchPlaceSync(dir, place);

        if (this.shouldSearchStopWithResult(placeResult)) {
          return placeResult;
        }
      } // config not found


      return null;
    }

    loadSearchPlaceSync(dir, place) {
      const filepath = _path.default.join(dir, place);

      const content = (0, readFile_1.readFileSync)(filepath);
      return this.createCosmiconfigResultSync(filepath, content, false);
    }

    loadFileContentSync(filepath, content) {
      if (content === null) {
        return null;
      }

      if (content.trim() === '') {
        return undefined;
      }

      const loader = this.getLoaderEntryForFile(filepath);

      try {
        return loader(filepath, content);
      } catch (e) {
        e.filepath = filepath;
        throw e;
      }
    }

    createCosmiconfigResultSync(filepath, content, forceProp) {
      const fileContent = this.loadFileContentSync(filepath, content);
      return this.loadedContentToCosmiconfigResult(filepath, fileContent, forceProp);
    }

    loadSync(filepath) {
      return this._loadFileSync(filepath, false);
    }

    _loadFileSync(filepath, forceProp) {
      this.validateFilePath(filepath);

      const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);

      const runLoadSync = () => {
        const content = (0, readFile_1.readFileSync)(absoluteFilePath, {
          throwNotFound: true
        });
        const cosmiconfigResult = this.createCosmiconfigResultSync(absoluteFilePath, content, forceProp);
        return this.config.transform(cosmiconfigResult);
      };

      if (this.loadCache) {
        return (0, cacheWrapper_1.cacheWrapperSync)(this.loadCache, absoluteFilePath, runLoadSync);
      }

      return runLoadSync();
    }

  }

  exports.ExplorerSync = ExplorerSync;
  });

  var dist = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.cosmiconfig = cosmiconfig;
  exports.cosmiconfigSync = cosmiconfigSync;
  exports.metaSearchPlaces = exports.defaultLoadersSync = exports.defaultLoaders = void 0;

  var _os = _interopRequireDefault(os__default['default']);









  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
  // this needs to be hardcoded, as this is intended for end users, who can't supply options at this point


  const metaSearchPlaces = ['package.json', '.config.json', '.config.yaml', '.config.yml', '.config.js', '.config.cjs', '.config.mjs']; // do not allow mutation of default loaders. Make sure it is set inside options

  exports.metaSearchPlaces = metaSearchPlaces;
  const defaultLoaders = Object.freeze({
    '.mjs': loaders_1.loaders.loadJs,
    '.cjs': loaders_1.loaders.loadJs,
    '.js': loaders_1.loaders.loadJs,
    '.json': loaders_1.loaders.loadJson,
    '.yaml': loaders_1.loaders.loadYaml,
    '.yml': loaders_1.loaders.loadYaml,
    noExt: loaders_1.loaders.loadYaml
  });
  exports.defaultLoaders = defaultLoaders;
  const defaultLoadersSync = Object.freeze({
    '.cjs': loaders_1.loaders.loadJsSync,
    '.js': loaders_1.loaders.loadJsSync,
    '.json': loaders_1.loaders.loadJson,
    '.yaml': loaders_1.loaders.loadYaml,
    '.yml': loaders_1.loaders.loadYaml,
    noExt: loaders_1.loaders.loadYaml
  });
  exports.defaultLoadersSync = defaultLoadersSync;

  const identity = function identity(x) {
    return x;
  };

  function replaceMetaPlaceholders(paths, moduleName) {
    return paths.map(path => path.replace('{name}', moduleName));
  }

  function getExplorerOptions(moduleName, options) {
    var _metaConfig$config;

    const metaExplorer = new ExplorerSync_1.ExplorerSync({
      packageProp: 'cosmiconfig',
      stopDir: process.cwd(),
      searchPlaces: metaSearchPlaces,
      ignoreEmptySearchPlaces: false,
      usePackagePropInConfigFiles: true,
      loaders: defaultLoaders,
      transform: identity,
      cache: true,
      metaConfigFilePath: null
    });
    const metaConfig = metaExplorer.searchSync();

    if (!metaConfig) {
      return options;
    }

    if ((_metaConfig$config = metaConfig.config) !== null && _metaConfig$config !== void 0 && _metaConfig$config.loaders) {
      throw new Error('Can not specify loaders in meta config file');
    }

    const overrideOptions = metaConfig.config ?? {};

    if (overrideOptions.searchPlaces) {
      overrideOptions.searchPlaces = replaceMetaPlaceholders(overrideOptions.searchPlaces, moduleName);
    }

    overrideOptions.metaConfigFilePath = metaConfig.filepath;
    return { ...options,
      ...overrideOptions
    };
  }

  function cosmiconfig(moduleName, options = {}) {
    const explorerOptions = getExplorerOptions(moduleName, options);
    const normalizedOptions = normalizeOptions(moduleName, explorerOptions);
    const explorer = new Explorer_1.Explorer(normalizedOptions);
    return {
      search: explorer.search.bind(explorer),
      load: explorer.load.bind(explorer),
      clearLoadCache: explorer.clearLoadCache.bind(explorer),
      clearSearchCache: explorer.clearSearchCache.bind(explorer),
      clearCaches: explorer.clearCaches.bind(explorer)
    };
  } // eslint-disable-next-line @typescript-eslint/explicit-function-return-type


  function cosmiconfigSync(moduleName, options = {}) {
    const explorerOptions = getExplorerOptions(moduleName, options);
    const normalizedOptions = normalizeOptionsSync(moduleName, explorerOptions);
    const explorerSync = new ExplorerSync_1.ExplorerSync(normalizedOptions);
    return {
      search: explorerSync.searchSync.bind(explorerSync),
      load: explorerSync.loadSync.bind(explorerSync),
      clearLoadCache: explorerSync.clearLoadCache.bind(explorerSync),
      clearSearchCache: explorerSync.clearSearchCache.bind(explorerSync),
      clearCaches: explorerSync.clearCaches.bind(explorerSync)
    };
  }

  function normalizeOptions(moduleName, options) {
    const defaults = {
      packageProp: moduleName,
      searchPlaces: ['package.json', `.${moduleName}rc`, `.${moduleName}rc.json`, `.${moduleName}rc.yaml`, `.${moduleName}rc.yml`, `.${moduleName}rc.js`, `.${moduleName}rc.cjs`, `.${moduleName}rc.mjs`, `.config/${moduleName}rc`, `.config/${moduleName}rc.json`, `.config/${moduleName}rc.yaml`, `.config/${moduleName}rc.yml`, `.config/${moduleName}rc.js`, `.config/${moduleName}rc.cjs`, `.config/${moduleName}rc.mjs`, `${moduleName}.config.js`, `${moduleName}.config.cjs`, `${moduleName}.config.mjs`].filter(Boolean),
      ignoreEmptySearchPlaces: true,
      stopDir: _os.default.homedir(),
      cache: true,
      transform: identity,
      loaders: defaultLoaders,
      metaConfigFilePath: null
    };
    const normalizedOptions = { ...defaults,
      ...options,
      loaders: { ...defaults.loaders,
        ...options.loaders
      }
    };
    return normalizedOptions;
  }

  function normalizeOptionsSync(moduleName, options) {
    const defaults = {
      packageProp: moduleName,
      searchPlaces: ['package.json', `.${moduleName}rc`, `.${moduleName}rc.json`, `.${moduleName}rc.yaml`, `.${moduleName}rc.yml`, `.${moduleName}rc.js`, `.${moduleName}rc.cjs`, `.config/${moduleName}rc`, `.config/${moduleName}rc.json`, `.config/${moduleName}rc.yaml`, `.config/${moduleName}rc.yml`, `.config/${moduleName}rc.js`, `.config/${moduleName}rc.cjs`, `${moduleName}.config.js`, `${moduleName}.config.cjs`],
      ignoreEmptySearchPlaces: true,
      stopDir: _os.default.homedir(),
      cache: true,
      transform: identity,
      loaders: defaultLoadersSync,
      metaConfigFilePath: null
    };
    const normalizedOptions = { ...defaults,
      ...options,
      loaders: { ...defaults.loaders,
        ...options.loaders
      }
    };
    return normalizedOptions;
  }
  });

  var ini = createCommonjsModule(function (module, exports) {
  exports.parse = exports.decode = decode;
  exports.stringify = exports.encode = encode;
  exports.safe = safe;
  exports.unsafe = unsafe;
  var eol = typeof process !== 'undefined' && process.platform === 'win32' ? '\r\n' : '\n';

  function encode(obj, opt) {
    var children = [];
    var out = '';

    if (typeof opt === 'string') {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || {};
      opt.whitespace = opt.whitespace === true;
    }

    var separator = opt.whitespace ? ' = ' : '=';
    Object.keys(obj).forEach(function (k, _, __) {
      var val = obj[k];

      if (val && Array.isArray(val)) {
        val.forEach(function (item) {
          out += safe(k + '[]') + separator + safe(item) + '\n';
        });
      } else if (val && typeof val === 'object') children.push(k);else out += safe(k) + separator + safe(val) + eol;
    });
    if (opt.section && out.length) out = '[' + safe(opt.section) + ']' + eol + out;
    children.forEach(function (k, _, __) {
      var nk = dotSplit(k).join('\\.');
      var section = (opt.section ? opt.section + '.' : '') + nk;
      var child = encode(obj[k], {
        section: section,
        whitespace: opt.whitespace
      });
      if (out.length && child.length) out += eol;
      out += child;
    });
    return out;
  }

  function dotSplit(str) {
    return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002').replace(/\\\./g, '\u0001').split(/\./).map(function (part) {
      return part.replace(/\1/g, '\\.').replace(/\2LITERAL\\1LITERAL\2/g, '\u0001');
    });
  }

  function decode(str) {
    var out = {};
    var p = out;
    var section = null; //          section     |key      = value

    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str.split(/[\r\n]+/g);
    lines.forEach(function (line, _, __) {
      if (!line || line.match(/^\s*[;#]/)) return;
      var match = line.match(re);
      if (!match) return;

      if (match[1] !== undefined) {
        section = unsafe(match[1]);

        if (section === '__proto__') {
          // not allowed
          // keep parsing the section, but don't attach it.
          p = {};
          return;
        }

        p = out[section] = out[section] || {};
        return;
      }

      var key = unsafe(match[2]);
      if (key === '__proto__') return;
      var value = match[3] ? unsafe(match[4]) : true;

      switch (value) {
        case 'true':
        case 'false':
        case 'null':
          value = JSON.parse(value);
      } // Convert keys with '[]' suffix to an array


      if (key.length > 2 && key.slice(-2) === '[]') {
        key = key.substring(0, key.length - 2);
        if (key === '__proto__') return;
        if (!p[key]) p[key] = [];else if (!Array.isArray(p[key])) p[key] = [p[key]];
      } // safeguard against resetting a previously defined
      // array by accidentally forgetting the brackets


      if (Array.isArray(p[key])) p[key].push(value);else p[key] = value;
    }); // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
    // use a filter to return the keys that have to be deleted.

    Object.keys(out).filter(function (k, _, __) {
      if (!out[k] || typeof out[k] !== 'object' || Array.isArray(out[k])) return false; // see if the parent section is also an object.
      // if so, add it to that, and mark this one for deletion

      var parts = dotSplit(k);
      var p = out;
      var l = parts.pop();
      var nl = l.replace(/\\\./g, '.');
      parts.forEach(function (part, _, __) {
        if (part === '__proto__') return;
        if (!p[part] || typeof p[part] !== 'object') p[part] = {};
        p = p[part];
      });
      if (p === out && nl === l) return false;
      p[nl] = out[k];
      return true;
    }).forEach(function (del, _, __) {
      delete out[del];
    });
    return out;
  }

  function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  }

  function safe(val) {
    return typeof val !== 'string' || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, '\\;').replace(/#/g, '\\#');
  }

  function unsafe(val, doUnesc) {
    val = (val || '').trim();

    if (isQuoted(val)) {
      // remove the single quotes before calling JSON.parse
      if (val.charAt(0) === "'") val = val.substr(1, val.length - 2);

      try {
        val = JSON.parse(val);
      } catch (_) {}
    } else {
      // walk the val to find the first not-escaped ; character
      var esc = false;
      var unesc = '';

      for (var i = 0, l = val.length; i < l; i++) {
        var c = val.charAt(i);

        if (esc) {
          if ('\\;#'.indexOf(c) !== -1) unesc += c;else unesc += '\\' + c;
          esc = false;
        } else if (';#'.indexOf(c) !== -1) break;else if (c === '\\') esc = true;else unesc += c;
      }

      if (esc) unesc += '\\';
      return unesc.trim();
    }

    return val;
  }
  });

  var windows = isexe$2;
  isexe$2.sync = sync$f;



  function checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;

    if (!pathext) {
      return true;
    }

    pathext = pathext.split(';');

    if (pathext.indexOf('') !== -1) {
      return true;
    }

    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();

      if (p && path.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }

    return false;
  }

  function checkStat$1(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }

    return checkPathExt(path, options);
  }

  function isexe$2(path, options, cb) {
    fs__default['default'].stat(path, function (er, stat) {
      cb(er, er ? false : checkStat$1(stat, path, options));
    });
  }

  function sync$f(path, options) {
    return checkStat$1(fs__default['default'].statSync(path), path, options);
  }

  var mode = isexe$1;
  isexe$1.sync = sync$e;



  function isexe$1(path, options, cb) {
    fs__default['default'].stat(path, function (er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }

  function sync$e(path, options) {
    return checkStat(fs__default['default'].statSync(path), options);
  }

  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }

  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt('100', 8);
    var g = parseInt('010', 8);
    var o = parseInt('001', 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }

  var core;

  if (process.platform === 'win32' || commonjsGlobal.TESTING_WINDOWS) {
    core = windows;
  } else {
    core = mode;
  }

  var isexe_1 = isexe;
  isexe.sync = sync$d;

  function isexe(path, options, cb) {
    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (!cb) {
      if (typeof Promise !== 'function') {
        throw new TypeError('callback not provided');
      }

      return new Promise(function (resolve, reject) {
        isexe(path, options || {}, function (er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }

    core(path, options || {}, function (er, is) {
      // ignore EACCES because that just means we aren't allowed to run it
      if (er) {
        if (er.code === 'EACCES' || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }

      cb(er, is);
    });
  }

  function sync$d(path, options) {
    // my kingdom for a filtered catch
    try {
      return core.sync(path, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === 'EACCES') {
        return false;
      } else {
        throw er;
      }
    }
  }

  var which_1 = which;
  which.sync = whichSync;
  var isWindows$2 = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';



  var COLON = isWindows$2 ? ';' : ':';



  function getNotFoundError(cmd) {
    var er = new Error('not found: ' + cmd);
    er.code = 'ENOENT';
    return er;
  }

  function getPathInfo(cmd, opt) {
    var colon = opt.colon || COLON;
    var pathEnv = opt.path || process.env.PATH || '';
    var pathExt = [''];
    pathEnv = pathEnv.split(colon);
    var pathExtExe = '';

    if (isWindows$2) {
      pathEnv.unshift(process.cwd());
      pathExtExe = opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM';
      pathExt = pathExtExe.split(colon); // Always test the cmd itself first.  isexe will check to make sure
      // it's found in the pathExt set.

      if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
    } // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.


    if (cmd.match(/\//) || isWindows$2 && cmd.match(/\\/)) pathEnv = [''];
    return {
      env: pathEnv,
      ext: pathExt,
      extExe: pathExtExe
    };
  }

  function which(cmd, opt, cb) {
    if (typeof opt === 'function') {
      cb = opt;
      opt = {};
    }

    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];

    (function F(i, l) {
      if (i === l) {
        if (opt.all && found.length) return cb(null, found);else return cb(getNotFoundError(cmd));
      }

      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"') pathPart = pathPart.slice(1, -1);
      var p = path__default['default'].join(pathPart, cmd);

      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }

      (function E(ii, ll) {
        if (ii === ll) return F(i + 1, l);
        var ext = pathExt[ii];
        isexe_1(p + ext, {
          pathExt: pathExtExe
        }, function (er, is) {
          if (!er && is) {
            if (opt.all) found.push(p + ext);else return cb(null, p + ext);
          }

          return E(ii + 1, ll);
        });
      })(0, pathExt.length);
    })(0, pathEnv.length);
  }

  function whichSync(cmd, opt) {
    opt = opt || {};
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];

    for (var i = 0, l = pathEnv.length; i < l; i++) {
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"') pathPart = pathPart.slice(1, -1);
      var p = path__default['default'].join(pathPart, cmd);

      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }

      for (var j = 0, ll = pathExt.length; j < ll; j++) {
        var cur = p + pathExt[j];
        var is;

        try {
          is = isexe_1.sync(cur, {
            pathExt: pathExtExe
          });

          if (is) {
            if (opt.all) found.push(cur);else return cur;
          }
        } catch (ex) {}
      }
    }

    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
  }

  /*!
   * global-prefix <https://github.com/jonschlinkert/global-prefix>
   *
   * Copyright (c) 2015-present Jon Schlinkert.
   * Licensed under the MIT license.
   */

  var globalPrefix = createCommonjsModule(function (module) {









  let prefix;

  const getPrefix = () => {
    if (process.env.PREFIX) return process.env.PREFIX;
    if (prefix) return prefix; // Start by checking if the global prefix is set by the user

    let home = os__default['default'].homedir(); // os.homedir() returns undefined if $HOME is not set; path.resolve requires strings

    if (home) {
      prefix = tryConfigPath(path__default['default'].resolve(home, '.npmrc'));
    }

    if (prefix) {
      return prefix;
    } // Otherwise find the path of npm


    let npm = tryNpmPath();

    if (npm) {
      // Check the built-in npm config file
      prefix = tryConfigPath(path__default['default'].resolve(npm, '..', '..', 'npmrc'));

      if (prefix) {
        // Now the global npm config can also be checked.
        prefix = tryConfigPath(path__default['default'].resolve(prefix, 'etc', 'npmrc')) || prefix;
      }
    }

    if (!prefix) {
      let {
        APPDATA,
        DESTDIR,
        OSTYPE
      } = process.env; // c:\node\node.exe --> prefix=c:\node\

      if (process.platform === 'win32' || OSTYPE === 'msys' || OSTYPE === 'cygwin') {
        prefix = APPDATA ? path__default['default'].join(APPDATA, 'npm') : path__default['default'].dirname(process.execPath);
        return prefix;
      } // /usr/local/bin/node --> prefix=/usr/local


      prefix = path__default['default'].dirname(path__default['default'].dirname(process.execPath)); // destdir only is respected on Unix

      if (DESTDIR) {
        prefix = path__default['default'].join(DESTDIR, prefix);
      }
    }

    return prefix;
  };

  function tryNpmPath() {
    try {
      return fs__default['default'].realpathSync(which_1.sync('npm'));
    } catch (err) {
      /* do nothing */
    }
  }

  function tryConfigPath(configPath) {
    try {
      return ini.parse(fs__default['default'].readFileSync(configPath, 'utf-8')).prefix;
    } catch (err) {
      /* do nothing */
    }
  }
  /**
   * Expose `prefix`
   */


  Reflect.defineProperty(module, 'exports', {
    get() {
      return getPrefix();
    }

  });
  });

  /*!
   * global-modules <https://github.com/jonschlinkert/global-modules>
   *
   * Copyright (c) 2015-2017 Jon Schlinkert.
   * Licensed under the MIT license.
   */

  var globalModules = createCommonjsModule(function (module) {





  let gm;

  function getPath() {
    if (process.platform === 'win32' || process.env.OSTYPE === 'msys' || process.env.OSTYPE === 'cygwin') {
      return path__default['default'].resolve(globalPrefix, 'node_modules');
    }

    return path__default['default'].resolve(globalPrefix, 'lib/node_modules');
  }
  /**
   * Expose `global-modules` path
   */


  Reflect.defineProperty(module, 'exports', {
    get() {
      return gm || (gm = getPath());
    }

  });
  });

  const resolveFrom = (fromDirectory, moduleId, silent) => {
    if (typeof fromDirectory !== 'string') {
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
    }

    if (typeof moduleId !== 'string') {
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }

    try {
      fromDirectory = fs__default['default'].realpathSync(fromDirectory);
    } catch (error) {
      if (error.code === 'ENOENT') {
        fromDirectory = path__default['default'].resolve(fromDirectory);
      } else if (silent) {
        return;
      } else {
        throw error;
      }
    }

    const fromFile = path__default['default'].join(fromDirectory, 'noop.js');

    const resolveFileName = () => Module__default['default']._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module__default['default']._nodeModulePaths(fromDirectory)
    });

    if (silent) {
      try {
        return resolveFileName();
      } catch (error) {
        return;
      }
    }

    return resolveFileName();
  };

  var resolveFrom_1 = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId);

  var silent = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId, true);
  resolveFrom_1.silent = silent;

  /**
   * @param {string} basedir
   * @param {string} lookup
   * @param {string} [cwd]
   * @return {string}
   */


  var getModulePath = function getModulePath(basedir, lookup, cwd = process.cwd()) {
    // 1. Try to resolve from the provided directory
    // 2. Try to resolve from `cwd` or `process.cwd()`
    // 3. Try to resolve from global `node_modules` directory
    let path = resolveFrom_1.silent(basedir, lookup);

    if (!path) {
      path = resolveFrom_1.silent(cwd, lookup);
    }

    if (!path) {
      path = resolveFrom_1.silent(globalModules, lookup);
    }

    if (!path) {
      throw configurationError(`Could not find "${lookup}". Do you need the "configBasedir" or "--config-basedir" option?`);
    }

    return path;
  };

  var slice$2 = Array.prototype.slice;

  function join()
  /* globs */
  {
    var args;
    args = slice$2.call(arguments, 0);
    return args.reduce(function (result, globs) {
      return _apply(result, function (path) {
        return _apply(globs, function (glob) {
          return _join(path, glob);
        });
      });
    }, '');
  }

  function _apply(values, fn) {
    if (Array.isArray(values)) {
      return values.reduce(function (result, value) {
        return result.concat(fn(value));
      }, []);
    }

    return fn(values);
  }

  function _join(path, glob) {
    var negative, positive;

    if (glob[0] === '!') {
      positive = glob.substr(1);

      if (path[0] === '!') {
        negative = '';
      } else {
        negative = '!';
      }

      return negative + path__default['default'].join(path, positive);
    }

    return path__default['default'].join(path, glob);
  }

  var globjoin = join;

  var utils$8 = createCommonjsModule(function (module, exports) {

  exports.isInteger = num => {
    if (typeof num === 'number') {
      return Number.isInteger(num);
    }

    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isInteger(Number(num));
    }

    return false;
  };
  /**
   * Find a node of the given type
   */


  exports.find = (node, type) => node.nodes.find(node => node.type === type);
  /**
   * Find a node of the given type
   */


  exports.exceedsLimit = (min, max, step = 1, limit) => {
    if (limit === false) return false;
    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
  };
  /**
   * Escape the given node with '\\' before node.value
   */


  exports.escapeNode = (block, n = 0, type) => {
    let node = block.nodes[n];
    if (!node) return;

    if (type && node.type === type || node.type === 'open' || node.type === 'close') {
      if (node.escaped !== true) {
        node.value = '\\' + node.value;
        node.escaped = true;
      }
    }
  };
  /**
   * Returns true if the given brace node should be enclosed in literal braces
   */


  exports.encloseBrace = node => {
    if (node.type !== 'brace') return false;

    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }

    return false;
  };
  /**
   * Returns true if a brace node is invalid.
   */


  exports.isInvalidBrace = block => {
    if (block.type !== 'brace') return false;
    if (block.invalid === true || block.dollar) return true;

    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }

    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }

    return false;
  };
  /**
   * Returns true if a node is an open or close node
   */


  exports.isOpenOrClose = node => {
    if (node.type === 'open' || node.type === 'close') {
      return true;
    }

    return node.open === true || node.close === true;
  };
  /**
   * Reduce an array of text nodes.
   */


  exports.reduce = nodes => nodes.reduce((acc, node) => {
    if (node.type === 'text') acc.push(node.value);
    if (node.type === 'range') node.type = 'text';
    return acc;
  }, []);
  /**
   * Flatten an array
   */


  exports.flatten = (...args) => {
    const result = [];

    const flat = arr => {
      for (let i = 0; i < arr.length; i++) {
        let ele = arr[i];
        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
      }

      return result;
    };

    flat(args);
    return result;
  };
  });

  var stringify$2 = (ast, options = {}) => {
    let stringify = (node, parent = {}) => {
      let invalidBlock = options.escapeInvalid && utils$8.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = '';

      if (node.value) {
        if ((invalidBlock || invalidNode) && utils$8.isOpenOrClose(node)) {
          return '\\' + node.value;
        }

        return node.value;
      }

      if (node.value) {
        return node.value;
      }

      if (node.nodes) {
        for (let child of node.nodes) {
          output += stringify(child);
        }
      }

      return output;
    };

    return stringify(ast);
  };

  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */

  var isNumber$1 = function (num) {
    if (typeof num === 'number') {
      return num - num === 0;
    }

    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }

    return false;
  };

  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */



  const toRegexRange = (min, max, options) => {
    if (isNumber$1(min) === false) {
      throw new TypeError('toRegexRange: expected the first argument to be a number');
    }

    if (max === void 0 || min === max) {
      return String(min);
    }

    if (isNumber$1(max) === false) {
      throw new TypeError('toRegexRange: expected the second argument to be a number.');
    }

    let opts = {
      relaxZeros: true,
      ...options
    };

    if (typeof opts.strictZeros === 'boolean') {
      opts.relaxZeros = opts.strictZeros === false;
    }

    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }

    let a = Math.min(min, max);
    let b = Math.max(min, max);

    if (Math.abs(a - b) === 1) {
      let result = min + '|' + max;

      if (opts.capture) {
        return `(${result})`;
      }

      if (opts.wrap === false) {
        return result;
      }

      return `(?:${result})`;
    }

    let isPadded = hasPadding(min) || hasPadding(max);
    let state = {
      min,
      max,
      a,
      b
    };
    let positives = [];
    let negatives = [];

    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }

    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }

    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }

    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives);

    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }

    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };

  function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, '-', false) || [];
    let onlyPositive = filterPatterns(pos, neg, '', false) || [];
    let intersected = filterPatterns(neg, pos, '-?', true) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join('|');
  }

  function splitToRanges(min, max) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min, nines);
    let stops = new Set([max]);

    while (min <= stop && stop <= max) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min, nines);
    }

    stop = countZeros(max + 1, zeros) - 1;

    while (min < stop && stop <= max) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }

    stops = [...stops];
    stops.sort(compare);
    return stops;
  }
  /**
   * Convert a range to a regex pattern
   * @param {Number} `start`
   * @param {Number} `stop`
   * @return {String}
   */


  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return {
        pattern: start,
        count: [],
        digits: 0
      };
    }

    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = '';
    let count = 0;

    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];

      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== '0' || stopDigit !== '9') {
        pattern += toCharacterClass(startDigit, stopDigit);
      } else {
        count++;
      }
    }

    if (count) {
      pattern += options.shorthand === true ? '\\d' : '[0-9]';
    }

    return {
      pattern,
      count: [count],
      digits
    };
  }

  function splitToPatterns(min, max, tok, options) {
    let ranges = splitToRanges(min, max);
    let tokens = [];
    let start = min;
    let prev;

    for (let i = 0; i < ranges.length; i++) {
      let max = ranges[i];
      let obj = rangeToPattern(String(start), String(max), options);
      let zeros = '';

      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }

        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max + 1;
        continue;
      }

      if (tok.isPadded) {
        zeros = padZeros(max, tok, options);
      }

      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max + 1;
      prev = obj;
    }

    return tokens;
  }

  function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];

    for (let ele of arr) {
      let {
        string
      } = ele; // only push if _both_ are negative...

      if (!intersection && !contains(comparison, 'string', string)) {
        result.push(prefix + string);
      } // or _both_ are positive


      if (intersection && contains(comparison, 'string', string)) {
        result.push(prefix + string);
      }
    }

    return result;
  }
  /**
   * Zip strings
   */


  function zip(a, b) {
    let arr = [];

    for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);

    return arr;
  }

  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }

  function contains(arr, key, val) {
    return arr.some(ele => ele[key] === val);
  }

  function countNines(min, len) {
    return Number(String(min).slice(0, -len) + '9'.repeat(len));
  }

  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }

  function toQuantifier(digits) {
    let [start = 0, stop = ''] = digits;

    if (stop || start > 1) {
      return `{${start + (stop ? ',' + stop : '')}}`;
    }

    return '';
  }

  function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? '' : '-'}${b}]`;
  }

  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }

  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }

    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;

    switch (diff) {
      case 0:
        return '';

      case 1:
        return relax ? '0?' : '0';

      case 2:
        return relax ? '0{0,2}' : '00';

      default:
        {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
    }
  }
  /**
   * Cache
   */


  toRegexRange.cache = {};

  toRegexRange.clearCache = () => toRegexRange.cache = {};
  /**
   * Expose `toRegexRange`
   */


  var toRegexRange_1 = toRegexRange;

  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */





  const isObject$3 = val => val !== null && typeof val === 'object' && !Array.isArray(val);

  const transform = toNumber => {
    return value => toNumber === true ? Number(value) : String(value);
  };

  const isValidValue = value => {
    return typeof value === 'number' || typeof value === 'string' && value !== '';
  };

  const isNumber = num => Number.isInteger(+num);

  const zeros = input => {
    let value = `${input}`;
    let index = -1;
    if (value[0] === '-') value = value.slice(1);
    if (value === '0') return false;

    while (value[++index] === '0');

    return index > 0;
  };

  const stringify$1 = (start, end, options) => {
    if (typeof start === 'string' || typeof end === 'string') {
      return true;
    }

    return options.stringify === true;
  };

  const pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === '-' ? '-' : '';
      if (dash) input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');
    }

    if (toNumber === false) {
      return String(input);
    }

    return input;
  };

  const toMaxLen = (input, maxLength) => {
    let negative = input[0] === '-' ? '-' : '';

    if (negative) {
      input = input.slice(1);
      maxLength--;
    }

    while (input.length < maxLength) input = '0' + input;

    return negative ? '-' + input : input;
  };

  const toSequence = (parts, options) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? '' : '?:';
    let positives = '';
    let negatives = '';
    let result;

    if (parts.positives.length) {
      positives = parts.positives.join('|');
    }

    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.join('|')})`;
    }

    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }

    if (options.wrap) {
      return `(${prefix}${result})`;
    }

    return result;
  };

  const toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange_1(a, b, {
        wrap: false,
        ...options
      });
    }

    let start = String.fromCharCode(a);
    if (a === b) return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };

  const toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? '' : '?:';
      return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
    }

    return toRegexRange_1(start, end, options);
  };

  const rangeError = (...args) => {
    return new RangeError('Invalid range arguments: ' + util__default['default'].inspect(...args));
  };

  const invalidRange = (start, end, options) => {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  };

  const invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }

    return [];
  };

  const fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);

    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    } // fix negative zero


    if (a === 0) a = 0;
    if (b === 0) b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify$1(start, end, options) === false;
    let format = options.transform || transform(toNumber);

    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }

    let parts = {
      negatives: [],
      positives: []
    };

    let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));

    let range = [];
    let index = 0;

    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format(a, index), maxLen, toNumber));
      }

      a = descending ? a - step : a + step;
      index++;
    }

    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options) : toRegex(range, null, {
        wrap: false,
        ...options
      });
    }

    return range;
  };

  const fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }

    let format = options.transform || (val => String.fromCharCode(val));

    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min = Math.min(a, b);
    let max = Math.max(a, b);

    if (options.toRegex && step === 1) {
      return toRange(min, max, false, options);
    }

    let range = [];
    let index = 0;

    while (descending ? a >= b : a <= b) {
      range.push(format(a, index));
      a = descending ? a - step : a + step;
      index++;
    }

    if (options.toRegex === true) {
      return toRegex(range, null, {
        wrap: false,
        options
      });
    }

    return range;
  };

  const fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }

    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }

    if (typeof step === 'function') {
      return fill(start, end, 1, {
        transform: step
      });
    }

    if (isObject$3(step)) {
      return fill(start, end, 0, step);
    }

    let opts = { ...options
    };
    if (opts.capture === true) opts.wrap = true;
    step = step || opts.step || 1;

    if (!isNumber(step)) {
      if (step != null && !isObject$3(step)) return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }

    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }

    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };

  var fillRange = fill;

  const compile = (ast, options = {}) => {
    let walk = (node, parent = {}) => {
      let invalidBlock = utils$8.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let invalid = invalidBlock === true || invalidNode === true;
      let prefix = options.escapeInvalid === true ? '\\' : '';
      let output = '';

      if (node.isOpen === true) {
        return prefix + node.value;
      }

      if (node.isClose === true) {
        return prefix + node.value;
      }

      if (node.type === 'open') {
        return invalid ? prefix + node.value : '(';
      }

      if (node.type === 'close') {
        return invalid ? prefix + node.value : ')';
      }

      if (node.type === 'comma') {
        return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
      }

      if (node.value) {
        return node.value;
      }

      if (node.nodes && node.ranges > 0) {
        let args = utils$8.reduce(node.nodes);
        let range = fillRange(...args, { ...options,
          wrap: false,
          toRegex: true
        });

        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }

      if (node.nodes) {
        for (let child of node.nodes) {
          output += walk(child, node);
        }
      }

      return output;
    };

    return walk(ast);
  };

  var compile_1 = compile;

  const append = (queue = '', stash = '', enclose = false) => {
    let result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length) return queue;

    if (!queue.length) {
      return enclose ? utils$8.flatten(stash).map(ele => `{${ele}}`) : stash;
    }

    for (let item of queue) {
      if (Array.isArray(item)) {
        for (let value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }

    return utils$8.flatten(result);
  };

  const expand$1 = (ast, options = {}) => {
    let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

    let walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;

      while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
        p = p.parent;
        q = p.queue;
      }

      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify$2(node, options)));
        return;
      }

      if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ['{}']));
        return;
      }

      if (node.nodes && node.ranges > 0) {
        let args = utils$8.reduce(node.nodes);

        if (utils$8.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
        }

        let range = fillRange(...args, options);

        if (range.length === 0) {
          range = stringify$2(node, options);
        }

        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }

      let enclose = utils$8.encloseBrace(node);
      let queue = node.queue;
      let block = node;

      while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
        block = block.parent;
        queue = block.queue;
      }

      for (let i = 0; i < node.nodes.length; i++) {
        let child = node.nodes[i];

        if (child.type === 'comma' && node.type === 'brace') {
          if (i === 1) queue.push('');
          queue.push('');
          continue;
        }

        if (child.type === 'close') {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }

        if (child.value && child.type !== 'open') {
          queue.push(append(queue.pop(), child.value));
          continue;
        }

        if (child.nodes) {
          walk(child, node);
        }
      }

      return queue;
    };

    return utils$8.flatten(walk(ast));
  };

  var expand_1 = expand$1;

  var constants$5 = {
    MAX_LENGTH: 1024 * 64,
    // Digits
    CHAR_0: '0',

    /* 0 */
    CHAR_9: '9',

    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 'A',

    /* A */
    CHAR_LOWERCASE_A: 'a',

    /* a */
    CHAR_UPPERCASE_Z: 'Z',

    /* Z */
    CHAR_LOWERCASE_Z: 'z',

    /* z */
    CHAR_LEFT_PARENTHESES: '(',

    /* ( */
    CHAR_RIGHT_PARENTHESES: ')',

    /* ) */
    CHAR_ASTERISK: '*',

    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: '&',

    /* & */
    CHAR_AT: '@',

    /* @ */
    CHAR_BACKSLASH: '\\',

    /* \ */
    CHAR_BACKTICK: '`',

    /* ` */
    CHAR_CARRIAGE_RETURN: '\r',

    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: '^',

    /* ^ */
    CHAR_COLON: ':',

    /* : */
    CHAR_COMMA: ',',

    /* , */
    CHAR_DOLLAR: '$',

    /* . */
    CHAR_DOT: '.',

    /* . */
    CHAR_DOUBLE_QUOTE: '"',

    /* " */
    CHAR_EQUAL: '=',

    /* = */
    CHAR_EXCLAMATION_MARK: '!',

    /* ! */
    CHAR_FORM_FEED: '\f',

    /* \f */
    CHAR_FORWARD_SLASH: '/',

    /* / */
    CHAR_HASH: '#',

    /* # */
    CHAR_HYPHEN_MINUS: '-',

    /* - */
    CHAR_LEFT_ANGLE_BRACKET: '<',

    /* < */
    CHAR_LEFT_CURLY_BRACE: '{',

    /* { */
    CHAR_LEFT_SQUARE_BRACKET: '[',

    /* [ */
    CHAR_LINE_FEED: '\n',

    /* \n */
    CHAR_NO_BREAK_SPACE: '\u00A0',

    /* \u00A0 */
    CHAR_PERCENT: '%',

    /* % */
    CHAR_PLUS: '+',

    /* + */
    CHAR_QUESTION_MARK: '?',

    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: '>',

    /* > */
    CHAR_RIGHT_CURLY_BRACE: '}',

    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: ']',

    /* ] */
    CHAR_SEMICOLON: ';',

    /* ; */
    CHAR_SINGLE_QUOTE: '\'',

    /* ' */
    CHAR_SPACE: ' ',

    /*   */
    CHAR_TAB: '\t',

    /* \t */
    CHAR_UNDERSCORE: '_',

    /* _ */
    CHAR_VERTICAL_LINE: '|',

    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF'
    /* \uFEFF */

  };

  /**
   * Constants
   */


  const {
    MAX_LENGTH: MAX_LENGTH$3,
    CHAR_BACKSLASH,

    /* \ */
    CHAR_BACKTICK,

    /* ` */
    CHAR_COMMA: CHAR_COMMA$3,

    /* , */
    CHAR_DOT: CHAR_DOT$3,

    /* . */
    CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$3,

    /* ( */
    CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$3,

    /* ) */
    CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$3,

    /* { */
    CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$3,

    /* } */
    CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$3,

    /* [ */
    CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$3,

    /* ] */
    CHAR_DOUBLE_QUOTE,

    /* " */
    CHAR_SINGLE_QUOTE,

    /* ' */
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = constants$5;
  /**
   * parse
   */


  const parse$6 = (input, options = {}) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    let opts = options || {};
    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$3, opts.maxLength) : MAX_LENGTH$3;

    if (input.length > max) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
    }

    let ast = {
      type: 'root',
      input,
      nodes: []
    };
    let stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    let length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    /**
     * Helpers
     */

    const advance = () => input[index++];

    const push = node => {
      if (node.type === 'text' && prev.type === 'dot') {
        prev.type = 'text';
      }

      if (prev && prev.type === 'text' && node.type === 'text') {
        prev.value += node.value;
        return;
      }

      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };

    push({
      type: 'bos'
    });

    while (index < length) {
      block = stack[stack.length - 1];
      value = advance();
      /**
       * Invalid chars
       */

      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      /**
       * Escaped chars
       */


      if (value === CHAR_BACKSLASH) {
        push({
          type: 'text',
          value: (options.keepEscaping ? value : '') + advance()
        });
        continue;
      }
      /**
       * Right square bracket (literal): ']'
       */


      if (value === CHAR_RIGHT_SQUARE_BRACKET$3) {
        push({
          type: 'text',
          value: '\\' + value
        });
        continue;
      }
      /**
       * Left square bracket: '['
       */


      if (value === CHAR_LEFT_SQUARE_BRACKET$3) {
        brackets++;
        let next;

        while (index < length && (next = advance())) {
          value += next;

          if (next === CHAR_LEFT_SQUARE_BRACKET$3) {
            brackets++;
            continue;
          }

          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET$3) {
            brackets--;

            if (brackets === 0) {
              break;
            }
          }
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Parentheses
       */


      if (value === CHAR_LEFT_PARENTHESES$3) {
        block = push({
          type: 'paren',
          nodes: []
        });
        stack.push(block);
        push({
          type: 'text',
          value
        });
        continue;
      }

      if (value === CHAR_RIGHT_PARENTHESES$3) {
        if (block.type !== 'paren') {
          push({
            type: 'text',
            value
          });
          continue;
        }

        block = stack.pop();
        push({
          type: 'text',
          value
        });
        block = stack[stack.length - 1];
        continue;
      }
      /**
       * Quotes: '|"|`
       */


      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        let open = value;
        let next;

        if (options.keepQuotes !== true) {
          value = '';
        }

        while (index < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }

          if (next === open) {
            if (options.keepQuotes === true) value += next;
            break;
          }

          value += next;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Left curly brace: '{'
       */


      if (value === CHAR_LEFT_CURLY_BRACE$3) {
        depth++;
        let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
        let brace = {
          type: 'brace',
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({
          type: 'open',
          value
        });
        continue;
      }
      /**
       * Right curly brace: '}'
       */


      if (value === CHAR_RIGHT_CURLY_BRACE$3) {
        if (block.type !== 'brace') {
          push({
            type: 'text',
            value
          });
          continue;
        }

        let type = 'close';
        block = stack.pop();
        block.close = true;
        push({
          type,
          value
        });
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      /**
       * Comma: ','
       */


      if (value === CHAR_COMMA$3 && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open = block.nodes.shift();
          block.nodes = [open, {
            type: 'text',
            value: stringify$2(block)
          }];
        }

        push({
          type: 'comma',
          value
        });
        block.commas++;
        continue;
      }
      /**
       * Dot: '.'
       */


      if (value === CHAR_DOT$3 && depth > 0 && block.commas === 0) {
        let siblings = block.nodes;

        if (depth === 0 || siblings.length === 0) {
          push({
            type: 'text',
            value
          });
          continue;
        }

        if (prev.type === 'dot') {
          block.range = [];
          prev.value += value;
          prev.type = 'range';

          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = 'text';
            continue;
          }

          block.ranges++;
          block.args = [];
          continue;
        }

        if (prev.type === 'range') {
          siblings.pop();
          let before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }

        push({
          type: 'dot',
          value
        });
        continue;
      }
      /**
       * Text
       */


      push({
        type: 'text',
        value
      });
    } // Mark imbalanced braces and brackets as invalid


    do {
      block = stack.pop();

      if (block.type !== 'root') {
        block.nodes.forEach(node => {
          if (!node.nodes) {
            if (node.type === 'open') node.isOpen = true;
            if (node.type === 'close') node.isClose = true;
            if (!node.nodes) node.type = 'text';
            node.invalid = true;
          }
        }); // get the location of the block on parent.nodes (block's siblings)

        let parent = stack[stack.length - 1];
        let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes

        parent.nodes.splice(index, 1, ...block.nodes);
      }
    } while (stack.length > 0);

    push({
      type: 'eos'
    });
    return ast;
  };

  var parse_1$4 = parse$6;

  /**
   * Expand the given pattern or create a regex-compatible string.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
   * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {String}
   * @api public
   */


  const braces = (input, options = {}) => {
    let output = [];

    if (Array.isArray(input)) {
      for (let pattern of input) {
        let result = braces.create(pattern, options);

        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }

    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }

    return output;
  };
  /**
   * Parse the given `str` with the given `options`.
   *
   * ```js
   * // braces.parse(pattern, [, options]);
   * const ast = braces.parse('a/{b,c}/d');
   * console.log(ast);
   * ```
   * @param {String} pattern Brace pattern to parse
   * @param {Object} options
   * @return {Object} Returns an AST
   * @api public
   */


  braces.parse = (input, options = {}) => parse_1$4(input, options);
  /**
   * Creates a braces string from an AST, or an AST node.
   *
   * ```js
   * const braces = require('braces');
   * let ast = braces.parse('foo/{a,b}/bar');
   * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
   * ```
   * @param {String} `input` Brace pattern or AST.
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */


  braces.stringify = (input, options = {}) => {
    if (typeof input === 'string') {
      return stringify$2(braces.parse(input, options), options);
    }

    return stringify$2(input, options);
  };
  /**
   * Compiles a brace pattern into a regex-compatible, optimized string.
   * This method is called by the main [braces](#braces) function by default.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.compile('a/{b,c}/d'));
   * //=> ['a/(b|c)/d']
   * ```
   * @param {String} `input` Brace pattern or AST.
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */


  braces.compile = (input, options = {}) => {
    if (typeof input === 'string') {
      input = braces.parse(input, options);
    }

    return compile_1(input, options);
  };
  /**
   * Expands a brace pattern into an array. This method is called by the
   * main [braces](#braces) function when `options.expand` is true. Before
   * using this method it's recommended that you read the [performance notes](#performance))
   * and advantages of using [.compile](#compile) instead.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.expand('a/{b,c}/d'));
   * //=> ['a/b/d', 'a/c/d'];
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */


  braces.expand = (input, options = {}) => {
    if (typeof input === 'string') {
      input = braces.parse(input, options);
    }

    let result = expand_1(input, options); // filter out empty strings if specified

    if (options.noempty === true) {
      result = result.filter(Boolean);
    } // filter out duplicates if specified


    if (options.nodupes === true) {
      result = [...new Set(result)];
    }

    return result;
  };
  /**
   * Processes a brace pattern and returns either an expanded array
   * (if `options.expand` is true), a highly optimized regex-compatible string.
   * This method is called by the main [braces](#braces) function.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
   * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */


  braces.create = (input, options = {}) => {
    if (input === '' || input.length < 3) {
      return [input];
    }

    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  /**
   * Expose "braces"
   */


  var braces_1 = braces;

  const WIN_SLASH$2 = '\\\\/';
  const WIN_NO_SLASH$2 = `[^${WIN_SLASH$2}]`;
  /**
   * Posix glob regex
   */

  const DOT_LITERAL$2 = '\\.';
  const PLUS_LITERAL$2 = '\\+';
  const QMARK_LITERAL$2 = '\\?';
  const SLASH_LITERAL$2 = '\\/';
  const ONE_CHAR$2 = '(?=.)';
  const QMARK$2 = '[^/]';
  const END_ANCHOR$2 = `(?:${SLASH_LITERAL$2}|$)`;
  const START_ANCHOR$2 = `(?:^|${SLASH_LITERAL$2})`;
  const DOTS_SLASH$2 = `${DOT_LITERAL$2}{1,2}${END_ANCHOR$2}`;
  const NO_DOT$2 = `(?!${DOT_LITERAL$2})`;
  const NO_DOTS$2 = `(?!${START_ANCHOR$2}${DOTS_SLASH$2})`;
  const NO_DOT_SLASH$2 = `(?!${DOT_LITERAL$2}{0,1}${END_ANCHOR$2})`;
  const NO_DOTS_SLASH$2 = `(?!${DOTS_SLASH$2})`;
  const QMARK_NO_DOT$2 = `[^.${SLASH_LITERAL$2}]`;
  const STAR$2 = `${QMARK$2}*?`;
  const POSIX_CHARS$2 = {
    DOT_LITERAL: DOT_LITERAL$2,
    PLUS_LITERAL: PLUS_LITERAL$2,
    QMARK_LITERAL: QMARK_LITERAL$2,
    SLASH_LITERAL: SLASH_LITERAL$2,
    ONE_CHAR: ONE_CHAR$2,
    QMARK: QMARK$2,
    END_ANCHOR: END_ANCHOR$2,
    DOTS_SLASH: DOTS_SLASH$2,
    NO_DOT: NO_DOT$2,
    NO_DOTS: NO_DOTS$2,
    NO_DOT_SLASH: NO_DOT_SLASH$2,
    NO_DOTS_SLASH: NO_DOTS_SLASH$2,
    QMARK_NO_DOT: QMARK_NO_DOT$2,
    STAR: STAR$2,
    START_ANCHOR: START_ANCHOR$2
  };
  /**
   * Windows glob regex
   */

  const WINDOWS_CHARS$2 = { ...POSIX_CHARS$2,
    SLASH_LITERAL: `[${WIN_SLASH$2}]`,
    QMARK: WIN_NO_SLASH$2,
    STAR: `${WIN_NO_SLASH$2}*?`,
    DOTS_SLASH: `${DOT_LITERAL$2}{1,2}(?:[${WIN_SLASH$2}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL$2})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH$2}])${DOT_LITERAL$2}{1,2}(?:[${WIN_SLASH$2}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL$2}{0,1}(?:[${WIN_SLASH$2}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL$2}{1,2}(?:[${WIN_SLASH$2}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH$2}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH$2}])`,
    END_ANCHOR: `(?:[${WIN_SLASH$2}]|$)`
  };
  /**
   * POSIX Bracket Regex
   */

  const POSIX_REGEX_SOURCE$5 = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
  };
  var constants$4 = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$5,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      '***': '*',
      '**/**': '**',
      '**/**/**': '**'
    },
    // Digits
    CHAR_0: 48,

    /* 0 */
    CHAR_9: 57,

    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,

    /* A */
    CHAR_LOWERCASE_A: 97,

    /* a */
    CHAR_UPPERCASE_Z: 90,

    /* Z */
    CHAR_LOWERCASE_Z: 122,

    /* z */
    CHAR_LEFT_PARENTHESES: 40,

    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,

    /* ) */
    CHAR_ASTERISK: 42,

    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,

    /* & */
    CHAR_AT: 64,

    /* @ */
    CHAR_BACKWARD_SLASH: 92,

    /* \ */
    CHAR_CARRIAGE_RETURN: 13,

    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,

    /* ^ */
    CHAR_COLON: 58,

    /* : */
    CHAR_COMMA: 44,

    /* , */
    CHAR_DOT: 46,

    /* . */
    CHAR_DOUBLE_QUOTE: 34,

    /* " */
    CHAR_EQUAL: 61,

    /* = */
    CHAR_EXCLAMATION_MARK: 33,

    /* ! */
    CHAR_FORM_FEED: 12,

    /* \f */
    CHAR_FORWARD_SLASH: 47,

    /* / */
    CHAR_GRAVE_ACCENT: 96,

    /* ` */
    CHAR_HASH: 35,

    /* # */
    CHAR_HYPHEN_MINUS: 45,

    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,

    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,

    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,

    /* [ */
    CHAR_LINE_FEED: 10,

    /* \n */
    CHAR_NO_BREAK_SPACE: 160,

    /* \u00A0 */
    CHAR_PERCENT: 37,

    /* % */
    CHAR_PLUS: 43,

    /* + */
    CHAR_QUESTION_MARK: 63,

    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,

    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,

    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,

    /* ] */
    CHAR_SEMICOLON: 59,

    /* ; */
    CHAR_SINGLE_QUOTE: 39,

    /* ' */
    CHAR_SPACE: 32,

    /*   */
    CHAR_TAB: 9,

    /* \t */
    CHAR_UNDERSCORE: 95,

    /* _ */
    CHAR_VERTICAL_LINE: 124,

    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,

    /* \uFEFF */
    SEP: path__default['default'].sep,

    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(chars) {
      return {
        '!': {
          type: 'negate',
          open: '(?:(?!(?:',
          close: `))${chars.STAR})`
        },
        '?': {
          type: 'qmark',
          open: '(?:',
          close: ')?'
        },
        '+': {
          type: 'plus',
          open: '(?:',
          close: ')+'
        },
        '*': {
          type: 'star',
          open: '(?:',
          close: ')*'
        },
        '@': {
          type: 'at',
          open: '(?:',
          close: ')'
        }
      };
    },

    /**
     * Create GLOB_CHARS
     */
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS$2 : POSIX_CHARS$2;
    }

  };

  var utils$7 = createCommonjsModule(function (module, exports) {



  const win32 = process.platform === 'win32';

  const {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = constants$4;

  exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

  exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);

  exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);

  exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');

  exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

  exports.removeBackslashes = str => {
    return str.replace(REGEX_REMOVE_BACKSLASH, match => {
      return match === '\\' ? '' : match;
    });
  };

  exports.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split('.').map(Number);

    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }

    return false;
  };

  exports.isWindows = options => {
    if (options && typeof options.windows === 'boolean') {
      return options.windows;
    }

    return win32 === true || path__default['default'].sep === '\\';
  };

  exports.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };

  exports.removePrefix = (input, state = {}) => {
    let output = input;

    if (output.startsWith('./')) {
      output = output.slice(2);
      state.prefix = './';
    }

    return output;
  };

  exports.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? '' : '^';
    const append = options.contains ? '' : '$';
    let output = `${prepend}(?:${input})${append}`;

    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }

    return output;
  };
  });

  const {
    CHAR_ASTERISK: CHAR_ASTERISK$2,

    /* * */
    CHAR_AT: CHAR_AT$2,

    /* @ */
    CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH$2,

    /* \ */
    CHAR_COMMA: CHAR_COMMA$2,

    /* , */
    CHAR_DOT: CHAR_DOT$2,

    /* . */
    CHAR_EXCLAMATION_MARK: CHAR_EXCLAMATION_MARK$2,

    /* ! */
    CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH$2,

    /* / */
    CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$2,

    /* { */
    CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$2,

    /* ( */
    CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$2,

    /* [ */
    CHAR_PLUS: CHAR_PLUS$2,

    /* + */
    CHAR_QUESTION_MARK: CHAR_QUESTION_MARK$2,

    /* ? */
    CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$2,

    /* } */
    CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$2,

    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$2
    /* ] */

  } = constants$4;

  const isPathSeparator$2 = code => {
    return code === CHAR_FORWARD_SLASH$2 || code === CHAR_BACKWARD_SLASH$2;
  };

  const depth$2 = token => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  /**
   * Quickly scans a glob pattern and returns an object with a handful of
   * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
   * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
   * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
   *
   * ```js
   * const pm = require('picomatch');
   * console.log(pm.scan('foo/bar/*.js'));
   * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object} Returns an object with tokens and regex source string.
   * @api public
   */


  const scan$2 = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {
      value: '',
      depth: 0,
      isGlob: false
    };

    const eos = () => index >= length;

    const peek = () => str.charCodeAt(index + 1);

    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };

    while (index < length) {
      code = advance();
      let next;

      if (code === CHAR_BACKWARD_SLASH$2) {
        backslashes = token.backslashes = true;
        code = advance();

        if (code === CHAR_LEFT_CURLY_BRACE$2) {
          braceEscaped = true;
        }

        continue;
      }

      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$2) {
        braces++;

        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH$2) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (code === CHAR_LEFT_CURLY_BRACE$2) {
            braces++;
            continue;
          }

          if (braceEscaped !== true && code === CHAR_DOT$2 && (code = advance()) === CHAR_DOT$2) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (braceEscaped !== true && code === CHAR_COMMA$2) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (code === CHAR_RIGHT_CURLY_BRACE$2) {
            braces--;

            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_FORWARD_SLASH$2) {
        slashes.push(index);
        tokens.push(token);
        token = {
          value: '',
          depth: 0,
          isGlob: false
        };
        if (finished === true) continue;

        if (prev === CHAR_DOT$2 && index === start + 1) {
          start += 2;
          continue;
        }

        lastIndex = index + 1;
        continue;
      }

      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS$2 || code === CHAR_AT$2 || code === CHAR_ASTERISK$2 || code === CHAR_QUESTION_MARK$2 || code === CHAR_EXCLAMATION_MARK$2;

        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES$2) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;

          if (code === CHAR_EXCLAMATION_MARK$2 && index === start) {
            negatedExtglob = true;
          }

          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH$2) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }

              if (code === CHAR_RIGHT_PARENTHESES$2) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }

            continue;
          }

          break;
        }
      }

      if (code === CHAR_ASTERISK$2) {
        if (prev === CHAR_ASTERISK$2) isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_QUESTION_MARK$2) {
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_LEFT_SQUARE_BRACKET$2) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH$2) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET$2) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK$2 && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }

      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$2) {
        isGlob = token.isGlob = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES$2) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES$2) {
              finished = true;
              break;
            }
          }

          continue;
        }

        break;
      }

      if (isGlob === true) {
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }
    }

    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }

    let base = str;
    let prefix = '';
    let glob = '';

    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }

    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = '';
      glob = str;
    } else {
      base = str;
    }

    if (base && base !== '' && base !== '/' && base !== str) {
      if (isPathSeparator$2(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }

    if (opts.unescape === true) {
      if (glob) glob = utils$7.removeBackslashes(glob);

      if (base && backslashes === true) {
        base = utils$7.removeBackslashes(base);
      }
    }

    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };

    if (opts.tokens === true) {
      state.maxDepth = 0;

      if (!isPathSeparator$2(code)) {
        tokens.push(token);
      }

      state.tokens = tokens;
    }

    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;

      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx];
        const value = input.slice(n, i);

        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }

          depth$2(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }

        if (idx !== 0 || value !== '') {
          parts.push(value);
        }

        prevIndex = i;
      }

      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);

        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth$2(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }

      state.slashes = slashes;
      state.parts = parts;
    }

    return state;
  };

  var scan_1$2 = scan$2;

  /**
   * Constants
   */


  const {
    MAX_LENGTH: MAX_LENGTH$2,
    POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$4,
    REGEX_NON_SPECIAL_CHARS: REGEX_NON_SPECIAL_CHARS$2,
    REGEX_SPECIAL_CHARS_BACKREF: REGEX_SPECIAL_CHARS_BACKREF$2,
    REPLACEMENTS: REPLACEMENTS$2
  } = constants$4;
  /**
   * Helpers
   */

  const expandRange$2 = (args, options) => {
    if (typeof options.expandRange === 'function') {
      return options.expandRange(...args, options);
    }

    args.sort();
    const value = `[${args.join('-')}]`;

    try {
      /* eslint-disable-next-line no-new */
      new RegExp(value);
    } catch (ex) {
      return args.map(v => utils$7.escapeRegex(v)).join('..');
    }

    return value;
  };
  /**
   * Create the message for a syntax error
   */


  const syntaxError$2 = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  /**
   * Parse the given input string.
   * @param {String} input
   * @param {Object} options
   * @return {Object}
   */


  const parse$5 = (input, options) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    input = REPLACEMENTS$2[input] || input;
    const opts = { ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$2, opts.maxLength) : MAX_LENGTH$2;
    let len = input.length;

    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }

    const bos = {
      type: 'bos',
      value: '',
      output: opts.prepend || ''
    };
    const tokens = [bos];
    const capture = opts.capture ? '' : '?:';
    const win32 = utils$7.isWindows(options); // create constants based on platform, for windows or posix

    const PLATFORM_CHARS = constants$4.globChars(win32);
    const EXTGLOB_CHARS = constants$4.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;

    const globstar = opts => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };

    const nodot = opts.dot ? '' : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;

    if (opts.capture) {
      star = `(${star})`;
    } // minimatch options support


    if (typeof opts.noext === 'boolean') {
      opts.noextglob = opts.noext;
    }

    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: '',
      output: '',
      prefix: '',
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils$7.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    /**
     * Tokenizing helpers
     */

    const eos = () => state.index === len - 1;

    const peek = state.peek = (n = 1) => input[state.index + n];

    const advance = state.advance = () => input[++state.index] || '';

    const remaining = () => input.slice(state.index + 1);

    const consume = (value = '', num = 0) => {
      state.consumed += value;
      state.index += num;
    };

    const append = token => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };

    const negate = () => {
      let count = 1;

      while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
        advance();
        state.start++;
        count++;
      }

      if (count % 2 === 0) {
        return false;
      }

      state.negated = true;
      state.start++;
      return true;
    };

    const increment = type => {
      state[type]++;
      stack.push(type);
    };

    const decrement = type => {
      state[type]--;
      stack.pop();
    };
    /**
     * Push tokens onto the tokens array. This helper speeds up
     * tokenizing by 1) helping us avoid backtracking as much as possible,
     * and 2) helping us avoid creating extra tokens when consecutive
     * characters are plain text. This improves performance and simplifies
     * lookbehinds.
     */


    const push = tok => {
      if (prev.type === 'globstar') {
        const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');

        if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = 'star';
          prev.value = '*';
          prev.output = star;
          state.output += prev.output;
        }
      }

      if (extglobs.length && tok.type !== 'paren') {
        extglobs[extglobs.length - 1].inner += tok.value;
      }

      if (tok.value || tok.output) append(tok);

      if (prev && prev.type === 'text' && tok.type === 'text') {
        prev.value += tok.value;
        prev.output = (prev.output || '') + tok.value;
        return;
      }

      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };

    const extglobOpen = (type, value) => {
      const token = { ...EXTGLOB_CHARS[value],
        conditions: 1,
        inner: ''
      };
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? '(' : '') + token.open;
      increment('parens');
      push({
        type,
        value,
        output: state.output ? '' : ONE_CHAR
      });
      push({
        type: 'paren',
        extglob: true,
        value: advance(),
        output
      });
      extglobs.push(token);
    };

    const extglobClose = token => {
      let output = token.close + (opts.capture ? ')' : '');
      let rest;

      if (token.type === 'negate') {
        let extglobStar = star;

        if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
          extglobStar = globstar(opts);
        }

        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)$))${extglobStar}`;
        }

        if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
          // In this case, we need to parse the string and use it in the output of the original pattern.
          // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
          //
          // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
          const expression = parse$5(rest, { ...options,
            fastpaths: false
          }).output;
          output = token.close = `)${expression})${extglobStar})`;
        }

        if (token.prev.type === 'bos') {
          state.negatedExtglob = true;
        }
      }

      push({
        type: 'paren',
        extglob: true,
        value,
        output
      });
      decrement('parens');
    };
    /**
     * Fast paths
     */


    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF$2, (m, esc, chars, first, rest, index) => {
        if (first === '\\') {
          backslashes = true;
          return m;
        }

        if (first === '?') {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : '');
          }

          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
          }

          return QMARK.repeat(chars.length);
        }

        if (first === '.') {
          return DOT_LITERAL.repeat(chars.length);
        }

        if (first === '*') {
          if (esc) {
            return esc + first + (rest ? star : '');
          }

          return star;
        }

        return esc ? m : `\\${m}`;
      });

      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, '');
        } else {
          output = output.replace(/\\+/g, m => {
            return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
          });
        }
      }

      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }

      state.output = utils$7.wrapOutput(output, state, options);
      return state;
    }
    /**
     * Tokenize input until we reach end-of-string
     */


    while (!eos()) {
      value = advance();

      if (value === '\u0000') {
        continue;
      }
      /**
       * Escaped characters
       */


      if (value === '\\') {
        const next = peek();

        if (next === '/' && opts.bash !== true) {
          continue;
        }

        if (next === '.' || next === ';') {
          continue;
        }

        if (!next) {
          value += '\\';
          push({
            type: 'text',
            value
          });
          continue;
        } // collapse slashes to reduce potential for exploits


        const match = /^\\+/.exec(remaining());
        let slashes = 0;

        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;

          if (slashes % 2 !== 0) {
            value += '\\';
          }
        }

        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }

        if (state.brackets === 0) {
          push({
            type: 'text',
            value
          });
          continue;
        }
      }
      /**
       * If we're inside a regex character class, continue
       * until we reach the closing bracket.
       */


      if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
        if (opts.posix !== false && value === ':') {
          const inner = prev.value.slice(1);

          if (inner.includes('[')) {
            prev.posix = true;

            if (inner.includes(':')) {
              const idx = prev.value.lastIndexOf('[');
              const pre = prev.value.slice(0, idx);
              const rest = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE$4[rest];

              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();

                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }

                continue;
              }
            }
          }
        }

        if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
          value = `\\${value}`;
        }

        if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
          value = `\\${value}`;
        }

        if (opts.posix === true && value === '!' && prev.value === '[') {
          value = '^';
        }

        prev.value += value;
        append({
          value
        });
        continue;
      }
      /**
       * If we're inside a quoted string, continue
       * until we reach the closing double quote.
       */


      if (state.quotes === 1 && value !== '"') {
        value = utils$7.escapeRegex(value);
        prev.value += value;
        append({
          value
        });
        continue;
      }
      /**
       * Double quotes
       */


      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;

        if (opts.keepQuotes === true) {
          push({
            type: 'text',
            value
          });
        }

        continue;
      }
      /**
       * Parentheses
       */


      if (value === '(') {
        increment('parens');
        push({
          type: 'paren',
          value
        });
        continue;
      }

      if (value === ')') {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError$2('opening', '('));
        }

        const extglob = extglobs[extglobs.length - 1];

        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }

        push({
          type: 'paren',
          value,
          output: state.parens ? ')' : '\\)'
        });
        decrement('parens');
        continue;
      }
      /**
       * Square brackets
       */


      if (value === '[') {
        if (opts.nobracket === true || !remaining().includes(']')) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError$2('closing', ']'));
          }

          value = `\\${value}`;
        } else {
          increment('brackets');
        }

        push({
          type: 'bracket',
          value
        });
        continue;
      }

      if (value === ']') {
        if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
          push({
            type: 'text',
            value,
            output: `\\${value}`
          });
          continue;
        }

        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError$2('opening', '['));
          }

          push({
            type: 'text',
            value,
            output: `\\${value}`
          });
          continue;
        }

        decrement('brackets');
        const prevValue = prev.value.slice(1);

        if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
          value = `/${value}`;
        }

        prev.value += value;
        append({
          value
        }); // when literal brackets are explicitly disabled
        // assume we should match with a regex character class

        if (opts.literalBrackets === false || utils$7.hasRegexChars(prevValue)) {
          continue;
        }

        const escaped = utils$7.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled
        // assume we should escape the brackets to match literal characters

        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        } // when the user specifies nothing, try to match both


        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      /**
       * Braces
       */


      if (value === '{' && opts.nobrace !== true) {
        increment('braces');
        const open = {
          type: 'brace',
          value,
          output: '(',
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }

      if (value === '}') {
        const brace = braces[braces.length - 1];

        if (opts.nobrace === true || !brace) {
          push({
            type: 'text',
            value,
            output: value
          });
          continue;
        }

        let output = ')';

        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];

          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();

            if (arr[i].type === 'brace') {
              break;
            }

            if (arr[i].type !== 'dots') {
              range.unshift(arr[i].value);
            }
          }

          output = expandRange$2(range, opts);
          state.backtrack = true;
        }

        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = '\\{';
          value = output = '\\}';
          state.output = out;

          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }

        push({
          type: 'brace',
          value,
          output
        });
        decrement('braces');
        braces.pop();
        continue;
      }
      /**
       * Pipes
       */


      if (value === '|') {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Commas
       */


      if (value === ',') {
        let output = value;
        const brace = braces[braces.length - 1];

        if (brace && stack[stack.length - 1] === 'braces') {
          brace.comma = true;
          output = '|';
        }

        push({
          type: 'comma',
          value,
          output
        });
        continue;
      }
      /**
       * Slashes
       */


      if (value === '/') {
        // if the beginning of the glob is "./", advance the start
        // to the current index, and don't add the "./" characters
        // to the state. This greatly simplifies lookbehinds when
        // checking for BOS characters like "!" and "." (not "./")
        if (prev.type === 'dot' && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = '';
          state.output = '';
          tokens.pop();
          prev = bos; // reset "prev" to the first token

          continue;
        }

        push({
          type: 'slash',
          value,
          output: SLASH_LITERAL
        });
        continue;
      }
      /**
       * Dots
       */


      if (value === '.') {
        if (state.braces > 0 && prev.type === 'dot') {
          if (prev.value === '.') prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = 'dots';
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }

        if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
          push({
            type: 'text',
            value,
            output: DOT_LITERAL
          });
          continue;
        }

        push({
          type: 'dot',
          value,
          output: DOT_LITERAL
        });
        continue;
      }
      /**
       * Question marks
       */


      if (value === '?') {
        const isGroup = prev && prev.value === '(';

        if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('qmark', value);
          continue;
        }

        if (prev && prev.type === 'paren') {
          const next = peek();
          let output = value;

          if (next === '<' && !utils$7.supportsLookbehinds()) {
            throw new Error('Node.js v10 or higher is required for regex lookbehinds');
          }

          if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }

          push({
            type: 'text',
            value,
            output
          });
          continue;
        }

        if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
          push({
            type: 'qmark',
            value,
            output: QMARK_NO_DOT
          });
          continue;
        }

        push({
          type: 'qmark',
          value,
          output: QMARK
        });
        continue;
      }
      /**
       * Exclamation
       */


      if (value === '!') {
        if (opts.noextglob !== true && peek() === '(') {
          if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
            extglobOpen('negate', value);
            continue;
          }
        }

        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      /**
       * Plus
       */


      if (value === '+') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('plus', value);
          continue;
        }

        if (prev && prev.value === '(' || opts.regex === false) {
          push({
            type: 'plus',
            value,
            output: PLUS_LITERAL
          });
          continue;
        }

        if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
          push({
            type: 'plus',
            value
          });
          continue;
        }

        push({
          type: 'plus',
          value: PLUS_LITERAL
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value === '@') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          push({
            type: 'at',
            extglob: true,
            value,
            output: ''
          });
          continue;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value !== '*') {
        if (value === '$' || value === '^') {
          value = `\\${value}`;
        }

        const match = REGEX_NON_SPECIAL_CHARS$2.exec(remaining());

        if (match) {
          value += match[0];
          state.index += match[0].length;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Stars
       */


      if (prev && (prev.type === 'globstar' || prev.star === true)) {
        prev.type = 'star';
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }

      let rest = remaining();

      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen('star', value);
        continue;
      }

      if (prev.type === 'star') {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }

        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === 'slash' || prior.type === 'bos';
        const afterStar = before && (before.type === 'star' || before.type === 'globstar');

        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
          push({
            type: 'star',
            value,
            output: ''
          });
          continue;
        }

        const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
        const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');

        if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
          push({
            type: 'star',
            value,
            output: ''
          });
          continue;
        } // strip consecutive `/**/`


        while (rest.slice(0, 3) === '/**') {
          const after = input[state.index + 4];

          if (after && after !== '/') {
            break;
          }

          rest = rest.slice(3);
          consume('/**', 3);
        }

        if (prior.type === 'bos' && eos()) {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = 'globstar';
          prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
          const end = rest[1] !== void 0 ? '|$' : '';
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = 'globstar';
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        }

        if (prior.type === 'bos' && rest[0] === '/') {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        } // remove single star from output


        state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar

        prev.type = 'globstar';
        prev.output = globstar(opts);
        prev.value += value; // reset output with globstar

        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      const token = {
        type: 'star',
        value,
        output: star
      };

      if (opts.bash === true) {
        token.output = '.*?';

        if (prev.type === 'bos' || prev.type === 'slash') {
          token.output = nodot + token.output;
        }

        push(token);
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }

      if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
        if (prev.type === 'dot') {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }

        if (peek() !== '*') {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }

      push(token);
    }

    while (state.brackets > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError$2('closing', ']'));
      state.output = utils$7.escapeLast(state.output, '[');
      decrement('brackets');
    }

    while (state.parens > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError$2('closing', ')'));
      state.output = utils$7.escapeLast(state.output, '(');
      decrement('parens');
    }

    while (state.braces > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError$2('closing', '}'));
      state.output = utils$7.escapeLast(state.output, '{');
      decrement('braces');
    }

    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
      push({
        type: 'maybe_slash',
        value: '',
        output: `${SLASH_LITERAL}?`
      });
    } // rebuild the output if we had to backtrack at any point


    if (state.backtrack === true) {
      state.output = '';

      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;

        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }

    return state;
  };
  /**
   * Fast paths for creating regular expressions for common glob patterns.
   * This can significantly speed up processing and has very little downside
   * impact when none of the fast paths match.
   */


  parse$5.fastpaths = (input, options) => {
    const opts = { ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$2, opts.maxLength) : MAX_LENGTH$2;
    const len = input.length;

    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }

    input = REPLACEMENTS$2[input] || input;
    const win32 = utils$7.isWindows(options); // create constants based on platform, for windows or posix

    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants$4.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? '' : '?:';
    const state = {
      negated: false,
      prefix: ''
    };
    let star = opts.bash === true ? '.*?' : STAR;

    if (opts.capture) {
      star = `(${star})`;
    }

    const globstar = opts => {
      if (opts.noglobstar === true) return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };

    const create = str => {
      switch (str) {
        case '*':
          return `${nodot}${ONE_CHAR}${star}`;

        case '.*':
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '*.*':
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '*/*':
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

        case '**':
          return nodot + globstar(opts);

        case '**/*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

        case '**/*.*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '**/.*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

        default:
          {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source = create(match[1]);
            if (!source) return;
            return source + DOT_LITERAL + match[2];
          }
      }
    };

    const output = utils$7.removePrefix(input, state);
    let source = create(output);

    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }

    return source;
  };

  var parse_1$3 = parse$5;

  const isObject$2 = val => val && typeof val === 'object' && !Array.isArray(val);
  /**
   * Creates a matcher function from one or more glob patterns. The
   * returned function takes a string to match as its first argument,
   * and returns true if the string is a match. The returned matcher
   * function also takes a boolean as the second argument that, when true,
   * returns an object with additional information.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch(glob[, options]);
   *
   * const isMatch = picomatch('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @name picomatch
   * @param {String|Array} `globs` One or more glob patterns.
   * @param {Object=} `options`
   * @return {Function=} Returns a matcher function.
   * @api public
   */


  const picomatch$5 = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map(input => picomatch$5(input, options, returnState));

      const arrayMatcher = str => {
        for (const isMatch of fns) {
          const state = isMatch(str);
          if (state) return state;
        }

        return false;
      };

      return arrayMatcher;
    }

    const isState = isObject$2(glob) && glob.tokens && glob.input;

    if (glob === '' || typeof glob !== 'string' && !isState) {
      throw new TypeError('Expected pattern to be a non-empty string');
    }

    const opts = options || {};
    const posix = utils$7.isWindows(options);
    const regex = isState ? picomatch$5.compileRe(glob, options) : picomatch$5.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;

    let isIgnored = () => false;

    if (opts.ignore) {
      const ignoreOpts = { ...options,
        ignore: null,
        onMatch: null,
        onResult: null
      };
      isIgnored = picomatch$5(opts.ignore, ignoreOpts, returnState);
    }

    const matcher = (input, returnObject = false) => {
      const {
        isMatch,
        match,
        output
      } = picomatch$5.test(input, regex, options, {
        glob,
        posix
      });
      const result = {
        glob,
        state,
        regex,
        posix,
        input,
        output,
        match,
        isMatch
      };

      if (typeof opts.onResult === 'function') {
        opts.onResult(result);
      }

      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (isIgnored(input)) {
        if (typeof opts.onIgnore === 'function') {
          opts.onIgnore(result);
        }

        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (typeof opts.onMatch === 'function') {
        opts.onMatch(result);
      }

      return returnObject ? result : true;
    };

    if (returnState) {
      matcher.state = state;
    }

    return matcher;
  };
  /**
   * Test `input` with the given `regex`. This is used by the main
   * `picomatch()` function to test the input string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.test(input, regex[, options]);
   *
   * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
   * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp} `regex`
   * @return {Object} Returns an object with matching info.
   * @api public
   */


  picomatch$5.test = (input, regex, options, {
    glob,
    posix
  } = {}) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected input to be a string');
    }

    if (input === '') {
      return {
        isMatch: false,
        output: ''
      };
    }

    const opts = options || {};
    const format = opts.format || (posix ? utils$7.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;

    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }

    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch$5.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }

    return {
      isMatch: Boolean(match),
      match,
      output
    };
  };
  /**
   * Match the basename of a filepath.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.matchBase(input, glob[, options]);
   * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
   * @return {Boolean}
   * @api public
   */


  picomatch$5.matchBase = (input, glob, options, posix = utils$7.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch$5.makeRe(glob, options);
    return regex.test(path__default['default'].basename(input));
  };
  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.isMatch(string, patterns[, options]);
   *
   * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String|Array} str The string to test.
   * @param {String|Array} patterns One or more glob patterns to use for matching.
   * @param {Object} [options] See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  picomatch$5.isMatch = (str, patterns, options) => picomatch$5(patterns, options)(str);
  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const result = picomatch.parse(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
   * @api public
   */


  picomatch$5.parse = (pattern, options) => {
    if (Array.isArray(pattern)) return pattern.map(p => picomatch$5.parse(p, options));
    return parse_1$3(pattern, { ...options,
      fastpaths: false
    });
  };
  /**
   * Scan a glob pattern to separate the pattern into segments.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.scan(input[, options]);
   *
   * const result = picomatch.scan('!./foo/*.js');
   * console.log(result);
   * { prefix: '!./',
   *   input: '!./foo/*.js',
   *   start: 3,
   *   base: 'foo',
   *   glob: '*.js',
   *   isBrace: false,
   *   isBracket: false,
   *   isGlob: true,
   *   isExtglob: false,
   *   isGlobstar: false,
   *   negated: true }
   * ```
   * @param {String} `input` Glob pattern to scan.
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */


  picomatch$5.scan = (input, options) => scan_1$2(input, options);
  /**
   * Compile a regular expression from the `state` object returned by the
   * [parse()](#parse) method.
   *
   * @param {Object} `state`
   * @param {Object} `options`
   * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
   * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
   * @return {RegExp}
   * @api public
   */


  picomatch$5.compileRe = (state, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state.output;
    }

    const opts = options || {};
    const prepend = opts.contains ? '' : '^';
    const append = opts.contains ? '' : '$';
    let source = `${prepend}(?:${state.output})${append}`;

    if (state && state.negated === true) {
      source = `^(?!${source}).*$`;
    }

    const regex = picomatch$5.toRegex(source, options);

    if (returnState === true) {
      regex.state = state;
    }

    return regex;
  };
  /**
   * Create a regular expression from a parsed glob pattern.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const state = picomatch.parse('*.js');
   * // picomatch.compileRe(state[, options]);
   *
   * console.log(picomatch.compileRe(state));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `state` The object returned from the `.parse` method.
   * @param {Object} `options`
   * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
   * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */


  picomatch$5.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== 'string') {
      throw new TypeError('Expected a non-empty string');
    }

    let parsed = {
      negated: false,
      fastpaths: true
    };

    if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
      parsed.output = parse_1$3.fastpaths(input, options);
    }

    if (!parsed.output) {
      parsed = parse_1$3(input, options);
    }

    return picomatch$5.compileRe(parsed, options, returnOutput, returnState);
  };
  /**
   * Create a regular expression from the given regex source string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.toRegex(source[, options]);
   *
   * const { output } = picomatch.parse('*.js');
   * console.log(picomatch.toRegex(output));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `source` Regular expression source string.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */


  picomatch$5.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
    } catch (err) {
      if (options && options.debug === true) throw err;
      return /$^/;
    }
  };
  /**
   * Picomatch constants.
   * @return {Object}
   */


  picomatch$5.constants = constants$4;
  /**
   * Expose "picomatch"
   */

  var picomatch_1$2 = picomatch$5;

  var picomatch$4 = picomatch_1$2;

  const isEmptyString$2 = val => val === '' || val === './';
  /**
   * Returns an array of strings that match one or more glob patterns.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm(list, patterns[, options]);
   *
   * console.log(mm(['a.js', 'a.txt'], ['*.js']));
   * //=> [ 'a.js' ]
   * ```
   * @param {String|Array<string>} `list` List of strings to match.
   * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options)
   * @return {Array} Returns an array of matches
   * @summary false
   * @api public
   */


  const micromatch$2 = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;

    let onResult = state => {
      items.add(state.output);

      if (options && options.onResult) {
        options.onResult(state);
      }
    };

    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch$4(String(patterns[i]), { ...options,
        onResult
      }, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated) negatives++;

      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match) continue;

        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }

    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter(item => !omit.has(item));

    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(', ')}"`);
      }

      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
      }
    }

    return matches;
  };
  /**
   * Backwards compatibility
   */


  micromatch$2.match = micromatch$2;
  /**
   * Returns a matcher function from the given glob `pattern` and `options`.
   * The returned function takes a string to match as its only argument and returns
   * true if the string is a match.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.matcher(pattern[, options]);
   *
   * const isMatch = mm.matcher('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @param {String} `pattern` Glob pattern
   * @param {Object} `options`
   * @return {Function} Returns a matcher function.
   * @api public
   */

  micromatch$2.matcher = (pattern, options) => picomatch$4(pattern, options);
  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.isMatch(string, patterns[, options]);
   *
   * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(mm.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `[options]` See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  micromatch$2.isMatch = (str, patterns, options) => picomatch$4(patterns, options)(str);
  /**
   * Backwards compatibility
   */


  micromatch$2.any = micromatch$2.isMatch;
  /**
   * Returns a list of strings that _**do not match any**_ of the given `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.not(list, patterns[, options]);
   *
   * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
   * //=> ['b.b', 'c.c']
   * ```
   * @param {Array} `list` Array of strings to match.
   * @param {String|Array} `patterns` One or more glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of strings that **do not match** the given patterns.
   * @api public
   */

  micromatch$2.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];

    let onResult = state => {
      if (options.onResult) options.onResult(state);
      items.push(state.output);
    };

    let matches = new Set(micromatch$2(list, patterns, { ...options,
      onResult
    }));

    for (let item of items) {
      if (!matches.has(item)) {
        result.add(item);
      }
    }

    return [...result];
  };
  /**
   * Returns true if the given `string` contains the given pattern. Similar
   * to [.isMatch](#isMatch) but the pattern can match any part of the string.
   *
   * ```js
   * var mm = require('micromatch');
   * // mm.contains(string, pattern[, options]);
   *
   * console.log(mm.contains('aa/bb/cc', '*b'));
   * //=> true
   * console.log(mm.contains('aa/bb/cc', '*d'));
   * //=> false
   * ```
   * @param {String} `str` The string to match.
   * @param {String|Array} `patterns` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
   * @api public
   */


  micromatch$2.contains = (str, pattern, options) => {
    if (typeof str !== 'string') {
      throw new TypeError(`Expected a string: "${util__default['default'].inspect(str)}"`);
    }

    if (Array.isArray(pattern)) {
      return pattern.some(p => micromatch$2.contains(str, p, options));
    }

    if (typeof pattern === 'string') {
      if (isEmptyString$2(str) || isEmptyString$2(pattern)) {
        return false;
      }

      if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {
        return true;
      }
    }

    return micromatch$2.isMatch(str, pattern, { ...options,
      contains: true
    });
  };
  /**
   * Filter the keys of the given object with the given `glob` pattern
   * and `options`. Does not attempt to match nested keys. If you need this feature,
   * use [glob-object][] instead.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.matchKeys(object, patterns[, options]);
   *
   * const obj = { aa: 'a', ab: 'b', ac: 'c' };
   * console.log(mm.matchKeys(obj, '*b'));
   * //=> { ab: 'b' }
   * ```
   * @param {Object} `object` The object with keys to filter.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Object} Returns an object with only keys that match the given patterns.
   * @api public
   */


  micromatch$2.matchKeys = (obj, patterns, options) => {
    if (!utils$7.isObject(obj)) {
      throw new TypeError('Expected the first argument to be an object');
    }

    let keys = micromatch$2(Object.keys(obj), patterns, options);
    let res = {};

    for (let key of keys) res[key] = obj[key];

    return res;
  };
  /**
   * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.some(list, patterns[, options]);
   *
   * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // true
   * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
   * @api public
   */


  micromatch$2.some = (list, patterns, options) => {
    let items = [].concat(list);

    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch$4(String(pattern), options);

      if (items.some(item => isMatch(item))) {
        return true;
      }
    }

    return false;
  };
  /**
   * Returns true if every string in the given `list` matches
   * any of the given glob `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.every(list, patterns[, options]);
   *
   * console.log(mm.every('foo.js', ['foo.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // false
   * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param {String|Array} `list` The string or array of strings to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
   * @api public
   */


  micromatch$2.every = (list, patterns, options) => {
    let items = [].concat(list);

    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch$4(String(pattern), options);

      if (!items.every(item => isMatch(item))) {
        return false;
      }
    }

    return true;
  };
  /**
   * Returns true if **all** of the given `patterns` match
   * the specified string.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.all(string, patterns[, options]);
   *
   * console.log(mm.all('foo.js', ['foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
   * // false
   *
   * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
   * // true
   * ```
   * @param {String|Array} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  micromatch$2.all = (str, patterns, options) => {
    if (typeof str !== 'string') {
      throw new TypeError(`Expected a string: "${util__default['default'].inspect(str)}"`);
    }

    return [].concat(patterns).every(p => picomatch$4(p, options)(str));
  };
  /**
   * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.capture(pattern, string[, options]);
   *
   * console.log(mm.capture('test/*.js', 'test/foo.js'));
   * //=> ['foo']
   * console.log(mm.capture('test/*.js', 'foo/bar.css'));
   * //=> null
   * ```
   * @param {String} `glob` Glob pattern to use for matching.
   * @param {String} `input` String to match
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
   * @api public
   */


  micromatch$2.capture = (glob, input, options) => {
    let posix = utils$7.isWindows(options);
    let regex = picomatch$4.makeRe(String(glob), { ...options,
      capture: true
    });
    let match = regex.exec(posix ? utils$7.toPosixSlashes(input) : input);

    if (match) {
      return match.slice(1).map(v => v === void 0 ? '' : v);
    }
  };
  /**
   * Create a regular expression from the given glob `pattern`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.makeRe(pattern[, options]);
   *
   * console.log(mm.makeRe('*.js'));
   * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
   * ```
   * @param {String} `pattern` A glob pattern to convert to regex.
   * @param {Object} `options`
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */


  micromatch$2.makeRe = (...args) => picomatch$4.makeRe(...args);
  /**
   * Scan a glob pattern to separate the pattern into segments. Used
   * by the [split](#split) method.
   *
   * ```js
   * const mm = require('micromatch');
   * const state = mm.scan(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */


  micromatch$2.scan = (...args) => picomatch$4.scan(...args);
  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const mm = require('micromatch');
   * const state = mm.parse(pattern[, options]);
   * ```
   * @param {String} `glob`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as regex source string.
   * @api public
   */


  micromatch$2.parse = (patterns, options) => {
    let res = [];

    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces_1(String(pattern), options)) {
        res.push(picomatch$4.parse(str, options));
      }
    }

    return res;
  };
  /**
   * Process the given brace `pattern`.
   *
   * ```js
   * const { braces } = require('micromatch');
   * console.log(braces('foo/{a,b,c}/bar'));
   * //=> [ 'foo/(a|b|c)/bar' ]
   *
   * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
   * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
   * ```
   * @param {String} `pattern` String with brace pattern to process.
   * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
   * @return {Array}
   * @api public
   */


  micromatch$2.braces = (pattern, options) => {
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');

    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }

    return braces_1(pattern, options);
  };
  /**
   * Expand braces
   */


  micromatch$2.braceExpand = (pattern, options) => {
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');
    return micromatch$2.braces(pattern, { ...options,
      expand: true
    });
  };
  /**
   * Expose micromatch
   */


  var micromatch_1$2 = micromatch$2;

  /** @typedef {import('stylelint').Config} StylelintConfig */

  /**
   * @param {StylelintConfig} config
   * @return {StylelintConfig}
   */


  function normalizeAllRuleSettings(config) {
    if (!config.rules) return config;
    /** @type {StylelintConfig['rules']} */

    const normalizedRules = {};

    for (const [ruleName, rawRuleSettings] of Object.entries(config.rules)) {
      const rule = getStylelintRule(ruleName, config);

      if (rule) {
        normalizedRules[ruleName] = normalizeRuleSettings(rawRuleSettings, rule);
      } else {
        normalizedRules[ruleName] = [];
      }
    }

    config.rules = normalizedRules;
    return config;
  }

  var normalizeAllRuleSettings_1 = normalizeAllRuleSettings;

  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  var normalizePath = function (path, stripTrailing) {
    if (typeof path !== 'string') {
      throw new TypeError('expected path to be a string');
    }

    if (path === '\\' || path === '/') return '/';
    var len = path.length;
    if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is
    // handled properly by the win32 version of path.parse() after being normalized
    // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces

    var prefix = '';

    if (len > 4 && path[3] === '\\') {
      var ch = path[2];

      if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
        path = path.slice(2);
        prefix = '//';
      }
    }

    var segs = path.split(/[/\\]+/);

    if (stripTrailing !== false && segs[segs.length - 1] === '') {
      segs.pop();
    }

    return prefix + segs.join('/');
  };

  /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */

  /** @typedef {import('stylelint').Config} StylelintConfig */

  /** @typedef {import('stylelint').CosmiconfigResult} StylelintCosmiconfigResult */

  /**
   * @param {string} glob
   * @param {string} basedir
   * @returns {string}
   */


  function absolutizeGlob(glob, basedir) {
    const result = path__default['default'].isAbsolute(glob.replace(/^!/, '')) ? glob : globjoin(basedir, glob); // Glob patterns for micromatch should be in POSIX-style

    return normalizePath(result);
  }
  /**
   * - Merges config and stylelint options
   * - Makes all paths absolute
   * - Merges extends
   * @param {StylelintInternalApi} stylelint
   * @param {StylelintConfig} config
   * @param {string} configDir
   * @param {boolean} allowOverrides
   * @param {string} rootConfigDir
   * @param {string} [filePath]
   * @returns {Promise<StylelintConfig>}
   */


  async function augmentConfigBasic(stylelint, config, configDir, allowOverrides, rootConfigDir, filePath) {
    let augmentedConfig = config;

    if (allowOverrides) {
      augmentedConfig = addOptions(stylelint, augmentedConfig);
    }

    if (filePath) {
      augmentedConfig = applyOverrides(augmentedConfig, rootConfigDir, filePath);
    }

    augmentedConfig = await extendConfig(stylelint, augmentedConfig, configDir, rootConfigDir, filePath);
    const cwd = stylelint._options.cwd;
    return absolutizePaths(augmentedConfig, configDir, cwd);
  }
  /**
   * Extended configs need to be run through augmentConfigBasic
   * but do not need the full treatment. Things like pluginFunctions
   * will be resolved and added by the parent config.
   * @param {string} cwd
   * @returns {(cosmiconfigResult?: StylelintCosmiconfigResult) => Promise<StylelintCosmiconfigResult>}
   */


  function augmentConfigExtended(cwd) {
    return async cosmiconfigResult => {
      if (!cosmiconfigResult) {
        return null;
      }

      const configDir = path__default['default'].dirname(cosmiconfigResult.filepath || '');
      const {
        config
      } = cosmiconfigResult;
      const augmentedConfig = absolutizePaths(config, configDir, cwd);
      return {
        config: augmentedConfig,
        filepath: cosmiconfigResult.filepath
      };
    };
  }
  /**
   * @param {StylelintInternalApi} stylelint
   * @param {string} [filePath]
   * @param {StylelintCosmiconfigResult} [cosmiconfigResult]
   * @returns {Promise<StylelintCosmiconfigResult>}
   */


  async function augmentConfigFull$1(stylelint, filePath, cosmiconfigResult) {
    if (!cosmiconfigResult) {
      return null;
    }

    const config = cosmiconfigResult.config;
    const filepath = cosmiconfigResult.filepath;
    const configDir = stylelint._options.configBasedir || path__default['default'].dirname(filepath || '');
    let augmentedConfig = await augmentConfigBasic(stylelint, config, configDir, true, configDir, filePath);
    augmentedConfig = addPluginFunctions(augmentedConfig);

    if (!augmentedConfig.rules) {
      throw configurationError('No rules found within configuration. Have you provided a "rules" property?');
    }

    augmentedConfig = normalizeAllRuleSettings_1(augmentedConfig);
    return {
      config: augmentedConfig,
      filepath: cosmiconfigResult.filepath
    };
  }
  /**
   * Make all paths in the config absolute.
   *
   * @param {StylelintConfig} config
   * @param {string} configDir
   * @param {string} cwd
   * @returns {StylelintConfig}
   */


  function absolutizePaths(config, configDir, cwd) {
    if (config.ignoreFiles) {
      config.ignoreFiles = [config.ignoreFiles].flat().map(glob => absolutizeGlob(glob, configDir));
    }

    if (config.plugins) {
      config.plugins = [config.plugins].flat().map(lookup => {
        if (typeof lookup === 'string') {
          return getModulePath(configDir, lookup, cwd);
        }

        return lookup;
      });
    }

    return config;
  }
  /**
   * @param {StylelintInternalApi} stylelint
   * @param {StylelintConfig} config
   * @param {string} configDir
   * @param {string} rootConfigDir
   * @param {string} [filePath]
   * @return {Promise<StylelintConfig>}
   */


  async function extendConfig(stylelint, config, configDir, rootConfigDir, filePath) {
    if (config.extends === undefined) {
      return config;
    }

    const {
      extends: configExtends,
      ...originalWithoutExtends
    } = config;
    const normalizedExtends = [configExtends].flat();
    let resultConfig = originalWithoutExtends;

    for (const extendLookup of normalizedExtends) {
      let extendResult;

      if (typeof extendLookup === 'string') {
        extendResult = await loadExtendedConfig(stylelint, configDir, extendLookup);
      } else if (typeof extendLookup === 'object' && extendLookup !== null) {
        extendResult = {
          config: extendLookup
        };
      }

      if (extendResult) {
        let extendResultConfig = extendResult.config;
        const extendConfigDir = path__default['default'].dirname(extendResult.filepath || '');
        extendResultConfig = await augmentConfigBasic(stylelint, extendResultConfig, extendConfigDir, false, rootConfigDir, filePath);
        resultConfig = mergeConfigs(resultConfig, extendResultConfig);
      }
    }

    return mergeConfigs(resultConfig, originalWithoutExtends);
  }
  /**
   * @param {StylelintInternalApi} stylelint
   * @param {string} configDir
   * @param {string} extendLookup
   * @return {Promise<StylelintCosmiconfigResult>}
   */


  function loadExtendedConfig(stylelint, configDir, extendLookup) {
    const extendPath = getModulePath(configDir, extendLookup, stylelint._options.cwd);
    return stylelint._extendExplorer.load(extendPath);
  }
  /**
   * When merging configs (via extends)
   * - plugin, extends, overrides arrays are joined
   * - rules are merged via Object.assign, so there is no attempt made to
   *   merge any given rule's settings. If b contains the same rule as a,
   *   b's rule settings will override a's rule settings entirely.
   * - Everything else is merged via Object.assign
   * @param {StylelintConfig} a
   * @param {StylelintConfig} b
   * @returns {StylelintConfig}
   */


  function mergeConfigs(a, b) {
    /** @type {Pick<StylelintConfig, 'plugins'>} */
    const pluginMerger = {};

    if (a.plugins || b.plugins) {
      pluginMerger.plugins = [];

      if (a.plugins) {
        pluginMerger.plugins = pluginMerger.plugins.concat(a.plugins);
      }

      if (b.plugins) {
        pluginMerger.plugins = [...new Set(pluginMerger.plugins.concat(b.plugins))];
      }
    }
    /** @type {Pick<StylelintConfig, 'overrides'>} */


    const overridesMerger = {};

    if (a.overrides || b.overrides) {
      overridesMerger.overrides = [];

      if (a.overrides) {
        overridesMerger.overrides = overridesMerger.overrides.concat(a.overrides);
      }

      if (b.overrides) {
        overridesMerger.overrides = [...new Set(overridesMerger.overrides.concat(b.overrides))];
      }
    }
    /** @type {Pick<StylelintConfig, 'extends'>} */


    const extendsMerger = {};

    if (a.extends || b.extends) {
      extendsMerger.extends = [];

      if (a.extends) {
        extendsMerger.extends = extendsMerger.extends.concat(a.extends);
      }

      if (b.extends) {
        extendsMerger.extends = extendsMerger.extends.concat(b.extends);
      } // Remove duplicates from the array, the last item takes precedence


      extendsMerger.extends = extendsMerger.extends.filter((item, index, arr) => arr.lastIndexOf(item) === index);
    }

    const rulesMerger = {};

    if (a.rules || b.rules) {
      rulesMerger.rules = { ...a.rules,
        ...b.rules
      };
    }

    const result = { ...a,
      ...b,
      ...extendsMerger,
      ...pluginMerger,
      ...overridesMerger,
      ...rulesMerger
    };
    return result;
  }
  /**
   * @param {StylelintConfig} config
   * @returns {StylelintConfig}
   */


  function addPluginFunctions(config) {
    if (!config.plugins) {
      return config;
    }

    const normalizedPlugins = [config.plugins].flat();
    /** @type {StylelintConfig['pluginFunctions']} */

    const pluginFunctions = {};

    for (const pluginLookup of normalizedPlugins) {
      let pluginImport;

      if (typeof pluginLookup === 'string') {
        pluginImport = commonjsRequire(pluginLookup);
      } else {
        pluginImport = pluginLookup;
      } // Handle either ES6 or CommonJS modules


      pluginImport = pluginImport.default || pluginImport; // A plugin can export either a single rule definition
      // or an array of them

      const normalizedPluginImport = [pluginImport].flat();

      for (const pluginRuleDefinition of normalizedPluginImport) {
        if (!pluginRuleDefinition.ruleName) {
          throw configurationError(`stylelint requires plugins to expose a ruleName. The plugin "${pluginLookup}" is not doing this, so will not work with stylelint. Please file an issue with the plugin.`);
        }

        if (!pluginRuleDefinition.ruleName.includes('/')) {
          throw configurationError(`stylelint requires plugin rules to be namespaced, i.e. only \`plugin-namespace/plugin-rule-name\` plugin rule names are supported. The plugin rule "${pluginRuleDefinition.ruleName}" does not do this, so will not work. Please file an issue with the plugin.`);
        }

        pluginFunctions[pluginRuleDefinition.ruleName] = pluginRuleDefinition.rule;
      }
    }

    config.pluginFunctions = pluginFunctions;
    return config;
  }
  /**
   * @param {StylelintConfig} fullConfig
   * @param {string} rootConfigDir
   * @param {string} filePath
   * @return {StylelintConfig}
   */


  function applyOverrides(fullConfig, rootConfigDir, filePath) {
    let {
      overrides,
      ...config
    } = fullConfig;

    if (!overrides) {
      return config;
    }

    if (!Array.isArray(overrides)) {
      throw new TypeError('The `overrides` configuration property should be an array, e.g. { "overrides": [{ "files": "*.css", "rules": {} }] }.');
    }

    for (const override of overrides) {
      const {
        files,
        ...configOverrides
      } = override;

      if (!files) {
        throw new Error('Every object in the `overrides` configuration property should have a `files` property with globs, e.g. { "overrides": [{ "files": "*.css", "rules": {} }] }.');
      }

      const absoluteGlobs = [files].flat().map(glob => absolutizeGlob(glob, rootConfigDir));

      if (micromatch_1$2.isMatch(filePath, absoluteGlobs, {
        dot: true
      }) || // E.g. `*.css` matches any CSS files in any directories.
      micromatch_1$2.isMatch(filePath, files, {
        dot: true,
        basename: true
      })) {
        config = mergeConfigs(config, configOverrides);
      }
    }

    return config;
  }
  /**
   * Add options to the config
   *
   * @param {StylelintInternalApi} stylelint
   * @param {StylelintConfig} config
   *
   * @returns {StylelintConfig}
   */


  function addOptions(stylelint, config) {
    const augmentedConfig = { ...config
    };

    if (stylelint._options.ignoreDisables) {
      augmentedConfig.ignoreDisables = stylelint._options.ignoreDisables;
    }

    if (stylelint._options.quiet) {
      augmentedConfig.quiet = stylelint._options.quiet;
    }

    if (stylelint._options.reportNeedlessDisables) {
      augmentedConfig.reportNeedlessDisables = stylelint._options.reportNeedlessDisables;
    }

    if (stylelint._options.reportInvalidScopeDisables) {
      augmentedConfig.reportInvalidScopeDisables = stylelint._options.reportInvalidScopeDisables;
    }

    if (stylelint._options.reportDescriptionlessDisables) {
      augmentedConfig.reportDescriptionlessDisables = stylelint._options.reportDescriptionlessDisables;
    }

    if (stylelint._options.customSyntax) {
      augmentedConfig.customSyntax = stylelint._options.customSyntax;
    }

    if (stylelint._options.fix) {
      augmentedConfig.fix = stylelint._options.fix;
    }

    return augmentedConfig;
  }

  var augmentConfig = {
    augmentConfigExtended,
    augmentConfigFull: augmentConfigFull$1,
    applyOverrides
  };

  /**
   * Helpers.
   */
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var ms = function (val, options) {
    options = options || {};
    var type = typeof val;

    if (type === 'string' && val.length > 0) {
      return parse$4(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }

    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */


  function parse$4(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;

      case 'weeks':
      case 'week':
      case 'w':
        return n * w;

      case 'days':
      case 'day':
      case 'd':
        return n * d;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */


  function fmtShort(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }

    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }

    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }

    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }

    return ms + 'ms';
  }
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */


  function fmtLong(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }

    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }

    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }

    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }

    return ms + ' ms';
  }
  /**
   * Pluralization helper.
   */


  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms;
    createDebug.destroy = destroy;
    Object.keys(env).forEach(key => {
      createDebug[key] = env[key];
    });
    /**
    * The currently active debug mode names, and names to skip.
    */

    createDebug.names = [];
    createDebug.skips = [];
    /**
    * Map of special "%n" handling functions, for the debug "format" argument.
    *
    * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    */

    createDebug.formatters = {};
    /**
    * Selects a color for a debug namespace
    * @param {String} namespace The namespace string for the debug instance to be colored
    * @return {Number|String} An ANSI color code for the given namespace
    * @api private
    */

    function selectColor(namespace) {
      let hash = 0;

      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }

    createDebug.selectColor = selectColor;
    /**
    * Create a debugger with the given `namespace`.
    *
    * @param {String} namespace
    * @return {Function}
    * @api public
    */

    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;

      function debug(...args) {
        // Disabled?
        if (!debug.enabled) {
          return;
        }

        const self = debug; // Set `diff` timestamp

        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        } // Apply any `formatters` transformations


        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return '%';
          }

          index++;
          const formatter = createDebug.formatters[format];

          if (typeof formatter === 'function') {
            const val = args[index];
            match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

            args.splice(index, 1);
            index--;
          }

          return match;
        }); // Apply env-specific formatting (colors, etc.)

        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }

          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }

          return enabledCache;
        },
        set: v => {
          enableOverride = v;
        }
      }); // Env-specific initialization logic for debug instances

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }

      return debug;
    }

    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    /**
    * Enables a debug mode by namespaces. This can include modes
    * separated by a colon and wildcards.
    *
    * @param {String} namespaces
    * @api public
    */


    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      const len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          // ignore empty strings
          continue;
        }

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    /**
    * Disable debug output.
    *
    * @return {String} namespaces
    * @api public
    */


    function disable() {
      const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');
      createDebug.enable('');
      return namespaces;
    }
    /**
    * Returns true if the given mode name is enabled, false otherwise.
    *
    * @param {String} name
    * @return {Boolean}
    * @api public
    */


    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }

      let i;
      let len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }
    /**
    * Convert regexp to namespace
    *
    * @param {RegExp} regxep
    * @return {String} namespace
    * @api private
    */


    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }
    /**
    * Coerce `val`.
    *
    * @param {Mixed} val
    * @return {Mixed}
    * @api private
    */


    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }

      return val;
    }
    /**
    * XXX DO NOT USE. This is a temporary stub function.
    * XXX It WILL be removed in the next major release.
    */


    function destroy() {
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }

    createDebug.enable(createDebug.load());
    return createDebug;
  }

  var common$3 = setup;

  /* eslint-env browser */

  var browser = createCommonjsModule(function (module, exports) {
  /**
   * This is the web browser implementation of `debug()`.
   */
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();

  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
      }
    };
  })();
  /**
   * Colors.
   */


  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  // eslint-disable-next-line complexity

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    } // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, match => {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes `console.debug()` when available.
   * No-op when `console.debug` is not a "function".
   * If `console.debug` is not available, falls back
   * to `console.log`.
   *
   * @api public
   */


  exports.log = console.debug || console.log || (() => {});
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    let r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */


  function localstorage() {
    try {
      // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
      // The Browser also has localStorage in the global context.
      return localStorage;
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }

  module.exports = common$3(exports);
  const {
    formatters
  } = module.exports;
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
  });

  /**
   * Module dependencies.
   */

  var node = createCommonjsModule(function (module, exports) {
  /**
   * This is the Node.js implementation of `debug()`.
   */


  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util__default['default'].deprecate(() => {}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  /**
   * Colors.
   */

  exports.colors = [6, 2, 3, 4, 5, 1];

  try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = supportsColor_1$1;

    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
    }
  } catch (error) {// Swallow - we only care if `supports-color` is available; it doesn't have to be.
  }
  /**
   * Build up the default `inspectOpts` object from the environment variables.
   *
   *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
   */


  exports.inspectOpts = Object.keys(process.env).filter(key => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    }); // Coerce string value into JS value

    let val = process.env[key];

    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === 'null') {
      val = null;
    } else {
      val = Number(val);
    }

    obj[prop] = val;
    return obj;
  }, {});
  /**
   * Is stdout a TTY? Colored output is enabled when `true`.
   */

  function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty__default['default'].isatty(process.stderr.fd);
  }
  /**
   * Adds ANSI color escape codes if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    const {
      namespace: name,
      useColors
    } = this;

    if (useColors) {
      const c = this.color;
      const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
      const prefix = `  ${colorCode};1m${name} \u001B[0m`;
      args[0] = prefix + args[0].split('\n').join('\n' + prefix);
      args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
      args[0] = getDate() + name + ' ' + args[0];
    }
  }

  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return '';
    }

    return new Date().toISOString() + ' ';
  }
  /**
   * Invokes `util.format()` with the specified arguments and writes to stderr.
   */


  function log(...args) {
    return process.stderr.write(util__default['default'].format(...args) + '\n');
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      // If you set a process.env field to null or undefined, it gets cast to the
      // string 'null' or 'undefined'. Just delete instead.
      delete process.env.DEBUG;
    }
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    return process.env.DEBUG;
  }
  /**
   * Init logic for `debug` instances.
   *
   * Create a new `inspectOpts` object in case `useColors` is set
   * differently for a particular `debug` instance.
   */


  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);

    for (let i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }

  module.exports = common$3(exports);
  const {
    formatters
  } = module.exports;
  /**
   * Map %o to `util.inspect()`, all on a single line.
   */

  formatters.o = function (v) {
    this.inspectOpts.colors = this.useColors;
    return util__default['default'].inspect(v, this.inspectOpts).split('\n').map(str => str.trim()).join(' ');
  };
  /**
   * Map %O to `util.inspect()`, allowing multiple lines if needed.
   */


  formatters.O = function (v) {
    this.inspectOpts.colors = this.useColors;
    return util__default['default'].inspect(v, this.inspectOpts);
  };
  });

  /**
   * Detect Electron renderer / nwjs process, which is node, but we should
   * treat as a browser.
   */

  var src$1 = createCommonjsModule(function (module) {
  if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
    module.exports = browser;
  } else {
    module.exports = node;
  }
  });

  /*! (c) 2020 Andrea Giammarchi */

  const {
    parse: $parse,
    stringify: $stringify
  } = JSON;
  const {
    keys
  } = Object;
  const Primitive = String; // it could be Number

  const primitive = 'string'; // it could be 'number'

  const ignore$3 = {};
  const object = 'object';

  const noop$1 = (_, value) => value;

  const primitives = value => value instanceof Primitive ? Primitive(value) : value;

  const Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;

  const revive = (input, parsed, output, $) => {
    const lazy = [];

    for (let ke = keys(output), {
      length
    } = ke, y = 0; y < length; y++) {
      const k = ke[y];
      const value = output[k];

      if (value instanceof Primitive) {
        const tmp = input[value];

        if (typeof tmp === object && !parsed.has(tmp)) {
          parsed.add(tmp);
          output[k] = ignore$3;
          lazy.push({
            k,
            a: [input, parsed, tmp, $]
          });
        } else output[k] = $.call(output, k, tmp);
      } else if (output[k] !== ignore$3) output[k] = $.call(output, k, value);
    }

    for (let {
      length
    } = lazy, i = 0; i < length; i++) {
      const {
        k,
        a
      } = lazy[i];
      output[k] = $.call(output, k, revive.apply(null, a));
    }

    return output;
  };

  const set = (known, input, value) => {
    const index = Primitive(input.push(value) - 1);
    known.set(value, index);
    return index;
  };

  const parse$3 = (text, reviver) => {
    const input = $parse(text, Primitives).map(primitives);
    const value = input[0];
    const $ = reviver || noop$1;
    const tmp = typeof value === object && value ? revive(input, new Set(), value, $) : value;
    return $.call({
      '': tmp
    }, '', tmp);
  };

  var parse_1$2 = parse$3;

  const stringify = (value, replacer, space) => {
    const $ = replacer && typeof replacer === object ? (k, v) => k === '' || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop$1;
    const known = new Map();
    const input = [];
    const output = [];
    let i = +set(known, input, $.call({
      '': value
    }, '', value));
    let firstRun = !i;

    while (i < input.length) {
      firstRun = true;
      output[i] = $stringify(input[i++], replace, space);
    }

    return '[' + output.join(',') + ']';

    function replace(key, value) {
      if (firstRun) {
        firstRun = !firstRun;
        return value;
      }

      const after = $.call(this, key, value);

      switch (typeof after) {
        case object:
          if (after === null) return after;

        case primitive:
          return known.get(after) || set(known, input, after);
      }

      return after;
    }
  };

  var stringify_1 = stringify;

  var cjs$1 = {
  	parse: parse_1$2,
  	stringify: stringify_1
  };

  var utils$6 = {
    tryParse: function (filePath, defaultValue) {
      var result;

      try {
        result = this.readJSON(filePath);
      } catch (ex) {
        result = defaultValue;
      }

      return result;
    },

    /**
     * Read json file synchronously using flatted
     *
     * @method readJSON
     * @param  {String} filePath Json filepath
     * @returns {*} parse result
     */
    readJSON: function (filePath) {
      return cjs$1.parse(fs__default['default'].readFileSync(filePath, {
        encoding: 'utf8'
      }));
    },

    /**
     * Write json file synchronously using circular-json
     *
     * @method writeJSON
     * @param  {String} filePath Json filepath
     * @param  {*} data Object to serialize
     */
    writeJSON: function (filePath, data) {
      fs__default['default'].mkdirSync(path__default['default'].dirname(filePath), {
        recursive: true
      });
      fs__default['default'].writeFileSync(filePath, cjs$1.stringify(data));
    }
  };

  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.


  var isWindows$1 = process.platform === 'win32';

   // JavaScript implementation of realpath, ported from node pre-v6


  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

  function rethrow() {
    // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
    // is fairly slow to generate.
    var callback;

    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else callback = missingCallback;

    return callback;

    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }

    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs
        else if (!process.noDeprecation) {
            var msg = 'fs: missing callback ' + (err.stack || err.message);
            if (process.traceDeprecation) console.trace(msg);else console.error(msg);
          }
      }
    }
  }

  function maybeCallback(cb) {
    return typeof cb === 'function' ? cb : rethrow();
  }

  path__default['default'].normalize; // Regexp that finds the next partion of a (partial) path
  // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']

  if (isWindows$1) {
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
  } // Regex to find the device root, including trailing slash. E.g. 'c:\\'.


  if (isWindows$1) {
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    var splitRootRe = /^[\/]*/;
  }

  var realpathSync$1 = function realpathSync(p, cache) {
    // make p is absolute
    p = path__default['default'].resolve(p);

    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }

    var original = p,
        seenLinks = {},
        knownHard = {}; // current character position in p

    var pos; // the partial path so far, including a trailing slash if any

    var current; // the partial path without a trailing slash (except when pointing at a root)

    var base; // the partial path scanned in the previous round, with slash

    var previous;
    start();

    function start() {
      // Skip over roots
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = ''; // On windows, check that the root exists. On unix there is no need.

      if (isWindows$1 && !knownHard[base]) {
        fs__default['default'].lstatSync(base);
        knownHard[base] = true;
      }
    } // walk down the path, swapping out linked pathparts for their real
    // values
    // NB: p.length changes.


    while (pos < p.length) {
      // find the next part
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex; // continue if not a symlink

      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }

      var resolvedLink;

      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        // some known symbolic link.  no need to stat again.
        resolvedLink = cache[base];
      } else {
        var stat = fs__default['default'].lstatSync(base);

        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache) cache[base] = base;
          continue;
        } // read the link if it wasn't read before
        // dev/ino always return 0 on windows, so skip the check.


        var linkTarget = null;

        if (!isWindows$1) {
          var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);

          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }

        if (linkTarget === null) {
          fs__default['default'].statSync(base);
          linkTarget = fs__default['default'].readlinkSync(base);
        }

        resolvedLink = path__default['default'].resolve(previous, linkTarget); // track this, if given a cache.

        if (cache) cache[base] = resolvedLink;
        if (!isWindows$1) seenLinks[id] = linkTarget;
      } // resolve the link, then start over


      p = path__default['default'].resolve(resolvedLink, p.slice(pos));
      start();
    }

    if (cache) cache[original] = p;
    return p;
  };

  var realpath$1 = function realpath(p, cache, cb) {
    if (typeof cb !== 'function') {
      cb = maybeCallback(cache);
      cache = null;
    } // make p is absolute


    p = path__default['default'].resolve(p);

    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }

    var original = p,
        seenLinks = {},
        knownHard = {}; // current character position in p

    var pos; // the partial path so far, including a trailing slash if any

    var current; // the partial path without a trailing slash (except when pointing at a root)

    var base; // the partial path scanned in the previous round, with slash

    var previous;
    start();

    function start() {
      // Skip over roots
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = ''; // On windows, check that the root exists. On unix there is no need.

      if (isWindows$1 && !knownHard[base]) {
        fs__default['default'].lstat(base, function (err) {
          if (err) return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    } // walk down the path, swapping out linked pathparts for their real
    // values


    function LOOP() {
      // stop if scanned past end of path
      if (pos >= p.length) {
        if (cache) cache[original] = p;
        return cb(null, p);
      } // find the next part


      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex; // continue if not a symlink

      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }

      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        // known symbolic link.  no need to stat again.
        return gotResolvedLink(cache[base]);
      }

      return fs__default['default'].lstat(base, gotStat);
    }

    function gotStat(err, stat) {
      if (err) return cb(err); // if not a symlink, skip to the next path part

      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        return process.nextTick(LOOP);
      } // stat & read the link if not read before
      // call gotTarget as soon as the link target is known
      // dev/ino always return 0 on windows, so skip the check.


      if (!isWindows$1) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);

        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }

      fs__default['default'].stat(base, function (err) {
        if (err) return cb(err);
        fs__default['default'].readlink(base, function (err, target) {
          if (!isWindows$1) seenLinks[id] = target;
          gotTarget(err, target);
        });
      });
    }

    function gotTarget(err, target, base) {
      if (err) return cb(err);
      var resolvedLink = path__default['default'].resolve(previous, target);
      if (cache) cache[base] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }

    function gotResolvedLink(resolvedLink) {
      // resolve the link, then start over
      p = path__default['default'].resolve(resolvedLink, p.slice(pos));
      start();
    }
  };

  var old = {
  	realpathSync: realpathSync$1,
  	realpath: realpath$1
  };

  var fs_realpath = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;



  var origRealpath = fs__default['default'].realpath;
  var origRealpathSync = fs__default['default'].realpathSync;
  var version$1 = process.version;
  var ok = /^v[0-5]\./.test(version$1);



  function newError(er) {
    return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');
  }

  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }

    if (typeof cache === 'function') {
      cb = cache;
      cache = null;
    }

    origRealpath(p, cache, function (er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }

  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }

    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }

  function monkeypatch() {
    fs__default['default'].realpath = realpath;
    fs__default['default'].realpathSync = realpathSync;
  }

  function unmonkeypatch() {
    fs__default['default'].realpath = origRealpath;
    fs__default['default'].realpathSync = origRealpathSync;
  }

  var concatMap = function (xs, fn) {
    var res = [];

    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x)) res.push.apply(res, x);else res.push(x);
    }

    return res;
  };

  var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };

  var balancedMatch = balanced;

  function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }

  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }

  balanced.range = range;

  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;

    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }

      begs = [];
      left = str.length;

      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();

          if (beg < left) {
            left = beg;
            right = bi;
          }

          bi = str.indexOf(b, i + 1);
        }

        i = ai < bi && ai >= 0 ? ai : bi;
      }

      if (begs.length) {
        result = [left, right];
      }
    }

    return result;
  }

  var braceExpansion = expandTop;
  var escSlash = '\0SLASH' + Math.random() + '\0';
  var escOpen = '\0OPEN' + Math.random() + '\0';
  var escClose = '\0CLOSE' + Math.random() + '\0';
  var escComma = '\0COMMA' + Math.random() + '\0';
  var escPeriod = '\0PERIOD' + Math.random() + '\0';

  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }

  function escapeBraces(str) {
    return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
  }

  function unescapeBraces(str) {
    return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
  } // Basically just str.split(","), but handling cases
  // where we have nested braced sections, which should be
  // treated as individual members, like {a,{b,c},d}


  function parseCommaParts(str) {
    if (!str) return [''];
    var parts = [];
    var m = balancedMatch('{', '}', str);
    if (!m) return str.split(',');
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(',');
    p[p.length - 1] += '{' + body + '}';
    var postParts = parseCommaParts(post);

    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }

    parts.push.apply(parts, p);
    return parts;
  }

  function expandTop(str) {
    if (!str) return []; // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}

    if (str.substr(0, 2) === '{}') {
      str = '\\{\\}' + str.substr(2);
    }

    return expand(escapeBraces(str), true).map(unescapeBraces);
  }

  function embrace(str) {
    return '{' + str + '}';
  }

  function isPadded(el) {
    return /^-?0\d/.test(el);
  }

  function lte(i, y) {
    return i <= y;
  }

  function gte(i, y) {
    return i >= y;
  }

  function expand(str, isTop) {
    var expansions = [];
    var m = balancedMatch('{', '}', str);
    if (!m || /\$$/.test(m.pre)) return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;

    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,.*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }

      return [str];
    }

    var n;

    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);

      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);

        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [''];
          return post.map(function (p) {
            return m.pre + n[0] + p;
          });
        }
      }
    } // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    // no need to expand pre, since it is guaranteed to be free of brace-sets


    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [''];
    var N;

    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;

      if (reverse) {
        incr *= -1;
        test = gte;
      }

      var pad = n.some(isPadded);
      N = [];

      for (var i = x; test(i, y); i += incr) {
        var c;

        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\') c = '';
        } else {
          c = String(i);

          if (pad) {
            var need = width - c.length;

            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
            }
          }
        }

        N.push(c);
      }
    } else {
      N = concatMap(n, function (el) {
        return expand(el, false);
      });
    }

    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion) expansions.push(expansion);
      }
    }

    return expansions;
  }

  var minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch$1;

  var path = function () {
    try {
      return path__default['default'];
    } catch (e) {}
  }() || {
    sep: '/'
  };

  minimatch.sep = path.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch$1.GLOBSTAR = {};



  var plTypes = {
    '!': {
      open: '(?:(?!(?:',
      close: '))[^/]*?)'
    },
    '?': {
      open: '(?:',
      close: ')?'
    },
    '+': {
      open: '(?:',
      close: ')+'
    },
    '*': {
      open: '(?:',
      close: ')*'
    },
    '@': {
      open: '(?:',
      close: ')'
    }
  }; // any single thing other than /
  // don't need to escape / when using new RegExp()

  var qmark = '[^/]'; // * => any number of characters

  var star = qmark + '*?'; // ** when dots are allowed.  Anything goes, except .. and .
  // not (^ or / followed by one or two dots followed by $ or /),
  // followed by anything, any number of times.

  var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'; // not a ^ or / followed by a dot,
  // followed by anything, any number of times.

  var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'; // characters that need to be escaped in RegExp.

  var reSpecials = charSet('().*{}+?[]^$\\!'); // "abc" -> { a:true, b:true, c:true }

  function charSet(s) {
    return s.split('').reduce(function (set, c) {
      set[c] = true;
      return set;
    }, {});
  } // normalizes slashes.


  var slashSplit = /\/+/;
  minimatch.filter = filter;

  function filter(pattern, options) {
    options = options || {};
    return function (p, i, list) {
      return minimatch(p, pattern, options);
    };
  }

  function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function (k) {
      t[k] = a[k];
    });
    Object.keys(b).forEach(function (k) {
      t[k] = b[k];
    });
    return t;
  }

  minimatch.defaults = function (def) {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
      return minimatch;
    }

    var orig = minimatch;

    var m = function minimatch(p, pattern, options) {
      return orig(p, pattern, ext(def, options));
    };

    m.Minimatch = function Minimatch(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };

    m.Minimatch.defaults = function defaults(options) {
      return orig.defaults(ext(def, options)).Minimatch;
    };

    m.filter = function filter(pattern, options) {
      return orig.filter(pattern, ext(def, options));
    };

    m.defaults = function defaults(options) {
      return orig.defaults(ext(def, options));
    };

    m.makeRe = function makeRe(pattern, options) {
      return orig.makeRe(pattern, ext(def, options));
    };

    m.braceExpand = function braceExpand(pattern, options) {
      return orig.braceExpand(pattern, ext(def, options));
    };

    m.match = function (list, pattern, options) {
      return orig.match(list, pattern, ext(def, options));
    };

    return m;
  };

  Minimatch$1.defaults = function (def) {
    return minimatch.defaults(def).Minimatch;
  };

  function minimatch(p, pattern, options) {
    assertValidPattern(pattern);
    if (!options) options = {}; // shortcut: comments match nothing.

    if (!options.nocomment && pattern.charAt(0) === '#') {
      return false;
    }

    return new Minimatch$1(pattern, options).match(p);
  }

  function Minimatch$1(pattern, options) {
    if (!(this instanceof Minimatch$1)) {
      return new Minimatch$1(pattern, options);
    }

    assertValidPattern(pattern);
    if (!options) options = {};
    pattern = pattern.trim(); // windows support: need to use /, not \

    if (!options.allowWindowsEscape && path.sep !== '/') {
      pattern = pattern.split(path.sep).join('/');
    }

    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial; // make the set of regexps etc.

    this.make();
  }

  Minimatch$1.prototype.debug = function () {};

  Minimatch$1.prototype.make = make;

  function make() {
    var pattern = this.pattern;
    var options = this.options; // empty patterns and comments match nothing.

    if (!options.nocomment && pattern.charAt(0) === '#') {
      this.comment = true;
      return;
    }

    if (!pattern) {
      this.empty = true;
      return;
    } // step 1: figure out negation, etc.


    this.parseNegate(); // step 2: expand braces

    var set = this.globSet = this.braceExpand();
    if (options.debug) this.debug = function debug() {
      console.error.apply(console, arguments);
    };
    this.debug(this.pattern, set); // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of "**", which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters

    set = this.globParts = set.map(function (s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set); // glob --> regexps

    set = set.map(function (s, si, set) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set); // filter out everything that didn't compile properly.

    set = set.filter(function (s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }

  Minimatch$1.prototype.parseNegate = parseNegate;

  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate) return;

    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
      negate = !negate;
      negateOffset++;
    }

    if (negateOffset) this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  } // Brace expansion:
  // a{b,c}d -> abd acd
  // a{b,}c -> abc ac
  // a{0..3}d -> a0d a1d a2d a3d
  // a{b,c{d,e}f}g -> abg acdfg acefg
  // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
  //
  // Invalid sets are not expanded.
  // a{2..}b -> a{2..}b
  // a{b}c -> a{b}c


  minimatch.braceExpand = function (pattern, options) {
    return braceExpand(pattern, options);
  };

  Minimatch$1.prototype.braceExpand = braceExpand;

  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch$1) {
        options = this.options;
      } else {
        options = {};
      }
    }

    pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
    assertValidPattern(pattern); // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.

    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      // shortcut. no need to expand.
      return [pattern];
    }

    return braceExpansion(pattern);
  }

  var MAX_PATTERN_LENGTH = 1024 * 64;

  var assertValidPattern = function (pattern) {
    if (typeof pattern !== 'string') {
      throw new TypeError('invalid pattern');
    }

    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError('pattern is too long');
    }
  }; // parse a component of the expanded set.
  // At this point, no pattern may contain "/" in it
  // so we're going to return a 2d array, where each entry is the full
  // pattern, split on '/', and then turned into a regular expression.
  // A regexp is made at the end which joins each array with an
  // escaped /, and another full one which joins each regexp with |.
  //
  // Following the lead of Bash 4.1, note that "**" only has special meaning
  // when it is the *only* thing in a path portion.  Otherwise, any series
  // of * is equivalent to a single *.  Globstar behavior is enabled by
  // default, and can be disabled by setting options.noglobstar.


  Minimatch$1.prototype.parse = parse$2;
  var SUBPARSE = {};

  function parse$2(pattern, isSub) {
    assertValidPattern(pattern);
    var options = this.options; // shortcuts

    if (pattern === '**') {
      if (!options.noglobstar) return GLOBSTAR;else pattern = '*';
    }

    if (pattern === '') return '';
    var re = '';
    var hasMagic = !!options.nocase;
    var escaping = false; // ? => one single character

    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1; // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.

    var patternStart = pattern.charAt(0) === '.' ? '' // anything
    // not (start or / followed by . or .. followed by / or end)
    : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
    var self = this;

    function clearStateChar() {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn't consumed by this pass.
        switch (stateChar) {
          case '*':
            re += star;
            hasMagic = true;
            break;

          case '?':
            re += qmark;
            hasMagic = true;
            break;

          default:
            re += '\\' + stateChar;
            break;
        }

        self.debug('clearStateChar %j %j', stateChar, re);
        stateChar = false;
      }
    }

    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug('%s\t%s %s %j', pattern, i, re, c); // skip over any that are escaped.

      if (escaping && reSpecials[c]) {
        re += '\\' + c;
        escaping = false;
        continue;
      }

      switch (c) {
        /* istanbul ignore next */
        case '/':
          {
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false;
          }

        case '\\':
          clearStateChar();
          escaping = true;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.

        case '?':
        case '*':
        case '+':
        case '@':
        case '!':
          this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c); // all of those are literals inside a class, except that
          // the glob [!a] means [^a] in regexp

          if (inClass) {
            this.debug('  in class');
            if (c === '!' && i === classStart + 1) c = '^';
            re += c;
            continue;
          } // if we already have a stateChar, then it means
          // that there was something like ** or +? in there.
          // Handle the stateChar, then proceed with this one.


          self.debug('call clearStateChar %j', stateChar);
          clearStateChar();
          stateChar = c; // if extglob is disabled, then +(asdf|foo) isn't a thing.
          // just clear the statechar *now*, rather than even diving into
          // the patternList stuff.

          if (options.noext) clearStateChar();
          continue;

        case '(':
          if (inClass) {
            re += '(';
            continue;
          }

          if (!stateChar) {
            re += '\\(';
            continue;
          }

          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          }); // negation is (?:(?!js)[^/]*)

          re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
          this.debug('plType %j %j', stateChar, re);
          stateChar = false;
          continue;

        case ')':
          if (inClass || !patternListStack.length) {
            re += '\\)';
            continue;
          }

          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop(); // negation is (?:(?!js)[^/]*)
          // The others are (?:<pattern>)<type>

          re += pl.close;

          if (pl.type === '!') {
            negativeLists.push(pl);
          }

          pl.reEnd = re.length;
          continue;

        case '|':
          if (inClass || !patternListStack.length || escaping) {
            re += '\\|';
            escaping = false;
            continue;
          }

          clearStateChar();
          re += '|';
          continue;
        // these are mostly the same in regexp and glob

        case '[':
          // swallow any state-tracking char before the [
          clearStateChar();

          if (inClass) {
            re += '\\' + c;
            continue;
          }

          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;

        case ']':
          //  a right bracket shall lose its special
          //  meaning and represent itself in
          //  a bracket expression if it occurs
          //  first in the list.  -- POSIX.2 2.8.3.2
          if (i === classStart + 1 || !inClass) {
            re += '\\' + c;
            escaping = false;
            continue;
          } // handle the case where we left a class open.
          // "[z-a]" is valid, equivalent to "\[z-a\]"
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.


          var cs = pattern.substring(classStart + 1, i);

          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          } // finish up the class.


          hasMagic = true;
          inClass = false;
          re += c;
          continue;

        default:
          // swallow any state char that wasn't consumed
          clearStateChar();

          if (escaping) {
            // no need
            escaping = false;
          } else if (reSpecials[c] && !(c === '^' && inClass)) {
            re += '\\';
          }

          re += c;
      } // switch

    } // for
    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"


    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + '\\[' + sp[0];
      hasMagic = hasMagic || sp[1];
    } // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.


    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug('setting tail', re, pl); // maybe some even number of \, then maybe 1 \, followed by a |

      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
        if (!$2) {
          // the | isn't already escaped, so escape it.
          $2 = '\\';
        } // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That's why this trick works.
        //
        // I am sorry that you have to see this.


        return $1 + $1 + $2 + '|';
      });
      this.debug('tail=%j\n   %s', tail, tail, pl, re);
      var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + '\\(' + tail;
    } // handle trailing things that only matter at the very end.


    clearStateChar();

    if (escaping) {
      // trailing \\
      re += '\\\\';
    } // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot


    var addPatternStart = false;

    switch (re.charAt(0)) {
      case '[':
      case '.':
      case '(':
        addPatternStart = true;
    } // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like 'a.xyz.yz' doesn't match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.


    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter; // Handle nested stuff like *(*.js|!(*.json)), where open parens
      // mean that we should *not* include the ) in the bit that is considered
      // "after" the negated section.

      var openParensBefore = nlBefore.split('(').length - 1;
      var cleanAfter = nlAfter;

      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
      }

      nlAfter = cleanAfter;
      var dollar = '';

      if (nlAfter === '' && isSub !== SUBPARSE) {
        dollar = '$';
      }

      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    } // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.


    if (re !== '' && hasMagic) {
      re = '(?=.)' + re;
    }

    if (addPatternStart) {
      re = patternStart + re;
    } // parsing just a piece of a larger pattern.


    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    } // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.


    if (!hasMagic) {
      return globUnescape(pattern);
    }

    var flags = options.nocase ? 'i' : '';

    try {
      var regExp = new RegExp('^' + re + '$', flags);
    } catch (er)
    /* istanbul ignore next - should be impossible */
    {
      // If it was an invalid regular expression, then it can't match
      // anything.  This trick looks for a character after the end of
      // the string, which is of course impossible, except in multi-line
      // mode, but it's not a /m regex.
      return new RegExp('$.');
    }

    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }

  minimatch.makeRe = function (pattern, options) {
    return new Minimatch$1(pattern, options || {}).makeRe();
  };

  Minimatch$1.prototype.makeRe = makeRe;

  function makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp; // at this point, this.set is a 2d array of partial
    // pattern strings, or "**".
    //
    // It's better to use .match().  This function shouldn't
    // be used, really, but it's pretty convenient sometimes,
    // when you just want to work with a regex.

    var set = this.set;

    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }

    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? 'i' : '';
    var re = set.map(function (pattern) {
      return pattern.map(function (p) {
        return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
      }).join('\\\/');
    }).join('|'); // must match entire pattern
    // ending in a * or ** will make it less strict.

    re = '^(?:' + re + ')$'; // can match anything, as long as it's not this.

    if (this.negate) re = '^(?!' + re + ').*$';

    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex)
    /* istanbul ignore next - should be impossible */
    {
      this.regexp = false;
    }

    return this.regexp;
  }

  minimatch.match = function (list, pattern, options) {
    options = options || {};
    var mm = new Minimatch$1(pattern, options);
    list = list.filter(function (f) {
      return mm.match(f);
    });

    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }

    return list;
  };

  Minimatch$1.prototype.match = function match(f, partial) {
    if (typeof partial === 'undefined') partial = this.partial;
    this.debug('match', f, this.pattern); // short-circuit in the case of busted things.
    // comments, etc.

    if (this.comment) return false;
    if (this.empty) return f === '';
    if (f === '/' && partial) return true;
    var options = this.options; // windows: need to use /, not \

    if (path.sep !== '/') {
      f = f.split(path.sep).join('/');
    } // treat the test path as a set of pathparts.


    f = f.split(slashSplit);
    this.debug(this.pattern, 'split', f); // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    var set = this.set;
    this.debug(this.pattern, 'set', set); // Find the basename of the path by looking for the last non-empty segment

    var filename;
    var i;

    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename) break;
    }

    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;

      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }

      var hit = this.matchOne(file, pattern, partial);

      if (hit) {
        if (options.flipNegate) return true;
        return !this.negate;
      }
    } // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.


    if (options.flipNegate) return false;
    return this.negate;
  }; // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.


  Minimatch$1.prototype.matchOne = function (file, pattern, partial) {
    var options = this.options;
    this.debug('matchOne', {
      'this': this,
      file: file,
      pattern: pattern
    });
    this.debug('matchOne', file.length, pattern.length);

    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug('matchOne loop');
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f); // should be impossible.
      // some invalid regexp stuff in the set.

      /* istanbul ignore if */

      if (p === false) return false;

      if (p === GLOBSTAR) {
        this.debug('GLOBSTAR', [pattern, p, f]); // "**"
        // a/**/b/**/c would match the following:
        // a/b/x/y/z/c
        // a/x/y/z/b/c
        // a/b/x/b/x/c
        // a/b/c
        // To do this, take the rest of the pattern after
        // the **, and see if it would match the file remainder.
        // If so, return success.
        // If not, the ** "swallows" a segment, and try again.
        // This is recursively awful.
        //
        // a/**/b/**/c matching a/b/x/y/z/c
        // - a matches a
        // - doublestar
        //   - matchOne(b/x/y/z/c, b/**/c)
        //     - b matches b
        //     - doublestar
        //       - matchOne(x/y/z/c, c) -> no
        //       - matchOne(y/z/c, c) -> no
        //       - matchOne(z/c, c) -> no
        //       - matchOne(c, c) yes, hit

        var fr = fi;
        var pr = pi + 1;

        if (pr === pl) {
          this.debug('** at the end'); // a ** at the end will just swallow the rest.
          // We have found a match.
          // however, it will not swallow /.x, unless
          // options.dot is set.
          // . and .. are *never* matched by **, for explosively
          // exponential reasons.

          for (; fi < fl; fi++) {
            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
          }

          return true;
        } // ok, let's see if we can swallow whatever we can.


        while (fr < fl) {
          var swallowee = file[fr];
          this.debug('\nglobstar while', file, fr, pattern, pr, swallowee); // XXX remove this slice.  Just pass the start index.

          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug('globstar found match!', fr, fl, swallowee); // found a match.

            return true;
          } else {
            // can't swallow "." or ".." ever.
            // can only swallow ".foo" when explicitly asked.
            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
              this.debug('dot detected!', file, fr, pattern, pr);
              break;
            } // ** swallows a segment, and continue.


            this.debug('globstar swallow a segment, and continue');
            fr++;
          }
        } // no match was found.
        // However, in partial mode, we can't say this is necessarily over.
        // If there's more *pattern* left, then

        /* istanbul ignore if */


        if (partial) {
          // ran out of file
          this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
          if (fr === fl) return true;
        }

        return false;
      } // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.


      var hit;

      if (typeof p === 'string') {
        hit = f === p;
        this.debug('string match', p, f, hit);
      } else {
        hit = f.match(p);
        this.debug('pattern match', p, f, hit);
      }

      if (!hit) return false;
    } // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*
    // now either we fell off the end of the pattern, or we're done.


    if (fi === fl && pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true;
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we're doing the match as part of
      // a glob fs traversal.
      return partial;
    } else
      /* istanbul ignore else */
      if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        return fi === fl - 1 && file[fi] === '';
      } // should be unreachable.

    /* istanbul ignore next */


    throw new Error('wtf?');
  }; // replace stuff like \* with *


  function globUnescape(s) {
    return s.replace(/\\(.)/g, '$1');
  }

  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
  }

  var inherits_browser = createCommonjsModule(function (module) {
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function () {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  });

  var inherits = createCommonjsModule(function (module) {
  try {
    var util = util__default['default'];
    /* istanbul ignore next */


    if (typeof util.inherits !== 'function') throw '';
    module.exports = util.inherits;
  } catch (e) {
    /* istanbul ignore next */
    module.exports = inherits_browser;
  }
  });

  function posix(path) {
    return path.charAt(0) === '/';
  }

  function win32(path) {
    // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path);
    var device = result[1] || '';
    var isUnc = Boolean(device && device.charAt(1) !== ':'); // UNC paths are always absolute

    return Boolean(result[2] || isUnc);
  }

  var pathIsAbsolute = process.platform === 'win32' ? win32 : posix;
  var posix_1 = posix;
  var win32_1 = win32;
  pathIsAbsolute.posix = posix_1;
  pathIsAbsolute.win32 = win32_1;

  var setopts_1 = setopts$2;
  var ownProp_1 = ownProp$2;
  var makeAbs_1 = makeAbs;
  var finish_1 = finish;
  var mark_1 = mark;
  var isIgnored_1 = isIgnored$2;
  var childrenIgnored_1 = childrenIgnored$2;

  function ownProp$2(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }







  var Minimatch = minimatch_1.Minimatch;

  function alphasort(a, b) {
    return a.localeCompare(b, 'en');
  }

  function setupIgnores(self, options) {
    self.ignore = options.ignore || [];
    if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];

    if (self.ignore.length) {
      self.ignore = self.ignore.map(ignoreMap);
    }
  } // ignore patterns are always in dot:true mode.


  function ignoreMap(pattern) {
    var gmatcher = null;

    if (pattern.slice(-3) === '/**') {
      var gpattern = pattern.replace(/(\/\*\*)+$/, '');
      gmatcher = new Minimatch(gpattern, {
        dot: true
      });
    }

    return {
      matcher: new Minimatch(pattern, {
        dot: true
      }),
      gmatcher: gmatcher
    };
  }

  function setopts$2(self, pattern, options) {
    if (!options) options = {}; // base-matching: just use globstar for that.

    if (options.matchBase && -1 === pattern.indexOf("/")) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }

      pattern = "**/" + pattern;
    }

    self.silent = !!options.silent;
    self.pattern = pattern;
    self.strict = options.strict !== false;
    self.realpath = !!options.realpath;
    self.realpathCache = options.realpathCache || Object.create(null);
    self.follow = !!options.follow;
    self.dot = !!options.dot;
    self.mark = !!options.mark;
    self.nodir = !!options.nodir;
    if (self.nodir) self.mark = true;
    self.sync = !!options.sync;
    self.nounique = !!options.nounique;
    self.nonull = !!options.nonull;
    self.nosort = !!options.nosort;
    self.nocase = !!options.nocase;
    self.stat = !!options.stat;
    self.noprocess = !!options.noprocess;
    self.absolute = !!options.absolute;
    self.maxLength = options.maxLength || Infinity;
    self.cache = options.cache || Object.create(null);
    self.statCache = options.statCache || Object.create(null);
    self.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self, options);
    self.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp$2(options, "cwd")) self.cwd = cwd;else {
      self.cwd = path__default['default'].resolve(options.cwd);
      self.changedCwd = self.cwd !== cwd;
    }
    self.root = options.root || path__default['default'].resolve(self.cwd, "/");
    self.root = path__default['default'].resolve(self.root);
    if (process.platform === "win32") self.root = self.root.replace(/\\/g, "/"); // TODO: is an absolute `cwd` supposed to be resolved against `root`?
    // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')

    self.cwdAbs = pathIsAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
    if (process.platform === "win32") self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
    self.nomount = !!options.nomount; // disable comments and negation in Minimatch.
    // Note that they are not supported in Glob itself anyway.

    options.nonegate = true;
    options.nocomment = true;
    self.minimatch = new Minimatch(pattern, options);
    self.options = self.minimatch.options;
  }

  function finish(self) {
    var nou = self.nounique;
    var all = nou ? [] : Object.create(null);

    for (var i = 0, l = self.matches.length; i < l; i++) {
      var matches = self.matches[i];

      if (!matches || Object.keys(matches).length === 0) {
        if (self.nonull) {
          // do like the shell, and spit out the literal glob
          var literal = self.minimatch.globSet[i];
          if (nou) all.push(literal);else all[literal] = true;
        }
      } else {
        // had matches
        var m = Object.keys(matches);
        if (nou) all.push.apply(all, m);else m.forEach(function (m) {
          all[m] = true;
        });
      }
    }

    if (!nou) all = Object.keys(all);
    if (!self.nosort) all = all.sort(alphasort); // at *some* point we statted all of these

    if (self.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self._mark(all[i]);
      }

      if (self.nodir) {
        all = all.filter(function (e) {
          var notDir = !/\/$/.test(e);
          var c = self.cache[e] || self.cache[makeAbs(self, e)];
          if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);
          return notDir;
        });
      }
    }

    if (self.ignore.length) all = all.filter(function (m) {
      return !isIgnored$2(self, m);
    });
    self.found = all;
  }

  function mark(self, p) {
    var abs = makeAbs(self, p);
    var c = self.cache[abs];
    var m = p;

    if (c) {
      var isDir = c === 'DIR' || Array.isArray(c);
      var slash = p.slice(-1) === '/';
      if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);

      if (m !== p) {
        var mabs = makeAbs(self, m);
        self.statCache[mabs] = self.statCache[abs];
        self.cache[mabs] = self.cache[abs];
      }
    }

    return m;
  } // lotta situps...


  function makeAbs(self, f) {
    var abs = f;

    if (f.charAt(0) === '/') {
      abs = path__default['default'].join(self.root, f);
    } else if (pathIsAbsolute(f) || f === '') {
      abs = f;
    } else if (self.changedCwd) {
      abs = path__default['default'].resolve(self.cwd, f);
    } else {
      abs = path__default['default'].resolve(f);
    }

    if (process.platform === 'win32') abs = abs.replace(/\\/g, '/');
    return abs;
  } // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
  // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents


  function isIgnored$2(self, path) {
    if (!self.ignore.length) return false;
    return self.ignore.some(function (item) {
      return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));
    });
  }

  function childrenIgnored$2(self, path) {
    if (!self.ignore.length) return false;
    return self.ignore.some(function (item) {
      return !!(item.gmatcher && item.gmatcher.match(path));
    });
  }

  var common$2 = {
  	setopts: setopts_1,
  	ownProp: ownProp_1,
  	makeAbs: makeAbs_1,
  	finish: finish_1,
  	mark: mark_1,
  	isIgnored: isIgnored_1,
  	childrenIgnored: childrenIgnored_1
  };

  var sync$c = globSync;
  globSync.GlobSync = GlobSync$1;











  var setopts$1 = common$2.setopts;
  var ownProp$1 = common$2.ownProp;
  var childrenIgnored$1 = common$2.childrenIgnored;
  var isIgnored$1 = common$2.isIgnored;

  function globSync(pattern, options) {
    if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');
    return new GlobSync$1(pattern, options).found;
  }

  function GlobSync$1(pattern, options) {
    if (!pattern) throw new Error('must provide pattern');
    if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');
    if (!(this instanceof GlobSync$1)) return new GlobSync$1(pattern, options);
    setopts$1(this, pattern, options);
    if (this.noprocess) return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);

    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }

    this._finish();
  }

  GlobSync$1.prototype._finish = function () {
    assert__default['default'](this instanceof GlobSync$1);

    if (this.realpath) {
      var self = this;
      this.matches.forEach(function (matchset, index) {
        var set = self.matches[index] = Object.create(null);

        for (var p in matchset) {
          try {
            p = self._makeAbs(p);
            var real = fs_realpath.realpathSync(p, self.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === 'stat') set[self._makeAbs(p)] = true;else throw er;
          }
        }
      });
    }

    common$2.finish(this);
  };

  GlobSync$1.prototype._process = function (pattern, index, inGlobStar) {
    assert__default['default'](this instanceof GlobSync$1); // Get the first [n] parts of pattern that are all strings.

    var n = 0;

    while (typeof pattern[n] === 'string') {
      n++;
    } // now n is the index of the first one that is *not* a string.
    // See if there's anything else


    var prefix;

    switch (n) {
      // if not, then this is rather simple
      case pattern.length:
        this._processSimple(pattern.join('/'), index);

        return;

      case 0:
        // pattern *starts* with some non-trivial item.
        // going to readdir(cwd), but not include the prefix in matches.
        prefix = null;
        break;

      default:
        // pattern has some string bits in the front.
        // whatever it starts with, whether that's 'absolute' like /foo/bar,
        // or 'relative' like '../baz'
        prefix = pattern.slice(0, n).join('/');
        break;
    }

    var remain = pattern.slice(n); // get the list of entries.

    var read;
    if (prefix === null) read = '.';else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
      if (!prefix || !pathIsAbsolute(prefix)) prefix = '/' + prefix;
      read = prefix;
    } else read = prefix;

    var abs = this._makeAbs(read); //if ignored, skip processing


    if (childrenIgnored$1(this, read)) return;
    var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };

  GlobSync$1.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar); // if the abs isn't a dir, then nothing can match!


    if (!entries) return; // It will only match dot entries if it starts with a dot, or if
    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.

    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === '.';
    var matchedEntries = [];

    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];

      if (e.charAt(0) !== '.' || dotOk) {
        var m;

        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }

        if (m) matchedEntries.push(e);
      }
    }

    var len = matchedEntries.length; // If there are no matched entries, then nothing matches.

    if (len === 0) return; // if this is the last remaining pattern bit, then no need for
    // an additional stat *unless* the user has specified mark or
    // stat explicitly.  We know they exist, since readdir returned
    // them.

    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index]) this.matches[index] = Object.create(null);

      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];

        if (prefix) {
          if (prefix.slice(-1) !== '/') e = prefix + '/' + e;else e = prefix + e;
        }

        if (e.charAt(0) === '/' && !this.nomount) {
          e = path__default['default'].join(this.root, e);
        }

        this._emitMatch(index, e);
      } // This was the last one, and no stats were needed


      return;
    } // now test all matched entries as stand-ins for that part
    // of the pattern.


    remain.shift();

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) newPattern = [prefix, e];else newPattern = [e];

      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };

  GlobSync$1.prototype._emitMatch = function (index, e) {
    if (isIgnored$1(this, e)) return;

    var abs = this._makeAbs(e);

    if (this.mark) e = this._mark(e);

    if (this.absolute) {
      e = abs;
    }

    if (this.matches[index][e]) return;

    if (this.nodir) {
      var c = this.cache[abs];
      if (c === 'DIR' || Array.isArray(c)) return;
    }

    this.matches[index][e] = true;
    if (this.stat) this._stat(e);
  };

  GlobSync$1.prototype._readdirInGlobStar = function (abs) {
    // follow all symlinked directories forever
    // just proceed as if this is a non-globstar situation
    if (this.follow) return this._readdir(abs, false);
    var entries;
    var lstat;

    try {
      lstat = fs__default['default'].lstatSync(abs);
    } catch (er) {
      if (er.code === 'ENOENT') {
        // lstat failed, doesn't exist
        return null;
      }
    }

    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.

    if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = 'FILE';else entries = this._readdir(abs, false);
    return entries;
  };

  GlobSync$1.prototype._readdir = function (abs, inGlobStar) {
    if (inGlobStar && !ownProp$1(this.symlinks, abs)) return this._readdirInGlobStar(abs);

    if (ownProp$1(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === 'FILE') return null;
      if (Array.isArray(c)) return c;
    }

    try {
      return this._readdirEntries(abs, fs__default['default'].readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);

      return null;
    }
  };

  GlobSync$1.prototype._readdirEntries = function (abs, entries) {
    // if we haven't asked to stat everything, then just
    // assume that everything in there exists, so we can avoid
    // having to stat it a second time.
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === '/') e = abs + e;else e = abs + '/' + e;
        this.cache[e] = true;
      }
    }

    this.cache[abs] = entries; // mark and cache dir-ness

    return entries;
  };

  GlobSync$1.prototype._readdirError = function (f, er) {
    // handle errors, and cache the information
    switch (er.code) {
      case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205

      case 'ENOTDIR':
        // totally normal. means it *does* exist.
        var abs = this._makeAbs(f);

        this.cache[abs] = 'FILE';

        if (abs === this.cwdAbs) {
          var error = new Error(er.code + ' invalid cwd ' + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }

        break;

      case 'ENOENT': // not terribly unusual

      case 'ELOOP':
      case 'ENAMETOOLONG':
      case 'UNKNOWN':
        this.cache[this._makeAbs(f)] = false;
        break;

      default:
        // some unusual error.  Treat as failure.
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) throw er;
        if (!this.silent) console.error('glob error', er);
        break;
    }
  };

  GlobSync$1.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar); // no entries means not a dir, so it can never have matches
    // foo.txt/** doesn't match foo.txt


    if (!entries) return; // test without the globstar, and with every child both below
    // and replacing the globstar.

    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state

    this._process(noGlobStar, index, false);

    var len = entries.length;
    var isSym = this.symlinks[abs]; // If it's a symlink, and we're in a globstar, then stop

    if (isSym && inGlobStar) return;

    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state

      var instead = gspref.concat(entries[i], remainWithoutGlobStar);

      this._process(instead, index, true);

      var below = gspref.concat(entries[i], remain);

      this._process(below, index, true);
    }
  };

  GlobSync$1.prototype._processSimple = function (prefix, index) {
    // XXX review this.  Shouldn't it be doing the mounting etc
    // before doing stat?  kinda weird?
    var exists = this._stat(prefix);

    if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results

    if (!exists) return;

    if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);

      if (prefix.charAt(0) === '/') {
        prefix = path__default['default'].join(this.root, prefix);
      } else {
        prefix = path__default['default'].resolve(this.root, prefix);
        if (trail) prefix += '/';
      }
    }

    if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/'); // Mark this as a match

    this._emitMatch(index, prefix);
  }; // Returns either 'DIR', 'FILE', or false


  GlobSync$1.prototype._stat = function (f) {
    var abs = this._makeAbs(f);

    var needDir = f.slice(-1) === '/';
    if (f.length > this.maxLength) return false;

    if (!this.stat && ownProp$1(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it

      if (!needDir || c === 'DIR') return c;
      if (needDir && c === 'FILE') return false; // otherwise we have to stat, because maybe c=true
      // if we know it exists, but not what it is.
    }
    var stat = this.statCache[abs];

    if (!stat) {
      var lstat;

      try {
        lstat = fs__default['default'].lstatSync(abs);
      } catch (er) {
        if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
          this.statCache[abs] = false;
          return false;
        }
      }

      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = fs__default['default'].statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }

    this.statCache[abs] = stat;
    var c = true;
    if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === 'FILE') return false;
    return c;
  };

  GlobSync$1.prototype._mark = function (p) {
    return common$2.mark(this, p);
  };

  GlobSync$1.prototype._makeAbs = function (f) {
    return common$2.makeAbs(this, f);
  };

  // Returns a wrapper function that returns a wrapped callback
  // The wrapper function should do some stuff, and return a
  // presumably different callback function.
  // This makes sure that own properties are retained, so that
  // decorations and such are not lost along the way.
  var wrappy_1 = wrappy;

  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== 'function') throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function (k) {
      wrapper[k] = fn[k];
    });
    return wrapper;

    function wrapper() {
      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      var ret = fn.apply(this, args);
      var cb = args[args.length - 1];

      if (typeof ret === 'function' && ret !== cb) {
        Object.keys(cb).forEach(function (k) {
          ret[k] = cb[k];
        });
      }

      return ret;
    }
  }

  var once_1 = wrappy_1(once);
  var strict = wrappy_1(onceStrict);
  once.proto = once(function () {
    Object.defineProperty(Function.prototype, 'once', {
      value: function () {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, 'onceStrict', {
      value: function () {
        return onceStrict(this);
      },
      configurable: true
    });
  });

  function once(fn) {
    var f = function () {
      if (f.called) return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };

    f.called = false;
    return f;
  }

  function onceStrict(fn) {
    var f = function () {
      if (f.called) throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };

    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  once_1.strict = strict;

  var reqs = Object.create(null);



  var inflight_1 = wrappy_1(inflight);

  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }

  function makeres(key) {
    return once_1(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice$1(arguments); // XXX It's somewhat ambiguous whether a new callback added in this
      // pass should be queued for later execution if something in the
      // list of callbacks throws, or if it should just be discarded.
      // However, it's such an edge case that it hardly matters, and either
      // choice is likely as surprising as the other.
      // As it happens, we do go ahead and schedule it for later execution.

      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          // added more in the interim.
          // de-zalgo, just in case, but don't call again.
          cbs.splice(0, len);
          process.nextTick(function () {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }

  function slice$1(args) {
    var length = args.length;
    var array = [];

    for (var i = 0; i < length; i++) array[i] = args[i];

    return array;
  }

  // Approach:
  //
  // 1. Get the minimatch set
  // 2. For each pattern in the set, PROCESS(pattern, false)
  // 3. Store matches per-set, then uniq them
  //
  // PROCESS(pattern, inGlobStar)
  // Get the first [n] items from pattern that are all strings
  // Join these together.  This is PREFIX.
  //   If there is no more remaining, then stat(PREFIX) and
  //   add to matches if it succeeds.  END.
  //
  // If inGlobStar and PREFIX is symlink and points to dir
  //   set ENTRIES = []
  // else readdir(PREFIX) as ENTRIES
  //   If fail, END
  //
  // with ENTRIES
  //   If pattern[n] is GLOBSTAR
  //     // handle the case where the globstar match is empty
  //     // by pruning it out, and testing the resulting pattern
  //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
  //     // handle other cases.
  //     for ENTRY in ENTRIES (not dotfiles)
  //       // attach globstar + tail onto the entry
  //       // Mark that this entry is a globstar match
  //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
  //
  //   else // not globstar
  //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
  //       Test ENTRY against pattern[n]
  //       If fails, continue
  //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
  //
  // Caveat:
  //   Cache all stats and readdirs results to minimize syscall.  Since all
  //   we ever care about is existence and directory-ness, we can just keep
  //   `true` for files, and [children,...] for directories, or `false` for
  //   things that don't exist.
  var glob_1 = glob$1;



  var EE = require$$0__default['default'].EventEmitter;











  var setopts = common$2.setopts;
  var ownProp = common$2.ownProp;





  var childrenIgnored = common$2.childrenIgnored;
  var isIgnored = common$2.isIgnored;



  function glob$1(pattern, options, cb) {
    if (typeof options === 'function') cb = options, options = {};
    if (!options) options = {};

    if (options.sync) {
      if (cb) throw new TypeError('callback provided to sync glob');
      return sync$c(pattern, options);
    }

    return new Glob(pattern, options, cb);
  }

  glob$1.sync = sync$c;
  var GlobSync = glob$1.GlobSync = sync$c.GlobSync; // old api surface

  glob$1.glob = glob$1;

  function extend(origin, add) {
    if (add === null || typeof add !== 'object') {
      return origin;
    }

    var keys = Object.keys(add);
    var i = keys.length;

    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }

    return origin;
  }

  glob$1.hasMagic = function (pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern) return false;
    if (set.length > 1) return true;

    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== 'string') return true;
    }

    return false;
  };

  glob$1.Glob = Glob;
  inherits(Glob, EE);

  function Glob(pattern, options, cb) {
    if (typeof options === 'function') {
      cb = options;
      options = null;
    }

    if (options && options.sync) {
      if (cb) throw new TypeError('callback provided to sync glob');
      return new GlobSync(pattern, options);
    }

    if (!(this instanceof Glob)) return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false; // process each pattern in the minimatch set

    var n = this.minimatch.set.length; // The matches are stored as {<filename>: true,...} so that
    // duplicates are automagically pruned.
    // Later, we do an Object.keys() on these.
    // Keep them as a list so we can fill in when nonull is set.

    this.matches = new Array(n);

    if (typeof cb === 'function') {
      cb = once_1(cb);
      this.on('error', cb);
      this.on('end', function (matches) {
        cb(null, matches);
      });
    }

    var self = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess) return this;
    if (n === 0) return done();
    var sync = true;

    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }

    sync = false;

    function done() {
      --self._processing;

      if (self._processing <= 0) {
        if (sync) {
          process.nextTick(function () {
            self._finish();
          });
        } else {
          self._finish();
        }
      }
    }
  }

  Glob.prototype._finish = function () {
    assert__default['default'](this instanceof Glob);
    if (this.aborted) return;
    if (this.realpath && !this._didRealpath) return this._realpath();
    common$2.finish(this);
    this.emit('end', this.found);
  };

  Glob.prototype._realpath = function () {
    if (this._didRealpath) return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0) return this._finish();
    var self = this;

    for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);

    function next() {
      if (--n === 0) self._finish();
    }
  };

  Glob.prototype._realpathSet = function (index, cb) {
    var matchset = this.matches[index];
    if (!matchset) return cb();
    var found = Object.keys(matchset);
    var self = this;
    var n = found.length;
    if (n === 0) return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function (p, i) {
      // If there's a problem with the stat, then it means that
      // one or more of the links in the realpath couldn't be
      // resolved.  just return the abs value in that case.
      p = self._makeAbs(p);
      fs_realpath.realpath(p, self.realpathCache, function (er, real) {
        if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here

        if (--n === 0) {
          self.matches[index] = set;
          cb();
        }
      });
    });
  };

  Glob.prototype._mark = function (p) {
    return common$2.mark(this, p);
  };

  Glob.prototype._makeAbs = function (f) {
    return common$2.makeAbs(this, f);
  };

  Glob.prototype.abort = function () {
    this.aborted = true;
    this.emit('abort');
  };

  Glob.prototype.pause = function () {
    if (!this.paused) {
      this.paused = true;
      this.emit('pause');
    }
  };

  Glob.prototype.resume = function () {
    if (this.paused) {
      this.emit('resume');
      this.paused = false;

      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);

        this._emitQueue.length = 0;

        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];

          this._emitMatch(e[0], e[1]);
        }
      }

      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);

        this._processQueue.length = 0;

        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;

          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };

  Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
    assert__default['default'](this instanceof Glob);
    assert__default['default'](typeof cb === 'function');
    if (this.aborted) return;
    this._processing++;

    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);

      return;
    } //console.error('PROCESS %d', this._processing, pattern)
    // Get the first [n] parts of pattern that are all strings.


    var n = 0;

    while (typeof pattern[n] === 'string') {
      n++;
    } // now n is the index of the first one that is *not* a string.
    // see if there's anything else


    var prefix;

    switch (n) {
      // if not, then this is rather simple
      case pattern.length:
        this._processSimple(pattern.join('/'), index, cb);

        return;

      case 0:
        // pattern *starts* with some non-trivial item.
        // going to readdir(cwd), but not include the prefix in matches.
        prefix = null;
        break;

      default:
        // pattern has some string bits in the front.
        // whatever it starts with, whether that's 'absolute' like /foo/bar,
        // or 'relative' like '../baz'
        prefix = pattern.slice(0, n).join('/');
        break;
    }

    var remain = pattern.slice(n); // get the list of entries.

    var read;
    if (prefix === null) read = '.';else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
      if (!prefix || !pathIsAbsolute(prefix)) prefix = '/' + prefix;
      read = prefix;
    } else read = prefix;

    var abs = this._makeAbs(read); //if ignored, skip _processing


    if (childrenIgnored(this, read)) return cb();
    var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };

  Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;

    this._readdir(abs, inGlobStar, function (er, entries) {
      return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };

  Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    // if the abs isn't a dir, then nothing can match!
    if (!entries) return cb(); // It will only match dot entries if it starts with a dot, or if
    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.

    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === '.';
    var matchedEntries = [];

    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];

      if (e.charAt(0) !== '.' || dotOk) {
        var m;

        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }

        if (m) matchedEntries.push(e);
      }
    } //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)


    var len = matchedEntries.length; // If there are no matched entries, then nothing matches.

    if (len === 0) return cb(); // if this is the last remaining pattern bit, then no need for
    // an additional stat *unless* the user has specified mark or
    // stat explicitly.  We know they exist, since readdir returned
    // them.

    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index]) this.matches[index] = Object.create(null);

      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];

        if (prefix) {
          if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
        }

        if (e.charAt(0) === '/' && !this.nomount) {
          e = path__default['default'].join(this.root, e);
        }

        this._emitMatch(index, e);
      } // This was the last one, and no stats were needed


      return cb();
    } // now test all matched entries as stand-ins for that part
    // of the pattern.


    remain.shift();

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];

      if (prefix) {
        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
      }

      this._process([e].concat(remain), index, inGlobStar, cb);
    }

    cb();
  };

  Glob.prototype._emitMatch = function (index, e) {
    if (this.aborted) return;
    if (isIgnored(this, e)) return;

    if (this.paused) {
      this._emitQueue.push([index, e]);

      return;
    }

    var abs = pathIsAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark) e = this._mark(e);
    if (this.absolute) e = abs;
    if (this.matches[index][e]) return;

    if (this.nodir) {
      var c = this.cache[abs];
      if (c === 'DIR' || Array.isArray(c)) return;
    }

    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st) this.emit('stat', e, st);
    this.emit('match', e);
  };

  Glob.prototype._readdirInGlobStar = function (abs, cb) {
    if (this.aborted) return; // follow all symlinked directories forever
    // just proceed as if this is a non-globstar situation

    if (this.follow) return this._readdir(abs, false, cb);
    var lstatkey = 'lstat\0' + abs;
    var self = this;
    var lstatcb = inflight_1(lstatkey, lstatcb_);
    if (lstatcb) fs__default['default'].lstat(abs, lstatcb);

    function lstatcb_(er, lstat) {
      if (er && er.code === 'ENOENT') return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.
      // don't bother doing a readdir in that case.

      if (!isSym && lstat && !lstat.isDirectory()) {
        self.cache[abs] = 'FILE';
        cb();
      } else self._readdir(abs, false, cb);
    }
  };

  Glob.prototype._readdir = function (abs, inGlobStar, cb) {
    if (this.aborted) return;
    cb = inflight_1('readdir\0' + abs + '\0' + inGlobStar, cb);
    if (!cb) return; //console.error('RD %j %j', +inGlobStar, abs)

    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);

    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === 'FILE') return cb();
      if (Array.isArray(c)) return cb(null, c);
    }
    fs__default['default'].readdir(abs, readdirCb(this, abs, cb));
  };

  function readdirCb(self, abs, cb) {
    return function (er, entries) {
      if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);
    };
  }

  Glob.prototype._readdirEntries = function (abs, entries, cb) {
    if (this.aborted) return; // if we haven't asked to stat everything, then just
    // assume that everything in there exists, so we can avoid
    // having to stat it a second time.

    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === '/') e = abs + e;else e = abs + '/' + e;
        this.cache[e] = true;
      }
    }

    this.cache[abs] = entries;
    return cb(null, entries);
  };

  Glob.prototype._readdirError = function (f, er, cb) {
    if (this.aborted) return; // handle errors, and cache the information

    switch (er.code) {
      case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205

      case 'ENOTDIR':
        // totally normal. means it *does* exist.
        var abs = this._makeAbs(f);

        this.cache[abs] = 'FILE';

        if (abs === this.cwdAbs) {
          var error = new Error(er.code + ' invalid cwd ' + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit('error', error);
          this.abort();
        }

        break;

      case 'ENOENT': // not terribly unusual

      case 'ELOOP':
      case 'ENAMETOOLONG':
      case 'UNKNOWN':
        this.cache[this._makeAbs(f)] = false;
        break;

      default:
        // some unusual error.  Treat as failure.
        this.cache[this._makeAbs(f)] = false;

        if (this.strict) {
          this.emit('error', er); // If the error is handled, then we abort
          // if not, we threw out of here

          this.abort();
        }

        if (!this.silent) console.error('glob error', er);
        break;
    }

    return cb();
  };

  Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;

    this._readdir(abs, inGlobStar, function (er, entries) {
      self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };

  Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    //console.error('pgs2', prefix, remain[0], entries)
    // no entries means not a dir, so it can never have matches
    // foo.txt/** doesn't match foo.txt
    if (!entries) return cb(); // test without the globstar, and with every child both below
    // and replacing the globstar.

    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state

    this._process(noGlobStar, index, false, cb);

    var isSym = this.symlinks[abs];
    var len = entries.length; // If it's a symlink, and we're in a globstar, then stop

    if (isSym && inGlobStar) return cb();

    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state

      var instead = gspref.concat(entries[i], remainWithoutGlobStar);

      this._process(instead, index, true, cb);

      var below = gspref.concat(entries[i], remain);

      this._process(below, index, true, cb);
    }

    cb();
  };

  Glob.prototype._processSimple = function (prefix, index, cb) {
    // XXX review this.  Shouldn't it be doing the mounting etc
    // before doing stat?  kinda weird?
    var self = this;

    this._stat(prefix, function (er, exists) {
      self._processSimple2(prefix, index, er, exists, cb);
    });
  };

  Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    //console.error('ps2', prefix, exists)
    if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results

    if (!exists) return cb();

    if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);

      if (prefix.charAt(0) === '/') {
        prefix = path__default['default'].join(this.root, prefix);
      } else {
        prefix = path__default['default'].resolve(this.root, prefix);
        if (trail) prefix += '/';
      }
    }

    if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/'); // Mark this as a match

    this._emitMatch(index, prefix);

    cb();
  }; // Returns either 'DIR', 'FILE', or false


  Glob.prototype._stat = function (f, cb) {
    var abs = this._makeAbs(f);

    var needDir = f.slice(-1) === '/';
    if (f.length > this.maxLength) return cb();

    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it

      if (!needDir || c === 'DIR') return cb(null, c);
      if (needDir && c === 'FILE') return cb(); // otherwise we have to stat, because maybe c=true
      // if we know it exists, but not what it is.
    }
    var stat = this.statCache[abs];

    if (stat !== undefined) {
      if (stat === false) return cb(null, stat);else {
        var type = stat.isDirectory() ? 'DIR' : 'FILE';
        if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);
      }
    }

    var self = this;
    var statcb = inflight_1('stat\0' + abs, lstatcb_);
    if (statcb) fs__default['default'].lstat(abs, statcb);

    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        // If it's a symlink, then treat it as the target, unless
        // the target does not exist, then treat it as a file.
        return fs__default['default'].stat(abs, function (er, stat) {
          if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);
        });
      } else {
        self._stat2(f, abs, er, lstat, cb);
      }
    }
  };

  Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
    if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
      this.statCache[abs] = false;
      return cb();
    }

    var needDir = f.slice(-1) === '/';
    this.statCache[abs] = stat;
    if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat);
    var c = true;
    if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === 'FILE') return cb();
    return cb(null, c, stat);
  };

  let glob = undefined;

  try {
    glob = glob_1;
  } catch (_err) {// treat glob as optional.
  }

  const defaultGlobOpts = {
    nosort: true,
    silent: true
  }; // for EMFILE handling

  let timeout = 0;
  const isWindows = process.platform === "win32";

  const defaults = options => {
    const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];
    methods.forEach(m => {
      options[m] = options[m] || fs__default['default'][m];
      m = m + 'Sync';
      options[m] = options[m] || fs__default['default'][m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1000;

    if (options.glob === false) {
      options.disableGlob = true;
    }

    if (options.disableGlob !== true && glob === undefined) {
      throw Error('glob dependency not found, set `options.disableGlob = true` if intentional');
    }

    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  };

  const rimraf$1 = (p, options, cb) => {
    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    assert__default['default'](p, 'rimraf: missing path');
    assert__default['default'].equal(typeof p, 'string', 'rimraf: path should be a string');
    assert__default['default'].equal(typeof cb, 'function', 'rimraf: callback function required');
    assert__default['default'](options, 'rimraf: invalid options argument provided');
    assert__default['default'].equal(typeof options, 'object', 'rimraf: options should be object');
    defaults(options);
    let busyTries = 0;
    let errState = null;
    let n = 0;

    const next = er => {
      errState = errState || er;
      if (--n === 0) cb(errState);
    };

    const afterGlob = (er, results) => {
      if (er) return cb(er);
      n = results.length;
      if (n === 0) return cb();
      results.forEach(p => {
        const CB = er => {
          if (er) {
            if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++; // try again, with the same exact callback as this one.

              return setTimeout(() => rimraf_(p, options, CB), busyTries * 100);
            } // this one won't happen if graceful-fs is used.


            if (er.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(() => rimraf_(p, options, CB), timeout++);
            } // already gone


            if (er.code === "ENOENT") er = null;
          }

          timeout = 0;
          next(er);
        };

        rimraf_(p, options, CB);
      });
    };

    if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [p]);
    options.lstat(p, (er, stat) => {
      if (!er) return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
  }; // Two possible strategies.
  // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
  // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
  //
  // Both result in an extra syscall when you guess wrong.  However, there
  // are likely far more normal files in the world than directories.  This
  // is based on the assumption that a the average number of files per
  // directory is >= 1.
  //
  // If anyone ever complains about this, then I guess the strategy could
  // be made configurable somehow.  But until then, YAGNI.


  const rimraf_ = (p, options, cb) => {
    assert__default['default'](p);
    assert__default['default'](options);
    assert__default['default'](typeof cb === 'function'); // sunos lets the root user unlink directories, which is... weird.
    // so we have to lstat here and make sure it's not a dir.

    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") return cb(null); // Windows can EPERM on stat.  Life is suffering.

      if (er && er.code === "EPERM" && isWindows) fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory()) return rmdir(p, options, er, cb);
      options.unlink(p, er => {
        if (er) {
          if (er.code === "ENOENT") return cb(null);
          if (er.code === "EPERM") return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);
          if (er.code === "EISDIR") return rmdir(p, options, er, cb);
        }

        return cb(er);
      });
    });
  };

  const fixWinEPERM = (p, options, er, cb) => {
    assert__default['default'](p);
    assert__default['default'](options);
    assert__default['default'](typeof cb === 'function');
    options.chmod(p, 0o666, er2 => {
      if (er2) cb(er2.code === "ENOENT" ? null : er);else options.stat(p, (er3, stats) => {
        if (er3) cb(er3.code === "ENOENT" ? null : er);else if (stats.isDirectory()) rmdir(p, options, er, cb);else options.unlink(p, cb);
      });
    });
  };

  const fixWinEPERMSync = (p, options, er) => {
    assert__default['default'](p);
    assert__default['default'](options);

    try {
      options.chmodSync(p, 0o666);
    } catch (er2) {
      if (er2.code === "ENOENT") return;else throw er;
    }

    let stats;

    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") return;else throw er;
    }

    if (stats.isDirectory()) rmdirSync(p, options, er);else options.unlinkSync(p);
  };

  const rmdir = (p, options, originalEr, cb) => {
    assert__default['default'](p);
    assert__default['default'](options);
    assert__default['default'](typeof cb === 'function'); // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
    // if we guessed wrong, and it's not a directory, then
    // raise the original error.

    options.rmdir(p, er => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) rmkids(p, options, cb);else if (er && er.code === "ENOTDIR") cb(originalEr);else cb(er);
    });
  };

  const rmkids = (p, options, cb) => {
    assert__default['default'](p);
    assert__default['default'](options);
    assert__default['default'](typeof cb === 'function');
    options.readdir(p, (er, files) => {
      if (er) return cb(er);
      let n = files.length;
      if (n === 0) return options.rmdir(p, cb);
      let errState;
      files.forEach(f => {
        rimraf$1(path__default['default'].join(p, f), options, er => {
          if (errState) return;
          if (er) return cb(errState = er);
          if (--n === 0) options.rmdir(p, cb);
        });
      });
    });
  }; // this looks simpler, and is strictly *faster*, but will
  // tie up the JavaScript thread and fail on excessively
  // deep directory trees.


  const rimrafSync = (p, options) => {
    options = options || {};
    defaults(options);
    assert__default['default'](p, 'rimraf: missing path');
    assert__default['default'].equal(typeof p, 'string', 'rimraf: path should be a string');
    assert__default['default'](options, 'rimraf: missing options');
    assert__default['default'].equal(typeof options, 'object', 'rimraf: options should be object');
    let results;

    if (options.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options.glob);
      }
    }

    if (!results.length) return;

    for (let i = 0; i < results.length; i++) {
      const p = results[i];
      let st;

      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") return; // Windows can EPERM on stat.  Life is suffering.

        if (er.code === "EPERM" && isWindows) fixWinEPERMSync(p, options, er);
      }

      try {
        // sunos lets the root user unlink directories, which is... weird.
        if (st && st.isDirectory()) rmdirSync(p, options, null);else options.unlinkSync(p);
      } catch (er) {
        if (er.code === "ENOENT") return;
        if (er.code === "EPERM") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        if (er.code !== "EISDIR") throw er;
        rmdirSync(p, options, er);
      }
    }
  };

  const rmdirSync = (p, options, originalEr) => {
    assert__default['default'](p);
    assert__default['default'](options);

    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT") return;
      if (er.code === "ENOTDIR") throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") rmkidsSync(p, options);
    }
  };

  const rmkidsSync = (p, options) => {
    assert__default['default'](p);
    assert__default['default'](options);
    options.readdirSync(p).forEach(f => rimrafSync(path__default['default'].join(p, f), options)); // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.

    const retries = isWindows ? 100 : 1;
    let i = 0;

    do {
      let threw = true;

      try {
        const ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw) continue;
      }
    } while (true);
  };

  var rimraf_1 = rimraf$1;
  rimraf$1.sync = rimrafSync;

  var rimraf = rimraf_1.sync;



  var del = function del(file) {
    if (fs__default['default'].existsSync(file)) {
      //if rimraf doesn't throw then the file has been deleted or didn't exist
      rimraf(file, {
        glob: false
      });
      return true;
    }

    return false;
  };

  var writeJSON = utils$6.writeJSON;
  var cache$2 = {
    /**
     * Load a cache identified by the given Id. If the element does not exists, then initialize an empty
     * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted
     * then the cache module directory `./cache` will be used instead
     *
     * @method load
     * @param docId {String} the id of the cache, would also be used as the name of the file cache
     * @param [cacheDir] {String} directory for the cache entry
     */
    load: function (docId, cacheDir) {
      var me = this;
      me._visited = {};
      me._persisted = {};
      me._pathToFile = cacheDir ? path__default['default'].resolve(cacheDir, docId) : path__default['default'].resolve(__dirname, '../.cache/', docId);

      if (fs__default['default'].existsSync(me._pathToFile)) {
        me._persisted = utils$6.tryParse(me._pathToFile, {});
      }
    },

    /**
     * Load the cache from the provided file
     * @method loadFile
     * @param  {String} pathToFile the path to the file containing the info for the cache
     */
    loadFile: function (pathToFile) {
      var me = this;
      var dir = path__default['default'].dirname(pathToFile);
      var fName = path__default['default'].basename(pathToFile);
      me.load(fName, dir);
    },

    /**
     * Returns the entire persisted object
     * @method all
     * @returns {*}
     */
    all: function () {
      return this._persisted;
    },
    keys: function () {
      return Object.keys(this._persisted);
    },

    /**
     * sets a key to a given value
     * @method setKey
     * @param key {string} the key to set
     * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify
     */
    setKey: function (key, value) {
      this._visited[key] = true;
      this._persisted[key] = value;
    },

    /**
     * remove a given key from the cache
     * @method removeKey
     * @param key {String} the key to remove from the object
     */
    removeKey: function (key) {
      delete this._visited[key]; // esfmt-ignore-line

      delete this._persisted[key]; // esfmt-ignore-line
    },

    /**
     * Return the value of the provided key
     * @method getKey
     * @param key {String} the name of the key to retrieve
     * @returns {*} the value from the key
     */
    getKey: function (key) {
      this._visited[key] = true;
      return this._persisted[key];
    },

    /**
     * Remove keys that were not accessed/set since the
     * last time the `prune` method was called.
     * @method _prune
     * @private
     */
    _prune: function () {
      var me = this;
      var obj = {};
      var keys = Object.keys(me._visited); // no keys visited for either get or set value

      if (keys.length === 0) {
        return;
      }

      keys.forEach(function (key) {
        obj[key] = me._persisted[key];
      });
      me._visited = {};
      me._persisted = obj;
    },

    /**
     * Save the state of the cache identified by the docId to disk
     * as a JSON structure
     * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files
     * @method save
     */
    save: function (noPrune) {
      var me = this;
      !noPrune && me._prune();
      writeJSON(me._pathToFile, me._persisted);
    },

    /**
     * remove the file where the cache is persisted
     * @method removeCacheFile
     * @return {Boolean} true or false if the file was successfully deleted
     */
    removeCacheFile: function () {
      return del(this._pathToFile);
    },

    /**
     * Destroy the file cache and cache content.
     * @method destroy
     */
    destroy: function () {
      var me = this;
      me._visited = {};
      me._persisted = {};
      me.removeCacheFile();
    }
  };
  var cache_1 = {
    /**
     * Alias for create. Should be considered depreacted. Will be removed in next releases
     *
     * @method load
     * @param docId {String} the id of the cache, would also be used as the name of the file cache
     * @param [cacheDir] {String} directory for the cache entry
     * @returns {cache} cache instance
     */
    load: function (docId, cacheDir) {
      return this.create(docId, cacheDir);
    },

    /**
     * Load a cache identified by the given Id. If the element does not exists, then initialize an empty
     * cache storage.
     *
     * @method create
     * @param docId {String} the id of the cache, would also be used as the name of the file cache
     * @param [cacheDir] {String} directory for the cache entry
     * @returns {cache} cache instance
     */
    create: function (docId, cacheDir) {
      var obj = Object.create(cache$2);
      obj.load(docId, cacheDir);
      return obj;
    },
    createFromFile: function (filePath) {
      var obj = Object.create(cache$2);
      obj.loadFile(filePath);
      return obj;
    },

    /**
     * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly
     *
     * @method clearCache
     * @param docId {String} the id of the cache, would also be used as the name of the file cache
     * @param cacheDir {String} the directory where the cache file was written
     * @returns {Boolean} true if the cache folder was deleted. False otherwise
     */
    clearCacheById: function (docId, cacheDir) {
      var filePath = cacheDir ? path__default['default'].resolve(cacheDir, docId) : path__default['default'].resolve(__dirname, '../.cache/', docId);
      return del(filePath);
    },

    /**
     * Remove all cache stored in the cache directory
     * @method clearAll
     * @returns {Boolean} true if the cache folder was deleted. False otherwise
     */
    clearAll: function (cacheDir) {
      var filePath = cacheDir ? path__default['default'].resolve(cacheDir) : path__default['default'].resolve(__dirname, '../.cache/');
      return del(filePath);
    }
  };

  var cache$1 = {
    createFromFile: function (filePath, useChecksum) {
      var fname = path__default['default'].basename(filePath);
      var dir = path__default['default'].dirname(filePath);
      return this.create(fname, dir, useChecksum);
    },
    create: function (cacheId, _path, useChecksum) {
      var fs = fs__default['default'];

      var flatCache = cache_1;

      var cache = flatCache.load(cacheId, _path);
      var normalizedEntries = {};

      var removeNotFoundFiles = function removeNotFoundFiles() {
        const cachedEntries = cache.keys(); // remove not found entries

        cachedEntries.forEach(function remover(fPath) {
          try {
            fs.statSync(fPath);
          } catch (err) {
            if (err.code === 'ENOENT') {
              cache.removeKey(fPath);
            }
          }
        });
      };

      removeNotFoundFiles();
      return {
        /**
         * the flat cache storage used to persist the metadata of the `files
         * @type {Object}
         */
        cache: cache,

        /**
         * Given a buffer, calculate md5 hash of its content.
         * @method getHash
         * @param  {Buffer} buffer   buffer to calculate hash on
         * @return {String}          content hash digest
         */
        getHash: function (buffer) {
          return crypto__default['default'].createHash('md5').update(buffer).digest('hex');
        },

        /**
         * Return whether or not a file has changed since last time reconcile was called.
         * @method hasFileChanged
         * @param  {String}  file  the filepath to check
         * @return {Boolean}       wheter or not the file has changed
         */
        hasFileChanged: function (file) {
          return this.getFileDescriptor(file).changed;
        },

        /**
         * given an array of file paths it return and object with three arrays:
         *  - changedFiles: Files that changed since previous run
         *  - notChangedFiles: Files that haven't change
         *  - notFoundFiles: Files that were not found, probably deleted
         *
         * @param  {Array} files the files to analyze and compare to the previous seen files
         * @return {[type]}       [description]
         */
        analyzeFiles: function (files) {
          var me = this;
          files = files || [];
          var res = {
            changedFiles: [],
            notFoundFiles: [],
            notChangedFiles: []
          };
          me.normalizeEntries(files).forEach(function (entry) {
            if (entry.changed) {
              res.changedFiles.push(entry.key);
              return;
            }

            if (entry.notFound) {
              res.notFoundFiles.push(entry.key);
              return;
            }

            res.notChangedFiles.push(entry.key);
          });
          return res;
        },
        getFileDescriptor: function (file) {
          var fstat;

          try {
            fstat = fs.statSync(file);
          } catch (ex) {
            this.removeEntry(file);
            return {
              key: file,
              notFound: true,
              err: ex
            };
          }

          if (useChecksum) {
            return this._getFileDescriptorUsingChecksum(file);
          }

          return this._getFileDescriptorUsingMtimeAndSize(file, fstat);
        },
        _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {
          var meta = cache.getKey(file);
          var cacheExists = !!meta;
          var cSize = fstat.size;
          var cTime = fstat.mtime.getTime();
          var isDifferentDate;
          var isDifferentSize;

          if (!meta) {
            meta = {
              size: cSize,
              mtime: cTime
            };
          } else {
            isDifferentDate = cTime !== meta.mtime;
            isDifferentSize = cSize !== meta.size;
          }

          var nEntry = normalizedEntries[file] = {
            key: file,
            changed: !cacheExists || isDifferentDate || isDifferentSize,
            meta: meta
          };
          return nEntry;
        },
        _getFileDescriptorUsingChecksum: function (file) {
          var meta = cache.getKey(file);
          var cacheExists = !!meta;
          var contentBuffer;

          try {
            contentBuffer = fs.readFileSync(file);
          } catch (ex) {
            contentBuffer = '';
          }

          var isDifferent = true;
          var hash = this.getHash(contentBuffer);

          if (!meta) {
            meta = {
              hash: hash
            };
          } else {
            isDifferent = hash !== meta.hash;
          }

          var nEntry = normalizedEntries[file] = {
            key: file,
            changed: !cacheExists || isDifferent,
            meta: meta
          };
          return nEntry;
        },

        /**
         * Return the list o the files that changed compared
         * against the ones stored in the cache
         *
         * @method getUpdated
         * @param files {Array} the array of files to compare against the ones in the cache
         * @returns {Array}
         */
        getUpdatedFiles: function (files) {
          var me = this;
          files = files || [];
          return me.normalizeEntries(files).filter(function (entry) {
            return entry.changed;
          }).map(function (entry) {
            return entry.key;
          });
        },

        /**
         * return the list of files
         * @method normalizeEntries
         * @param files
         * @returns {*}
         */
        normalizeEntries: function (files) {
          files = files || [];
          var me = this;
          var nEntries = files.map(function (file) {
            return me.getFileDescriptor(file);
          }); //normalizeEntries = nEntries;

          return nEntries;
        },

        /**
         * Remove an entry from the file-entry-cache. Useful to force the file to still be considered
         * modified the next time the process is run
         *
         * @method removeEntry
         * @param entryName
         */
        removeEntry: function (entryName) {
          delete normalizedEntries[entryName];
          cache.removeKey(entryName);
        },

        /**
         * Delete the cache file from the disk
         * @method deleteCacheFile
         */
        deleteCacheFile: function () {
          cache.removeCacheFile();
        },

        /**
         * remove the cache from the file and clear the memory cache
         */
        destroy: function () {
          normalizedEntries = {};
          cache.destroy();
        },
        _getMetaForFileUsingCheckSum: function (cacheEntry) {
          var contentBuffer = fs.readFileSync(cacheEntry.key);
          var hash = this.getHash(contentBuffer);
          var meta = Object.assign(cacheEntry.meta, {
            hash: hash
          });
          delete meta.size;
          delete meta.mtime;
          return meta;
        },
        _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {
          var stat = fs.statSync(cacheEntry.key);
          var meta = Object.assign(cacheEntry.meta, {
            size: stat.size,
            mtime: stat.mtime.getTime()
          });
          delete meta.hash;
          return meta;
        },

        /**
         * Sync the files and persist them to the cache
         * @method reconcile
         */
        reconcile: function (noPrune) {
          removeNotFoundFiles();
          noPrune = typeof noPrune === 'undefined' ? true : noPrune;
          var entries = normalizedEntries;
          var keys = Object.keys(entries);

          if (keys.length === 0) {
            return;
          }

          var me = this;
          keys.forEach(function (entryName) {
            var cacheEntry = entries[entryName];

            try {
              var meta = useChecksum ? me._getMetaForFileUsingCheckSum(cacheEntry) : me._getMetaForFileUsingMtimeAndSize(cacheEntry);
              cache.setKey(entryName, meta);
            } catch (err) {
              // if the file does not exists we don't save it
              // other errors are just thrown
              if (err.code !== 'ENOENT') {
                throw err;
              }
            }
          });
          cache.save(noPrune);
        }
      };
    }
  };

  var name = "stylelint";
  var version = "15.10.1";
  var description = "A mighty CSS linter that helps you avoid errors and enforce conventions.";
  var keywords = [
  	"css-in-js",
  	"css",
  	"less",
  	"lint",
  	"linter",
  	"markdown",
  	"sass",
  	"scss",
  	"stylelint",
  	"sugarss"
  ];
  var homepage = "https://stylelint.io";
  var repository = "stylelint/stylelint";
  var funding = {
  	type: "opencollective",
  	url: "https://opencollective.com/stylelint"
  };
  var license = "MIT";
  var author = "stylelint";
  var main = "lib/index.js";
  var types = "types/stylelint/index.d.ts";
  var bin = {
  	stylelint: "bin/stylelint.mjs"
  };
  var files = [
  	"bin/**/*.js",
  	"bin/**/*.mjs",
  	"lib/**/*.js",
  	"lib/**/*.mjs",
  	"!**/__tests__/**",
  	"!lib/testUtils/**",
  	"types/stylelint/index.d.ts"
  ];
  var scripts = {
  	"benchmark-rule": "node scripts/benchmark-rule.mjs",
  	format: "prettier . --write --cache",
  	lint: "npm-run-all --parallel --continue-on-error lint:*",
  	"lint:formatting": "prettier . --check --cache",
  	"lint:js": "eslint . --cache --max-warnings=0 --ext .js,.mjs",
  	"lint:md": "remark . --quiet --frail",
  	"lint:types": "tsc",
  	prepare: "husky install && patch-package",
  	release: "np --no-release-draft",
  	pretest: "npm run lint",
  	test: "node --experimental-vm-modules node_modules/jest/bin/jest.js",
  	"test-coverage": "npm test --ignore-scripts -- --coverage",
  	"test-only": "npm test --ignore-scripts",
  	version: "changeset version",
  	postversion: "git restore package.json",
  	watch: "npm test --ignore-scripts -- --watch",
  	"changelog-to-github-release": "remark --quiet --use ./scripts/remark-changelog-to-github-release.mjs CHANGELOG.md"
  };
  var prettier = "@stylelint/prettier-config";
  var eslintConfig = {
  	"extends": [
  		"stylelint",
  		"stylelint/jest"
  	],
  	overrides: [
  		{
  			files: [
  				"**/*.mjs"
  			],
  			plugins: [
  				"eslint-plugin-import"
  			],
  			rules: {
  				"import/extensions": [
  					"error",
  					"ignorePackages"
  				]
  			}
  		}
  	],
  	globals: {
  		__dirname: true,
  		module: true,
  		require: true,
  		testRule: true
  	},
  	root: true
  };
  var remarkConfig = {
  	plugins: [
  		"@stylelint/remark-preset"
  	]
  };
  var jest = {
  	clearMocks: true,
  	collectCoverage: false,
  	collectCoverageFrom: [
  		"lib/**/*.{js,mjs}",
  		"!lib/**/{__tests__,testUtils}/**/*.{js,mjs}"
  	],
  	coverageDirectory: "./.coverage/",
  	coverageProvider: "v8",
  	coverageReporters: [
  		"lcov",
  		"text-summary"
  	],
  	coverageThreshold: {
  		global: {
  			branches: 75,
  			functions: 75,
  			lines: 75,
  			statements: 75
  		}
  	},
  	moduleNameMapper: {
  		"^stylelint$": "<rootDir>/lib/index.js",
  		"stylelint/lib/utils/getOsEol": "<rootDir>/lib/utils/getOsEol.js"
  	},
  	preset: "jest-preset-stylelint",
  	roots: [
  		"lib",
  		"system-tests"
  	],
  	testEnvironment: "node",
  	testRegex: ".*\\.test\\.m?js$|rules/.*/__tests__/.*\\.m?js$",
  	watchPlugins: [
  		"jest-watch-typeahead/filename",
  		"jest-watch-typeahead/testname"
  	]
  };
  var dependencies = {
  	"@csstools/css-parser-algorithms": "^2.3.0",
  	"@csstools/css-tokenizer": "^2.1.1",
  	"@csstools/media-query-list-parser": "^2.1.2",
  	"@csstools/selector-specificity": "^3.0.0",
  	"balanced-match": "^2.0.0",
  	colord: "^2.9.3",
  	cosmiconfig: "^8.2.0",
  	"css-functions-list": "^3.1.0",
  	"css-tree": "^2.3.1",
  	debug: "^4.3.4",
  	"fast-glob": "^3.3.0",
  	"fastest-levenshtein": "^1.0.16",
  	"file-entry-cache": "^6.0.1",
  	"global-modules": "^2.0.0",
  	globby: "^11.1.0",
  	globjoin: "^0.1.4",
  	"html-tags": "^3.3.1",
  	ignore: "^5.2.4",
  	"import-lazy": "^4.0.0",
  	imurmurhash: "^0.1.4",
  	"is-plain-object": "^5.0.0",
  	"known-css-properties": "^0.27.0",
  	"mathml-tag-names": "^2.1.3",
  	meow: "^10.1.5",
  	micromatch: "^4.0.5",
  	"normalize-path": "^3.0.0",
  	picocolors: "^1.0.0",
  	postcss: "^8.4.24",
  	"postcss-resolve-nested-selector": "^0.1.1",
  	"postcss-safe-parser": "^6.0.0",
  	"postcss-selector-parser": "^6.0.13",
  	"postcss-value-parser": "^4.2.0",
  	"resolve-from": "^5.0.0",
  	"string-width": "^4.2.3",
  	"strip-ansi": "^6.0.1",
  	"style-search": "^0.1.0",
  	"supports-hyperlinks": "^3.0.0",
  	"svg-tags": "^1.0.0",
  	table: "^6.8.1",
  	"write-file-atomic": "^5.0.1"
  };
  var devDependencies = {
  	"@changesets/cli": "^2.26.2",
  	"@changesets/get-github-info": "^0.5.2",
  	"@jest/globals": "^29.5.0",
  	"@stylelint/prettier-config": "^2.0.0",
  	"@stylelint/remark-preset": "^4.0.0",
  	"@types/balanced-match": "^1.0.2",
  	"@types/css-tree": "^2.3.1",
  	"@types/debug": "^4.1.8",
  	"@types/file-entry-cache": "^5.0.2",
  	"@types/global-modules": "^2.0.0",
  	"@types/globjoin": "^0.1.0",
  	"@types/imurmurhash": "^0.1.1",
  	"@types/micromatch": "^4.0.2",
  	"@types/normalize-path": "^3.0.0",
  	"@types/postcss-less": "^4.0.2",
  	"@types/postcss-resolve-nested-selector": "^0.1.0",
  	"@types/postcss-safe-parser": "^5.0.1",
  	"@types/style-search": "^0.1.3",
  	"@types/svg-tags": "^1.0.0",
  	"@types/write-file-atomic": "^4.0.0",
  	benchmark: "^2.1.4",
  	"common-tags": "^1.8.2",
  	deepmerge: "^4.3.1",
  	eslint: "^8.44.0",
  	"eslint-config-stylelint": "^19.0.0",
  	"eslint-plugin-import": "^2.27.5",
  	"eslint-plugin-jest": "^27.2.2",
  	husky: "^8.0.3",
  	jest: "^29.5.0",
  	"jest-preset-stylelint": "^6.1.0",
  	"jest-watch-typeahead": "^2.2.2",
  	"lint-staged": "^13.2.3",
  	np: "^8.0.4",
  	"npm-run-all": "^4.1.5",
  	"patch-package": "^7.0.0",
  	"postcss-html": "^1.5.0",
  	"postcss-import": "^15.1.0",
  	"postcss-less": "^6.0.0",
  	"postcss-sass": "^0.5.0",
  	"postcss-scss": "^4.0.6",
  	"remark-cli": "^11.0.0",
  	sugarss: "^4.0.1",
  	typescript: "^5.1.6"
  };
  var engines = {
  	node: "^14.13.1 || >=16.0.0"
  };
  var pkg = {
  	name: name,
  	version: version,
  	description: description,
  	keywords: keywords,
  	homepage: homepage,
  	repository: repository,
  	funding: funding,
  	license: license,
  	author: author,
  	main: main,
  	types: types,
  	bin: bin,
  	files: files,
  	scripts: scripts,
  	"lint-staged": {
  	"*.{js,mjs}": "eslint --cache --fix",
  	"*.{js,json,md,mjs,ts,yml}": "prettier --write"
  },
  	prettier: prettier,
  	eslintConfig: eslintConfig,
  	remarkConfig: remarkConfig,
  	jest: jest,
  	dependencies: dependencies,
  	devDependencies: devDependencies,
  	engines: engines
  };

  /**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   */

  var imurmurhash = createCommonjsModule(function (module) {
  (function () {
    var cache; // Call this function without `new` to use the cached object (good for
    // single-threaded environments), or with `new` to create a new object.
    //
    // @param {string} key A UTF-16 or ASCII string
    // @param {number} seed An optional positive integer
    // @return {object} A MurmurHash3 object for incremental hashing

    function MurmurHash3(key, seed) {
      var m = this instanceof MurmurHash3 ? this : cache;
      m.reset(seed);

      if (typeof key === 'string' && key.length > 0) {
        m.hash(key);
      }

      if (m !== this) {
        return m;
      }
    }
    //
    // @param {string} key A UTF-16 or ASCII string
    // @return {object} this

    MurmurHash3.prototype.hash = function (key) {
      var h1, k1, i, top, len;
      len = key.length;
      this.len += len;
      k1 = this.k1;
      i = 0;

      switch (this.rem) {
        case 0:
          k1 ^= len > i ? key.charCodeAt(i++) & 0xffff : 0;

        case 1:
          k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;

        case 2:
          k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;

        case 3:
          k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;
          k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;
      }

      this.rem = len + this.rem & 3; // & 3 is same as % 4

      len -= this.rem;

      if (len > 0) {
        h1 = this.h1;

        while (1) {
          k1 = k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000 & 0xffffffff;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000 & 0xffffffff;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = h1 * 5 + 0xe6546b64 & 0xffffffff;

          if (i >= len) {
            break;
          }

          k1 = key.charCodeAt(i++) & 0xffff ^ (key.charCodeAt(i++) & 0xffff) << 8 ^ (key.charCodeAt(i++) & 0xffff) << 16;
          top = key.charCodeAt(i++);
          k1 ^= (top & 0xff) << 24 ^ (top & 0xff00) >> 8;
        }

        k1 = 0;

        switch (this.rem) {
          case 3:
            k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;

          case 2:
            k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;

          case 1:
            k1 ^= key.charCodeAt(i) & 0xffff;
        }

        this.h1 = h1;
      }

      this.k1 = k1;
      return this;
    }; // Get the result of this hash
    //
    // @return {number} The 32-bit hash


    MurmurHash3.prototype.result = function () {
      var k1, h1;
      k1 = this.k1;
      h1 = this.h1;

      if (k1 > 0) {
        k1 = k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000 & 0xffffffff;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000 & 0xffffffff;
        h1 ^= k1;
      }

      h1 ^= this.len;
      h1 ^= h1 >>> 16;
      h1 = h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000 & 0xffffffff;
      h1 ^= h1 >>> 13;
      h1 = h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000 & 0xffffffff;
      h1 ^= h1 >>> 16;
      return h1 >>> 0;
    }; // Reset the hash object for reuse
    //
    // @param {number} seed An optional positive integer


    MurmurHash3.prototype.reset = function (seed) {
      this.h1 = typeof seed === 'number' ? seed : 0;
      this.rem = this.k1 = this.len = 0;
      return this;
    }; // A cached object to use. This can be safely used if you're in a single-
    // threaded environment, otherwise you need to create new hashes to use.


    cache = new MurmurHash3();

    {
      module.exports = MurmurHash3;
    }
  })();
  });

  /**
   * hash the given string
   * @param  {string} str the string to hash
   * @returns {string} the hash
   */


  var hash = function hash(str) {
    return imurmurhash(str).result().toString(36);
  };

  /**
   * Return the cacheFile to be used by stylelint, based on whether the provided parameter is
   * a directory or looks like a directory (ends in `path.sep`), in which case the file
   * name will be `cacheFile/.cache_hashOfCWD`.
   *
   * If cacheFile points to a file or looks like a file, then it will just use that file.
   *
   * @param {string} cacheFile - The name of file to be used to store the cache
   * @param {string} cwd - Current working directory. Used for tests
   * @returns {string} Resolved path to the cache file
   */


  var getCacheFile = function getCacheFile(cacheFile, cwd) {
    /*
     * Make sure path separators are normalized for environment/os.
     * Also, keep trailing path separator if present.
     */
    cacheFile = path__default['default'].normalize(cacheFile);
    const resolvedCacheFile = path__default['default'].resolve(cwd, cacheFile); // If the last character passed is a path separator, we assume is a directory.

    const looksLikeADirectory = cacheFile[cacheFile.length - 1] === path__default['default'].sep;
    /**
     * Return the default cache file name when provided parameter is a directory.
     * @returns {string} - Resolved path to the cacheFile
     */

    function getCacheFileForDirectory() {
      return path__default['default'].join(resolvedCacheFile, `.stylelintcache_${hash(cwd)}`);
    }

    let fileStats;

    try {
      fileStats = fs__default['default'].lstatSync(resolvedCacheFile);
    } catch {
      fileStats = null;
    }

    if (looksLikeADirectory || fileStats && fileStats.isDirectory()) {
      // Return path to provided directory with generated file name.
      return getCacheFileForDirectory();
    } // Return normalized path to cache file.


    return resolvedCacheFile;
  };

  const DEFAULT_CACHE_LOCATION$1 = './.stylelintcache';
  const CACHE_STRATEGY_METADATA$1 = 'metadata';
  const CACHE_STRATEGY_CONTENT$1 = 'content';
  const DEFAULT_CACHE_STRATEGY$1 = CACHE_STRATEGY_METADATA$1;
  const DEFAULT_IGNORE_FILENAME$1 = '.stylelintignore';
  const DEFAULT_FORMATTER = 'string';
  const EXIT_CODE_ERROR = 2;
  var constants$3 = {
    DEFAULT_CACHE_LOCATION: DEFAULT_CACHE_LOCATION$1,
    CACHE_STRATEGY_METADATA: CACHE_STRATEGY_METADATA$1,
    CACHE_STRATEGY_CONTENT: CACHE_STRATEGY_CONTENT$1,
    DEFAULT_CACHE_STRATEGY: DEFAULT_CACHE_STRATEGY$1,
    DEFAULT_IGNORE_FILENAME: DEFAULT_IGNORE_FILENAME$1,
    DEFAULT_FORMATTER,
    EXIT_CODE_ERROR
  };

  const debug$1 = src$1('stylelint:file-cache');











  const {
    DEFAULT_CACHE_LOCATION,
    CACHE_STRATEGY_METADATA,
    CACHE_STRATEGY_CONTENT,
    DEFAULT_CACHE_STRATEGY
  } = constants$3;
  /** @typedef {import('file-entry-cache').FileDescriptor["meta"] & { hashOfConfig?: string }} CacheMetadata */


  class FileCache {
    constructor(cacheLocation = DEFAULT_CACHE_LOCATION, cacheStrategy = DEFAULT_CACHE_STRATEGY, cwd = process.cwd()) {
      if (![CACHE_STRATEGY_METADATA, CACHE_STRATEGY_CONTENT].includes(cacheStrategy)) {
        throw new Error(`"${cacheStrategy}" cache strategy is unsupported. Specify either "${CACHE_STRATEGY_METADATA}" or "${CACHE_STRATEGY_CONTENT}"`);
      }

      const cacheFile = path__default['default'].resolve(getCacheFile(cacheLocation, cwd));
      const useCheckSum = cacheStrategy === CACHE_STRATEGY_CONTENT;
      debug$1(`Cache file is created at ${cacheFile}`);
      this._fileCache = cache$1.create(cacheFile, undefined, useCheckSum);
      this._hashOfConfig = '';
    }
    /**
     * @param {import('stylelint').Config} config
     */


    calcHashOfConfig(config) {
      if (this._hashOfConfig) return;
      const stylelintVersion = pkg.version;
      const configString = JSON.stringify(config || {});
      this._hashOfConfig = hash(`${stylelintVersion}_${configString}`);
    }
    /**
     * @param {string} absoluteFilepath
     * @return {boolean}
     */


    hasFileChanged(absoluteFilepath) {
      // Get file descriptor compares current metadata against cached
      // one and stores the result to "changed" prop.w
      const descriptor = this._fileCache.getFileDescriptor(absoluteFilepath);
      /** @type {CacheMetadata} */


      const meta = descriptor.meta || {};
      const changed = descriptor.changed || meta.hashOfConfig !== this._hashOfConfig;

      if (!changed) {
        debug$1(`Skip linting ${absoluteFilepath}. File hasn't changed.`);
      } // Mutate file descriptor object and store config hash to each file.
      // Running lint with different config should invalidate the cache.


      if (meta.hashOfConfig !== this._hashOfConfig) {
        meta.hashOfConfig = this._hashOfConfig;
      }

      return changed;
    }

    reconcile() {
      this._fileCache.reconcile();
    }

    destroy() {
      this._fileCache.destroy();
    }
    /**
     * @param {string} absoluteFilepath
     */


    removeEntry(absoluteFilepath) {
      this._fileCache.removeEntry(absoluteFilepath);
    }

  }

  var FileCache_1 = FileCache;

  const {
    cosmiconfig: cosmiconfig$1,
    defaultLoadersSync: defaultLoadersSync$1
  } = dist;
  const STOP_DIR$1 = undefined;
  /**
   * @type {import('stylelint')['_createLinter']}
   */

  var createStylelint = function createStylelint(options = {}) {
    const cwd = options.cwd || process.cwd();
    return {
      _options: { ...options,
        cwd
      },
      _extendExplorer: cosmiconfig$1('', {
        transform: augmentConfig.augmentConfigExtended(cwd),
        loaders: {
          '.cjs': (cjsPath, cjsContent) => Promise.resolve(defaultLoadersSync$1['.cjs'](cjsPath, cjsContent)),
          '.js': (jsPath, cjsContent) => Promise.resolve(defaultLoadersSync$1['.js'](jsPath, cjsContent))
        },
        stopDir: STOP_DIR$1
      }),
      _specifiedConfigCache: new Map(),
      _postcssResultCache: new Map(),
      _fileCache: new FileCache_1(options.cacheLocation, options.cacheStrategy, cwd)
    };
  };

  /** @typedef {import('stylelint').LintResult} LintResult */

  /** @typedef {LintResult['parseErrors'][0]} ParseError */

  /** @typedef {LintResult['warnings'][0]} Warning */

  /** @typedef {Warning['severity']} Severity */

  /**
   * Preprocess warnings in a given lint result.
   * Note that this function has a side-effect.
   *
   * @param {LintResult} result
   * @returns {LintResult}
   */

  var preprocessWarnings = function preprocessWarnings(result) {
    for (const error of result.parseErrors || []) {
      result.warnings.push(parseErrorToWarning(error));
    }

    for (const warning of result.warnings) {
      warning.severity = normalizeSeverity(warning);
    }

    result.warnings.sort(byLocationOrder);
    return result;
  };
  /**
   * @param {ParseError} error
   * @returns {Warning}
   */


  function parseErrorToWarning(error) {
    return {
      line: error.line,
      column: error.column,
      rule: error.stylelintType,
      severity: 'error',
      text: `${error.text} (${error.stylelintType})`
    };
  }
  /**
   * @param {Warning} warning
   * @returns {Severity}
   */


  function normalizeSeverity(warning) {
    // NOTE: Plugins may add a warning without severity, for example,
    // by directly using the PostCSS `Result#warn()` API.
    return warning.severity || 'error';
  }
  /**
   * @param {Warning} a
   * @param {Warning} b
   * @returns {number}
   */


  function byLocationOrder(a, b) {
    // positionless first
    if (!a.line && b.line) return -1; // positionless first

    if (a.line && !b.line) return 1;
    if (a.line < b.line) return -1;
    if (a.line > b.line) return 1;
    if (a.column < b.column) return -1;
    if (a.column > b.column) return 1;
    return 0;
  }

  /**
   * @type {import('stylelint').Formatter}
   */


  var compactFormatter = function compactFormatter(results) {
    return results.flatMap(result => {
      const {
        warnings
      } = preprocessWarnings(result);
      return warnings.map(warning => `${result.source}: ` + `line ${warning.line}, ` + `col ${warning.column}, ` + `${warning.severity} - ` + `${warning.text}`);
    }).join('\n');
  };

  /**
   * @see https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions
   *
   * @type {import('stylelint').Formatter}
   */


  var githubFormatter = function githubFormatter(results, returnValue) {
    const title = 'Stylelint problem';
    const metadata = returnValue.ruleMetadata;
    const lines = results.flatMap(result => {
      const {
        source,
        warnings
      } = preprocessWarnings(result);
      return warnings.map(({
        line,
        column,
        endLine,
        endColumn,
        text,
        severity,
        rule
      }) => {
        const msg = buildMessage(text, metadata[rule]);
        return endLine === undefined ? `::${severity} file=${source},line=${line},col=${column},title=${title}::${msg}` : `::${severity} file=${source},line=${line},col=${column},endLine=${endLine},endColumn=${endColumn},title=${title}::${msg}`;
      });
    });
    lines.push('');
    return lines.join('\n');
  };
  /**
   * @param {string} msg
   * @param {Partial<import('stylelint').RuleMeta> | undefined} metadata
   * @returns {string}
   */


  function buildMessage(msg, metadata) {
    if (!metadata) return msg;
    const url = metadata.url ? ` - ${metadata.url}` : '';
    let additional = [metadata.fixable ? 'maybe fixable' : '', metadata.deprecated ? 'deprecated' : ''].filter(Boolean).join(', ');
    additional = additional ? ` [${additional}]` : '';
    return `${msg}${additional}${url}`;
  }

  /**
   * Omit any properties starting with `_`, which are fake-private
   *
   * @type {import('stylelint').Formatter}
   */

  var jsonFormatter = function jsonFormatter(results) {
    const cleanedResults = results.map(result => Object.entries(result).filter(([key]) => !key.startsWith('_')).reduce((
    /** @type {{ [key: string]: any }} */
    obj, [key, value]) => {
      obj[key] = value;
      return obj;
    }, {}));
    return JSON.stringify(cleanedResults);
  };

  var ansiRegex = ({
    onlyFirst = false
  } = {}) => {
    const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
  };

  var stripAnsi$1 = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;

  /* eslint-disable yoda */

  const isFullwidthCodePoint = codePoint => {
    if (Number.isNaN(codePoint)) {
      return false;
    } // Code points are derived from:
    // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


    if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
    codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
    // CJK Radicals Supplement .. Enclosed CJK Letters and Months
    0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
    0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
    0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
    0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
    0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
    0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
    0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
    0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
    0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
    0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
    0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
    0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
      return true;
    }

    return false;
  };

  var isFullwidthCodePoint_1 = isFullwidthCodePoint;
  var _default$E = isFullwidthCodePoint;
  isFullwidthCodePoint_1.default = _default$E;

  var emojiRegex = function () {
    // https://mths.be/emoji
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };

  const stringWidth$1 = string => {
    if (typeof string !== 'string' || string.length === 0) {
      return 0;
    }

    string = stripAnsi$1(string);

    if (string.length === 0) {
      return 0;
    }

    string = string.replace(emojiRegex(), '  ');
    let width = 0;

    for (let i = 0; i < string.length; i++) {
      const code = string.codePointAt(i); // Ignore control characters

      if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
        continue;
      } // Ignore combining characters


      if (code >= 0x300 && code <= 0x36F) {
        continue;
      } // Surrogates


      if (code > 0xFFFF) {
        i++;
      }

      width += isFullwidthCodePoint_1(code) ? 2 : 1;
    }

    return width;
  };

  var stringWidth_1$1 = stringWidth$1; // TODO: remove this in the next major version

  var _default$D = stringWidth$1;
  stringWidth_1$1.default = _default$D;

  var stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;

  const stringWidth = string => {
    if (typeof string !== 'string' || string.length === 0) {
      return 0;
    }

    string = stripAnsi(string);

    if (string.length === 0) {
      return 0;
    }

    string = string.replace(emojiRegex(), '  ');
    let width = 0;

    for (let i = 0; i < string.length; i++) {
      const code = string.codePointAt(i); // Ignore control characters

      if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
        continue;
      } // Ignore combining characters


      if (code >= 0x300 && code <= 0x36F) {
        continue;
      } // Surrogates


      if (code > 0xFFFF) {
        i++;
      }

      width += isFullwidthCodePoint_1(code) ? 2 : 1;
    }

    return width;
  };

  var stringWidth_1 = stringWidth; // TODO: remove this in the next major version

  var _default$C = stringWidth;
  stringWidth_1.default = _default$C;

  const regex = '[\uD800-\uDBFF][\uDC00-\uDFFF]';

  const astralRegex = options => options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, 'g');

  var astralRegex_1 = astralRegex;

  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  /* MIT license */

  /* eslint-disable no-mixed-operators */
   // NOTE: conversions should only return primitive values (i.e. arrays, or
  //       values that give correct `typeof` results).
  //       do not use box values types (i.e. Number(), String(), etc.)


  const reverseKeywords = {};

  for (const key of Object.keys(colorName)) {
    reverseKeywords[colorName[key]] = key;
  }

  const convert$1 = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  };
  var conversions = convert$1; // Hide .channels and .labels properties

  for (const model of Object.keys(convert$1)) {
    if (!('channels' in convert$1[model])) {
      throw new Error('missing channels property: ' + model);
    }

    if (!('labels' in convert$1[model])) {
      throw new Error('missing channel labels property: ' + model);
    }

    if (convert$1[model].labels.length !== convert$1[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model);
    }

    const {
      channels,
      labels
    } = convert$1[model];
    delete convert$1[model].channels;
    delete convert$1[model].labels;
    Object.defineProperty(convert$1[model], 'channels', {
      value: channels
    });
    Object.defineProperty(convert$1[model], 'labels', {
      value: labels
    });
  }

  convert$1.rgb.hsl = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    const l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  convert$1.rgb.hsv = function (rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);

    const diffc = function (c) {
      return (v - c) / 6 / diff + 1 / 2;
    };

    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);

      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }

      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }

    return [h * 360, s * 100, v * 100];
  };

  convert$1.rgb.hwb = function (rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert$1.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };

  convert$1.rgb.cmyk = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };

  function comparativeDistance(x, y) {
    /*
    	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
    */
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }

  convert$1.rgb.keyword = function (rgb) {
    const reversed = reverseKeywords[rgb];

    if (reversed) {
      return reversed;
    }

    let currentClosestDistance = Infinity;
    let currentClosestKeyword;

    for (const keyword of Object.keys(colorName)) {
      const value = colorName[keyword]; // Compute comparative distance

      const distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }

    return currentClosestKeyword;
  };

  convert$1.keyword.rgb = function (keyword) {
    return colorName[keyword];
  };

  convert$1.rgb.xyz = function (rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255; // Assume sRGB

    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };

  convert$1.rgb.lab = function (rgb) {
    const xyz = convert$1.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };

  convert$1.hsl.rgb = function (hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;

    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }

    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];

    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);

      if (t3 < 0) {
        t3++;
      }

      if (t3 > 1) {
        t3--;
      }

      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }

      rgb[i] = val * 255;
    }

    return rgb;
  };

  convert$1.hsl.hsv = function (hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };

  convert$1.hsv.rgb = function (hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;

    switch (hi) {
      case 0:
        return [v, t, p];

      case 1:
        return [q, v, p];

      case 2:
        return [p, v, t];

      case 3:
        return [p, q, v];

      case 4:
        return [t, p, v];

      case 5:
        return [v, p, q];
    }
  };

  convert$1.hsv.hsl = function (hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


  convert$1.hwb.rgb = function (hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f; // Wh + bl cant be > 1

    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;

    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }

    const n = wh + f * (v - wh); // Linear interpolation

    let r;
    let g;
    let b;
    /* eslint-disable max-statements-per-line,no-multi-spaces */

    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;

      case 1:
        r = n;
        g = v;
        b = wh;
        break;

      case 2:
        r = wh;
        g = v;
        b = n;
        break;

      case 3:
        r = wh;
        g = n;
        b = v;
        break;

      case 4:
        r = n;
        g = wh;
        b = v;
        break;

      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    /* eslint-enable max-statements-per-line,no-multi-spaces */


    return [r * 255, g * 255, b * 255];
  };

  convert$1.cmyk.rgb = function (cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };

  convert$1.xyz.rgb = function (xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570; // Assume sRGB

    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };

  convert$1.xyz.lab = function (xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };

  convert$1.lab.xyz = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };

  convert$1.lab.lch = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;

    if (h < 0) {
      h += 360;
    }

    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };

  convert$1.lch.lab = function (lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };

  convert$1.rgb.ansi16 = function (args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

    value = Math.round(value / 50);

    if (value === 0) {
      return 30;
    }

    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

    if (value === 2) {
      ansi += 60;
    }

    return ansi;
  };

  convert$1.hsv.ansi16 = function (args) {
    // Optimization here; we already know the value and don't need to get
    // it converted for us.
    return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
  };

  convert$1.rgb.ansi256 = function (args) {
    const r = args[0];
    const g = args[1];
    const b = args[2]; // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.

    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }

      if (r > 248) {
        return 231;
      }

      return Math.round((r - 8) / 247 * 24) + 232;
    }

    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };

  convert$1.ansi16.rgb = function (args) {
    let color = args % 10; // Handle greyscale

    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }

      color = color / 10.5 * 255;
      return [color, color, color];
    }

    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };

  convert$1.ansi256.rgb = function (args) {
    // Handle greyscale
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }

    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };

  convert$1.rgb.hex = function (args) {
    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert$1.hex.rgb = function (args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

    if (!match) {
      return [0, 0, 0];
    }

    let colorString = match[0];

    if (match[0].length === 3) {
      colorString = colorString.split('').map(char => {
        return char + char;
      }).join('');
    }

    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 0xFF;
    const g = integer >> 8 & 0xFF;
    const b = integer & 0xFF;
    return [r, g, b];
  };

  convert$1.rgb.hcg = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;

    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }

    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }

    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };

  convert$1.hsl.hcg = function (hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    let f = 0;

    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }

    return [hsl[0], c * 100, f * 100];
  };

  convert$1.hsv.hcg = function (hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;

    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }

    return [hsv[0], c * 100, f * 100];
  };

  convert$1.hcg.rgb = function (hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;

    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }

    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    /* eslint-disable max-statements-per-line */

    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;

      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;

      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;

      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;

      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;

      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    /* eslint-enable max-statements-per-line */


    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };

  convert$1.hcg.hsv = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    let f = 0;

    if (v > 0.0) {
      f = c / v;
    }

    return [hcg[0], f * 100, v * 100];
  };

  convert$1.hcg.hsl = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1.0 - c) + 0.5 * c;
    let s = 0;

    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }

    return [hcg[0], s * 100, l * 100];
  };

  convert$1.hcg.hwb = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  convert$1.hwb.hcg = function (hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;

    if (c < 1) {
      g = (v - c) / (1 - c);
    }

    return [hwb[0], c * 100, g * 100];
  };

  convert$1.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };

  convert$1.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };

  convert$1.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  convert$1.gray.hsl = function (args) {
    return [0, 0, args[0]];
  };

  convert$1.gray.hsv = convert$1.gray.hsl;

  convert$1.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };

  convert$1.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };

  convert$1.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };

  convert$1.gray.hex = function (gray) {
    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert$1.rgb.gray = function (rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };

  /*
  	This function routes a model to all other models.

  	all functions that are routed have a property `.conversion` attached
  	to the returned synthetic function. This property is an array
  	of strings, each with the steps in between the 'from' and 'to'
  	color models (inclusive).

  	conversions that are not possible simply are not included.
  */


  function buildGraph() {
    const graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

    const models = Object.keys(conversions);

    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }

    return graph;
  } // https://en.wikipedia.org/wiki/Breadth-first_search


  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel]; // Unshift -> queue -> pop

    graph[fromModel].distance = 0;

    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);

      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  var route = function (fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);

    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];

      if (node.parent === null) {
        // No possible conversion, or this node is the source model.
        continue;
      }

      conversion[toModel] = wrapConversion(toModel, graph);
    }

    return conversion;
  };

  const convert = {};
  const models = Object.keys(conversions);

  function wrapRaw(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];

      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }

      if (arg0.length > 1) {
        args = arg0;
      }

      return fn(args);
    }; // Preserve .conversion property if there is one


    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];

      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }

      if (arg0.length > 1) {
        args = arg0;
      }

      const result = fn(args); // We're assuming the result is an array here.
      // see notice in conversions.js; don't use box types
      // in conversion functions.

      if (typeof result === 'object') {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    }; // Preserve .conversion property if there is one


    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models.forEach(fromModel => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: conversions[fromModel].labels
    });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach(toModel => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert;

  var ansiStyles = createCommonjsModule(function (module) {

  const wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\u001B[${code + offset}m`;
  };

  const wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\u001B[${38 + offset};5;${code}m`;
  };

  const wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };

  const ansi2ansi = n => n;

  const rgb2rgb = (r, g, b) => [r, g, b];

  const setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  /** @type {typeof import('color-convert')} */


  let colorConvert$1;

  const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert$1 === undefined) {
      colorConvert$1 = colorConvert;
    }

    const offset = isBackground ? 10 : 0;
    const styles = {};

    for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
      const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;

      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === 'object') {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }

    return styles;
  };

  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    }; // Alias bright black as gray (and grey)

    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\u001B[${style[0]}m`,
          close: `\u001B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }

      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }

    Object.defineProperty(styles, 'codes', {
      value: codes,
      enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
    setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
    setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
    setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
    setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
    setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
    return styles;
  } // Make the export immutable


  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
  });

  const ESCAPES = ['\u001B', '\u009B'];

  const wrapAnsi = code => `${ESCAPES[0]}[${code}m`;

  const checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
    let output = [];
    ansiCodes = [...ansiCodes];

    for (let ansiCode of ansiCodes) {
      const ansiCodeOrigin = ansiCode;

      if (ansiCode.includes(';')) {
        ansiCode = ansiCode.split(';')[0][0] + '0';
      }

      const item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));

      if (item) {
        const indexEscape = ansiCodes.indexOf(item.toString());

        if (indexEscape === -1) {
          output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
        } else {
          ansiCodes.splice(indexEscape, 1);
        }
      } else if (isEscapes) {
        output.push(wrapAnsi(0));
        break;
      } else {
        output.push(wrapAnsi(ansiCodeOrigin));
      }
    }

    if (isEscapes) {
      output = output.filter((element, index) => output.indexOf(element) === index);

      if (endAnsiCode !== undefined) {
        const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));
        output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
      }
    }

    return output.join('');
  };

  var sliceAnsi = (string, begin, end) => {
    const characters = [...string];
    const ansiCodes = [];
    let stringEnd = typeof end === 'number' ? end : characters.length;
    let isInsideEscape = false;
    let ansiCode;
    let visible = 0;
    let output = '';

    for (const [index, character] of characters.entries()) {
      let leftEscape = false;

      if (ESCAPES.includes(character)) {
        const code = /\d[^m]*/.exec(string.slice(index, index + 18));
        ansiCode = code && code.length > 0 ? code[0] : undefined;

        if (visible < stringEnd) {
          isInsideEscape = true;

          if (ansiCode !== undefined) {
            ansiCodes.push(ansiCode);
          }
        }
      } else if (isInsideEscape && character === 'm') {
        isInsideEscape = false;
        leftEscape = true;
      }

      if (!isInsideEscape && !leftEscape) {
        visible++;
      }

      if (!astralRegex_1({
        exact: true
      }).test(character) && isFullwidthCodePoint_1(character.codePointAt())) {
        visible++;

        if (typeof end !== 'number') {
          stringEnd++;
        }
      }

      if (visible > begin && visible <= stringEnd) {
        output += character;
      } else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {
        output = checkAnsi(ansiCodes);
      } else if (visible >= stringEnd) {
        output += checkAnsi(ansiCodes, true, ansiCode);
        break;
      }
    }

    return output;
  };

  var getBorderCharacters_1 = createCommonjsModule(function (module, exports) {
  /* eslint-disable sort-keys-fix/sort-keys-fix */

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getBorderCharacters = void 0;

  const getBorderCharacters = name => {
    if (name === 'honeywell') {
      return {
        topBody: '═',
        topJoin: '╤',
        topLeft: '╔',
        topRight: '╗',
        bottomBody: '═',
        bottomJoin: '╧',
        bottomLeft: '╚',
        bottomRight: '╝',
        bodyLeft: '║',
        bodyRight: '║',
        bodyJoin: '│',
        headerJoin: '┬',
        joinBody: '─',
        joinLeft: '╟',
        joinRight: '╢',
        joinJoin: '┼',
        joinMiddleDown: '┬',
        joinMiddleUp: '┴',
        joinMiddleLeft: '┤',
        joinMiddleRight: '├'
      };
    }

    if (name === 'norc') {
      return {
        topBody: '─',
        topJoin: '┬',
        topLeft: '┌',
        topRight: '┐',
        bottomBody: '─',
        bottomJoin: '┴',
        bottomLeft: '└',
        bottomRight: '┘',
        bodyLeft: '│',
        bodyRight: '│',
        bodyJoin: '│',
        headerJoin: '┬',
        joinBody: '─',
        joinLeft: '├',
        joinRight: '┤',
        joinJoin: '┼',
        joinMiddleDown: '┬',
        joinMiddleUp: '┴',
        joinMiddleLeft: '┤',
        joinMiddleRight: '├'
      };
    }

    if (name === 'ramac') {
      return {
        topBody: '-',
        topJoin: '+',
        topLeft: '+',
        topRight: '+',
        bottomBody: '-',
        bottomJoin: '+',
        bottomLeft: '+',
        bottomRight: '+',
        bodyLeft: '|',
        bodyRight: '|',
        bodyJoin: '|',
        headerJoin: '+',
        joinBody: '-',
        joinLeft: '|',
        joinRight: '|',
        joinJoin: '|',
        joinMiddleDown: '+',
        joinMiddleUp: '+',
        joinMiddleLeft: '+',
        joinMiddleRight: '+'
      };
    }

    if (name === 'void') {
      return {
        topBody: '',
        topJoin: '',
        topLeft: '',
        topRight: '',
        bottomBody: '',
        bottomJoin: '',
        bottomLeft: '',
        bottomRight: '',
        bodyLeft: '',
        bodyRight: '',
        bodyJoin: '',
        headerJoin: '',
        joinBody: '',
        joinLeft: '',
        joinRight: '',
        joinJoin: '',
        joinMiddleDown: '',
        joinMiddleUp: '',
        joinMiddleLeft: '',
        joinMiddleRight: ''
      };
    }

    throw new Error('Unknown border template "' + name + '".');
  };

  exports.getBorderCharacters = getBorderCharacters;
  });

  var utils$5 = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isCellInRange = exports.areCellEqual = exports.calculateRangeCoordinate = exports.findOriginalRowIndex = exports.flatten = exports.extractTruncates = exports.sumArray = exports.sequence = exports.distributeUnevenly = exports.countSpaceSequence = exports.groupBySizes = exports.makeBorderConfig = exports.splitAnsi = exports.normalizeString = void 0;

  const slice_ansi_1 = __importDefault(sliceAnsi);

  const string_width_1 = __importDefault(stringWidth_1);

  const strip_ansi_1 = __importDefault(stripAnsi);


  /**
   * Converts Windows-style newline to Unix-style
   *
   * @internal
   */


  const normalizeString = input => {
    return input.replace(/\r\n/g, '\n');
  };

  exports.normalizeString = normalizeString;
  /**
   * Splits ansi string by newlines
   *
   * @internal
   */

  const splitAnsi = input => {
    const lengths = (0, strip_ansi_1.default)(input).split('\n').map(string_width_1.default);
    const result = [];
    let startIndex = 0;
    lengths.forEach(length => {
      result.push(length === 0 ? '' : (0, slice_ansi_1.default)(input, startIndex, startIndex + length)); // Plus 1 for the newline character itself

      startIndex += length + 1;
    });
    return result;
  };

  exports.splitAnsi = splitAnsi;
  /**
   * Merges user provided border characters with the default border ("honeywell") characters.
   *
   * @internal
   */

  const makeBorderConfig = border => {
    return { ...(0, getBorderCharacters_1.getBorderCharacters)('honeywell'),
      ...border
    };
  };

  exports.makeBorderConfig = makeBorderConfig;
  /**
   * Groups the array into sub-arrays by sizes.
   *
   * @internal
   * @example
   * groupBySizes(['a', 'b', 'c', 'd', 'e'], [2, 1, 2]) = [ ['a', 'b'], ['c'], ['d', 'e'] ]
   */

  const groupBySizes = (array, sizes) => {
    let startIndex = 0;
    return sizes.map(size => {
      const group = array.slice(startIndex, startIndex + size);
      startIndex += size;
      return group;
    });
  };

  exports.groupBySizes = groupBySizes;
  /**
   * Counts the number of continuous spaces in a string
   *
   * @internal
   * @example
   * countGroupSpaces('a  bc  de f') = 3
   */

  const countSpaceSequence = input => {
    var _a, _b;

    return (_b = (_a = input.match(/\s+/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
  };

  exports.countSpaceSequence = countSpaceSequence;
  /**
   * Creates the non-increasing number array given sum and length
   * whose the difference between maximum and minimum is not greater than 1
   *
   * @internal
   * @example
   * distributeUnevenly(6, 3) = [2, 2, 2]
   * distributeUnevenly(8, 3) = [3, 3, 2]
   */

  const distributeUnevenly = (sum, length) => {
    const result = Array.from({
      length
    }).fill(Math.floor(sum / length));
    return result.map((element, index) => {
      return element + (index < sum % length ? 1 : 0);
    });
  };

  exports.distributeUnevenly = distributeUnevenly;

  const sequence = (start, end) => {
    return Array.from({
      length: end - start + 1
    }, (_, index) => {
      return index + start;
    });
  };

  exports.sequence = sequence;

  const sumArray = array => {
    return array.reduce((accumulator, element) => {
      return accumulator + element;
    }, 0);
  };

  exports.sumArray = sumArray;

  const extractTruncates = config => {
    return config.columns.map(({
      truncate
    }) => {
      return truncate;
    });
  };

  exports.extractTruncates = extractTruncates;

  const flatten = array => {
    return [].concat(...array);
  };

  exports.flatten = flatten;

  const findOriginalRowIndex = (mappedRowHeights, mappedRowIndex) => {
    const rowIndexMapping = (0, exports.flatten)(mappedRowHeights.map((height, index) => {
      return Array.from({
        length: height
      }, () => {
        return index;
      });
    }));
    return rowIndexMapping[mappedRowIndex];
  };

  exports.findOriginalRowIndex = findOriginalRowIndex;

  const calculateRangeCoordinate = spanningCellConfig => {
    const {
      row,
      col,
      colSpan = 1,
      rowSpan = 1
    } = spanningCellConfig;
    return {
      bottomRight: {
        col: col + colSpan - 1,
        row: row + rowSpan - 1
      },
      topLeft: {
        col,
        row
      }
    };
  };

  exports.calculateRangeCoordinate = calculateRangeCoordinate;

  const areCellEqual = (cell1, cell2) => {
    return cell1.row === cell2.row && cell1.col === cell2.col;
  };

  exports.areCellEqual = areCellEqual;

  const isCellInRange = (cell, {
    topLeft,
    bottomRight
  }) => {
    return topLeft.row <= cell.row && cell.row <= bottomRight.row && topLeft.col <= cell.col && cell.col <= bottomRight.col;
  };

  exports.isCellInRange = isCellInRange;
  });

  var alignString_1 = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.alignString = void 0;

  const string_width_1 = __importDefault(stringWidth_1);



  const alignLeft = (subject, width) => {
    return subject + ' '.repeat(width);
  };

  const alignRight = (subject, width) => {
    return ' '.repeat(width) + subject;
  };

  const alignCenter = (subject, width) => {
    return ' '.repeat(Math.floor(width / 2)) + subject + ' '.repeat(Math.ceil(width / 2));
  };

  const alignJustify = (subject, width) => {
    const spaceSequenceCount = (0, utils$5.countSpaceSequence)(subject);

    if (spaceSequenceCount === 0) {
      return alignLeft(subject, width);
    }

    const addingSpaces = (0, utils$5.distributeUnevenly)(width, spaceSequenceCount);

    if (Math.max(...addingSpaces) > 3) {
      return alignLeft(subject, width);
    }

    let spaceSequenceIndex = 0;
    return subject.replace(/\s+/g, groupSpace => {
      return groupSpace + ' '.repeat(addingSpaces[spaceSequenceIndex++]);
    });
  };
  /**
   * Pads a string to the left and/or right to position the subject
   * text in a desired alignment within a container.
   */


  const alignString = (subject, containerWidth, alignment) => {
    const subjectWidth = (0, string_width_1.default)(subject);

    if (subjectWidth === containerWidth) {
      return subject;
    }

    if (subjectWidth > containerWidth) {
      throw new Error('Subject parameter value width cannot be greater than the container width.');
    }

    if (subjectWidth === 0) {
      return ' '.repeat(containerWidth);
    }

    const availableWidth = containerWidth - subjectWidth;

    if (alignment === 'left') {
      return alignLeft(subject, availableWidth);
    }

    if (alignment === 'right') {
      return alignRight(subject, availableWidth);
    }

    if (alignment === 'justify') {
      return alignJustify(subject, availableWidth);
    }

    return alignCenter(subject, availableWidth);
  };

  exports.alignString = alignString;
  });

  var alignTableData_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.alignTableData = void 0;



  const alignTableData = (rows, config) => {
    return rows.map((row, rowIndex) => {
      return row.map((cell, cellIndex) => {
        var _a;

        const {
          width,
          alignment
        } = config.columns[cellIndex];
        const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({
          col: cellIndex,
          row: rowIndex
        }, {
          mapped: true
        });

        if (containingRange) {
          return cell;
        }

        return (0, alignString_1.alignString)(cell, width, alignment);
      });
    });
  };

  exports.alignTableData = alignTableData;
  });

  var wrapString_1 = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.wrapString = void 0;

  const slice_ansi_1 = __importDefault(sliceAnsi);

  const string_width_1 = __importDefault(stringWidth_1);
  /**
   * Creates an array of strings split into groups the length of size.
   * This function works with strings that contain ASCII characters.
   *
   * wrapText is different from would-be "chunk" implementation
   * in that whitespace characters that occur on a chunk size limit are trimmed.
   *
   */


  const wrapString = (subject, size) => {
    let subjectSlice = subject;
    const chunks = [];

    do {
      chunks.push((0, slice_ansi_1.default)(subjectSlice, 0, size));
      subjectSlice = (0, slice_ansi_1.default)(subjectSlice, size).trim();
    } while ((0, string_width_1.default)(subjectSlice));

    return chunks;
  };

  exports.wrapString = wrapString;
  });

  var wrapWord_1 = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.wrapWord = void 0;

  const slice_ansi_1 = __importDefault(sliceAnsi);

  const strip_ansi_1 = __importDefault(stripAnsi);

  const calculateStringLengths = (input, size) => {
    let subject = (0, strip_ansi_1.default)(input);
    const chunks = []; // https://regex101.com/r/gY5kZ1/1

    const re = new RegExp('(^.{1,' + String(Math.max(size, 1)) + '}(\\s+|$))|(^.{1,' + String(Math.max(size - 1, 1)) + '}(\\\\|/|_|\\.|,|;|-))');

    do {
      let chunk;
      const match = re.exec(subject);

      if (match) {
        chunk = match[0];
        subject = subject.slice(chunk.length);
        const trimmedLength = chunk.trim().length;
        const offset = chunk.length - trimmedLength;
        chunks.push([trimmedLength, offset]);
      } else {
        chunk = subject.slice(0, size);
        subject = subject.slice(size);
        chunks.push([chunk.length, 0]);
      }
    } while (subject.length);

    return chunks;
  };

  const wrapWord = (input, size) => {
    const result = [];
    let startIndex = 0;
    calculateStringLengths(input, size).forEach(([length, offset]) => {
      result.push((0, slice_ansi_1.default)(input, startIndex, startIndex + length));
      startIndex += length + offset;
    });
    return result;
  };

  exports.wrapWord = wrapWord;
  });

  var wrapCell_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.wrapCell = void 0;






  /**
   * Wrap a single cell value into a list of lines
   *
   * Always wraps on newlines, for the remainder uses either word or string wrapping
   * depending on user configuration.
   *
   */


  const wrapCell = (cellValue, cellWidth, useWrapWord) => {
    // First split on literal newlines
    const cellLines = (0, utils$5.splitAnsi)(cellValue); // Then iterate over the list and word-wrap every remaining line if necessary.

    for (let lineNr = 0; lineNr < cellLines.length;) {
      let lineChunks;

      if (useWrapWord) {
        lineChunks = (0, wrapWord_1.wrapWord)(cellLines[lineNr], cellWidth);
      } else {
        lineChunks = (0, wrapString_1.wrapString)(cellLines[lineNr], cellWidth);
      } // Replace our original array element with whatever the wrapping returned


      cellLines.splice(lineNr, 1, ...lineChunks);
      lineNr += lineChunks.length;
    }

    return cellLines;
  };

  exports.wrapCell = wrapCell;
  });

  var calculateCellHeight_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.calculateCellHeight = void 0;


  /**
   * Calculates height of cell content in regard to its width and word wrapping.
   */


  const calculateCellHeight = (value, columnWidth, useWrapWord = false) => {
    return (0, wrapCell_1.wrapCell)(value, columnWidth, useWrapWord).length;
  };

  exports.calculateCellHeight = calculateCellHeight;
  });

  var calculateRowHeights_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.calculateRowHeights = void 0;




  /**
   * Produces an array of values that describe the largest value length (height) in every row.
   */


  const calculateRowHeights = (rows, config) => {
    const rowHeights = [];

    for (const [rowIndex, row] of rows.entries()) {
      let rowHeight = 1;
      row.forEach((cell, cellIndex) => {
        var _a;

        const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({
          col: cellIndex,
          row: rowIndex
        });

        if (!containingRange) {
          const cellHeight = (0, calculateCellHeight_1.calculateCellHeight)(cell, config.columns[cellIndex].width, config.columns[cellIndex].wrapWord);
          rowHeight = Math.max(rowHeight, cellHeight);
          return;
        }

        const {
          topLeft,
          bottomRight,
          height
        } = containingRange; // bottom-most cell of a range needs to contain all remain lines of spanning cells

        if (rowIndex === bottomRight.row) {
          const totalOccupiedSpanningCellHeight = (0, utils$5.sumArray)(rowHeights.slice(topLeft.row));
          const totalHorizontalBorderHeight = bottomRight.row - topLeft.row;
          const totalHiddenHorizontalBorderHeight = (0, utils$5.sequence)(topLeft.row + 1, bottomRight.row).filter(horizontalBorderIndex => {
            var _a;
            /* istanbul ignore next */


            return !((_a = config.drawHorizontalLine) === null || _a === void 0 ? void 0 : _a.call(config, horizontalBorderIndex, rows.length));
          }).length;
          const cellHeight = height - totalOccupiedSpanningCellHeight - totalHorizontalBorderHeight + totalHiddenHorizontalBorderHeight;
          rowHeight = Math.max(rowHeight, cellHeight);
        } // otherwise, just depend on other sibling cell heights in the row

      });
      rowHeights.push(rowHeight);
    }

    return rowHeights;
  };

  exports.calculateRowHeights = calculateRowHeights;
  });

  var drawContent_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.drawContent = void 0;

  const drawContent = parameters => {
    const {
      contents,
      separatorGetter,
      drawSeparator,
      spanningCellManager,
      rowIndex,
      elementType
    } = parameters;
    const contentSize = contents.length;
    const result = [];

    if (drawSeparator(0, contentSize)) {
      result.push(separatorGetter(0, contentSize));
    }

    contents.forEach((content, contentIndex) => {
      if (!elementType || elementType === 'border' || elementType === 'row') {
        result.push(content);
      }

      if (elementType === 'cell' && rowIndex === undefined) {
        result.push(content);
      }

      if (elementType === 'cell' && rowIndex !== undefined) {
        /* istanbul ignore next */
        const containingRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange({
          col: contentIndex,
          row: rowIndex
        }); // when drawing content row, just add a cell when it is a normal cell
        // or belongs to first column of spanning cell

        if (!containingRange || contentIndex === containingRange.topLeft.col) {
          result.push(content);
        }
      } // Only append the middle separator if the content is not the last


      if (contentIndex + 1 < contentSize && drawSeparator(contentIndex + 1, contentSize)) {
        const separator = separatorGetter(contentIndex + 1, contentSize);

        if (elementType === 'cell' && rowIndex !== undefined) {
          const currentCell = {
            col: contentIndex + 1,
            row: rowIndex
          };
          /* istanbul ignore next */

          const containingRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange(currentCell);

          if (!containingRange || containingRange.topLeft.col === currentCell.col) {
            result.push(separator);
          }
        } else {
          result.push(separator);
        }
      }
    });

    if (drawSeparator(contentSize, contentSize)) {
      result.push(separatorGetter(contentSize, contentSize));
    }

    return result.join('');
  };

  exports.drawContent = drawContent;
  });

  var drawBorder_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createTableBorderGetter = exports.drawBorderBottom = exports.drawBorderJoin = exports.drawBorderTop = exports.drawBorder = exports.createSeparatorGetter = exports.drawBorderSegments = void 0;



  const drawBorderSegments = (columnWidths, parameters) => {
    const {
      separator,
      horizontalBorderIndex,
      spanningCellManager
    } = parameters;
    return columnWidths.map((columnWidth, columnIndex) => {
      const normalSegment = separator.body.repeat(columnWidth);

      if (horizontalBorderIndex === undefined) {
        return normalSegment;
      }
      /* istanbul ignore next */


      const range = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange({
        col: columnIndex,
        row: horizontalBorderIndex
      });

      if (!range) {
        return normalSegment;
      }

      const {
        topLeft
      } = range; // draw border segments as usual for top border of spanning cell

      if (horizontalBorderIndex === topLeft.row) {
        return normalSegment;
      } // if for first column/row of spanning cell, just skip


      if (columnIndex !== topLeft.col) {
        return '';
      }

      return range.extractBorderContent(horizontalBorderIndex);
    });
  };

  exports.drawBorderSegments = drawBorderSegments;

  const createSeparatorGetter = dependencies => {
    const {
      separator,
      spanningCellManager,
      horizontalBorderIndex,
      rowCount
    } = dependencies; // eslint-disable-next-line complexity

    return (verticalBorderIndex, columnCount) => {
      const inSameRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.inSameRange;

      if (horizontalBorderIndex !== undefined && inSameRange) {
        const topCell = {
          col: verticalBorderIndex,
          row: horizontalBorderIndex - 1
        };
        const leftCell = {
          col: verticalBorderIndex - 1,
          row: horizontalBorderIndex
        };
        const oppositeCell = {
          col: verticalBorderIndex - 1,
          row: horizontalBorderIndex - 1
        };
        const currentCell = {
          col: verticalBorderIndex,
          row: horizontalBorderIndex
        };
        const pairs = [[oppositeCell, topCell], [topCell, currentCell], [currentCell, leftCell], [leftCell, oppositeCell]]; // left side of horizontal border

        if (verticalBorderIndex === 0) {
          if (inSameRange(currentCell, topCell) && separator.bodyJoinOuter) {
            return separator.bodyJoinOuter;
          }

          return separator.left;
        } // right side of horizontal border


        if (verticalBorderIndex === columnCount) {
          if (inSameRange(oppositeCell, leftCell) && separator.bodyJoinOuter) {
            return separator.bodyJoinOuter;
          }

          return separator.right;
        } // top horizontal border


        if (horizontalBorderIndex === 0) {
          if (inSameRange(currentCell, leftCell)) {
            return separator.body;
          }

          return separator.join;
        } // bottom horizontal border


        if (horizontalBorderIndex === rowCount) {
          if (inSameRange(topCell, oppositeCell)) {
            return separator.body;
          }

          return separator.join;
        }

        const sameRangeCount = pairs.map(pair => {
          return inSameRange(...pair);
        }).filter(Boolean).length; // four cells are belongs to different spanning cells

        if (sameRangeCount === 0) {
          return separator.join;
        } // belong to one spanning cell


        if (sameRangeCount === 4) {
          return '';
        } // belongs to two spanning cell


        if (sameRangeCount === 2) {
          if (inSameRange(...pairs[1]) && inSameRange(...pairs[3]) && separator.bodyJoinInner) {
            return separator.bodyJoinInner;
          }

          return separator.body;
        }
        /* istanbul ignore next */


        if (sameRangeCount === 1) {
          if (!separator.joinRight || !separator.joinLeft || !separator.joinUp || !separator.joinDown) {
            throw new Error(`Can not get border separator for position [${horizontalBorderIndex}, ${verticalBorderIndex}]`);
          }

          if (inSameRange(...pairs[0])) {
            return separator.joinDown;
          }

          if (inSameRange(...pairs[1])) {
            return separator.joinLeft;
          }

          if (inSameRange(...pairs[2])) {
            return separator.joinUp;
          }

          return separator.joinRight;
        }
        /* istanbul ignore next */


        throw new Error('Invalid case');
      }

      if (verticalBorderIndex === 0) {
        return separator.left;
      }

      if (verticalBorderIndex === columnCount) {
        return separator.right;
      }

      return separator.join;
    };
  };

  exports.createSeparatorGetter = createSeparatorGetter;

  const drawBorder = (columnWidths, parameters) => {
    const borderSegments = (0, exports.drawBorderSegments)(columnWidths, parameters);
    const {
      drawVerticalLine,
      horizontalBorderIndex,
      spanningCellManager
    } = parameters;
    return (0, drawContent_1.drawContent)({
      contents: borderSegments,
      drawSeparator: drawVerticalLine,
      elementType: 'border',
      rowIndex: horizontalBorderIndex,
      separatorGetter: (0, exports.createSeparatorGetter)(parameters),
      spanningCellManager
    }) + '\n';
  };

  exports.drawBorder = drawBorder;

  const drawBorderTop = (columnWidths, parameters) => {
    const {
      border
    } = parameters;
    const result = (0, exports.drawBorder)(columnWidths, { ...parameters,
      separator: {
        body: border.topBody,
        join: border.topJoin,
        left: border.topLeft,
        right: border.topRight
      }
    });

    if (result === '\n') {
      return '';
    }

    return result;
  };

  exports.drawBorderTop = drawBorderTop;

  const drawBorderJoin = (columnWidths, parameters) => {
    const {
      border
    } = parameters;
    return (0, exports.drawBorder)(columnWidths, { ...parameters,
      separator: {
        body: border.joinBody,
        bodyJoinInner: border.bodyJoin,
        bodyJoinOuter: border.bodyLeft,
        join: border.joinJoin,
        joinDown: border.joinMiddleDown,
        joinLeft: border.joinMiddleLeft,
        joinRight: border.joinMiddleRight,
        joinUp: border.joinMiddleUp,
        left: border.joinLeft,
        right: border.joinRight
      }
    });
  };

  exports.drawBorderJoin = drawBorderJoin;

  const drawBorderBottom = (columnWidths, parameters) => {
    const {
      border
    } = parameters;
    return (0, exports.drawBorder)(columnWidths, { ...parameters,
      separator: {
        body: border.bottomBody,
        join: border.bottomJoin,
        left: border.bottomLeft,
        right: border.bottomRight
      }
    });
  };

  exports.drawBorderBottom = drawBorderBottom;

  const createTableBorderGetter = (columnWidths, parameters) => {
    return (index, size) => {
      const drawBorderParameters = { ...parameters,
        horizontalBorderIndex: index
      };

      if (index === 0) {
        return (0, exports.drawBorderTop)(columnWidths, drawBorderParameters);
      } else if (index === size) {
        return (0, exports.drawBorderBottom)(columnWidths, drawBorderParameters);
      }

      return (0, exports.drawBorderJoin)(columnWidths, drawBorderParameters);
    };
  };

  exports.createTableBorderGetter = createTableBorderGetter;
  });

  var drawRow_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.drawRow = void 0;



  const drawRow = (row, config) => {
    const {
      border,
      drawVerticalLine,
      rowIndex,
      spanningCellManager
    } = config;
    return (0, drawContent_1.drawContent)({
      contents: row,
      drawSeparator: drawVerticalLine,
      elementType: 'cell',
      rowIndex,
      separatorGetter: (index, columnCount) => {
        if (index === 0) {
          return border.bodyLeft;
        }

        if (index === columnCount) {
          return border.bodyRight;
        }

        return border.bodyJoin;
      },
      spanningCellManager
    }) + '\n';
  };

  exports.drawRow = drawRow;
  });

  var fastDeepEqual = function equal(a, b) {
    if (a === b) return true;

    if (a && b && typeof a == 'object' && typeof b == 'object') {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;

      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;

        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;

        return true;
      }

      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;

      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!equal(a[key], b[key])) return false;
      }

      return true;
    } // true if both NaN, false otherwise


    return a !== a && b !== b;
  };

  // https://github.com/ajv-validator/ajv/issues/889



  fastDeepEqual.code = 'require("ajv/dist/runtime/equal").default';
  var _default$B = fastDeepEqual;

  var equal_1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$B
  }, '__esModule', {value: true});

  var validators = createCommonjsModule(function (module, exports) {

  exports["config.json"] = validate43;
  const schema13 = {
    "$id": "config.json",
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "properties": {
      "border": {
        "$ref": "shared.json#/definitions/borders"
      },
      "header": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string"
          },
          "alignment": {
            "$ref": "shared.json#/definitions/alignment"
          },
          "wrapWord": {
            "type": "boolean"
          },
          "truncate": {
            "type": "integer"
          },
          "paddingLeft": {
            "type": "integer"
          },
          "paddingRight": {
            "type": "integer"
          }
        },
        "required": ["content"],
        "additionalProperties": false
      },
      "columns": {
        "$ref": "shared.json#/definitions/columns"
      },
      "columnDefault": {
        "$ref": "shared.json#/definitions/column"
      },
      "drawVerticalLine": {
        "typeof": "function"
      },
      "drawHorizontalLine": {
        "typeof": "function"
      },
      "singleLine": {
        "typeof": "boolean"
      },
      "spanningCells": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "col": {
              "type": "integer",
              "minimum": 0
            },
            "row": {
              "type": "integer",
              "minimum": 0
            },
            "colSpan": {
              "type": "integer",
              "minimum": 1
            },
            "rowSpan": {
              "type": "integer",
              "minimum": 1
            },
            "alignment": {
              "$ref": "shared.json#/definitions/alignment"
            },
            "verticalAlignment": {
              "$ref": "shared.json#/definitions/verticalAlignment"
            },
            "wrapWord": {
              "type": "boolean"
            },
            "truncate": {
              "type": "integer"
            },
            "paddingLeft": {
              "type": "integer"
            },
            "paddingRight": {
              "type": "integer"
            }
          },
          "required": ["row", "col"],
          "additionalProperties": false
        }
      }
    },
    "additionalProperties": false
  };
  const schema15 = {
    "type": "object",
    "properties": {
      "topBody": {
        "$ref": "#/definitions/border"
      },
      "topJoin": {
        "$ref": "#/definitions/border"
      },
      "topLeft": {
        "$ref": "#/definitions/border"
      },
      "topRight": {
        "$ref": "#/definitions/border"
      },
      "bottomBody": {
        "$ref": "#/definitions/border"
      },
      "bottomJoin": {
        "$ref": "#/definitions/border"
      },
      "bottomLeft": {
        "$ref": "#/definitions/border"
      },
      "bottomRight": {
        "$ref": "#/definitions/border"
      },
      "bodyLeft": {
        "$ref": "#/definitions/border"
      },
      "bodyRight": {
        "$ref": "#/definitions/border"
      },
      "bodyJoin": {
        "$ref": "#/definitions/border"
      },
      "headerJoin": {
        "$ref": "#/definitions/border"
      },
      "joinBody": {
        "$ref": "#/definitions/border"
      },
      "joinLeft": {
        "$ref": "#/definitions/border"
      },
      "joinRight": {
        "$ref": "#/definitions/border"
      },
      "joinJoin": {
        "$ref": "#/definitions/border"
      },
      "joinMiddleUp": {
        "$ref": "#/definitions/border"
      },
      "joinMiddleDown": {
        "$ref": "#/definitions/border"
      },
      "joinMiddleLeft": {
        "$ref": "#/definitions/border"
      },
      "joinMiddleRight": {
        "$ref": "#/definitions/border"
      }
    },
    "additionalProperties": false
  };
  const func8 = Object.prototype.hasOwnProperty;

  function validate46(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (typeof data !== "string") {
      const err0 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "string"
        },
        message: "must be string"
      };

      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }

      errors++;
    }

    validate46.errors = vErrors;
    return errors === 0;
  }

  function validate45(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        if (!func8.call(schema15.properties, key0)) {
          const err0 = {
            instancePath,
            schemaPath: "#/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }

          errors++;
        }
      }

      if (data.topBody !== undefined) {
        if (!validate46(data.topBody, {
          instancePath: instancePath + "/topBody",
          parentData: data,
          parentDataProperty: "topBody",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.topJoin !== undefined) {
        if (!validate46(data.topJoin, {
          instancePath: instancePath + "/topJoin",
          parentData: data,
          parentDataProperty: "topJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.topLeft !== undefined) {
        if (!validate46(data.topLeft, {
          instancePath: instancePath + "/topLeft",
          parentData: data,
          parentDataProperty: "topLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.topRight !== undefined) {
        if (!validate46(data.topRight, {
          instancePath: instancePath + "/topRight",
          parentData: data,
          parentDataProperty: "topRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bottomBody !== undefined) {
        if (!validate46(data.bottomBody, {
          instancePath: instancePath + "/bottomBody",
          parentData: data,
          parentDataProperty: "bottomBody",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bottomJoin !== undefined) {
        if (!validate46(data.bottomJoin, {
          instancePath: instancePath + "/bottomJoin",
          parentData: data,
          parentDataProperty: "bottomJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bottomLeft !== undefined) {
        if (!validate46(data.bottomLeft, {
          instancePath: instancePath + "/bottomLeft",
          parentData: data,
          parentDataProperty: "bottomLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bottomRight !== undefined) {
        if (!validate46(data.bottomRight, {
          instancePath: instancePath + "/bottomRight",
          parentData: data,
          parentDataProperty: "bottomRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bodyLeft !== undefined) {
        if (!validate46(data.bodyLeft, {
          instancePath: instancePath + "/bodyLeft",
          parentData: data,
          parentDataProperty: "bodyLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bodyRight !== undefined) {
        if (!validate46(data.bodyRight, {
          instancePath: instancePath + "/bodyRight",
          parentData: data,
          parentDataProperty: "bodyRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bodyJoin !== undefined) {
        if (!validate46(data.bodyJoin, {
          instancePath: instancePath + "/bodyJoin",
          parentData: data,
          parentDataProperty: "bodyJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.headerJoin !== undefined) {
        if (!validate46(data.headerJoin, {
          instancePath: instancePath + "/headerJoin",
          parentData: data,
          parentDataProperty: "headerJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinBody !== undefined) {
        if (!validate46(data.joinBody, {
          instancePath: instancePath + "/joinBody",
          parentData: data,
          parentDataProperty: "joinBody",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinLeft !== undefined) {
        if (!validate46(data.joinLeft, {
          instancePath: instancePath + "/joinLeft",
          parentData: data,
          parentDataProperty: "joinLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinRight !== undefined) {
        if (!validate46(data.joinRight, {
          instancePath: instancePath + "/joinRight",
          parentData: data,
          parentDataProperty: "joinRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinJoin !== undefined) {
        if (!validate46(data.joinJoin, {
          instancePath: instancePath + "/joinJoin",
          parentData: data,
          parentDataProperty: "joinJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinMiddleUp !== undefined) {
        if (!validate46(data.joinMiddleUp, {
          instancePath: instancePath + "/joinMiddleUp",
          parentData: data,
          parentDataProperty: "joinMiddleUp",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinMiddleDown !== undefined) {
        if (!validate46(data.joinMiddleDown, {
          instancePath: instancePath + "/joinMiddleDown",
          parentData: data,
          parentDataProperty: "joinMiddleDown",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinMiddleLeft !== undefined) {
        if (!validate46(data.joinMiddleLeft, {
          instancePath: instancePath + "/joinMiddleLeft",
          parentData: data,
          parentDataProperty: "joinMiddleLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinMiddleRight !== undefined) {
        if (!validate46(data.joinMiddleRight, {
          instancePath: instancePath + "/joinMiddleRight",
          parentData: data,
          parentDataProperty: "joinMiddleRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }
    } else {
      const err1 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    validate45.errors = vErrors;
    return errors === 0;
  }

  const schema17 = {
    "type": "string",
    "enum": ["left", "right", "center", "justify"]
  };

  equal_1.default;

  function validate68(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (typeof data !== "string") {
      const err0 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "string"
        },
        message: "must be string"
      };

      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }

      errors++;
    }

    if (!(data === "left" || data === "right" || data === "center" || data === "justify")) {
      const err1 = {
        instancePath,
        schemaPath: "#/enum",
        keyword: "enum",
        params: {
          allowedValues: schema17.enum
        },
        message: "must be equal to one of the allowed values"
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    validate68.errors = vErrors;
    return errors === 0;
  }
  const pattern0 = new RegExp("^[0-9]+$", "u");

  function validate72(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (typeof data !== "string") {
      const err0 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "string"
        },
        message: "must be string"
      };

      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }

      errors++;
    }

    if (!(data === "left" || data === "right" || data === "center" || data === "justify")) {
      const err1 = {
        instancePath,
        schemaPath: "#/enum",
        keyword: "enum",
        params: {
          allowedValues: schema17.enum
        },
        message: "must be equal to one of the allowed values"
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    validate72.errors = vErrors;
    return errors === 0;
  }

  const schema21 = {
    "type": "string",
    "enum": ["top", "middle", "bottom"]
  };

  function validate74(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (typeof data !== "string") {
      const err0 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "string"
        },
        message: "must be string"
      };

      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }

      errors++;
    }

    if (!(data === "top" || data === "middle" || data === "bottom")) {
      const err1 = {
        instancePath,
        schemaPath: "#/enum",
        keyword: "enum",
        params: {
          allowedValues: schema21.enum
        },
        message: "must be equal to one of the allowed values"
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    validate74.errors = vErrors;
    return errors === 0;
  }

  function validate71(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        if (!(key0 === "alignment" || key0 === "verticalAlignment" || key0 === "width" || key0 === "wrapWord" || key0 === "truncate" || key0 === "paddingLeft" || key0 === "paddingRight")) {
          const err0 = {
            instancePath,
            schemaPath: "#/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }

          errors++;
        }
      }

      if (data.alignment !== undefined) {
        if (!validate72(data.alignment, {
          instancePath: instancePath + "/alignment",
          parentData: data,
          parentDataProperty: "alignment",
          rootData
        })) {
          vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
          errors = vErrors.length;
        }
      }

      if (data.verticalAlignment !== undefined) {
        if (!validate74(data.verticalAlignment, {
          instancePath: instancePath + "/verticalAlignment",
          parentData: data,
          parentDataProperty: "verticalAlignment",
          rootData
        })) {
          vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
          errors = vErrors.length;
        }
      }

      if (data.width !== undefined) {
        let data2 = data.width;

        if (!(typeof data2 == "number" && !(data2 % 1) && !isNaN(data2) && isFinite(data2))) {
          const err1 = {
            instancePath: instancePath + "/width",
            schemaPath: "#/properties/width/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }

          errors++;
        }

        if (typeof data2 == "number" && isFinite(data2)) {
          if (data2 < 1 || isNaN(data2)) {
            const err2 = {
              instancePath: instancePath + "/width",
              schemaPath: "#/properties/width/minimum",
              keyword: "minimum",
              params: {
                comparison: ">=",
                limit: 1
              },
              message: "must be >= 1"
            };

            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }

            errors++;
          }
        }
      }

      if (data.wrapWord !== undefined) {
        if (typeof data.wrapWord !== "boolean") {
          const err3 = {
            instancePath: instancePath + "/wrapWord",
            schemaPath: "#/properties/wrapWord/type",
            keyword: "type",
            params: {
              type: "boolean"
            },
            message: "must be boolean"
          };

          if (vErrors === null) {
            vErrors = [err3];
          } else {
            vErrors.push(err3);
          }

          errors++;
        }
      }

      if (data.truncate !== undefined) {
        let data4 = data.truncate;

        if (!(typeof data4 == "number" && !(data4 % 1) && !isNaN(data4) && isFinite(data4))) {
          const err4 = {
            instancePath: instancePath + "/truncate",
            schemaPath: "#/properties/truncate/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err4];
          } else {
            vErrors.push(err4);
          }

          errors++;
        }
      }

      if (data.paddingLeft !== undefined) {
        let data5 = data.paddingLeft;

        if (!(typeof data5 == "number" && !(data5 % 1) && !isNaN(data5) && isFinite(data5))) {
          const err5 = {
            instancePath: instancePath + "/paddingLeft",
            schemaPath: "#/properties/paddingLeft/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err5];
          } else {
            vErrors.push(err5);
          }

          errors++;
        }
      }

      if (data.paddingRight !== undefined) {
        let data6 = data.paddingRight;

        if (!(typeof data6 == "number" && !(data6 % 1) && !isNaN(data6) && isFinite(data6))) {
          const err6 = {
            instancePath: instancePath + "/paddingRight",
            schemaPath: "#/properties/paddingRight/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }

          errors++;
        }
      }
    } else {
      const err7 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err7];
      } else {
        vErrors.push(err7);
      }

      errors++;
    }

    validate71.errors = vErrors;
    return errors === 0;
  }

  function validate70(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs1 = errors;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        if (!pattern0.test(key0)) {
          const err0 = {
            instancePath,
            schemaPath: "#/oneOf/0/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }

          errors++;
        }
      }

      for (const key1 in data) {
        if (pattern0.test(key1)) {
          if (!validate71(data[key1], {
            instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
            parentData: data,
            parentDataProperty: key1,
            rootData
          })) {
            vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
            errors = vErrors.length;
          }
        }
      }
    } else {
      const err1 = {
        instancePath,
        schemaPath: "#/oneOf/0/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    var _valid0 = _errs1 === errors;

    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }

    const _errs5 = errors;

    if (Array.isArray(data)) {
      const len0 = data.length;

      for (let i0 = 0; i0 < len0; i0++) {
        if (!validate71(data[i0], {
          instancePath: instancePath + "/" + i0,
          parentData: data,
          parentDataProperty: i0,
          rootData
        })) {
          vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
          errors = vErrors.length;
        }
      }
    } else {
      const err2 = {
        instancePath,
        schemaPath: "#/oneOf/1/type",
        keyword: "type",
        params: {
          type: "array"
        },
        message: "must be array"
      };

      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }

      errors++;
    }

    var _valid0 = _errs5 === errors;

    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }

    if (!valid0) {
      const err3 = {
        instancePath,
        schemaPath: "#/oneOf",
        keyword: "oneOf",
        params: {
          passingSchemas: passing0
        },
        message: "must match exactly one schema in oneOf"
      };

      if (vErrors === null) {
        vErrors = [err3];
      } else {
        vErrors.push(err3);
      }

      errors++;
    } else {
      errors = _errs0;

      if (vErrors !== null) {
        if (_errs0) {
          vErrors.length = _errs0;
        } else {
          vErrors = null;
        }
      }
    }

    validate70.errors = vErrors;
    return errors === 0;
  }

  function validate79(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        if (!(key0 === "alignment" || key0 === "verticalAlignment" || key0 === "width" || key0 === "wrapWord" || key0 === "truncate" || key0 === "paddingLeft" || key0 === "paddingRight")) {
          const err0 = {
            instancePath,
            schemaPath: "#/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }

          errors++;
        }
      }

      if (data.alignment !== undefined) {
        if (!validate72(data.alignment, {
          instancePath: instancePath + "/alignment",
          parentData: data,
          parentDataProperty: "alignment",
          rootData
        })) {
          vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
          errors = vErrors.length;
        }
      }

      if (data.verticalAlignment !== undefined) {
        if (!validate74(data.verticalAlignment, {
          instancePath: instancePath + "/verticalAlignment",
          parentData: data,
          parentDataProperty: "verticalAlignment",
          rootData
        })) {
          vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
          errors = vErrors.length;
        }
      }

      if (data.width !== undefined) {
        let data2 = data.width;

        if (!(typeof data2 == "number" && !(data2 % 1) && !isNaN(data2) && isFinite(data2))) {
          const err1 = {
            instancePath: instancePath + "/width",
            schemaPath: "#/properties/width/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }

          errors++;
        }

        if (typeof data2 == "number" && isFinite(data2)) {
          if (data2 < 1 || isNaN(data2)) {
            const err2 = {
              instancePath: instancePath + "/width",
              schemaPath: "#/properties/width/minimum",
              keyword: "minimum",
              params: {
                comparison: ">=",
                limit: 1
              },
              message: "must be >= 1"
            };

            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }

            errors++;
          }
        }
      }

      if (data.wrapWord !== undefined) {
        if (typeof data.wrapWord !== "boolean") {
          const err3 = {
            instancePath: instancePath + "/wrapWord",
            schemaPath: "#/properties/wrapWord/type",
            keyword: "type",
            params: {
              type: "boolean"
            },
            message: "must be boolean"
          };

          if (vErrors === null) {
            vErrors = [err3];
          } else {
            vErrors.push(err3);
          }

          errors++;
        }
      }

      if (data.truncate !== undefined) {
        let data4 = data.truncate;

        if (!(typeof data4 == "number" && !(data4 % 1) && !isNaN(data4) && isFinite(data4))) {
          const err4 = {
            instancePath: instancePath + "/truncate",
            schemaPath: "#/properties/truncate/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err4];
          } else {
            vErrors.push(err4);
          }

          errors++;
        }
      }

      if (data.paddingLeft !== undefined) {
        let data5 = data.paddingLeft;

        if (!(typeof data5 == "number" && !(data5 % 1) && !isNaN(data5) && isFinite(data5))) {
          const err5 = {
            instancePath: instancePath + "/paddingLeft",
            schemaPath: "#/properties/paddingLeft/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err5];
          } else {
            vErrors.push(err5);
          }

          errors++;
        }
      }

      if (data.paddingRight !== undefined) {
        let data6 = data.paddingRight;

        if (!(typeof data6 == "number" && !(data6 % 1) && !isNaN(data6) && isFinite(data6))) {
          const err6 = {
            instancePath: instancePath + "/paddingRight",
            schemaPath: "#/properties/paddingRight/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }

          errors++;
        }
      }
    } else {
      const err7 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err7];
      } else {
        vErrors.push(err7);
      }

      errors++;
    }

    validate79.errors = vErrors;
    return errors === 0;
  }

  function validate84(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (typeof data !== "string") {
      const err0 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "string"
        },
        message: "must be string"
      };

      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }

      errors++;
    }

    if (!(data === "top" || data === "middle" || data === "bottom")) {
      const err1 = {
        instancePath,
        schemaPath: "#/enum",
        keyword: "enum",
        params: {
          allowedValues: schema21.enum
        },
        message: "must be equal to one of the allowed values"
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    validate84.errors = vErrors;
    return errors === 0;
  }

  function validate43(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        if (!(key0 === "border" || key0 === "header" || key0 === "columns" || key0 === "columnDefault" || key0 === "drawVerticalLine" || key0 === "drawHorizontalLine" || key0 === "singleLine" || key0 === "spanningCells")) {
          const err0 = {
            instancePath,
            schemaPath: "#/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }

          errors++;
        }
      }

      if (data.border !== undefined) {
        if (!validate45(data.border, {
          instancePath: instancePath + "/border",
          parentData: data,
          parentDataProperty: "border",
          rootData
        })) {
          vErrors = vErrors === null ? validate45.errors : vErrors.concat(validate45.errors);
          errors = vErrors.length;
        }
      }

      if (data.header !== undefined) {
        let data1 = data.header;

        if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
          if (data1.content === undefined) {
            const err1 = {
              instancePath: instancePath + "/header",
              schemaPath: "#/properties/header/required",
              keyword: "required",
              params: {
                missingProperty: "content"
              },
              message: "must have required property '" + "content" + "'"
            };

            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }

            errors++;
          }

          for (const key1 in data1) {
            if (!(key1 === "content" || key1 === "alignment" || key1 === "wrapWord" || key1 === "truncate" || key1 === "paddingLeft" || key1 === "paddingRight")) {
              const err2 = {
                instancePath: instancePath + "/header",
                schemaPath: "#/properties/header/additionalProperties",
                keyword: "additionalProperties",
                params: {
                  additionalProperty: key1
                },
                message: "must NOT have additional properties"
              };

              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }

              errors++;
            }
          }

          if (data1.content !== undefined) {
            if (typeof data1.content !== "string") {
              const err3 = {
                instancePath: instancePath + "/header/content",
                schemaPath: "#/properties/header/properties/content/type",
                keyword: "type",
                params: {
                  type: "string"
                },
                message: "must be string"
              };

              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }

              errors++;
            }
          }

          if (data1.alignment !== undefined) {
            if (!validate68(data1.alignment, {
              instancePath: instancePath + "/header/alignment",
              parentData: data1,
              parentDataProperty: "alignment",
              rootData
            })) {
              vErrors = vErrors === null ? validate68.errors : vErrors.concat(validate68.errors);
              errors = vErrors.length;
            }
          }

          if (data1.wrapWord !== undefined) {
            if (typeof data1.wrapWord !== "boolean") {
              const err4 = {
                instancePath: instancePath + "/header/wrapWord",
                schemaPath: "#/properties/header/properties/wrapWord/type",
                keyword: "type",
                params: {
                  type: "boolean"
                },
                message: "must be boolean"
              };

              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }

              errors++;
            }
          }

          if (data1.truncate !== undefined) {
            let data5 = data1.truncate;

            if (!(typeof data5 == "number" && !(data5 % 1) && !isNaN(data5) && isFinite(data5))) {
              const err5 = {
                instancePath: instancePath + "/header/truncate",
                schemaPath: "#/properties/header/properties/truncate/type",
                keyword: "type",
                params: {
                  type: "integer"
                },
                message: "must be integer"
              };

              if (vErrors === null) {
                vErrors = [err5];
              } else {
                vErrors.push(err5);
              }

              errors++;
            }
          }

          if (data1.paddingLeft !== undefined) {
            let data6 = data1.paddingLeft;

            if (!(typeof data6 == "number" && !(data6 % 1) && !isNaN(data6) && isFinite(data6))) {
              const err6 = {
                instancePath: instancePath + "/header/paddingLeft",
                schemaPath: "#/properties/header/properties/paddingLeft/type",
                keyword: "type",
                params: {
                  type: "integer"
                },
                message: "must be integer"
              };

              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }

              errors++;
            }
          }

          if (data1.paddingRight !== undefined) {
            let data7 = data1.paddingRight;

            if (!(typeof data7 == "number" && !(data7 % 1) && !isNaN(data7) && isFinite(data7))) {
              const err7 = {
                instancePath: instancePath + "/header/paddingRight",
                schemaPath: "#/properties/header/properties/paddingRight/type",
                keyword: "type",
                params: {
                  type: "integer"
                },
                message: "must be integer"
              };

              if (vErrors === null) {
                vErrors = [err7];
              } else {
                vErrors.push(err7);
              }

              errors++;
            }
          }
        } else {
          const err8 = {
            instancePath: instancePath + "/header",
            schemaPath: "#/properties/header/type",
            keyword: "type",
            params: {
              type: "object"
            },
            message: "must be object"
          };

          if (vErrors === null) {
            vErrors = [err8];
          } else {
            vErrors.push(err8);
          }

          errors++;
        }
      }

      if (data.columns !== undefined) {
        if (!validate70(data.columns, {
          instancePath: instancePath + "/columns",
          parentData: data,
          parentDataProperty: "columns",
          rootData
        })) {
          vErrors = vErrors === null ? validate70.errors : vErrors.concat(validate70.errors);
          errors = vErrors.length;
        }
      }

      if (data.columnDefault !== undefined) {
        if (!validate79(data.columnDefault, {
          instancePath: instancePath + "/columnDefault",
          parentData: data,
          parentDataProperty: "columnDefault",
          rootData
        })) {
          vErrors = vErrors === null ? validate79.errors : vErrors.concat(validate79.errors);
          errors = vErrors.length;
        }
      }

      if (data.drawVerticalLine !== undefined) {
        if (typeof data.drawVerticalLine != "function") {
          const err9 = {
            instancePath: instancePath + "/drawVerticalLine",
            schemaPath: "#/properties/drawVerticalLine/typeof",
            keyword: "typeof",
            params: {},
            message: "must pass \"typeof\" keyword validation"
          };

          if (vErrors === null) {
            vErrors = [err9];
          } else {
            vErrors.push(err9);
          }

          errors++;
        }
      }

      if (data.drawHorizontalLine !== undefined) {
        if (typeof data.drawHorizontalLine != "function") {
          const err10 = {
            instancePath: instancePath + "/drawHorizontalLine",
            schemaPath: "#/properties/drawHorizontalLine/typeof",
            keyword: "typeof",
            params: {},
            message: "must pass \"typeof\" keyword validation"
          };

          if (vErrors === null) {
            vErrors = [err10];
          } else {
            vErrors.push(err10);
          }

          errors++;
        }
      }

      if (data.singleLine !== undefined) {
        if (typeof data.singleLine != "boolean") {
          const err11 = {
            instancePath: instancePath + "/singleLine",
            schemaPath: "#/properties/singleLine/typeof",
            keyword: "typeof",
            params: {},
            message: "must pass \"typeof\" keyword validation"
          };

          if (vErrors === null) {
            vErrors = [err11];
          } else {
            vErrors.push(err11);
          }

          errors++;
        }
      }

      if (data.spanningCells !== undefined) {
        let data13 = data.spanningCells;

        if (Array.isArray(data13)) {
          const len0 = data13.length;

          for (let i0 = 0; i0 < len0; i0++) {
            let data14 = data13[i0];

            if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
              if (data14.row === undefined) {
                const err12 = {
                  instancePath: instancePath + "/spanningCells/" + i0,
                  schemaPath: "#/properties/spanningCells/items/required",
                  keyword: "required",
                  params: {
                    missingProperty: "row"
                  },
                  message: "must have required property '" + "row" + "'"
                };

                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }

                errors++;
              }

              if (data14.col === undefined) {
                const err13 = {
                  instancePath: instancePath + "/spanningCells/" + i0,
                  schemaPath: "#/properties/spanningCells/items/required",
                  keyword: "required",
                  params: {
                    missingProperty: "col"
                  },
                  message: "must have required property '" + "col" + "'"
                };

                if (vErrors === null) {
                  vErrors = [err13];
                } else {
                  vErrors.push(err13);
                }

                errors++;
              }

              for (const key2 in data14) {
                if (!func8.call(schema13.properties.spanningCells.items.properties, key2)) {
                  const err14 = {
                    instancePath: instancePath + "/spanningCells/" + i0,
                    schemaPath: "#/properties/spanningCells/items/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                      additionalProperty: key2
                    },
                    message: "must NOT have additional properties"
                  };

                  if (vErrors === null) {
                    vErrors = [err14];
                  } else {
                    vErrors.push(err14);
                  }

                  errors++;
                }
              }

              if (data14.col !== undefined) {
                let data15 = data14.col;

                if (!(typeof data15 == "number" && !(data15 % 1) && !isNaN(data15) && isFinite(data15))) {
                  const err15 = {
                    instancePath: instancePath + "/spanningCells/" + i0 + "/col",
                    schemaPath: "#/properties/spanningCells/items/properties/col/type",
                    keyword: "type",
                    params: {
                      type: "integer"
                    },
                    message: "must be integer"
                  };

                  if (vErrors === null) {
                    vErrors = [err15];
                  } else {
                    vErrors.push(err15);
                  }

                  errors++;
                }

                if (typeof data15 == "number" && isFinite(data15)) {
                  if (data15 < 0 || isNaN(data15)) {
                    const err16 = {
                      instancePath: instancePath + "/spanningCells/" + i0 + "/col",
                      schemaPath: "#/properties/spanningCells/items/properties/col/minimum",
                      keyword: "minimum",
                      params: {
                        comparison: ">=",
                        limit: 0
                      },
                      message: "must be >= 0"
                    };

                    if (vErrors === null) {
                      vErrors = [err16];
                    } else {
                      vErrors.push(err16);
                    }

                    errors++;
                  }
                }
              }

              if (data14.row !== undefined) {
                let data16 = data14.row;

                if (!(typeof data16 == "number" && !(data16 % 1) && !isNaN(data16) && isFinite(data16))) {
                  const err17 = {
                    instancePath: instancePath + "/spanningCells/" + i0 + "/row",
                    schemaPath: "#/properties/spanningCells/items/properties/row/type",
                    keyword: "type",
                    params: {
                      type: "integer"
                    },
                    message: "must be integer"
                  };

                  if (vErrors === null) {
                    vErrors = [err17];
                  } else {
                    vErrors.push(err17);
                  }

                  errors++;
                }

                if (typeof data16 == "number" && isFinite(data16)) {
                  if (data16 < 0 || isNaN(data16)) {
                    const err18 = {
                      instancePath: instancePath + "/spanningCells/" + i0 + "/row",
                      schemaPath: "#/properties/spanningCells/items/properties/row/minimum",
                      keyword: "minimum",
                      params: {
                        comparison: ">=",
                        limit: 0
                      },
                      message: "must be >= 0"
                    };

                    if (vErrors === null) {
                      vErrors = [err18];
                    } else {
                      vErrors.push(err18);
                    }

                    errors++;
                  }
                }
              }

              if (data14.colSpan !== undefined) {
                let data17 = data14.colSpan;

                if (!(typeof data17 == "number" && !(data17 % 1) && !isNaN(data17) && isFinite(data17))) {
                  const err19 = {
                    instancePath: instancePath + "/spanningCells/" + i0 + "/colSpan",
                    schemaPath: "#/properties/spanningCells/items/properties/colSpan/type",
                    keyword: "type",
                    params: {
                      type: "integer"
                    },
                    message: "must be integer"
                  };

                  if (vErrors === null) {
                    vErrors = [err19];
                  } else {
                    vErrors.push(err19);
                  }

                  errors++;
                }

                if (typeof data17 == "number" && isFinite(data17)) {
                  if (data17 < 1 || isNaN(data17)) {
                    const err20 = {
                      instancePath: instancePath + "/spanningCells/" + i0 + "/colSpan",
                      schemaPath: "#/properties/spanningCells/items/properties/colSpan/minimum",
                      keyword: "minimum",
                      params: {
                        comparison: ">=",
                        limit: 1
                      },
                      message: "must be >= 1"
                    };

                    if (vErrors === null) {
                      vErrors = [err20];
                    } else {
                      vErrors.push(err20);
                    }

                    errors++;
                  }
                }
              }

              if (data14.rowSpan !== undefined) {
                let data18 = data14.rowSpan;

                if (!(typeof data18 == "number" && !(data18 % 1) && !isNaN(data18) && isFinite(data18))) {
                  const err21 = {
                    instancePath: instancePath + "/spanningCells/" + i0 + "/rowSpan",
                    schemaPath: "#/properties/spanningCells/items/properties/rowSpan/type",
                    keyword: "type",
                    params: {
                      type: "integer"
                    },
                    message: "must be integer"
                  };

                  if (vErrors === null) {
                    vErrors = [err21];
                  } else {
                    vErrors.push(err21);
                  }

                  errors++;
                }

                if (typeof data18 == "number" && isFinite(data18)) {
                  if (data18 < 1 || isNaN(data18)) {
                    const err22 = {
                      instancePath: instancePath + "/spanningCells/" + i0 + "/rowSpan",
                      schemaPath: "#/properties/spanningCells/items/properties/rowSpan/minimum",
                      keyword: "minimum",
                      params: {
                        comparison: ">=",
                        limit: 1
                      },
                      message: "must be >= 1"
                    };

                    if (vErrors === null) {
                      vErrors = [err22];
                    } else {
                      vErrors.push(err22);
                    }

                    errors++;
                  }
                }
              }

              if (data14.alignment !== undefined) {
                if (!validate68(data14.alignment, {
                  instancePath: instancePath + "/spanningCells/" + i0 + "/alignment",
                  parentData: data14,
                  parentDataProperty: "alignment",
                  rootData
                })) {
                  vErrors = vErrors === null ? validate68.errors : vErrors.concat(validate68.errors);
                  errors = vErrors.length;
                }
              }

              if (data14.verticalAlignment !== undefined) {
                if (!validate84(data14.verticalAlignment, {
                  instancePath: instancePath + "/spanningCells/" + i0 + "/verticalAlignment",
                  parentData: data14,
                  parentDataProperty: "verticalAlignment",
                  rootData
                })) {
                  vErrors = vErrors === null ? validate84.errors : vErrors.concat(validate84.errors);
                  errors = vErrors.length;
                }
              }

              if (data14.wrapWord !== undefined) {
                if (typeof data14.wrapWord !== "boolean") {
                  const err23 = {
                    instancePath: instancePath + "/spanningCells/" + i0 + "/wrapWord",
                    schemaPath: "#/properties/spanningCells/items/properties/wrapWord/type",
                    keyword: "type",
                    params: {
                      type: "boolean"
                    },
                    message: "must be boolean"
                  };

                  if (vErrors === null) {
                    vErrors = [err23];
                  } else {
                    vErrors.push(err23);
                  }

                  errors++;
                }
              }

              if (data14.truncate !== undefined) {
                let data22 = data14.truncate;

                if (!(typeof data22 == "number" && !(data22 % 1) && !isNaN(data22) && isFinite(data22))) {
                  const err24 = {
                    instancePath: instancePath + "/spanningCells/" + i0 + "/truncate",
                    schemaPath: "#/properties/spanningCells/items/properties/truncate/type",
                    keyword: "type",
                    params: {
                      type: "integer"
                    },
                    message: "must be integer"
                  };

                  if (vErrors === null) {
                    vErrors = [err24];
                  } else {
                    vErrors.push(err24);
                  }

                  errors++;
                }
              }

              if (data14.paddingLeft !== undefined) {
                let data23 = data14.paddingLeft;

                if (!(typeof data23 == "number" && !(data23 % 1) && !isNaN(data23) && isFinite(data23))) {
                  const err25 = {
                    instancePath: instancePath + "/spanningCells/" + i0 + "/paddingLeft",
                    schemaPath: "#/properties/spanningCells/items/properties/paddingLeft/type",
                    keyword: "type",
                    params: {
                      type: "integer"
                    },
                    message: "must be integer"
                  };

                  if (vErrors === null) {
                    vErrors = [err25];
                  } else {
                    vErrors.push(err25);
                  }

                  errors++;
                }
              }

              if (data14.paddingRight !== undefined) {
                let data24 = data14.paddingRight;

                if (!(typeof data24 == "number" && !(data24 % 1) && !isNaN(data24) && isFinite(data24))) {
                  const err26 = {
                    instancePath: instancePath + "/spanningCells/" + i0 + "/paddingRight",
                    schemaPath: "#/properties/spanningCells/items/properties/paddingRight/type",
                    keyword: "type",
                    params: {
                      type: "integer"
                    },
                    message: "must be integer"
                  };

                  if (vErrors === null) {
                    vErrors = [err26];
                  } else {
                    vErrors.push(err26);
                  }

                  errors++;
                }
              }
            } else {
              const err27 = {
                instancePath: instancePath + "/spanningCells/" + i0,
                schemaPath: "#/properties/spanningCells/items/type",
                keyword: "type",
                params: {
                  type: "object"
                },
                message: "must be object"
              };

              if (vErrors === null) {
                vErrors = [err27];
              } else {
                vErrors.push(err27);
              }

              errors++;
            }
          }
        } else {
          const err28 = {
            instancePath: instancePath + "/spanningCells",
            schemaPath: "#/properties/spanningCells/type",
            keyword: "type",
            params: {
              type: "array"
            },
            message: "must be array"
          };

          if (vErrors === null) {
            vErrors = [err28];
          } else {
            vErrors.push(err28);
          }

          errors++;
        }
      }
    } else {
      const err29 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err29];
      } else {
        vErrors.push(err29);
      }

      errors++;
    }

    validate43.errors = vErrors;
    return errors === 0;
  }

  exports["streamConfig.json"] = validate86;

  function validate87(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        if (!func8.call(schema15.properties, key0)) {
          const err0 = {
            instancePath,
            schemaPath: "#/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }

          errors++;
        }
      }

      if (data.topBody !== undefined) {
        if (!validate46(data.topBody, {
          instancePath: instancePath + "/topBody",
          parentData: data,
          parentDataProperty: "topBody",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.topJoin !== undefined) {
        if (!validate46(data.topJoin, {
          instancePath: instancePath + "/topJoin",
          parentData: data,
          parentDataProperty: "topJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.topLeft !== undefined) {
        if (!validate46(data.topLeft, {
          instancePath: instancePath + "/topLeft",
          parentData: data,
          parentDataProperty: "topLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.topRight !== undefined) {
        if (!validate46(data.topRight, {
          instancePath: instancePath + "/topRight",
          parentData: data,
          parentDataProperty: "topRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bottomBody !== undefined) {
        if (!validate46(data.bottomBody, {
          instancePath: instancePath + "/bottomBody",
          parentData: data,
          parentDataProperty: "bottomBody",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bottomJoin !== undefined) {
        if (!validate46(data.bottomJoin, {
          instancePath: instancePath + "/bottomJoin",
          parentData: data,
          parentDataProperty: "bottomJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bottomLeft !== undefined) {
        if (!validate46(data.bottomLeft, {
          instancePath: instancePath + "/bottomLeft",
          parentData: data,
          parentDataProperty: "bottomLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bottomRight !== undefined) {
        if (!validate46(data.bottomRight, {
          instancePath: instancePath + "/bottomRight",
          parentData: data,
          parentDataProperty: "bottomRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bodyLeft !== undefined) {
        if (!validate46(data.bodyLeft, {
          instancePath: instancePath + "/bodyLeft",
          parentData: data,
          parentDataProperty: "bodyLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bodyRight !== undefined) {
        if (!validate46(data.bodyRight, {
          instancePath: instancePath + "/bodyRight",
          parentData: data,
          parentDataProperty: "bodyRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.bodyJoin !== undefined) {
        if (!validate46(data.bodyJoin, {
          instancePath: instancePath + "/bodyJoin",
          parentData: data,
          parentDataProperty: "bodyJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.headerJoin !== undefined) {
        if (!validate46(data.headerJoin, {
          instancePath: instancePath + "/headerJoin",
          parentData: data,
          parentDataProperty: "headerJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinBody !== undefined) {
        if (!validate46(data.joinBody, {
          instancePath: instancePath + "/joinBody",
          parentData: data,
          parentDataProperty: "joinBody",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinLeft !== undefined) {
        if (!validate46(data.joinLeft, {
          instancePath: instancePath + "/joinLeft",
          parentData: data,
          parentDataProperty: "joinLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinRight !== undefined) {
        if (!validate46(data.joinRight, {
          instancePath: instancePath + "/joinRight",
          parentData: data,
          parentDataProperty: "joinRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinJoin !== undefined) {
        if (!validate46(data.joinJoin, {
          instancePath: instancePath + "/joinJoin",
          parentData: data,
          parentDataProperty: "joinJoin",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinMiddleUp !== undefined) {
        if (!validate46(data.joinMiddleUp, {
          instancePath: instancePath + "/joinMiddleUp",
          parentData: data,
          parentDataProperty: "joinMiddleUp",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinMiddleDown !== undefined) {
        if (!validate46(data.joinMiddleDown, {
          instancePath: instancePath + "/joinMiddleDown",
          parentData: data,
          parentDataProperty: "joinMiddleDown",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinMiddleLeft !== undefined) {
        if (!validate46(data.joinMiddleLeft, {
          instancePath: instancePath + "/joinMiddleLeft",
          parentData: data,
          parentDataProperty: "joinMiddleLeft",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }

      if (data.joinMiddleRight !== undefined) {
        if (!validate46(data.joinMiddleRight, {
          instancePath: instancePath + "/joinMiddleRight",
          parentData: data,
          parentDataProperty: "joinMiddleRight",
          rootData
        })) {
          vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
          errors = vErrors.length;
        }
      }
    } else {
      const err1 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    validate87.errors = vErrors;
    return errors === 0;
  }

  function validate109(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs1 = errors;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        if (!pattern0.test(key0)) {
          const err0 = {
            instancePath,
            schemaPath: "#/oneOf/0/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }

          errors++;
        }
      }

      for (const key1 in data) {
        if (pattern0.test(key1)) {
          if (!validate71(data[key1], {
            instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
            parentData: data,
            parentDataProperty: key1,
            rootData
          })) {
            vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
            errors = vErrors.length;
          }
        }
      }
    } else {
      const err1 = {
        instancePath,
        schemaPath: "#/oneOf/0/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    var _valid0 = _errs1 === errors;

    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }

    const _errs5 = errors;

    if (Array.isArray(data)) {
      const len0 = data.length;

      for (let i0 = 0; i0 < len0; i0++) {
        if (!validate71(data[i0], {
          instancePath: instancePath + "/" + i0,
          parentData: data,
          parentDataProperty: i0,
          rootData
        })) {
          vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
          errors = vErrors.length;
        }
      }
    } else {
      const err2 = {
        instancePath,
        schemaPath: "#/oneOf/1/type",
        keyword: "type",
        params: {
          type: "array"
        },
        message: "must be array"
      };

      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }

      errors++;
    }

    var _valid0 = _errs5 === errors;

    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }

    if (!valid0) {
      const err3 = {
        instancePath,
        schemaPath: "#/oneOf",
        keyword: "oneOf",
        params: {
          passingSchemas: passing0
        },
        message: "must match exactly one schema in oneOf"
      };

      if (vErrors === null) {
        vErrors = [err3];
      } else {
        vErrors.push(err3);
      }

      errors++;
    } else {
      errors = _errs0;

      if (vErrors !== null) {
        if (_errs0) {
          vErrors.length = _errs0;
        } else {
          vErrors = null;
        }
      }
    }

    validate109.errors = vErrors;
    return errors === 0;
  }

  function validate113(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      for (const key0 in data) {
        if (!(key0 === "alignment" || key0 === "verticalAlignment" || key0 === "width" || key0 === "wrapWord" || key0 === "truncate" || key0 === "paddingLeft" || key0 === "paddingRight")) {
          const err0 = {
            instancePath,
            schemaPath: "#/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }

          errors++;
        }
      }

      if (data.alignment !== undefined) {
        if (!validate72(data.alignment, {
          instancePath: instancePath + "/alignment",
          parentData: data,
          parentDataProperty: "alignment",
          rootData
        })) {
          vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
          errors = vErrors.length;
        }
      }

      if (data.verticalAlignment !== undefined) {
        if (!validate74(data.verticalAlignment, {
          instancePath: instancePath + "/verticalAlignment",
          parentData: data,
          parentDataProperty: "verticalAlignment",
          rootData
        })) {
          vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
          errors = vErrors.length;
        }
      }

      if (data.width !== undefined) {
        let data2 = data.width;

        if (!(typeof data2 == "number" && !(data2 % 1) && !isNaN(data2) && isFinite(data2))) {
          const err1 = {
            instancePath: instancePath + "/width",
            schemaPath: "#/properties/width/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }

          errors++;
        }

        if (typeof data2 == "number" && isFinite(data2)) {
          if (data2 < 1 || isNaN(data2)) {
            const err2 = {
              instancePath: instancePath + "/width",
              schemaPath: "#/properties/width/minimum",
              keyword: "minimum",
              params: {
                comparison: ">=",
                limit: 1
              },
              message: "must be >= 1"
            };

            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }

            errors++;
          }
        }
      }

      if (data.wrapWord !== undefined) {
        if (typeof data.wrapWord !== "boolean") {
          const err3 = {
            instancePath: instancePath + "/wrapWord",
            schemaPath: "#/properties/wrapWord/type",
            keyword: "type",
            params: {
              type: "boolean"
            },
            message: "must be boolean"
          };

          if (vErrors === null) {
            vErrors = [err3];
          } else {
            vErrors.push(err3);
          }

          errors++;
        }
      }

      if (data.truncate !== undefined) {
        let data4 = data.truncate;

        if (!(typeof data4 == "number" && !(data4 % 1) && !isNaN(data4) && isFinite(data4))) {
          const err4 = {
            instancePath: instancePath + "/truncate",
            schemaPath: "#/properties/truncate/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err4];
          } else {
            vErrors.push(err4);
          }

          errors++;
        }
      }

      if (data.paddingLeft !== undefined) {
        let data5 = data.paddingLeft;

        if (!(typeof data5 == "number" && !(data5 % 1) && !isNaN(data5) && isFinite(data5))) {
          const err5 = {
            instancePath: instancePath + "/paddingLeft",
            schemaPath: "#/properties/paddingLeft/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err5];
          } else {
            vErrors.push(err5);
          }

          errors++;
        }
      }

      if (data.paddingRight !== undefined) {
        let data6 = data.paddingRight;

        if (!(typeof data6 == "number" && !(data6 % 1) && !isNaN(data6) && isFinite(data6))) {
          const err6 = {
            instancePath: instancePath + "/paddingRight",
            schemaPath: "#/properties/paddingRight/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }

          errors++;
        }
      }
    } else {
      const err7 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err7];
      } else {
        vErrors.push(err7);
      }

      errors++;
    }

    validate113.errors = vErrors;
    return errors === 0;
  }

  function validate86(data, {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data
  } = {}) {
    let vErrors = null;
    let errors = 0;

    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.columnDefault === undefined) {
        const err0 = {
          instancePath,
          schemaPath: "#/required",
          keyword: "required",
          params: {
            missingProperty: "columnDefault"
          },
          message: "must have required property '" + "columnDefault" + "'"
        };

        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }

        errors++;
      }

      if (data.columnCount === undefined) {
        const err1 = {
          instancePath,
          schemaPath: "#/required",
          keyword: "required",
          params: {
            missingProperty: "columnCount"
          },
          message: "must have required property '" + "columnCount" + "'"
        };

        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }

        errors++;
      }

      for (const key0 in data) {
        if (!(key0 === "border" || key0 === "columns" || key0 === "columnDefault" || key0 === "columnCount" || key0 === "drawVerticalLine")) {
          const err2 = {
            instancePath,
            schemaPath: "#/additionalProperties",
            keyword: "additionalProperties",
            params: {
              additionalProperty: key0
            },
            message: "must NOT have additional properties"
          };

          if (vErrors === null) {
            vErrors = [err2];
          } else {
            vErrors.push(err2);
          }

          errors++;
        }
      }

      if (data.border !== undefined) {
        if (!validate87(data.border, {
          instancePath: instancePath + "/border",
          parentData: data,
          parentDataProperty: "border",
          rootData
        })) {
          vErrors = vErrors === null ? validate87.errors : vErrors.concat(validate87.errors);
          errors = vErrors.length;
        }
      }

      if (data.columns !== undefined) {
        if (!validate109(data.columns, {
          instancePath: instancePath + "/columns",
          parentData: data,
          parentDataProperty: "columns",
          rootData
        })) {
          vErrors = vErrors === null ? validate109.errors : vErrors.concat(validate109.errors);
          errors = vErrors.length;
        }
      }

      if (data.columnDefault !== undefined) {
        if (!validate113(data.columnDefault, {
          instancePath: instancePath + "/columnDefault",
          parentData: data,
          parentDataProperty: "columnDefault",
          rootData
        })) {
          vErrors = vErrors === null ? validate113.errors : vErrors.concat(validate113.errors);
          errors = vErrors.length;
        }
      }

      if (data.columnCount !== undefined) {
        let data3 = data.columnCount;

        if (!(typeof data3 == "number" && !(data3 % 1) && !isNaN(data3) && isFinite(data3))) {
          const err3 = {
            instancePath: instancePath + "/columnCount",
            schemaPath: "#/properties/columnCount/type",
            keyword: "type",
            params: {
              type: "integer"
            },
            message: "must be integer"
          };

          if (vErrors === null) {
            vErrors = [err3];
          } else {
            vErrors.push(err3);
          }

          errors++;
        }

        if (typeof data3 == "number" && isFinite(data3)) {
          if (data3 < 1 || isNaN(data3)) {
            const err4 = {
              instancePath: instancePath + "/columnCount",
              schemaPath: "#/properties/columnCount/minimum",
              keyword: "minimum",
              params: {
                comparison: ">=",
                limit: 1
              },
              message: "must be >= 1"
            };

            if (vErrors === null) {
              vErrors = [err4];
            } else {
              vErrors.push(err4);
            }

            errors++;
          }
        }
      }

      if (data.drawVerticalLine !== undefined) {
        if (typeof data.drawVerticalLine != "function") {
          const err5 = {
            instancePath: instancePath + "/drawVerticalLine",
            schemaPath: "#/properties/drawVerticalLine/typeof",
            keyword: "typeof",
            params: {},
            message: "must pass \"typeof\" keyword validation"
          };

          if (vErrors === null) {
            vErrors = [err5];
          } else {
            vErrors.push(err5);
          }

          errors++;
        }
      }
    } else {
      const err6 = {
        instancePath,
        schemaPath: "#/type",
        keyword: "type",
        params: {
          type: "object"
        },
        message: "must be object"
      };

      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }

      errors++;
    }

    validate86.errors = vErrors;
    return errors === 0;
  }
  });

  var validateConfig_1 = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validateConfig = void 0;

  const validators_1 = __importDefault(validators);

  const validateConfig = (schemaId, config) => {
    const validate = validators_1.default[schemaId];

    if (!validate(config) && validate.errors) {
      // eslint-disable-next-line promise/prefer-await-to-callbacks
      const errors = validate.errors.map(error => {
        return {
          message: error.message,
          params: error.params,
          schemaPath: error.schemaPath
        };
      });
      /* eslint-disable no-console */

      console.log('config', config);
      console.log('errors', errors);
      /* eslint-enable no-console */

      throw new Error('Invalid config.');
    }
  };

  exports.validateConfig = validateConfig;
  });

  var makeStreamConfig_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.makeStreamConfig = void 0;




  /**
   * Creates a configuration for every column using default
   * values for the missing configuration properties.
   */


  const makeColumnsConfig = (columnCount, columns = {}, columnDefault) => {
    return Array.from({
      length: columnCount
    }).map((_, index) => {
      return {
        alignment: 'left',
        paddingLeft: 1,
        paddingRight: 1,
        truncate: Number.POSITIVE_INFINITY,
        verticalAlignment: 'top',
        wrapWord: false,
        ...columnDefault,
        ...columns[index]
      };
    });
  };
  /**
   * Makes a new configuration object out of the userConfig object
   * using default values for the missing configuration properties.
   */


  const makeStreamConfig = config => {
    (0, validateConfig_1.validateConfig)('streamConfig.json', config);

    if (config.columnDefault.width === undefined) {
      throw new Error('Must provide config.columnDefault.width when creating a stream.');
    }

    return {
      drawVerticalLine: () => {
        return true;
      },
      ...config,
      border: (0, utils$5.makeBorderConfig)(config.border),
      columns: makeColumnsConfig(config.columnCount, config.columns, config.columnDefault)
    };
  };

  exports.makeStreamConfig = makeStreamConfig;
  });

  var mapDataUsingRowHeights_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mapDataUsingRowHeights = exports.padCellVertically = void 0;





  const createEmptyStrings = length => {
    return new Array(length).fill('');
  };

  const padCellVertically = (lines, rowHeight, verticalAlignment) => {
    const availableLines = rowHeight - lines.length;

    if (verticalAlignment === 'top') {
      return [...lines, ...createEmptyStrings(availableLines)];
    }

    if (verticalAlignment === 'bottom') {
      return [...createEmptyStrings(availableLines), ...lines];
    }

    return [...createEmptyStrings(Math.floor(availableLines / 2)), ...lines, ...createEmptyStrings(Math.ceil(availableLines / 2))];
  };

  exports.padCellVertically = padCellVertically;

  const mapDataUsingRowHeights = (unmappedRows, rowHeights, config) => {
    const nColumns = unmappedRows[0].length;
    const mappedRows = unmappedRows.map((unmappedRow, unmappedRowIndex) => {
      const outputRowHeight = rowHeights[unmappedRowIndex];
      const outputRow = Array.from({
        length: outputRowHeight
      }, () => {
        return new Array(nColumns).fill('');
      });
      unmappedRow.forEach((cell, cellIndex) => {
        var _a;

        const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({
          col: cellIndex,
          row: unmappedRowIndex
        });

        if (containingRange) {
          containingRange.extractCellContent(unmappedRowIndex).forEach((cellLine, cellLineIndex) => {
            outputRow[cellLineIndex][cellIndex] = cellLine;
          });
          return;
        }

        const cellLines = (0, wrapCell_1.wrapCell)(cell, config.columns[cellIndex].width, config.columns[cellIndex].wrapWord);
        const paddedCellLines = (0, exports.padCellVertically)(cellLines, outputRowHeight, config.columns[cellIndex].verticalAlignment);
        paddedCellLines.forEach((cellLine, cellLineIndex) => {
          outputRow[cellLineIndex][cellIndex] = cellLine;
        });
      });
      return outputRow;
    });
    return (0, utils$5.flatten)(mappedRows);
  };

  exports.mapDataUsingRowHeights = mapDataUsingRowHeights;
  });

  var padTableData_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.padTableData = exports.padString = void 0;

  const padString = (input, paddingLeft, paddingRight) => {
    return ' '.repeat(paddingLeft) + input + ' '.repeat(paddingRight);
  };

  exports.padString = padString;

  const padTableData = (rows, config) => {
    return rows.map((cells, rowIndex) => {
      return cells.map((cell, cellIndex) => {
        var _a;

        const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({
          col: cellIndex,
          row: rowIndex
        }, {
          mapped: true
        });

        if (containingRange) {
          return cell;
        }

        const {
          paddingLeft,
          paddingRight
        } = config.columns[cellIndex];
        return (0, exports.padString)(cell, paddingLeft, paddingRight);
      });
    });
  };

  exports.padTableData = padTableData;
  });

  var stringifyTableData_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.stringifyTableData = void 0;



  const stringifyTableData = rows => {
    return rows.map(cells => {
      return cells.map(cell => {
        return (0, utils$5.normalizeString)(String(cell));
      });
    });
  };

  exports.stringifyTableData = stringifyTableData;
  });

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  var lodash_truncate = createCommonjsModule(function (module, exports) {
  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';
  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;
  /** `Object#toString` result references. */

  var regexpTag = '[object RegExp]',
      symbolTag = '[object Symbol]';
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to match `RegExp` flags from their coerced string values. */

  var reFlags = /\w*$/;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Used to compose unicode character classes. */

  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
      rsComboSymbolsRange = '\\u20d0-\\u20f0',
      rsVarRange = '\\ufe0e\\ufe0f';
  /** Used to compose unicode capture groups. */

  var rsAstral = '[' + rsAstralRange + ']',
      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ = '\\u200d';
  /** Used to compose unicode regexes. */

  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      return freeProcess && freeProcess.binding('util');
    } catch (e) {}
  }();
  /* Node.js helper references. */


  var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */

  var asciiSize = baseProperty('length');
  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function asciiToArray(string) {
    return string.split('');
  }
  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */


  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */


  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */


  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */


  function stringSize(string) {
    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }
  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */


  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */


  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;

    while (reUnicode.test(string)) {
      result++;
    }

    return result;
  }
  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */


  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  /** Used for built-in method references. */


  var objectProto = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString = objectProto.toString;
  /** Built-in value references. */

  var Symbol = root.Symbol;
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;
  /**
   * The base implementation of `_.isRegExp` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   */

  function baseIsRegExp(value) {
    return isObject(value) && objectToString.call(value) == regexpTag;
  }
  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */


  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */


  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */


  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  /**
   * Checks if `value` is classified as a `RegExp` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   * @example
   *
   * _.isRegExp(/abc/);
   * // => true
   *
   * _.isRegExp('/abc/');
   * // => false
   */


  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */


  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber(value);

    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }
  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */


  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */


  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */


  function toString(value) {
    return value == null ? '' : baseToString(value);
  }
  /**
   * Truncates `string` if it's longer than the given maximum string length.
   * The last characters of the truncated string are replaced with the omission
   * string which defaults to "...".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to truncate.
   * @param {Object} [options={}] The options object.
   * @param {number} [options.length=30] The maximum string length.
   * @param {string} [options.omission='...'] The string to indicate text is omitted.
   * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
   * @returns {string} Returns the truncated string.
   * @example
   *
   * _.truncate('hi-diddly-ho there, neighborino');
   * // => 'hi-diddly-ho there, neighbo...'
   *
   * _.truncate('hi-diddly-ho there, neighborino', {
   *   'length': 24,
   *   'separator': ' '
   * });
   * // => 'hi-diddly-ho there,...'
   *
   * _.truncate('hi-diddly-ho there, neighborino', {
   *   'length': 24,
   *   'separator': /,? +/
   * });
   * // => 'hi-diddly-ho there...'
   *
   * _.truncate('hi-diddly-ho there, neighborino', {
   *   'omission': ' [...]'
   * });
   * // => 'hi-diddly-ho there, neig [...]'
   */


  function truncate(string, options) {
    var length = DEFAULT_TRUNC_LENGTH,
        omission = DEFAULT_TRUNC_OMISSION;

    if (isObject(options)) {
      var separator = 'separator' in options ? options.separator : separator;
      length = 'length' in options ? toInteger(options.length) : length;
      omission = 'omission' in options ? baseToString(options.omission) : omission;
    }

    string = toString(string);
    var strLength = string.length;

    if (hasUnicode(string)) {
      var strSymbols = stringToArray(string);
      strLength = strSymbols.length;
    }

    if (length >= strLength) {
      return string;
    }

    var end = length - stringSize(omission);

    if (end < 1) {
      return omission;
    }

    var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);

    if (separator === undefined) {
      return result + omission;
    }

    if (strSymbols) {
      end += result.length - end;
    }

    if (isRegExp(separator)) {
      if (string.slice(end).search(separator)) {
        var match,
            substring = result;

        if (!separator.global) {
          separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
        }

        separator.lastIndex = 0;

        while (match = separator.exec(substring)) {
          var newEnd = match.index;
        }

        result = result.slice(0, newEnd === undefined ? end : newEnd);
      }
    } else if (string.indexOf(baseToString(separator), end) != end) {
      var index = result.lastIndexOf(separator);

      if (index > -1) {
        result = result.slice(0, index);
      }
    }

    return result + omission;
  }

  module.exports = truncate;
  });

  var truncateTableData_1 = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.truncateTableData = exports.truncateString = void 0;

  const lodash_truncate_1 = __importDefault(lodash_truncate);

  const truncateString = (input, length) => {
    return (0, lodash_truncate_1.default)(input, {
      length,
      omission: '…'
    });
  };

  exports.truncateString = truncateString;
  /**
   * @todo Make it work with ASCII content.
   */

  const truncateTableData = (rows, truncates) => {
    return rows.map(cells => {
      return cells.map((cell, cellIndex) => {
        return (0, exports.truncateString)(cell, truncates[cellIndex]);
      });
    });
  };

  exports.truncateTableData = truncateTableData;
  });

  var createStream_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createStream = void 0;





















  const prepareData = (data, config) => {
    let rows = (0, stringifyTableData_1.stringifyTableData)(data);
    rows = (0, truncateTableData_1.truncateTableData)(rows, (0, utils$5.extractTruncates)(config));
    const rowHeights = (0, calculateRowHeights_1.calculateRowHeights)(rows, config);
    rows = (0, mapDataUsingRowHeights_1.mapDataUsingRowHeights)(rows, rowHeights, config);
    rows = (0, alignTableData_1.alignTableData)(rows, config);
    rows = (0, padTableData_1.padTableData)(rows, config);
    return rows;
  };

  const create = (row, columnWidths, config) => {
    const rows = prepareData([row], config);
    const body = rows.map(literalRow => {
      return (0, drawRow_1.drawRow)(literalRow, config);
    }).join('');
    let output;
    output = '';
    output += (0, drawBorder_1.drawBorderTop)(columnWidths, config);
    output += body;
    output += (0, drawBorder_1.drawBorderBottom)(columnWidths, config);
    output = output.trimEnd();
    process.stdout.write(output);
  };

  const append = (row, columnWidths, config) => {
    const rows = prepareData([row], config);
    const body = rows.map(literalRow => {
      return (0, drawRow_1.drawRow)(literalRow, config);
    }).join('');
    let output = '';
    const bottom = (0, drawBorder_1.drawBorderBottom)(columnWidths, config);

    if (bottom !== '\n') {
      output = '\r\u001B[K';
    }

    output += (0, drawBorder_1.drawBorderJoin)(columnWidths, config);
    output += body;
    output += bottom;
    output = output.trimEnd();
    process.stdout.write(output);
  };

  const createStream = userConfig => {
    const config = (0, makeStreamConfig_1.makeStreamConfig)(userConfig);
    const columnWidths = Object.values(config.columns).map(column => {
      return column.width + column.paddingLeft + column.paddingRight;
    });
    let empty = true;
    return {
      write: row => {
        if (row.length !== config.columnCount) {
          throw new Error('Row cell count does not match the config.columnCount.');
        }

        if (empty) {
          empty = false;
          create(row, columnWidths, config);
        } else {
          append(row, columnWidths, config);
        }
      }
    };
  };

  exports.createStream = createStream;
  });

  var calculateOutputColumnWidths_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.calculateOutputColumnWidths = void 0;

  const calculateOutputColumnWidths = config => {
    return config.columns.map(col => {
      return col.paddingLeft + col.width + col.paddingRight;
    });
  };

  exports.calculateOutputColumnWidths = calculateOutputColumnWidths;
  });

  var drawTable_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.drawTable = void 0;









  const drawTable = (rows, outputColumnWidths, rowHeights, config) => {
    const {
      drawHorizontalLine,
      singleLine
    } = config;
    const contents = (0, utils$5.groupBySizes)(rows, rowHeights).map((group, groupIndex) => {
      return group.map(row => {
        return (0, drawRow_1.drawRow)(row, { ...config,
          rowIndex: groupIndex
        });
      }).join('');
    });
    return (0, drawContent_1.drawContent)({
      contents,
      drawSeparator: (index, size) => {
        // Top/bottom border
        if (index === 0 || index === size) {
          return drawHorizontalLine(index, size);
        }

        return !singleLine && drawHorizontalLine(index, size);
      },
      elementType: 'row',
      rowIndex: -1,
      separatorGetter: (0, drawBorder_1.createTableBorderGetter)(outputColumnWidths, { ...config,
        rowCount: contents.length
      }),
      spanningCellManager: config.spanningCellManager
    });
  };

  exports.drawTable = drawTable;
  });

  var injectHeaderConfig_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.injectHeaderConfig = void 0;

  const injectHeaderConfig = (rows, config) => {
    var _a;

    let spanningCellConfig = (_a = config.spanningCells) !== null && _a !== void 0 ? _a : [];
    const headerConfig = config.header;
    const adjustedRows = [...rows];

    if (headerConfig) {
      spanningCellConfig = spanningCellConfig.map(({
        row,
        ...rest
      }) => {
        return { ...rest,
          row: row + 1
        };
      });
      const {
        content,
        ...headerStyles
      } = headerConfig;
      spanningCellConfig.unshift({
        alignment: 'center',
        col: 0,
        colSpan: rows[0].length,
        paddingLeft: 1,
        paddingRight: 1,
        row: 0,
        wrapWord: false,
        ...headerStyles
      });
      adjustedRows.unshift([content, ...Array.from({
        length: rows[0].length - 1
      }).fill('')]);
    }

    return [adjustedRows, spanningCellConfig];
  };

  exports.injectHeaderConfig = injectHeaderConfig;
  });

  var calculateMaximumColumnWidths_1 = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.calculateMaximumColumnWidths = exports.calculateMaximumCellWidth = void 0;

  const string_width_1 = __importDefault(stringWidth_1);



  const calculateMaximumCellWidth = cell => {
    return Math.max(...cell.split('\n').map(string_width_1.default));
  };

  exports.calculateMaximumCellWidth = calculateMaximumCellWidth;
  /**
   * Produces an array of values that describe the largest value length (width) in every column.
   */

  const calculateMaximumColumnWidths = (rows, spanningCellConfigs = []) => {
    const columnWidths = new Array(rows[0].length).fill(0);
    const rangeCoordinates = spanningCellConfigs.map(utils$5.calculateRangeCoordinate);

    const isSpanningCell = (rowIndex, columnIndex) => {
      return rangeCoordinates.some(rangeCoordinate => {
        return (0, utils$5.isCellInRange)({
          col: columnIndex,
          row: rowIndex
        }, rangeCoordinate);
      });
    };

    rows.forEach((row, rowIndex) => {
      row.forEach((cell, cellIndex) => {
        if (isSpanningCell(rowIndex, cellIndex)) {
          return;
        }

        columnWidths[cellIndex] = Math.max(columnWidths[cellIndex], (0, exports.calculateMaximumCellWidth)(cell));
      });
    });
    return columnWidths;
  };

  exports.calculateMaximumColumnWidths = calculateMaximumColumnWidths;
  });

  var alignSpanningCell = createCommonjsModule(function (module, exports) {

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.alignVerticalRangeContent = exports.wrapRangeContent = void 0;

  const string_width_1 = __importDefault(stringWidth_1);












  /**
   * Fill content into all cells in range in order to calculate total height
   */


  const wrapRangeContent = (rangeConfig, rangeWidth, context) => {
    const {
      topLeft,
      paddingRight,
      paddingLeft,
      truncate,
      wrapWord,
      alignment
    } = rangeConfig;
    const originalContent = context.rows[topLeft.row][topLeft.col];
    const contentWidth = rangeWidth - paddingLeft - paddingRight;
    return (0, wrapCell_1.wrapCell)((0, truncateTableData_1.truncateString)(originalContent, truncate), contentWidth, wrapWord).map(line => {
      const alignedLine = (0, alignString_1.alignString)(line, contentWidth, alignment);
      return (0, padTableData_1.padString)(alignedLine, paddingLeft, paddingRight);
    });
  };

  exports.wrapRangeContent = wrapRangeContent;

  const alignVerticalRangeContent = (range, content, context) => {
    const {
      rows,
      drawHorizontalLine,
      rowHeights
    } = context;
    const {
      topLeft,
      bottomRight,
      verticalAlignment
    } = range; // They are empty before calculateRowHeights function run

    if (rowHeights.length === 0) {
      return [];
    }

    const totalCellHeight = (0, utils$5.sumArray)(rowHeights.slice(topLeft.row, bottomRight.row + 1));
    const totalBorderHeight = bottomRight.row - topLeft.row;
    const hiddenHorizontalBorderCount = (0, utils$5.sequence)(topLeft.row + 1, bottomRight.row).filter(horizontalBorderIndex => {
      return !drawHorizontalLine(horizontalBorderIndex, rows.length);
    }).length;
    const availableRangeHeight = totalCellHeight + totalBorderHeight - hiddenHorizontalBorderCount;
    return (0, mapDataUsingRowHeights_1.padCellVertically)(content, availableRangeHeight, verticalAlignment).map(line => {
      if (line.length === 0) {
        return ' '.repeat((0, string_width_1.default)(content[0]));
      }

      return line;
    });
  };

  exports.alignVerticalRangeContent = alignVerticalRangeContent;
  });

  var calculateSpanningCellWidth_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.calculateSpanningCellWidth = void 0;



  const calculateSpanningCellWidth = (rangeConfig, dependencies) => {
    const {
      columnsConfig,
      drawVerticalLine
    } = dependencies;
    const {
      topLeft,
      bottomRight
    } = rangeConfig;
    const totalWidth = (0, utils$5.sumArray)(columnsConfig.slice(topLeft.col, bottomRight.col + 1).map(({
      width
    }) => {
      return width;
    }));
    const totalPadding = topLeft.col === bottomRight.col ? columnsConfig[topLeft.col].paddingRight + columnsConfig[bottomRight.col].paddingLeft : (0, utils$5.sumArray)(columnsConfig.slice(topLeft.col, bottomRight.col + 1).map(({
      paddingLeft,
      paddingRight
    }) => {
      return paddingLeft + paddingRight;
    }));
    const totalBorderWidths = bottomRight.col - topLeft.col;
    const totalHiddenVerticalBorders = (0, utils$5.sequence)(topLeft.col + 1, bottomRight.col).filter(verticalBorderIndex => {
      return !drawVerticalLine(verticalBorderIndex, columnsConfig.length);
    }).length;
    return totalWidth + totalPadding + totalBorderWidths - totalHiddenVerticalBorders;
  };

  exports.calculateSpanningCellWidth = calculateSpanningCellWidth;
  });

  var makeRangeConfig_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.makeRangeConfig = void 0;



  const makeRangeConfig = (spanningCellConfig, columnsConfig) => {
    var _a;

    const {
      topLeft,
      bottomRight
    } = (0, utils$5.calculateRangeCoordinate)(spanningCellConfig);
    const cellConfig = { ...columnsConfig[topLeft.col],
      ...spanningCellConfig,
      paddingRight: (_a = spanningCellConfig.paddingRight) !== null && _a !== void 0 ? _a : columnsConfig[bottomRight.col].paddingRight
    };
    return { ...cellConfig,
      bottomRight,
      topLeft
    };
  };

  exports.makeRangeConfig = makeRangeConfig;
  });

  var spanningCellManager = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createSpanningCellManager = void 0;









  const findRangeConfig = (cell, rangeConfigs) => {
    return rangeConfigs.find(rangeCoordinate => {
      return (0, utils$5.isCellInRange)(cell, rangeCoordinate);
    });
  };

  const getContainingRange = (rangeConfig, context) => {
    const width = (0, calculateSpanningCellWidth_1.calculateSpanningCellWidth)(rangeConfig, context);
    const wrappedContent = (0, alignSpanningCell.wrapRangeContent)(rangeConfig, width, context);
    const alignedContent = (0, alignSpanningCell.alignVerticalRangeContent)(rangeConfig, wrappedContent, context);

    const getCellContent = rowIndex => {
      const {
        topLeft
      } = rangeConfig;
      const {
        drawHorizontalLine,
        rowHeights
      } = context;
      const totalWithinHorizontalBorderHeight = rowIndex - topLeft.row;
      const totalHiddenHorizontalBorderHeight = (0, utils$5.sequence)(topLeft.row + 1, rowIndex).filter(index => {
        /* istanbul ignore next */
        return !(drawHorizontalLine === null || drawHorizontalLine === void 0 ? void 0 : drawHorizontalLine(index, rowHeights.length));
      }).length;
      const offset = (0, utils$5.sumArray)(rowHeights.slice(topLeft.row, rowIndex)) + totalWithinHorizontalBorderHeight - totalHiddenHorizontalBorderHeight;
      return alignedContent.slice(offset, offset + rowHeights[rowIndex]);
    };

    const getBorderContent = borderIndex => {
      const {
        topLeft
      } = rangeConfig;
      const offset = (0, utils$5.sumArray)(context.rowHeights.slice(topLeft.row, borderIndex)) + (borderIndex - topLeft.row - 1);
      return alignedContent[offset];
    };

    return { ...rangeConfig,
      extractBorderContent: getBorderContent,
      extractCellContent: getCellContent,
      height: wrappedContent.length,
      width
    };
  };

  const inSameRange = (cell1, cell2, ranges) => {
    const range1 = findRangeConfig(cell1, ranges);
    const range2 = findRangeConfig(cell2, ranges);

    if (range1 && range2) {
      return (0, utils$5.areCellEqual)(range1.topLeft, range2.topLeft);
    }

    return false;
  };

  const hashRange = range => {
    const {
      row,
      col
    } = range.topLeft;
    return `${row}/${col}`;
  };

  const createSpanningCellManager = parameters => {
    const {
      spanningCellConfigs,
      columnsConfig
    } = parameters;
    const ranges = spanningCellConfigs.map(config => {
      return (0, makeRangeConfig_1.makeRangeConfig)(config, columnsConfig);
    });
    const rangeCache = {};
    let rowHeights = [];
    return {
      getContainingRange: (cell, options) => {
        var _a;

        const originalRow = (options === null || options === void 0 ? void 0 : options.mapped) ? (0, utils$5.findOriginalRowIndex)(rowHeights, cell.row) : cell.row;
        const range = findRangeConfig({ ...cell,
          row: originalRow
        }, ranges);

        if (!range) {
          return undefined;
        }

        if (rowHeights.length === 0) {
          return getContainingRange(range, { ...parameters,
            rowHeights
          });
        }

        const hash = hashRange(range);
        (_a = rangeCache[hash]) !== null && _a !== void 0 ? _a : rangeCache[hash] = getContainingRange(range, { ...parameters,
          rowHeights
        });
        return rangeCache[hash];
      },
      inSameRange: (cell1, cell2) => {
        return inSameRange(cell1, cell2, ranges);
      },
      rowHeights,
      setRowHeights: _rowHeights => {
        rowHeights = _rowHeights;
      }
    };
  };

  exports.createSpanningCellManager = createSpanningCellManager;
  });

  var validateSpanningCellConfig_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validateSpanningCellConfig = void 0;



  const inRange = (start, end, value) => {
    return start <= value && value <= end;
  };

  const validateSpanningCellConfig = (rows, configs) => {
    const [nRow, nCol] = [rows.length, rows[0].length];
    configs.forEach((config, configIndex) => {
      const {
        colSpan,
        rowSpan
      } = config;

      if (colSpan === undefined && rowSpan === undefined) {
        throw new Error(`Expect at least colSpan or rowSpan is provided in config.spanningCells[${configIndex}]`);
      }

      if (colSpan !== undefined && colSpan < 1) {
        throw new Error(`Expect colSpan is not equal zero, instead got: ${colSpan} in config.spanningCells[${configIndex}]`);
      }

      if (rowSpan !== undefined && rowSpan < 1) {
        throw new Error(`Expect rowSpan is not equal zero, instead got: ${rowSpan} in config.spanningCells[${configIndex}]`);
      }
    });
    const rangeCoordinates = configs.map(utils$5.calculateRangeCoordinate);
    rangeCoordinates.forEach(({
      topLeft,
      bottomRight
    }, rangeIndex) => {
      if (!inRange(0, nCol - 1, topLeft.col) || !inRange(0, nRow - 1, topLeft.row) || !inRange(0, nCol - 1, bottomRight.col) || !inRange(0, nRow - 1, bottomRight.row)) {
        throw new Error(`Some cells in config.spanningCells[${rangeIndex}] are out of the table`);
      }
    });
    const configOccupy = Array.from({
      length: nRow
    }, () => {
      return Array.from({
        length: nCol
      });
    });
    rangeCoordinates.forEach(({
      topLeft,
      bottomRight
    }, rangeIndex) => {
      (0, utils$5.sequence)(topLeft.row, bottomRight.row).forEach(row => {
        (0, utils$5.sequence)(topLeft.col, bottomRight.col).forEach(col => {
          if (configOccupy[row][col] !== undefined) {
            throw new Error(`Spanning cells in config.spanningCells[${configOccupy[row][col]}] and config.spanningCells[${rangeIndex}] are overlap each other`);
          }

          configOccupy[row][col] = rangeIndex;
        });
      });
    });
  };

  exports.validateSpanningCellConfig = validateSpanningCellConfig;
  });

  var makeTableConfig_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.makeTableConfig = void 0;










  /**
   * Creates a configuration for every column using default
   * values for the missing configuration properties.
   */


  const makeColumnsConfig = (rows, columns, columnDefault, spanningCellConfigs) => {
    const columnWidths = (0, calculateMaximumColumnWidths_1.calculateMaximumColumnWidths)(rows, spanningCellConfigs);
    return rows[0].map((_, columnIndex) => {
      return {
        alignment: 'left',
        paddingLeft: 1,
        paddingRight: 1,
        truncate: Number.POSITIVE_INFINITY,
        verticalAlignment: 'top',
        width: columnWidths[columnIndex],
        wrapWord: false,
        ...columnDefault,
        ...(columns === null || columns === void 0 ? void 0 : columns[columnIndex])
      };
    });
  };
  /**
   * Makes a new configuration object out of the userConfig object
   * using default values for the missing configuration properties.
   */


  const makeTableConfig = (rows, config = {}, injectedSpanningCellConfig) => {
    var _a, _b, _c, _d, _e;

    (0, validateConfig_1.validateConfig)('config.json', config);
    (0, validateSpanningCellConfig_1.validateSpanningCellConfig)(rows, (_a = config.spanningCells) !== null && _a !== void 0 ? _a : []);
    const spanningCellConfigs = (_b = injectedSpanningCellConfig !== null && injectedSpanningCellConfig !== void 0 ? injectedSpanningCellConfig : config.spanningCells) !== null && _b !== void 0 ? _b : [];
    const columnsConfig = makeColumnsConfig(rows, config.columns, config.columnDefault, spanningCellConfigs);
    const drawVerticalLine = (_c = config.drawVerticalLine) !== null && _c !== void 0 ? _c : () => {
      return true;
    };
    const drawHorizontalLine = (_d = config.drawHorizontalLine) !== null && _d !== void 0 ? _d : () => {
      return true;
    };
    return { ...config,
      border: (0, utils$5.makeBorderConfig)(config.border),
      columns: columnsConfig,
      drawHorizontalLine,
      drawVerticalLine,
      singleLine: (_e = config.singleLine) !== null && _e !== void 0 ? _e : false,
      spanningCellManager: (0, spanningCellManager.createSpanningCellManager)({
        columnsConfig,
        drawHorizontalLine,
        drawVerticalLine,
        rows,
        spanningCellConfigs
      })
    };
  };

  exports.makeTableConfig = makeTableConfig;
  });

  var validateTableData_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validateTableData = void 0;



  const validateTableData = rows => {
    if (!Array.isArray(rows)) {
      throw new TypeError('Table data must be an array.');
    }

    if (rows.length === 0) {
      throw new Error('Table must define at least one row.');
    }

    if (rows[0].length === 0) {
      throw new Error('Table must define at least one column.');
    }

    const columnNumber = rows[0].length;

    for (const row of rows) {
      if (!Array.isArray(row)) {
        throw new TypeError('Table row data must be an array.');
      }

      if (row.length !== columnNumber) {
        throw new Error('Table must have a consistent number of cells.');
      }

      for (const cell of row) {
        // eslint-disable-next-line no-control-regex
        if (/[\u0001-\u0006\u0008\u0009\u000B-\u001A]/.test((0, utils$5.normalizeString)(String(cell)))) {
          throw new Error('Table data must not contain control characters.');
        }
      }
    }
  };

  exports.validateTableData = validateTableData;
  });

  var table_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.table = void 0;

























  const table = (data, userConfig = {}) => {
    (0, validateTableData_1.validateTableData)(data);
    let rows = (0, stringifyTableData_1.stringifyTableData)(data);
    const [injectedRows, injectedSpanningCellConfig] = (0, injectHeaderConfig_1.injectHeaderConfig)(rows, userConfig);
    const config = (0, makeTableConfig_1.makeTableConfig)(injectedRows, userConfig, injectedSpanningCellConfig);
    rows = (0, truncateTableData_1.truncateTableData)(injectedRows, (0, utils$5.extractTruncates)(config));
    const rowHeights = (0, calculateRowHeights_1.calculateRowHeights)(rows, config);
    config.spanningCellManager.setRowHeights(rowHeights);
    rows = (0, mapDataUsingRowHeights_1.mapDataUsingRowHeights)(rows, rowHeights, config);
    rows = (0, alignTableData_1.alignTableData)(rows, config);
    rows = (0, padTableData_1.padTableData)(rows, config);
    const outputColumnWidths = (0, calculateOutputColumnWidths_1.calculateOutputColumnWidths)(config);
    return (0, drawTable_1.drawTable)(rows, outputColumnWidths, rowHeights, config);
  };

  exports.table = table;
  });

  var api = /*#__PURE__*/Object.defineProperty({

  }, '__esModule', {value: true});

  var src = createCommonjsModule(function (module, exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function () {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getBorderCharacters = exports.createStream = exports.table = void 0;



  Object.defineProperty(exports, "createStream", {
    enumerable: true,
    get: function () {
      return createStream_1.createStream;
    }
  });



  Object.defineProperty(exports, "getBorderCharacters", {
    enumerable: true,
    get: function () {
      return getBorderCharacters_1.getBorderCharacters;
    }
  });



  Object.defineProperty(exports, "table", {
    enumerable: true,
    get: function () {
      return table_1.table;
    }
  });

  __exportStar(api, exports);
  });

  /**
   * @typedef {import('stylelint').Severity} Severity
   *
   * @param {Severity} severity
   * @param {Record<Severity, number>} counts
   * @returns {void}
   */

  var calcSeverityCounts = function calcSeverityCounts(severity, counts) {
    switch (severity) {
      case 'error':
        counts.error += 1;
        break;

      case 'warning':
        counts.warning += 1;
        break;

      default:
        throw new Error(`Unknown severity: "${severity}"`);
    }
  };

  /**
   * Returns the plural form of the given word.
   *
   * @param {string} singular
   * @param {number} count
   * @returns {string}
   */

  var pluralize = function pluralize(singular, count) {
    return count === 1 ? singular : `${singular}s`;
  };

  var hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };

  const {
    env
  } = process;
  let forceColor;

  if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
  } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
  }

  if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
      forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }

  function translateLevel(level) {
    if (level === 0) {
      return false;
    }

    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }

  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }

    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
      return 3;
    }

    if (hasFlag('color=256')) {
      return 2;
    }

    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }

    const min = forceColor || 0;

    if (env.TERM === 'dumb') {
      return min;
    }

    if (process.platform === 'win32') {
      // Windows 10 build 10586 is the first Windows release that supports 256 colors.
      // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
      const osRelease = os__default['default'].release().split('.');

      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }

      return 1;
    }

    if ('CI' in env) {
      if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
        return 1;
      }

      return min;
    }

    if ('TEAMCITY_VERSION' in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }

    if (env.COLORTERM === 'truecolor') {
      return 3;
    }

    if ('TERM_PROGRAM' in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

      switch (env.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;

        case 'Apple_Terminal':
          return 2;
        // No default
      }
    }

    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }

    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }

    if ('COLORTERM' in env) {
      return 1;
    }

    return min;
  }

  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }

  var supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty__default['default'].isatty(1))),
    stderr: translateLevel(supportsColor(true, tty__default['default'].isatty(2)))
  };

  /**
  @param {string} versionString
  @returns {{ major: number, minor: number, patch: number }}
  */


  function parseVersion(versionString) {
    if (/^\d{3,4}$/.test(versionString)) {
      // Env var doesn't always use dots. example: 4601 => 46.1.0
      const m = /(\d{1,2})(\d{2})/.exec(versionString) || [];
      return {
        major: 0,
        minor: parseInt(m[1], 10),
        patch: parseInt(m[2], 10)
      };
    }

    const versions = (versionString || '').split('.').map(n => parseInt(n, 10));
    return {
      major: versions[0],
      minor: versions[1],
      patch: versions[2]
    };
  }
  /**
  @param {{ isTTY?: boolean | undefined }} stream
  @returns {boolean}
  */


  function supportsHyperlink(stream) {
    const {
      CI,
      FORCE_HYPERLINK,
      NETLIFY,
      TEAMCITY_VERSION,
      TERM_PROGRAM,
      TERM_PROGRAM_VERSION,
      VTE_VERSION
    } = process.env;

    if (FORCE_HYPERLINK) {
      return !(FORCE_HYPERLINK.length > 0 && parseInt(FORCE_HYPERLINK, 10) === 0);
    }

    if (hasFlag('no-hyperlink') || hasFlag('no-hyperlinks') || hasFlag('hyperlink=false') || hasFlag('hyperlink=never')) {
      return false;
    }

    if (hasFlag('hyperlink=true') || hasFlag('hyperlink=always')) {
      return true;
    } // Netlify does not run a TTY, it does not need `supportsColor` check


    if (NETLIFY) {
      return true;
    } // If they specify no colors, they probably don't want hyperlinks.


    if (!supportsColor_1.supportsColor(stream)) {
      return false;
    }

    if (stream && !stream.isTTY) {
      return false;
    }

    if (process.platform === 'win32') {
      return false;
    }

    if (CI) {
      return false;
    }

    if (TEAMCITY_VERSION) {
      return false;
    }

    if (TERM_PROGRAM) {
      const version = parseVersion(TERM_PROGRAM_VERSION || '');

      switch (TERM_PROGRAM) {
        case 'iTerm.app':
          if (version.major === 3) {
            return version.minor >= 1;
          }

          return version.major > 3;

        case 'WezTerm':
          return version.major >= 20200620;

        case 'vscode':
          // eslint-disable-next-line no-mixed-operators
          return version.major > 1 || version.major === 1 && version.minor >= 72;
        // No default
      }
    }

    if (VTE_VERSION) {
      // 0.50.0 was supposed to support hyperlinks, but throws a segfault
      if (VTE_VERSION === '0.50.0') {
        return false;
      }

      const version = parseVersion(VTE_VERSION);
      return version.major > 0 || version.minor >= 50;
    }

    return false;
  }

  var supportsHyperlinks = {
    supportsHyperlink,
    stdout: supportsHyperlink(process.stdout),
    stderr: supportsHyperlink(process.stderr)
  };

  // ANSI escapes


  const OSC = '\u001B]';
  const BEL = '\u0007';
  const SEP = ';';
  /**
   * @see https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda
   *
   * @param {string} text
   * @param {string} url
   * @returns {string}
   */

  var terminalLink = function terminalLink(text, url) {
    if (supportsHyperlinks.stdout) {
      return [OSC, '8', SEP, SEP, url, BEL, text, OSC, '8', SEP, SEP, BEL].join('');
    }

    return text;
  };

  const {
    yellow: yellow$1,
    dim: dim$1,
    underline: underline$1,
    blue,
    red: red$1,
    green: green$1
  } = picocolors;





  const {
    assertNumber: assertNumber$1
  } = validateTypes;





  const NON_ASCII_PATTERN = /\P{ASCII}/u;
  const MARGIN_WIDTHS = 9;
  /**
   * @param {string} s
   * @returns {string}
   */

  function nope(s) {
    return s;
  }

  const levelColors = {
    info: blue,
    warning: yellow$1,
    error: red$1,
    success: nope
  };
  const symbols = {
    info: blue('ℹ'),
    warning: yellow$1('⚠'),
    error: red$1('✖'),
    success: green$1('✔')
  };
  /**
   * @param {import('stylelint').LintResult[]} results
   * @returns {string}
   */

  function deprecationsFormatter(results) {
    const allDeprecationWarnings = results.flatMap(result => result.deprecations || []);

    if (allDeprecationWarnings.length === 0) {
      return '';
    }

    const seenText = new Set();
    const lines = [];

    for (const {
      text,
      reference
    } of allDeprecationWarnings) {
      if (seenText.has(text)) continue;
      seenText.add(text);
      let line = ` ${dim$1('-')} ${text}`;

      if (reference) {
        line += dim$1(` See: ${underline$1(reference)}`);
      }

      lines.push(line);
    }

    return ['', yellow$1('Deprecation warnings:'), ...lines, ''].join('\n');
  }
  /**
   * @param {import('stylelint').LintResult[]} results
   * @return {string}
   */


  function invalidOptionsFormatter(results) {
    const allInvalidOptionWarnings = results.flatMap(result => (result.invalidOptionWarnings || []).map(warning => warning.text));
    const uniqueInvalidOptionWarnings = [...new Set(allInvalidOptionWarnings)];
    return uniqueInvalidOptionWarnings.reduce((output, warning) => {
      output += red$1('Invalid Option: ');
      output += warning;
      return `${output}\n`;
    }, '\n');
  }
  /**
   * @param {string} fromValue
   * @param {string} cwd
   * @return {string}
   */


  function logFrom(fromValue, cwd) {
    if (fromValue.startsWith('<')) {
      return underline$1(fromValue);
    }

    const filePath = path__default['default'].relative(cwd, fromValue).split(path__default['default'].sep).join('/');
    return terminalLink(filePath, `file://${fromValue}`);
  }
  /**
   * @param {{[k: number]: number}} columnWidths
   * @return {number}
   */


  function getMessageWidth(columnWidths) {
    const width = columnWidths[3];
    assertNumber$1(width);

    if (!process.stdout.isTTY) {
      return width;
    }

    const availableWidth = process.stdout.columns < 80 ? 80 : process.stdout.columns;
    const fullWidth = Object.values(columnWidths).reduce((a, b) => a + b); // If there is no reason to wrap the text, we won't align the last column to the right

    if (availableWidth > fullWidth + MARGIN_WIDTHS) {
      return width;
    }

    return availableWidth - (fullWidth - width + MARGIN_WIDTHS);
  }
  /**
   * @param {import('stylelint').Warning[]} messages
   * @param {string} source
   * @param {string} cwd
   * @return {string}
   */


  function formatter(messages, source, cwd) {
    if (messages.length === 0) return '';
    /**
     * Create a list of column widths, needed to calculate
     * the size of the message column and if needed wrap it.
     * @type {{[k: string]: number}}
     */

    const columnWidths = {
      0: 1,
      1: 1,
      2: 1,
      3: 1,
      4: 1
    };
    /**
     * @param {[string, string, string, string, string]} columns
     * @return {[string, string, string, string, string]}
     */

    function calculateWidths(columns) {
      for (const [key, value] of Object.entries(columns)) {
        const normalisedValue = value ? value.toString() : value;
        const width = columnWidths[key];
        assertNumber$1(width);
        columnWidths[key] = Math.max(width, stringWidth_1$1(normalisedValue));
      }

      return columns;
    }

    let output = '\n';

    if (source) {
      output += `${logFrom(source, cwd)}\n`;
    }
    /**
     * @param {import('stylelint').Warning} message
     * @return {string}
     */


    function formatMessageText(message) {
      let result = message.text;
      result = result // Remove all control characters (newline, tab and etc)
      .replace(/[\u0001-\u001A]+/g, ' ') // eslint-disable-line no-control-regex
      .replace(/\.$/, '');
      const ruleString = ` (${message.rule})`;

      if (result.endsWith(ruleString)) {
        result = result.slice(0, result.lastIndexOf(ruleString));
      }

      return result;
    }

    const cleanedMessages = messages.map(message => {
      const {
        line,
        column,
        severity
      } = message;
      /**
       * @type {[string, string, string, string, string]}
       */

      const row = [line ? line.toString() : '', column ? column.toString() : '', symbols[severity] ? levelColors[severity](symbols[severity]) : severity, formatMessageText(message), dim$1(message.rule || '')];
      calculateWidths(row);
      return row;
    });
    const messageWidth = getMessageWidth(columnWidths);
    const hasNonAsciiChar = messages.some(msg => NON_ASCII_PATTERN.test(msg.text));
    output += src.table(cleanedMessages, {
      border: src.getBorderCharacters('void'),
      columns: {
        0: {
          alignment: 'right',
          width: columnWidths[0],
          paddingRight: 0
        },
        1: {
          alignment: 'left',
          width: columnWidths[1]
        },
        2: {
          alignment: 'center',
          width: columnWidths[2]
        },
        3: {
          alignment: 'left',
          width: messageWidth,
          wrapWord: messageWidth > 1 && !hasNonAsciiChar
        },
        4: {
          alignment: 'left',
          width: columnWidths[4],
          paddingRight: 0
        }
      },
      drawHorizontalLine: () => false
    }).split('\n').map(el => el.replace(/(\d+)\s+(\d+)/, (_m, p1, p2) => dim$1(`${p1}:${p2}`)).trimEnd()).join('\n');
    return output;
  }
  /**
   * @type {import('stylelint').Formatter}
   */


  var stringFormatter = function stringFormatter(results, returnValue) {
    let output = invalidOptionsFormatter(results);
    output += deprecationsFormatter(results);
    const counts = {
      error: 0,
      warning: 0
    };
    output = results.reduce((accum, result) => {
      preprocessWarnings(result);
      accum += formatter(result.warnings, result.source || '', returnValue && returnValue.cwd || process.cwd());

      for (const warning of result.warnings) {
        calcSeverityCounts(warning.severity, counts);
      }

      return accum;
    }, output); // Ensure consistent padding

    output = output.trim();

    if (output !== '') {
      output = `\n${output}\n\n`;
      const errorCount = counts.error;
      const warningCount = counts.warning;
      const total = errorCount + warningCount;

      if (total > 0) {
        const error = red$1(`${errorCount} ${pluralize('error', errorCount)}`);
        const warning = yellow$1(`${warningCount} ${pluralize('warning', warningCount)}`);
        const tally = `${total} ${pluralize('problem', total)} (${error}, ${warning})`;
        output += `${tally}\n\n`;
      }
    }

    return output;
  };

  /**
   * @type {import('stylelint').Formatter}
   */


  var tapFormatter = function tapFormatter(results) {
    const lines = [`TAP version 13\n1..${results.length}`];

    for (const [index, result] of results.entries()) {
      preprocessWarnings(result);
      lines.push(`${result.errored ? 'not ok' : 'ok'} ${index + 1} - ${result.ignored ? 'ignored ' : ''}${result.source}`);

      if (result.warnings.length > 0) {
        lines.push('---', 'messages:');

        for (const warning of result.warnings) {
          lines.push(` - message: "${warning.text}"`, `   severity: ${warning.severity}`, `   data:`, `     line: ${warning.line}`, `     column: ${warning.column}`);

          if (typeof warning.endLine === 'number') {
            lines.push(`     endLine: ${warning.endLine}`);
          }

          if (typeof warning.endColumn === 'number') {
            lines.push(`     endColumn: ${warning.endColumn}`);
          }

          if (typeof warning.rule === 'string') {
            lines.push(`     ruleId: ${warning.rule}`);
          }
        }

        lines.push('---');
      }
    }

    lines.push('');
    return lines.join('\n');
  };

  /**
   * @type {import('stylelint').Formatter}
   */


  var unixFormatter = function unixFormatter(results) {
    const counts = {
      error: 0,
      warning: 0
    };
    const lines = results.flatMap(result => {
      preprocessWarnings(result);
      return result.warnings.map(warning => {
        calcSeverityCounts(warning.severity, counts);
        return `${result.source}:${warning.line}:${warning.column}: ` + `${warning.text} [${warning.severity}]`;
      });
    });
    const total = lines.length;
    let output = lines.join('\n');

    if (total > 0) {
      output += `\n\n${total} ${pluralize('problem', total)}`;
      output += ` (${counts.error} ${pluralize('error', counts.error)}`;
      output += `, ${counts.warning} ${pluralize('warning', counts.warning)})\n`;
    }

    return output;
  };

  const {
    underline,
    red,
    yellow,
    dim,
    green
  } = picocolors;






  /** @typedef {import('stylelint').Formatter} Formatter */

  /** @typedef {import('stylelint').LintResult} LintResult */

  /** @typedef {import('stylelint').Warning} Warning */

  /** @typedef {import('stylelint').Severity} Severity */

  /** @typedef {import('stylelint').RuleMeta} RuleMeta */

  /**
   * @type {Formatter}
   */


  var verboseFormatter = function verboseFormatter(results, returnValue) {
    let output = stringFormatter(results, returnValue);

    if (output === '') {
      output = '\n';
    }

    const ignoredCount = results.filter(result => result.ignored).length;
    const checkedDisplay = ignoredCount ? `${results.length - ignoredCount} of ${results.length}` : results.length;
    output += underline(`${checkedDisplay} ${pluralize('source', results.length)} checked\n`);

    for (const result of results) {
      let formatting = green;

      if (result.errored) {
        formatting = red;
      } else if (result.warnings.length) {
        formatting = yellow;
      } else if (result.ignored) {
        formatting = dim;
      }

      let sourceText = fileLink(result.source);

      if (result.ignored) {
        sourceText += ' (ignored)';
      }

      output += formatting(` ${sourceText}\n`);
    }

    const warnings = results.flatMap(r => r.warnings);

    if (warnings.length === 0) {
      output += '\n0 problems found\n';
    } else {
      const warningsBySeverity = groupBy(warnings, w => w.severity);
      let fixableProblemsFound = false;
      /**
       * @param {Severity} severity
       */

      const printProblems = severity => {
        const problems = warningsBySeverity[severity];
        if (problems === undefined) return;
        output += '\n';
        output += underline(`${problems.length} ${pluralize(severity, problems.length)} found\n`);
        const problemsByRule = groupBy(problems, w => w.rule);
        const metadata = returnValue.ruleMetadata;

        for (const [rule, list] of Object.entries(problemsByRule)) {
          const meta = metadata[rule] || {};
          let additional = [meta.fixable ? 'maybe fixable' : '', meta.deprecated ? 'deprecated' : ''].filter(Boolean).join(', ');
          additional = additional ? ` (${additional})` : '';
          output += dim(` ${ruleLink(rule, meta)}: ${list.length}${additional}\n`);

          if (!fixableProblemsFound && meta.fixable) {
            fixableProblemsFound = true;
          }
        }
      };

      printProblems('error');
      printProblems('warning');

      if (fixableProblemsFound) {
        output += yellow('\nYou may fix some problems with the "--fix" option.\n');
      }
    }

    return `${output}\n`;
  };
  /**
   * @template {string} K
   * @param {Warning[]} array
   * @param {(w: Warning) => K} keyFn
   * @returns {Record<K, Warning[]>}
   */


  function groupBy(array, keyFn) {
    /** @type {Record<string, Warning[]>} */
    const result = {};

    for (const item of array) {
      const key = keyFn(item);
      let warnings = result[key];

      if (warnings === undefined) {
        result[key] = warnings = [];
      }

      warnings.push(item);
    }

    return result;
  }
  /**
   * @param {string | undefined} source
   * @returns {string}
   */


  function fileLink(source) {
    if (!source || source.startsWith('<')) {
      return `${source}`;
    }

    return terminalLink(source, `file://${source}`);
  }
  /**
   * @param {string} rule
   * @param {Partial<RuleMeta> | undefined} metadata
   * @returns {string}
   */


  function ruleLink(rule, metadata) {
    if (metadata && metadata.url) {
      return terminalLink(rule, metadata.url);
    }

    return rule;
  }

  /** @type {import('stylelint')['formatters']} */


  const formatters = {
    compact: importLazy(() => compactFormatter)(),
    github: importLazy(() => githubFormatter)(),
    json: importLazy(() => jsonFormatter)(),
    string: importLazy(() => stringFormatter)(),
    tap: importLazy(() => tapFormatter)(),
    unix: importLazy(() => unixFormatter)(),
    verbose: importLazy(() => verboseFormatter)()
  };
  var formatters_1 = formatters;

  const {
    augmentConfigFull
  } = augmentConfig;

  const {
    cosmiconfig,
    defaultLoadersSync
  } = dist;
  const STOP_DIR = undefined;
  /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */

  /** @typedef {import('stylelint').Config} StylelintConfig */

  /** @typedef {import('stylelint').CosmiconfigResult} StylelintCosmiconfigResult */

  /**
   * @param {StylelintInternalApi} stylelint
   * @param {string} [searchPath]
   * @param {string} [filePath]
   * @returns {Promise<StylelintCosmiconfigResult>}
   */

  var getConfigForFile = async function getConfigForFile(stylelint, searchPath = stylelint._options.cwd, filePath) {
    const optionsConfig = stylelint._options.config;
    const cwd = stylelint._options.cwd;

    if (optionsConfig !== undefined) {
      const cached = stylelint._specifiedConfigCache.get(optionsConfig); // If config has overrides the resulting config might be different for some files.
      // Cache results only if resulted config is the same for all linted files.


      if (cached && !optionsConfig.overrides) {
        return cached;
      }

      const augmentedResult = augmentConfigFull(stylelint, filePath, {
        config: optionsConfig,
        // Add the extra path part so that we can get the directory without being
        // confused
        filepath: path__default['default'].join(cwd, 'argument-config')
      });

      stylelint._specifiedConfigCache.set(optionsConfig, augmentedResult);

      return augmentedResult;
    }

    const configExplorer = cosmiconfig('stylelint', {
      transform: cosmiconfigResult => augmentConfigFull(stylelint, filePath, cosmiconfigResult),
      loaders: {
        '.cjs': (cjsPath, cjsContent) => Promise.resolve(defaultLoadersSync['.cjs'](cjsPath, cjsContent)),
        '.js': (jsPath, cjsContent) => Promise.resolve(defaultLoadersSync['.js'](jsPath, cjsContent))
      },
      stopDir: STOP_DIR
    });
    let config = stylelint._options.configFile ? await configExplorer.load(stylelint._options.configFile) : await configExplorer.search(searchPath);

    if (!config) {
      config = await configExplorer.search(cwd);
    }

    if (!config) {
      return Promise.reject(configurationError(`No configuration provided${searchPath ? ` for ${searchPath}` : ''}`));
    }

    return config;
  };

  class SafeParser extends parser$1 {
    createTokenizer() {
      this.tokenizer = tokenize$6(this.input, {
        ignoreErrors: true
      });
    }

    comment(token) {
      let node = new comment$1();
      this.init(node, token[2]);
      let pos = this.input.fromOffset(token[3]) || this.input.fromOffset(this.input.css.length - 1);
      node.source.end = {
        offset: token[3],
        line: pos.line,
        column: pos.col
      };
      let text = token[1].slice(2);
      if (text.slice(-2) === '*/') text = text.slice(0, -2);

      if (/^\s*$/.test(text)) {
        node.text = '';
        node.raws.left = text;
        node.raws.right = '';
      } else {
        let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
        node.text = match[2];
        node.raws.left = match[1];
        node.raws.right = match[3];
      }
    }

    decl(tokens) {
      if (tokens.length > 1 && tokens.some(i => i[0] === 'word')) {
        super.decl(tokens);
      }
    }

    unclosedBracket() {}

    unknownWord(tokens) {
      this.spaces += tokens.map(i => i[1]).join('');
    }

    unexpectedClose() {
      this.current.raws.after += '}';
    }

    doubleColon() {}

    unnamedAtrule(node) {
      node.name = '';
    }

    precheckMissedSemicolon(tokens) {
      let colon = this.colon(tokens);
      if (colon === false) return;
      let nextStart, prevEnd;

      for (nextStart = colon - 1; nextStart >= 0; nextStart--) {
        if (tokens[nextStart][0] === 'word') break;
      }

      if (nextStart === 0) return;

      for (prevEnd = nextStart - 1; prevEnd >= 0; prevEnd--) {
        if (tokens[prevEnd][0] !== 'space') {
          prevEnd += 1;
          break;
        }
      }

      let other = tokens.slice(nextStart);
      let spaces = tokens.slice(prevEnd, nextStart);
      tokens.splice(prevEnd, tokens.length - prevEnd);
      this.spaces = spaces.map(i => i[1]).join('');
      this.decl(other);
    }

    checkMissedSemicolon() {}

    endFile() {
      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }

      this.current.raws.after = (this.current.raws.after || '') + this.spaces;

      while (this.current.parent) {
        this.current = this.current.parent;
        this.current.raws.after = '';
      }
    }

  }

  var safeParser = SafeParser;

  let {
    Input
  } = postcss_1;



  var safeParse = function safeParse(css, opts) {
    let input = new Input(css, opts);
    let parser = new safeParser(input);
    parser.parse();
    return parser.root;
  };

  const LazyResult = lazyResult.default;



  const {
    default: postcss$1
  } = postcss_1;

  const {
    promises: fs$3
  } = fs__default['default'];


  /** @typedef {import('postcss').Result} Result */

  /** @typedef {import('postcss').Syntax} Syntax */

  /** @typedef {import('stylelint').CustomSyntax} CustomSyntax */

  /** @typedef {import('stylelint').GetPostcssOptions} GetPostcssOptions */

  /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */


  const postcssProcessor = postcss$1();
  /**
   * @param {StylelintInternalApi} stylelint
   * @param {GetPostcssOptions} options
   *
   * @returns {Promise<Result>}
   */

  var getPostcssResult = async function getPostcssResult(stylelint, options = {}) {
    const cached = options.filePath ? stylelint._postcssResultCache.get(options.filePath) : undefined;

    if (cached) {
      return cached;
    }

    const syntax = options.customSyntax ? getCustomSyntax(options.customSyntax, stylelint._options.configBasedir) : cssSyntax(stylelint, options.filePath);
    const postcssOptions = {
      from: options.filePath,
      syntax
    };
    /** @type {string | undefined} */

    let getCode;

    if (options.code !== undefined) {
      getCode = options.code;
    } else if (options.filePath) {
      getCode = await fs$3.readFile(options.filePath, 'utf8');
    }

    if (getCode === undefined) {
      return Promise.reject(new Error('code or filePath required'));
    }

    const postcssResult = await new LazyResult(postcssProcessor, getCode, postcssOptions);

    if (options.filePath) {
      stylelint._postcssResultCache.set(options.filePath, postcssResult);
    }

    return postcssResult;
  };
  /**
   * @param {CustomSyntax} customSyntax
   * @param {string | undefined} basedir
   * @returns {Syntax}
   */


  function getCustomSyntax(customSyntax, basedir) {
    if (typeof customSyntax === 'string') {
      const customSyntaxLookup = basedir ? getModulePath(basedir, customSyntax) : customSyntax;
      let resolved;

      try {
        resolved = commonjsRequire(customSyntaxLookup);
      } catch (error) {
        if (error && typeof error === 'object' && 'code' in error && error.code === 'MODULE_NOT_FOUND' && 'message' in error && typeof error.message === 'string' && error.message.includes(customSyntax)) {
          throw new Error(`Cannot resolve custom syntax module "${customSyntax}". Check that module "${customSyntax}" is available and spelled correctly.\n\nCaused by: ${error}`);
        }

        throw error;
      }
      /*
       * PostCSS allows for syntaxes that only contain a parser, however,
       * it then expects the syntax to be set as the `parse` option.
       */


      if (!resolved.parse) {
        resolved = {
          parse: resolved,
          stringify: postcss$1.stringify
        };
      }

      return resolved;
    }

    if (typeof customSyntax === 'object') {
      if (typeof customSyntax.parse === 'function') {
        return { ...customSyntax
        };
      }

      throw new TypeError('An object provided to the "customSyntax" option must have a "parse" property. Ensure the "parse" property exists and its value is a function.');
    }

    throw new Error('Custom syntax must be a string or a Syntax object');
  }
  /**
   * @param {StylelintInternalApi} stylelint
   * @param {string|undefined} filePath
   * @returns {Syntax}
   */


  function cssSyntax(stylelint, filePath) {
    const fileExtension = filePath ? path__default['default'].extname(filePath).slice(1).toLowerCase() : '';
    const extensions = ['css', 'pcss', 'postcss'];

    if (fileExtension && !extensions.includes(fileExtension)) {
      console.warn(`${filePath}: you should use the "customSyntax" option when linting something other than CSS`);
    }

    return {
      parse: stylelint._options.fix && extensions.includes(fileExtension) ? safeParse : postcss$1.parse,
      stringify: postcss$1.stringify
    };
  }

  // A simple implementation of make-array
  function makeArray$1(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }

  const EMPTY$1 = '';
  const SPACE$1 = ' ';
  const ESCAPE$1 = '\\';
  const REGEX_TEST_BLANK_LINE$1 = /^\s+$/;
  const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
  const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION$1 = /^\\!/;
  const REGEX_REPLACE_LEADING_EXCAPED_HASH$1 = /^\\#/;
  const REGEX_SPLITALL_CRLF$1 = /\r?\n/g; // /foo,
  // ./foo,
  // ../foo,
  // .
  // ..

  const REGEX_TEST_INVALID_PATH$1 = /^\.*\/|^\.+$/;
  const SLASH$1 = '/'; // Do not use ternary expression here, since "istanbul ignore next" is buggy

  let TMP_KEY_IGNORE = 'node-ignore';
  /* istanbul ignore else */

  if (typeof Symbol !== 'undefined') {
    TMP_KEY_IGNORE = Symbol.for('node-ignore');
  }

  const KEY_IGNORE$1 = TMP_KEY_IGNORE;

  const define$1 = (object, key, value) => Object.defineProperty(object, key, {
    value
  });

  const REGEX_REGEXP_RANGE$1 = /([0-z])-([0-z])/g;

  const RETURN_FALSE$1 = () => false; // Sanitize the range of a regular expression
  // The cases are complicated, see test cases for details


  const sanitizeRange$1 = range => range.replace(REGEX_REGEXP_RANGE$1, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but
  //   fatal for JavaScript regular expression, so eliminate it.
  : EMPTY$1); // See fixtures #59


  const cleanRangeBackSlash$1 = slashes => {
    const {
      length
    } = slashes;
    return slashes.slice(0, length - length % 2);
  }; // > If the pattern ends with a slash,
  // > it is removed for the purpose of the following description,
  // > but it would only find a match with a directory.
  // > In other words, foo/ will match a directory foo and paths underneath it,
  // > but will not match a regular file or a symbolic link foo
  // >  (this is consistent with the way how pathspec works in general in Git).
  // '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
  // -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
  //      you could use option `mark: true` with `glob`
  // '`foo/`' should not continue with the '`..`'


  const REPLACERS$1 = [// > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [// (a\ ) -> (a )
  // (a  ) -> (a)
  // (a \ ) -> (a  )
  /\\?\s+$/, match => match.indexOf('\\') === 0 ? SPACE$1 : EMPTY$1], // replace (\ ) with ' '
  [/\\\s/g, () => SPACE$1], // Escape metacharacters
  // which is written down by users but means special for regular expressions.
  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [/[\\$.|*+(){^]/g, match => `\\${match}`], [// > a question mark (?) matches a single character
  /(?!\\)\?/g, () => '[^/]'], // leading slash
  [// > A leading slash matches the beginning of the pathname.
  // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
  // A leading slash matches the beginning of the pathname
  /^\//, () => '^'], // replace special metacharacter slash after the leading slash
  [/\//g, () => '\\/'], [// > A leading "**" followed by a slash means match in all directories.
  // > For example, "**/foo" matches file or directory "foo" anywhere,
  // > the same as pattern "foo".
  // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
  // >   under directory "foo".
  // Notice that the '*'s have been replaced as '\\*'
  /^\^*\\\*\\\*\\\//, // '**/foo' <-> 'foo'
  () => '^(?:.*\\/)?'], // starting
  [// there will be no leading '/'
  //   (which has been replaced by section "leading slash")
  // If starts with '**', adding a '^' to the regular expression also works
  /^(?=[^^])/, function startingReplacer() {
    // If has a slash `/` at the beginning or middle
    return !/\/(?!$)/.test(this) // > Prior to 2.22.1
    // > If the pattern does not contain a slash /,
    // >   Git treats it as a shell glob pattern
    // Actually, if there is only a trailing slash,
    //   git also treats it as a shell glob pattern
    // After 2.22.1 (compatible but clearer)
    // > If there is a separator at the beginning or middle (or both)
    // > of the pattern, then the pattern is relative to the directory
    // > level of the particular .gitignore file itself.
    // > Otherwise the pattern may also match at any level below
    // > the .gitignore level.
    ? '(?:^|\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for
    // >   consumption by fnmatch(3)
    : '^';
  }], // two globstars
  [// Use lookahead assertions so that we could match more than one `'/**'`
  /\\\/\\\*\\\*(?=\\\/|$)/g, // Zero, one or several directories
  // should not use '*', or it will be replaced by the next replacer
  // Check if it is not the last `'/**'`
  (_, index, str) => index + 6 < str.length // case: /**/
  // > A slash followed by two consecutive asterisks then a slash matches
  // >   zero or more directories.
  // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
  // '/**/'
  ? '(?:\\/[^\\/]+)*' // case: /**
  // > A trailing `"/**"` matches everything inside.
  // #21: everything inside but it should not include the current folder
  : '\\/.+'], // normal intermediate wildcards
  [// Never replace escaped '*'
  // ignore rule '\*' will match the path '*'
  // 'abc.*/' -> go
  // 'abc.*'  -> skip this rule,
  //    coz trailing single wildcard will be handed by [trailing wildcard]
  /(^|[^\\]+)(\\\*)+(?=.+)/g, // '*.js' matches '.js'
  // '*.js' doesn't match 'abc'
  (_, p1, p2) => {
    // 1.
    // > An asterisk "*" matches anything except a slash.
    // 2.
    // > Other consecutive asterisks are considered regular asterisks
    // > and will match according to the previous rules.
    const unescaped = p2.replace(/\\\*/g, '[^\\/]*');
    return p1 + unescaped;
  }], [// unescape, revert step 3 except for back slash
  // For example, if a user escape a '\\*',
  // after step 3, the result will be '\\\\\\*'
  /\\\\\\(?=[$.|*+(){^])/g, () => ESCAPE$1], [// '\\\\' -> '\\'
  /\\\\/g, () => ESCAPE$1], [// > The range notation, e.g. [a-zA-Z],
  // > can be used to match one of the characters in a range.
  // `\` is escaped by step 3
  /(\\)?\[([^\]/]*?)(\\*)($|\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE$1 // '\\[bar]' -> '\\\\[bar\\]'
  ? `\\[${range}${cleanRangeBackSlash$1(endEscape)}${close}` : close === ']' ? endEscape.length % 2 === 0 // A normal case, and it is a range notation
  // '[bar]'
  // '[bar\\\\]'
  ? `[${sanitizeRange$1(range)}${endEscape}]` // Invalid range notaton
  // '[bar\\]' -> '[bar\\\\]'
  : '[]' : '[]'], // ending
  [// 'js' will not match 'js.'
  // 'ab' will not match 'abc'
  /(?:[^*])$/, // WTF!
  // https://git-scm.com/docs/gitignore
  // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
  // which re-fixes #24, #38
  // > If there is a separator at the end of the pattern then the pattern
  // > will only match directories, otherwise the pattern can match both
  // > files and directories.
  // 'js*' will not match 'a.js'
  // 'js/' will not match 'a.js'
  // 'js' will match 'a.js' and 'a.js/'
  match => /\/$/.test(match) // foo/ will not match 'foo'
  ? `${match}$` // foo matches 'foo' and 'foo/'
  : `${match}(?=$|\\/$)`], // trailing wildcard
  [/(\^|\\\/)?\\\*$/, (_, p1) => {
    const prefix = p1 // '\^':
    // '/*' does not match EMPTY
    // '/*' does not match everything
    // '\\\/':
    // 'abc/*' does not match 'abc/'
    ? `${p1}[^/]+` // 'a*' matches 'a'
    // 'a*' matches 'aa'
    : '[^/]*';
    return `${prefix}(?=$|\\/$)`;
  }]]; // A simple cache, because an ignore rule only has only one certain meaning

  const regexCache$1 = Object.create(null); // @param {pattern}

  const makeRegex$1 = (pattern, ignoreCase) => {
    let source = regexCache$1[pattern];

    if (!source) {
      source = REPLACERS$1.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
      regexCache$1[pattern] = source;
    }

    return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);
  };

  const isString$2 = subject => typeof subject === 'string'; // > A blank line matches no files, so it can serve as a separator for readability.


  const checkPattern$1 = pattern => pattern && isString$2(pattern) && !REGEX_TEST_BLANK_LINE$1.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0;

  const splitPattern$1 = pattern => pattern.split(REGEX_SPLITALL_CRLF$1);

  class IgnoreRule$1 {
    constructor(origin, pattern, negative, regex) {
      this.origin = origin;
      this.pattern = pattern;
      this.negative = negative;
      this.regex = regex;
    }

  }

  const createRule$1 = (pattern, ignoreCase) => {
    const origin = pattern;
    let negative = false; // > An optional prefix "!" which negates the pattern;

    if (pattern.indexOf('!') === 0) {
      negative = true;
      pattern = pattern.substr(1);
    }

    pattern = pattern // > Put a backslash ("\") in front of the first "!" for patterns that
    // >   begin with a literal "!", for example, `"\!important!.txt"`.
    .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION$1, '!') // > Put a backslash ("\") in front of the first hash for patterns that
    // >   begin with a hash.
    .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH$1, '#');
    const regex = makeRegex$1(pattern, ignoreCase);
    return new IgnoreRule$1(origin, pattern, negative, regex);
  };

  const throwError$1 = (message, Ctor) => {
    throw new Ctor(message);
  };

  const checkPath$1 = (path, originalPath, doThrow) => {
    if (!isString$2(path)) {
      return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    } // We don't know if we should ignore EMPTY, so throw


    if (!path) {
      return doThrow(`path must not be empty`, TypeError);
    } // Check if it is a relative path


    if (checkPath$1.isNotRelative(path)) {
      const r = '`path.relative()`d';
      return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }

    return true;
  };

  const isNotRelative$1 = path => REGEX_TEST_INVALID_PATH$1.test(path);

  checkPath$1.isNotRelative = isNotRelative$1;

  checkPath$1.convert = p => p;

  class Ignore$1 {
    constructor({
      ignorecase = true,
      ignoreCase = ignorecase,
      allowRelativePaths = false
    } = {}) {
      define$1(this, KEY_IGNORE$1, true);
      this._rules = [];
      this._ignoreCase = ignoreCase;
      this._allowRelativePaths = allowRelativePaths;

      this._initCache();
    }

    _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }

    _addPattern(pattern) {
      // #32
      if (pattern && pattern[KEY_IGNORE$1]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }

      if (checkPattern$1(pattern)) {
        const rule = createRule$1(pattern, this._ignoreCase);
        this._added = true;

        this._rules.push(rule);
      }
    } // @param {Array<string> | string | Ignore} pattern


    add(pattern) {
      this._added = false;
      makeArray$1(isString$2(pattern) ? splitPattern$1(pattern) : pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,
      // making the behavior changed.

      if (this._added) {
        this._initCache();
      }

      return this;
    } // legacy


    addPattern(pattern) {
      return this.add(pattern);
    } //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns {TestResult} true if a file is ignored


    _testOne(path, checkUnignored) {
      let ignored = false;
      let unignored = false;

      this._rules.forEach(rule => {
        const {
          negative
        } = rule;

        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }

        const matched = rule.regex.test(path);

        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });

      return {
        ignored,
        unignored
      };
    } // @returns {TestResult}


    _test(originalPath, cache, checkUnignored, slices) {
      const path = originalPath // Supports nullable path
      && checkPath$1.convert(originalPath);
      checkPath$1(path, originalPath, this._allowRelativePaths ? RETURN_FALSE$1 : throwError$1);
      return this._t(path, cache, checkUnignored, slices);
    }

    _t(path, cache, checkUnignored, slices) {
      if (path in cache) {
        return cache[path];
      }

      if (!slices) {
        // path/to/a.js
        // ['path', 'to', 'a.js']
        slices = path.split(SLASH$1);
      }

      slices.pop(); // If the path has no parent directory, just test it

      if (!slices.length) {
        return cache[path] = this._testOne(path, checkUnignored);
      }

      const parent = this._t(slices.join(SLASH$1) + SLASH$1, cache, checkUnignored, slices); // If the path contains a parent directory, check the parent first


      return cache[path] = parent.ignored // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent : this._testOne(path, checkUnignored);
    }

    ignores(path) {
      return this._test(path, this._ignoreCache, false).ignored;
    }

    createFilter() {
      return path => !this.ignores(path);
    }

    filter(paths) {
      return makeArray$1(paths).filter(this.createFilter());
    } // @returns {TestResult}


    test(path) {
      return this._test(path, this._testCache, true);
    }

  }

  const factory$1 = options => new Ignore$1(options);

  const isPathValid$2 = path => checkPath$1(path && checkPath$1.convert(path), path, RETURN_FALSE$1);

  factory$1.isPathValid = isPathValid$2; // Fixes typescript

  factory$1.default = factory$1;
  var ignore$2 = factory$1; // Windows
  // --------------------------------------------------------------

  /* istanbul ignore if */

  if ( // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {
    /* eslint no-control-regex: "off" */
    const makePosix = str => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, '/');

    checkPath$1.convert = makePosix; // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
    // 'd:\\foo'

    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;

    checkPath$1.isNotRelative = path => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative$1(path);
  }

  const {
    isPathValid: isPathValid$1
  } = ignore$2.default;
  /**
   * @param {import('ignore').Ignore} ignorer
   * @param {string[]} filePaths
   * @returns {string[]}
   */


  var filterFilePaths = function filterFilePaths(ignorer, filePaths) {
    const validForIgnore = filePaths.filter(isPathValid$1); // Paths which starts with `..` are not valid for `ignore`, e. g. `../style.css`

    const notValidForIgnore = new Set(filePaths.filter(p => !validForIgnore.includes(p)));
    const filteredByIgnore = new Set(ignorer.filter(validForIgnore)); // Preserving files order, while removing paths which were filtered by `ignore`

    return filePaths.filter(p => notValidForIgnore.has(p) || filteredByIgnore.has(p));
  };

  /**
   * @param {unknown} error
   * @returns {error is NodeJS.ErrnoException}
   */


  var isPathNotFoundError = function isPathNotFoundError(error) {
    return util__default['default'].types.isNativeError(error) && 'code' in error && error.code === 'ENOENT';
  };

  const {
    default: ignore$1
  } = ignore$2;

  const {
    DEFAULT_IGNORE_FILENAME
  } = constants$3;


  /**
   * @typedef {import('stylelint').LinterOptions} LinterOptions
   *
   * @param {Pick<LinterOptions, 'ignorePath' | 'ignorePattern'> & { cwd: string }} options
   * @return {import('ignore').Ignore}
   */


  var getFileIgnorer = function getFileIgnorer({
    ignorePath,
    ignorePattern,
    cwd
  }) {
    const ignorer = ignore$1();
    const ignorePaths = [ignorePath || []].flat();

    if (ignorePaths.length === 0) {
      ignorePaths.push(DEFAULT_IGNORE_FILENAME);
    }

    for (const ignoreFilePath of ignorePaths) {
      const absoluteIgnoreFilePath = path__default['default'].isAbsolute(ignoreFilePath) ? ignoreFilePath : path__default['default'].resolve(cwd, ignoreFilePath);

      try {
        const ignoreText = fs__default['default'].readFileSync(absoluteIgnoreFilePath, 'utf8');
        ignorer.add(ignoreText);
      } catch (readError) {
        if (!isPathNotFoundError(readError)) {
          throw readError;
        }
      }
    }

    if (ignorePattern) ignorer.add(ignorePattern);
    return ignorer;
  };

  /**
   * To find out if a path is ignored, we need to load the config,
   * which may have an ignoreFiles property. We then check the path
   * against these.
   * @param {import('stylelint').InternalApi} stylelint
   * @param {string} [filePath]
   * @return {Promise<boolean>}
   */


  var isPathIgnored = async function isPathIgnored(stylelint, filePath) {
    if (!filePath) {
      return false;
    }

    const cwd = stylelint._options.cwd;
    const result = await getConfigForFile(stylelint, filePath, filePath);

    if (!result) {
      return true;
    }

    const ignoreFiles = result.config.ignoreFiles || [];
    const absoluteFilePath = path__default['default'].isAbsolute(filePath) ? filePath : path__default['default'].resolve(cwd, filePath);

    if (micromatch_1$2([absoluteFilePath], ignoreFiles).length > 0) {
      return true;
    }

    const ignorer = getFileIgnorer(stylelint._options);

    if (filterFilePaths(ignorer, [path__default['default'].relative(cwd, absoluteFilePath)]).length === 0) {
      return true;
    }

    return false;
  };

  const {
    DISABLE_COMMAND,
    DISABLE_LINE_COMMAND,
    DISABLE_NEXT_LINE_COMMAND,
    ENABLE_COMMAND,
    extractConfigurationComment,
    getConfigurationComment,
    isConfigurationComment
  } = configurationComment;

  const {
    assert: assert$1,
    assertNumber,
    assertString
  } = validateTypes;

  const ALL_RULES = 'all';
  /** @typedef {import('postcss').Comment} PostcssComment */

  /** @typedef {import('postcss').Root} PostcssRoot */

  /** @typedef {import('postcss').Document} PostcssDocument */

  /** @typedef {import('stylelint').PostcssResult} PostcssResult */

  /** @typedef {import('stylelint').DisabledRangeObject} DisabledRangeObject */

  /** @typedef {import('stylelint').DisabledRange} DisabledRange */

  /**
   * @param {PostcssComment} comment
   * @param {number} start
   * @param {boolean} strictStart
   * @param {string|undefined} description
   * @param {number} [end]
   * @param {boolean} [strictEnd]
   * @returns {DisabledRange}
   */

  function createDisableRange(comment, start, strictStart, description, end, strictEnd) {
    return {
      comment,
      start,
      end: end || undefined,
      strictStart,
      strictEnd: typeof strictEnd === 'boolean' ? strictEnd : undefined,
      description
    };
  }
  /**
   * Run it like a PostCSS plugin
   * @param {PostcssRoot | PostcssDocument} root
   * @param {PostcssResult} result
   * @returns {PostcssResult}
   */


  var assignDisabledRanges = function assignDisabledRanges(root, result) {
    result.stylelint = result.stylelint || {
      disabledRanges: {},
      ruleSeverities: {},
      customMessages: {},
      ruleMetadata: {}
    };
    /**
     * Most of the functions below work via side effects mutating this object
     * @type {DisabledRangeObject & { all: DisabledRange[] }}
     */

    const disabledRanges = {
      [ALL_RULES]: []
    };
    result.stylelint.disabledRanges = disabledRanges; // Work around postcss/postcss-scss#109 by merging adjacent `//` comments
    // into a single node before passing to `checkComment`.

    /** @type {PostcssComment?} */

    let inlineEnd;
    const configurationComment = result.stylelint.config?.configurationComment;
    root.walkComments(comment => {
      if (inlineEnd) {
        // Ignore comments already processed by grouping with a previous one.
        if (inlineEnd === comment) inlineEnd = null;
        return;
      }

      const nextComment = comment.next(); // If any of these conditions are not met, do not merge comments.

      if (!(!isStandardSyntaxComment(comment) && isConfigurationComment(comment, configurationComment) && nextComment && nextComment.type === 'comment' && (comment.text.includes('--') || nextComment.text.startsWith('--')))) {
        checkComment(comment);
        return;
      }

      let lastLine = comment.source && comment.source.end && comment.source.end.line || 0;
      const fullComment = comment.clone();
      let current = nextComment;

      while (!isStandardSyntaxComment(current) && !isConfigurationComment(current, configurationComment)) {
        const currentLine = current.source && current.source.end && current.source.end.line || 0;
        if (lastLine + 1 !== currentLine) break;
        fullComment.text += `\n${current.text}`;

        if (fullComment.source && current.source) {
          fullComment.source.end = current.source.end;
        }

        inlineEnd = current;
        const next = current.next();
        if (!next || next.type !== 'comment') break;
        current = next;
        lastLine = currentLine;
      }

      checkComment(fullComment);
    });
    return result;
    /**
     * @param {PostcssComment} comment
     */

    function processDisableLineCommand(comment) {
      if (comment.source && comment.source.start) {
        const line = comment.source.start.line;
        const description = getDescription(comment.text);

        for (const ruleName of getCommandRules(DISABLE_LINE_COMMAND, comment.text)) {
          disableLine(comment, line, ruleName, description);
        }
      }
    }
    /**
     * @param {PostcssComment} comment
     */


    function processDisableNextLineCommand(comment) {
      if (comment.source && comment.source.end) {
        const line = comment.source.end.line;
        const description = getDescription(comment.text);

        for (const ruleName of getCommandRules(DISABLE_NEXT_LINE_COMMAND, comment.text)) {
          disableLine(comment, line + 1, ruleName, description);
        }
      }
    }
    /**
     * @param {PostcssComment} comment
     * @param {number} line
     * @param {string} ruleName
     * @param {string|undefined} description
     */


    function disableLine(comment, line, ruleName, description) {
      if (ruleIsDisabled(ALL_RULES)) {
        throw comment.error('All rules have already been disabled', {
          plugin: 'stylelint'
        });
      }

      if (ruleName === ALL_RULES) {
        for (const disabledRuleName of Object.keys(disabledRanges)) {
          if (ruleIsDisabled(disabledRuleName)) continue;
          const strict = disabledRuleName === ALL_RULES;
          startDisabledRange(comment, line, disabledRuleName, strict, description);
          endDisabledRange(line, disabledRuleName, strict);
        }
      } else {
        if (ruleIsDisabled(ruleName)) {
          throw comment.error(`"${ruleName}" has already been disabled`, {
            plugin: 'stylelint'
          });
        }

        startDisabledRange(comment, line, ruleName, true, description);
        endDisabledRange(line, ruleName, true);
      }
    }
    /**
     * @param {PostcssComment} comment
     */


    function processDisableCommand(comment) {
      const description = getDescription(comment.text);

      for (const ruleToDisable of getCommandRules(DISABLE_COMMAND, comment.text)) {
        const isAllRules = ruleToDisable === ALL_RULES;

        if (ruleIsDisabled(ruleToDisable)) {
          throw comment.error(isAllRules ? 'All rules have already been disabled' : `"${ruleToDisable}" has already been disabled`, {
            plugin: 'stylelint'
          });
        }

        if (comment.source && comment.source.start) {
          const line = comment.source.start.line;

          if (isAllRules) {
            for (const ruleName of Object.keys(disabledRanges)) {
              startDisabledRange(comment, line, ruleName, ruleName === ALL_RULES, description);
            }
          } else {
            startDisabledRange(comment, line, ruleToDisable, true, description);
          }
        }
      }
    }
    /**
     * @param {PostcssComment} comment
     */


    function processEnableCommand(comment) {
      for (const ruleToEnable of getCommandRules(ENABLE_COMMAND, comment.text)) {
        // need fallback if endLine will be undefined
        const endLine = comment.source && comment.source.end && comment.source.end.line;
        assertNumber(endLine);

        if (ruleToEnable === ALL_RULES) {
          if (Object.values(disabledRanges).every(ranges => {
            if (ranges.length === 0) return true;
            const lastRange = ranges[ranges.length - 1];
            return lastRange && typeof lastRange.end === 'number';
          })) {
            throw comment.error('No rules have been disabled', {
              plugin: 'stylelint'
            });
          }

          for (const [ruleName, ranges] of Object.entries(disabledRanges)) {
            const lastRange = ranges[ranges.length - 1];

            if (!lastRange || !lastRange.end) {
              endDisabledRange(endLine, ruleName, ruleName === ALL_RULES);
            }
          }

          continue;
        }

        if (ruleIsDisabled(ALL_RULES) && disabledRanges[ruleToEnable] === undefined) {
          // Get a starting point from the where all rules were disabled
          disabledRanges[ruleToEnable] = disabledRanges[ALL_RULES].map(({
            start,
            end,
            description
          }) => createDisableRange(comment, start, false, description, end, false));
          endDisabledRange(endLine, ruleToEnable, true);
          continue;
        }

        if (ruleIsDisabled(ruleToEnable)) {
          endDisabledRange(endLine, ruleToEnable, true);
          continue;
        }

        throw comment.error(`"${ruleToEnable}" has not been disabled`, {
          plugin: 'stylelint'
        });
      }
    }
    /**
     * @param {PostcssComment} comment
     */


    function checkComment(comment) {
      // Ignore comments that are not relevant commands
      if (!isConfigurationComment(comment, configurationComment)) {
        return;
      }

      switch (extractConfigurationComment(comment, configurationComment)) {
        case DISABLE_LINE_COMMAND:
          processDisableLineCommand(comment);
          break;

        case DISABLE_NEXT_LINE_COMMAND:
          processDisableNextLineCommand(comment);
          break;

        case DISABLE_COMMAND:
          processDisableCommand(comment);
          break;

        case ENABLE_COMMAND:
          processEnableCommand(comment);
          break;
      }
    }
    /**
     * @param {string} command
     * @param {string} fullText
     * @returns {string[]}
     */


    function getCommandRules(command, fullText) {
      // Allow for description (f.e. /* stylelint-disable a, b -- Description */).
      const fullCommand = getConfigurationComment(command, configurationComment);
      const rulesText = fullText.slice(fullCommand.length).split(/\s-{2,}\s/u)[0];
      assertString(rulesText);
      const rules = rulesText.trim().split(',').filter(Boolean).map(r => r.trim());

      if (rules.length === 0) {
        return [ALL_RULES];
      }

      return rules;
    }
    /**
     * @param {string} fullText
     * @returns {string|undefined}
     */


    function getDescription(fullText) {
      const descriptionStart = fullText.indexOf('--');
      if (descriptionStart === -1) return;
      return fullText.slice(descriptionStart + 2).trim();
    }
    /**
     * @param {PostcssComment} comment
     * @param {number} line
     * @param {string} ruleName
     * @param {boolean} strict
     * @param {string|undefined} description
     */


    function startDisabledRange(comment, line, ruleName, strict, description) {
      const rangeObj = createDisableRange(comment, line, strict, description);
      ensureRuleRanges(ruleName);
      const range = disabledRanges[ruleName];
      assert$1(range);
      range.push(rangeObj);
    }
    /**
     * @param {number} line
     * @param {string} ruleName
     * @param {boolean} strict
     */


    function endDisabledRange(line, ruleName, strict) {
      const ranges = disabledRanges[ruleName];
      const lastRangeForRule = ranges ? ranges[ranges.length - 1] : null;

      if (!lastRangeForRule) {
        return;
      } // Add an `end` prop to the last range of that rule


      lastRangeForRule.end = line;
      lastRangeForRule.strictEnd = strict;
    }
    /**
     * @param {string} ruleName
     */


    function ensureRuleRanges(ruleName) {
      if (!disabledRanges[ruleName]) {
        disabledRanges[ruleName] = disabledRanges[ALL_RULES].map(({
          comment,
          start,
          end,
          description
        }) => createDisableRange(comment, start, false, description, end, false));
      }
    }
    /**
     * @param {string} ruleName
     * @returns {boolean}
     */


    function ruleIsDisabled(ruleName) {
      const ranges = disabledRanges[ruleName];
      if (!ranges) return false;
      const lastRange = ranges[ranges.length - 1];
      if (!lastRange) return false;
      if (!lastRange.end) return true;
      return false;
    }
  };

  // This function simply provides roundabout way of getting os.EOL
  // so we can mock this for Jest tests


  function getOsEl() {
    return os__default['default'].EOL;
  }

  var getOsEol = getOsEl;

  const peq = new Uint32Array(0x10000);

  const myers_32 = (a, b) => {
    const n = a.length;
    const m = b.length;
    const lst = 1 << n - 1;
    let pv = -1;
    let mv = 0;
    let sc = n;
    let i = n;

    while (i--) {
      peq[a.charCodeAt(i)] |= 1 << i;
    }

    for (i = 0; i < m; i++) {
      let eq = peq[b.charCodeAt(i)];
      const xv = eq | mv;
      eq |= (eq & pv) + pv ^ pv;
      mv |= ~(eq | pv);
      pv &= eq;

      if (mv & lst) {
        sc++;
      }

      if (pv & lst) {
        sc--;
      }

      mv = mv << 1 | 1;
      pv = pv << 1 | ~(xv | mv);
      mv &= xv;
    }

    i = n;

    while (i--) {
      peq[a.charCodeAt(i)] = 0;
    }

    return sc;
  };

  const myers_x = (b, a) => {
    const n = a.length;
    const m = b.length;
    const mhc = [];
    const phc = [];
    const hsize = Math.ceil(n / 32);
    const vsize = Math.ceil(m / 32);

    for (let i = 0; i < hsize; i++) {
      phc[i] = -1;
      mhc[i] = 0;
    }

    let j = 0;

    for (; j < vsize - 1; j++) {
      let mv = 0;
      let pv = -1;
      const start = j * 32;
      const vlen = Math.min(32, m) + start;

      for (let k = start; k < vlen; k++) {
        peq[b.charCodeAt(k)] |= 1 << k;
      }

      for (let i = 0; i < n; i++) {
        const eq = peq[a.charCodeAt(i)];
        const pb = phc[i / 32 | 0] >>> i & 1;
        const mb = mhc[i / 32 | 0] >>> i & 1;
        const xv = eq | mv;
        const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
        let ph = mv | ~(xh | pv);
        let mh = pv & xh;

        if (ph >>> 31 ^ pb) {
          phc[i / 32 | 0] ^= 1 << i;
        }

        if (mh >>> 31 ^ mb) {
          mhc[i / 32 | 0] ^= 1 << i;
        }

        ph = ph << 1 | pb;
        mh = mh << 1 | mb;
        pv = mh | ~(xv | ph);
        mv = ph & xv;
      }

      for (let k = start; k < vlen; k++) {
        peq[b.charCodeAt(k)] = 0;
      }
    }

    let mv = 0;
    let pv = -1;
    const start = j * 32;
    const vlen = Math.min(32, m - start) + start;

    for (let k = start; k < vlen; k++) {
      peq[b.charCodeAt(k)] |= 1 << k;
    }

    let score = m;

    for (let i = 0; i < n; i++) {
      const eq = peq[a.charCodeAt(i)];
      const pb = phc[i / 32 | 0] >>> i & 1;
      const mb = mhc[i / 32 | 0] >>> i & 1;
      const xv = eq | mv;
      const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
      let ph = mv | ~(xh | pv);
      let mh = pv & xh;
      score += ph >>> m - 1 & 1;
      score -= mh >>> m - 1 & 1;

      if (ph >>> 31 ^ pb) {
        phc[i / 32 | 0] ^= 1 << i;
      }

      if (mh >>> 31 ^ mb) {
        mhc[i / 32 | 0] ^= 1 << i;
      }

      ph = ph << 1 | pb;
      mh = mh << 1 | mb;
      pv = mh | ~(xv | ph);
      mv = ph & xv;
    }

    for (let k = start; k < vlen; k++) {
      peq[b.charCodeAt(k)] = 0;
    }

    return score;
  };

  const distance = (a, b) => {
    if (a.length < b.length) {
      const tmp = b;
      b = a;
      a = tmp;
    }

    if (b.length === 0) {
      return a.length;
    }

    if (a.length <= 32) {
      return myers_32(a, b);
    }

    return myers_x(a, b);
  };

  const closest = (str, arr) => {
    let min_distance = Infinity;
    let min_index = 0;

    for (let i = 0; i < arr.length; i++) {
      const dist = distance(str, arr[i]);

      if (dist < min_distance) {
        min_distance = dist;
        min_index = i;
      }
    }

    return arr[min_index];
  };

  var mod = /*#__PURE__*/Object.freeze({
    __proto__: null,
    closest: closest,
    distance: distance
  });

  var levenshtein = /*@__PURE__*/getAugmentedNamespace(mod);

  const MAX_LEVENSHTEIN_DISTANCE = 6;
  const MAX_SUGGESTIONS_COUNT = 3;
  /**
   * @param {string} ruleName
   * @return {string[]}
   */

  function extractSuggestions(ruleName) {
    const suggestions = Array.from({
      length: MAX_LEVENSHTEIN_DISTANCE
    });

    for (let i = 0; i < suggestions.length; i++) {
      suggestions[i] = [];
    }

    for (const existRuleName of Object.keys(rules_1)) {
      const distance = levenshtein.distance(existRuleName, ruleName);

      if (distance <= MAX_LEVENSHTEIN_DISTANCE) {
        suggestions[distance - 1].push(existRuleName);
      }
    }
    /** @type {string[]} */


    let result = [];

    for (const [i, suggestion] of suggestions.entries()) {
      if (suggestion.length > 0) {
        if (i < 3) {
          return suggestion.slice(0, MAX_SUGGESTIONS_COUNT);
        }

        result = result.concat(suggestion);
      }
    }

    return result.slice(0, MAX_SUGGESTIONS_COUNT);
  }
  /**
   * @param {string} ruleName
   * @param {string[]} [suggestions=[]]
   * @return {string}
   */


  function rejectMessage(ruleName, suggestions = []) {
    return `Unknown rule ${ruleName}.${suggestions.length > 0 ? ` Did you mean ${suggestions.join(', ')}?` : ''}`;
  }
  /** @type {Map<string, string[]>} */


  const cache = new Map();
  /**
   * @param {string} unknownRuleName
   * @param {import('postcss').Root} postcssRoot
   * @param {import('stylelint').PostcssResult} postcssResult
   * @returns {void}
   */

  var reportUnknownRuleNames = function reportUnknownRuleNames(unknownRuleName, postcssRoot, postcssResult) {
    const suggestions = cache.has(unknownRuleName) ?
    /** @type {string[]} */
    cache.get(unknownRuleName) : extractSuggestions(unknownRuleName);
    cache.set(unknownRuleName, suggestions);
    postcssResult.warn(rejectMessage(unknownRuleName, suggestions), {
      severity: 'error',
      rule: unknownRuleName,
      node: postcssRoot,
      index: 0
    });
  };

  const {
    DEFAULT_CONFIGURATION_COMMENT
  } = configurationComment;
  /** @typedef {import('stylelint').LinterOptions} LinterOptions */

  /** @typedef {import('stylelint').PostcssResult} PostcssResult */

  /** @typedef {import('stylelint').Config} StylelintConfig */

  /**
   * @param {LinterOptions} stylelintOptions
   * @param {PostcssResult} postcssResult
   * @param {StylelintConfig} config
   * @returns {Promise<any>}
   */


  var lintPostcssResult = function lintPostcssResult(stylelintOptions, postcssResult, config) {
    postcssResult.stylelint.ruleSeverities = {};
    postcssResult.stylelint.customMessages = {};
    postcssResult.stylelint.ruleMetadata = {};
    postcssResult.stylelint.stylelintError = false;
    postcssResult.stylelint.stylelintWarning = false;
    postcssResult.stylelint.quiet = config.quiet;
    postcssResult.stylelint.config = config;
    /** @type {string | undefined} */

    let newline;
    const postcssDoc = postcssResult.root;

    if (postcssDoc) {
      if (!('type' in postcssDoc)) {
        throw new Error('Unexpected Postcss root object!');
      }

      const newlineMatch = postcssDoc.source && postcssDoc.source.input.css.match(/\r?\n/);
      newline = newlineMatch ? newlineMatch[0] : getOsEol();
      assignDisabledRanges(postcssDoc, postcssResult);
    }

    const isFileFixCompatible = isFixCompatible(postcssResult);

    if (!isFileFixCompatible) {
      postcssResult.stylelint.disableWritingFix = true;
    }

    const postcssRoots =
    /** @type {import('postcss').Root[]} */
    postcssDoc && postcssDoc.constructor.name === 'Document' ? postcssDoc.nodes : [postcssDoc]; // Promises for the rules. Although the rule code runs synchronously now,
    // the use of Promises makes it compatible with the possibility of async
    // rules down the line.

    /** @type {Array<Promise<any>>} */

    const performRules = [];
    const rulesOrder = Object.keys(rules_1);
    const ruleNames = config.rules ? Object.keys(config.rules).sort((a, b) => rulesOrder.indexOf(a) - rulesOrder.indexOf(b)) : [];

    for (const ruleName of ruleNames) {
      const ruleFunction = getStylelintRule(ruleName, config);

      if (ruleFunction === undefined) {
        performRules.push(Promise.all(postcssRoots.map(postcssRoot => reportUnknownRuleNames(ruleName, postcssRoot, postcssResult))));
        continue;
      }

      const ruleSettings = config.rules && config.rules[ruleName];

      if (ruleSettings === null || ruleSettings[0] === null) {
        continue;
      }

      if (ruleFunction.meta && ruleFunction.meta.deprecated && !stylelintOptions.quietDeprecationWarnings) {
        warnDeprecatedRule(postcssResult, ruleName);
      }

      const primaryOption = ruleSettings[0];
      const secondaryOptions = ruleSettings[1]; // Log the rule's severity in the PostCSS result

      const defaultSeverity = config.defaultSeverity || 'error'; // disableFix in secondary option

      const disableFix = secondaryOptions && secondaryOptions.disableFix === true || false;
      postcssResult.stylelint.ruleSeverities[ruleName] = secondaryOptions && secondaryOptions.severity || defaultSeverity;
      postcssResult.stylelint.customMessages[ruleName] = secondaryOptions && secondaryOptions.message;
      postcssResult.stylelint.ruleMetadata[ruleName] = ruleFunction.meta || {};
      performRules.push(Promise.all(postcssRoots.map(postcssRoot => ruleFunction(primaryOption, secondaryOptions, {
        configurationComment: config.configurationComment || DEFAULT_CONFIGURATION_COMMENT,
        fix: !disableFix && config.fix && // Next two conditionals are temporary measures until #2643 is resolved
        isFileFixCompatible && !postcssResult.stylelint.disabledRanges[ruleName],
        newline
      })(postcssRoot, postcssResult))));
    }

    return Promise.all(performRules);
  };
  /**
   * There are currently some bugs in the autofixer of Stylelint.
   * The autofixer does not yet adhere to stylelint-disable comments, so if there are disabled
   * ranges we can not autofix this document. More info in issue #2643.
   *
   * @param {PostcssResult} postcssResult
   * @returns {boolean}
   */


  function isFixCompatible({
    stylelint
  }) {
    // Check for issue #2643
    if (stylelint.disabledRanges.all && stylelint.disabledRanges.all.length) return false;
    return true;
  }
  /**
   * @param {PostcssResult} result
   * @param {string} ruleName
   * @returns {void}
   */


  function warnDeprecatedRule(result, ruleName) {
    result.warn(`The "${ruleName}" rule is deprecated.`, {
      stylelintType: 'deprecation'
    });
  }

  /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */

  /** @typedef {import('stylelint').GetLintSourceOptions} Options */

  /** @typedef {import('postcss').Result} Result */

  /** @typedef {import('stylelint').PostcssResult} PostcssResult */

  /** @typedef {import('stylelint').StylelintPostcssResult} StylelintPostcssResult */

  /**
   * Run stylelint on a PostCSS Result, either one that is provided
   * or one that we create
   * @param {StylelintInternalApi} stylelint
   * @param {Options} options
   * @returns {Promise<PostcssResult>}
   */


  var lintSource = async function lintSource(stylelint, options = {}) {
    if (!options.filePath && options.code === undefined && !options.existingPostcssResult) {
      return Promise.reject(new Error('You must provide filePath, code, or existingPostcssResult'));
    }

    const isCodeNotFile = options.code !== undefined;
    const inputFilePath = isCodeNotFile ? options.codeFilename : options.filePath;

    if (inputFilePath !== undefined && !path__default['default'].isAbsolute(inputFilePath)) {
      if (isCodeNotFile) {
        return Promise.reject(new Error('codeFilename must be an absolute path'));
      }

      return Promise.reject(new Error('filePath must be an absolute path'));
    }

    const isIgnored = await isPathIgnored(stylelint, inputFilePath).catch(err => {
      if (isCodeNotFile && isPathNotFoundError(err)) return false;
      throw err;
    });

    if (isIgnored) {
      return options.existingPostcssResult ? Object.assign(options.existingPostcssResult, {
        stylelint: createEmptyStylelintPostcssResult()
      }) : createEmptyPostcssResult(inputFilePath);
    }

    const configSearchPath = stylelint._options.configFile || inputFilePath;
    const cwd = stylelint._options.cwd;
    let configForFile;

    try {
      configForFile = await getConfigForFile(stylelint, configSearchPath, inputFilePath);
    } catch (err) {
      if (isCodeNotFile && isPathNotFoundError(err)) {
        configForFile = await getConfigForFile(stylelint, cwd);
      } else {
        throw err;
      }
    }

    if (!configForFile) {
      return Promise.reject(new Error('Config file not found'));
    }

    const config = configForFile.config;
    const existingPostcssResult = options.existingPostcssResult;

    if (options.cache) {
      stylelint._fileCache.calcHashOfConfig(config);

      if (options.filePath && !stylelint._fileCache.hasFileChanged(options.filePath)) {
        return existingPostcssResult ? Object.assign(existingPostcssResult, {
          stylelint: createEmptyStylelintPostcssResult()
        }) : createEmptyPostcssResult(inputFilePath);
      }
    }
    /** @type {StylelintPostcssResult} */


    const stylelintResult = {
      ruleSeverities: {},
      customMessages: {},
      ruleMetadata: {},
      disabledRanges: {}
    };
    const postcssResult = existingPostcssResult || (await getPostcssResult(stylelint, {
      code: options.code,
      codeFilename: options.codeFilename,
      filePath: inputFilePath,
      customSyntax: config.customSyntax
    }));
    const stylelintPostcssResult = Object.assign(postcssResult, {
      stylelint: stylelintResult
    });
    await lintPostcssResult(stylelint._options, stylelintPostcssResult, config);
    return stylelintPostcssResult;
  };
  /**
   * @returns {StylelintPostcssResult}
   */


  function createEmptyStylelintPostcssResult() {
    return {
      ruleSeverities: {},
      customMessages: {},
      ruleMetadata: {},
      disabledRanges: {},
      ignored: true,
      stylelintError: false,
      stylelintWarning: false
    };
  }
  /**
   * @param {string} [filePath]
   * @returns {PostcssResult}
   */


  function createEmptyPostcssResult(filePath) {
    return {
      root: {
        source: {
          input: {
            file: filePath
          }
        }
      },
      messages: [],
      opts: undefined,
      stylelint: createEmptyStylelintPostcssResult(),
      warn: () => {}
    };
  }

  /** @typedef {import('stylelint').PostcssPluginOptions} PostcssPluginOptions */

  /** @typedef {import('stylelint').Config} StylelintConfig */

  /**
   * @type {import('postcss').PluginCreator<PostcssPluginOptions>}
   * */


  var postcssPlugin = (options = {}) => {
    const [cwd, tailoredOptions] = isConfig(options) ? [process.cwd(), {
      config: options
    }] : [options.cwd || process.cwd(), options];
    const stylelint = createStylelint(tailoredOptions);
    return {
      postcssPlugin: 'stylelint',

      Once(root, {
        result
      }) {
        let filePath = root.source && root.source.input.file;

        if (filePath && !path__default['default'].isAbsolute(filePath)) {
          filePath = path__default['default'].join(cwd, filePath);
        }

        return lintSource(stylelint, {
          filePath,
          existingPostcssResult: result
        });
      }

    };
  };

  var postcss = true;
  /**
   * @param {PostcssPluginOptions} options
   * @returns {options is StylelintConfig}
   */

  function isConfig(options) {
    return 'rules' in options;
  }
  postcssPlugin.postcss = postcss;

  /**
   * @type {import('stylelint')['resolveConfig']}
   */


  var resolveConfig = async function resolveConfig(filePath, {
    cwd = process.cwd(),
    config,
    configBasedir,
    configFile
  } = {}) {
    if (!filePath) {
      return undefined;
    }

    const stylelint = createStylelint({
      config,
      configFile,
      configBasedir,
      cwd
    });
    const absoluteFilePath = !path__default['default'].isAbsolute(filePath) ? path__default['default'].join(cwd, filePath) : path__default['default'].normalize(filePath);
    const configSearchPath = stylelint._options.configFile || absoluteFilePath;
    const resolved = await getConfigForFile(stylelint, configSearchPath, absoluteFilePath);

    if (!resolved) {
      return undefined;
    }

    return resolved.config;
  };

  var array$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.splitWhen = exports.flatten = void 0;

  function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
  }

  exports.flatten = flatten;

  function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;

    for (const item of items) {
      if (predicate(item)) {
        groupIndex++;
        result[groupIndex] = [];
      } else {
        result[groupIndex].push(item);
      }
    }

    return result;
  }

  exports.splitWhen = splitWhen;
  });

  var errno$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isEnoentCodeError = void 0;

  function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
  }

  exports.isEnoentCodeError = isEnoentCodeError;
  });

  var fs$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createDirentFromStats = void 0;

  class DirentFromStats {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }

  }

  function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
  }

  exports.createDirentFromStats = createDirentFromStats;
  });

  var path_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;





  const IS_WINDOWS_PLATFORM = os__default['default'].platform() === 'win32';
  const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\

  /**
   * All non-escaped special characters.
   * Posix: ()*?[\]{|}, !+@ before (, ! at the beginning, \\ before non-special characters.
   * Windows: (){}, !+@ before (, ! at the beginning.
   */

  const POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
  const WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([(){}]|^!|[!+@](?=\())/g;
  /**
   * The device path (\\.\ or \\?\).
   * https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#dos-device-paths
   */

  const DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
  /**
   * All backslashes except those escaping special characters.
   * Windows: !()+@{}
   * https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions
   */

  const WINDOWS_BACKSLASHES_RE = /\\(?![!()+@{}])/g;
  /**
   * Designed to work only with simple paths: `dir\\file`.
   */

  function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
  }

  exports.unixify = unixify;

  function makeAbsolute(cwd, filepath) {
    return path__default['default'].resolve(cwd, filepath);
  }

  exports.makeAbsolute = makeAbsolute;

  function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
      const secondCharactery = entry.charAt(1);

      if (secondCharactery === '/' || secondCharactery === '\\') {
        return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
    }

    return entry;
  }

  exports.removeLeadingDotSegment = removeLeadingDotSegment;
  exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;

  function escapeWindowsPath(pattern) {
    return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
  }

  exports.escapeWindowsPath = escapeWindowsPath;

  function escapePosixPath(pattern) {
    return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
  }

  exports.escapePosixPath = escapePosixPath;
  exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;

  function convertWindowsPathToPattern(filepath) {
    return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, '//$1').replace(WINDOWS_BACKSLASHES_RE, '/');
  }

  exports.convertWindowsPathToPattern = convertWindowsPathToPattern;

  function convertPosixPathToPattern(filepath) {
    return escapePosixPath(filepath);
  }

  exports.convertPosixPathToPattern = convertPosixPathToPattern;
  });

  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var isExtglob = function isExtglob(str) {
    if (typeof str !== 'string' || str === '') {
      return false;
    }

    var match;

    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2]) return true;
      str = str.slice(match.index + match[0].length);
    }

    return false;
  };

  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */

  var chars = {
    '{': '}',
    '(': ')',
    '[': ']'
  };
  var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

  var isGlob = function isGlob(str, options) {
    if (typeof str !== 'string' || str === '') {
      return false;
    }

    if (isExtglob(str)) {
      return true;
    }

    var regex = strictRegex;
    var match; // optionally relax regex

    if (options && options.strict === false) {
      regex = relaxedRegex;
    }

    while (match = regex.exec(str)) {
      if (match[2]) return true;
      var idx = match.index + match[0].length; // if an open bracket/brace/paren is escaped,
      // set the index to the next closing character

      var open = match[1];
      var close = open ? chars[open] : null;

      if (open && close) {
        var n = str.indexOf(close, idx);

        if (n !== -1) {
          idx = n + 1;
        }
      }

      str = str.slice(idx);
    }

    return false;
  };

  var pathPosixDirname = path__default['default'].posix.dirname;

  var isWin32 = os__default['default'].platform() === 'win32';
  var slash$1 = '/';
  var backslash = /\\/g;
  var enclosure = /[\{\[].*[\}\]]$/;
  var globby$1 = /(^|[^\\])([\{\[]|\([^\)]+$)/;
  var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  /**
   * @param {string} str
   * @param {Object} opts
   * @param {boolean} [opts.flipBackslashes=true]
   * @returns {string}
   */

  var globParent = function globParent(str, opts) {
    var options = Object.assign({
      flipBackslashes: true
    }, opts); // flip windows path separators

    if (options.flipBackslashes && isWin32 && str.indexOf(slash$1) < 0) {
      str = str.replace(backslash, slash$1);
    } // special case for strings ending in enclosure containing path separator


    if (enclosure.test(str)) {
      str += slash$1;
    } // preserves full path in case of trailing path separator


    str += 'a'; // remove path parts that are globby

    do {
      str = pathPosixDirname(str);
    } while (isGlob(str) || globby$1.test(str)); // remove escape chars and return result


    return str.replace(escaped, '$1');
  };

  const WIN_SLASH$1 = '\\\\/';
  const WIN_NO_SLASH$1 = `[^${WIN_SLASH$1}]`;
  /**
   * Posix glob regex
   */

  const DOT_LITERAL$1 = '\\.';
  const PLUS_LITERAL$1 = '\\+';
  const QMARK_LITERAL$1 = '\\?';
  const SLASH_LITERAL$1 = '\\/';
  const ONE_CHAR$1 = '(?=.)';
  const QMARK$1 = '[^/]';
  const END_ANCHOR$1 = `(?:${SLASH_LITERAL$1}|$)`;
  const START_ANCHOR$1 = `(?:^|${SLASH_LITERAL$1})`;
  const DOTS_SLASH$1 = `${DOT_LITERAL$1}{1,2}${END_ANCHOR$1}`;
  const NO_DOT$1 = `(?!${DOT_LITERAL$1})`;
  const NO_DOTS$1 = `(?!${START_ANCHOR$1}${DOTS_SLASH$1})`;
  const NO_DOT_SLASH$1 = `(?!${DOT_LITERAL$1}{0,1}${END_ANCHOR$1})`;
  const NO_DOTS_SLASH$1 = `(?!${DOTS_SLASH$1})`;
  const QMARK_NO_DOT$1 = `[^.${SLASH_LITERAL$1}]`;
  const STAR$1 = `${QMARK$1}*?`;
  const POSIX_CHARS$1 = {
    DOT_LITERAL: DOT_LITERAL$1,
    PLUS_LITERAL: PLUS_LITERAL$1,
    QMARK_LITERAL: QMARK_LITERAL$1,
    SLASH_LITERAL: SLASH_LITERAL$1,
    ONE_CHAR: ONE_CHAR$1,
    QMARK: QMARK$1,
    END_ANCHOR: END_ANCHOR$1,
    DOTS_SLASH: DOTS_SLASH$1,
    NO_DOT: NO_DOT$1,
    NO_DOTS: NO_DOTS$1,
    NO_DOT_SLASH: NO_DOT_SLASH$1,
    NO_DOTS_SLASH: NO_DOTS_SLASH$1,
    QMARK_NO_DOT: QMARK_NO_DOT$1,
    STAR: STAR$1,
    START_ANCHOR: START_ANCHOR$1
  };
  /**
   * Windows glob regex
   */

  const WINDOWS_CHARS$1 = { ...POSIX_CHARS$1,
    SLASH_LITERAL: `[${WIN_SLASH$1}]`,
    QMARK: WIN_NO_SLASH$1,
    STAR: `${WIN_NO_SLASH$1}*?`,
    DOTS_SLASH: `${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL$1})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH$1}])${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL$1}{0,1}(?:[${WIN_SLASH$1}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH$1}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH$1}])`,
    END_ANCHOR: `(?:[${WIN_SLASH$1}]|$)`
  };
  /**
   * POSIX Bracket Regex
   */

  const POSIX_REGEX_SOURCE$3 = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
  };
  var constants$2 = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$3,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      '***': '*',
      '**/**': '**',
      '**/**/**': '**'
    },
    // Digits
    CHAR_0: 48,

    /* 0 */
    CHAR_9: 57,

    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,

    /* A */
    CHAR_LOWERCASE_A: 97,

    /* a */
    CHAR_UPPERCASE_Z: 90,

    /* Z */
    CHAR_LOWERCASE_Z: 122,

    /* z */
    CHAR_LEFT_PARENTHESES: 40,

    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,

    /* ) */
    CHAR_ASTERISK: 42,

    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,

    /* & */
    CHAR_AT: 64,

    /* @ */
    CHAR_BACKWARD_SLASH: 92,

    /* \ */
    CHAR_CARRIAGE_RETURN: 13,

    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,

    /* ^ */
    CHAR_COLON: 58,

    /* : */
    CHAR_COMMA: 44,

    /* , */
    CHAR_DOT: 46,

    /* . */
    CHAR_DOUBLE_QUOTE: 34,

    /* " */
    CHAR_EQUAL: 61,

    /* = */
    CHAR_EXCLAMATION_MARK: 33,

    /* ! */
    CHAR_FORM_FEED: 12,

    /* \f */
    CHAR_FORWARD_SLASH: 47,

    /* / */
    CHAR_GRAVE_ACCENT: 96,

    /* ` */
    CHAR_HASH: 35,

    /* # */
    CHAR_HYPHEN_MINUS: 45,

    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,

    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,

    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,

    /* [ */
    CHAR_LINE_FEED: 10,

    /* \n */
    CHAR_NO_BREAK_SPACE: 160,

    /* \u00A0 */
    CHAR_PERCENT: 37,

    /* % */
    CHAR_PLUS: 43,

    /* + */
    CHAR_QUESTION_MARK: 63,

    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,

    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,

    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,

    /* ] */
    CHAR_SEMICOLON: 59,

    /* ; */
    CHAR_SINGLE_QUOTE: 39,

    /* ' */
    CHAR_SPACE: 32,

    /*   */
    CHAR_TAB: 9,

    /* \t */
    CHAR_UNDERSCORE: 95,

    /* _ */
    CHAR_VERTICAL_LINE: 124,

    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,

    /* \uFEFF */
    SEP: path__default['default'].sep,

    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(chars) {
      return {
        '!': {
          type: 'negate',
          open: '(?:(?!(?:',
          close: `))${chars.STAR})`
        },
        '?': {
          type: 'qmark',
          open: '(?:',
          close: ')?'
        },
        '+': {
          type: 'plus',
          open: '(?:',
          close: ')+'
        },
        '*': {
          type: 'star',
          open: '(?:',
          close: ')*'
        },
        '@': {
          type: 'at',
          open: '(?:',
          close: ')'
        }
      };
    },

    /**
     * Create GLOB_CHARS
     */
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS$1 : POSIX_CHARS$1;
    }

  };

  var utils$4 = createCommonjsModule(function (module, exports) {



  const win32 = process.platform === 'win32';

  const {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = constants$2;

  exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

  exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);

  exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);

  exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');

  exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

  exports.removeBackslashes = str => {
    return str.replace(REGEX_REMOVE_BACKSLASH, match => {
      return match === '\\' ? '' : match;
    });
  };

  exports.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split('.').map(Number);

    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }

    return false;
  };

  exports.isWindows = options => {
    if (options && typeof options.windows === 'boolean') {
      return options.windows;
    }

    return win32 === true || path__default['default'].sep === '\\';
  };

  exports.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };

  exports.removePrefix = (input, state = {}) => {
    let output = input;

    if (output.startsWith('./')) {
      output = output.slice(2);
      state.prefix = './';
    }

    return output;
  };

  exports.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? '' : '^';
    const append = options.contains ? '' : '$';
    let output = `${prepend}(?:${input})${append}`;

    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }

    return output;
  };
  });

  const {
    CHAR_ASTERISK: CHAR_ASTERISK$1,

    /* * */
    CHAR_AT: CHAR_AT$1,

    /* @ */
    CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH$1,

    /* \ */
    CHAR_COMMA: CHAR_COMMA$1,

    /* , */
    CHAR_DOT: CHAR_DOT$1,

    /* . */
    CHAR_EXCLAMATION_MARK: CHAR_EXCLAMATION_MARK$1,

    /* ! */
    CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH$1,

    /* / */
    CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,

    /* { */
    CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,

    /* ( */
    CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,

    /* [ */
    CHAR_PLUS: CHAR_PLUS$1,

    /* + */
    CHAR_QUESTION_MARK: CHAR_QUESTION_MARK$1,

    /* ? */
    CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,

    /* } */
    CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,

    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1
    /* ] */

  } = constants$2;

  const isPathSeparator$1 = code => {
    return code === CHAR_FORWARD_SLASH$1 || code === CHAR_BACKWARD_SLASH$1;
  };

  const depth$1 = token => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  /**
   * Quickly scans a glob pattern and returns an object with a handful of
   * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
   * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
   *
   * ```js
   * const pm = require('picomatch');
   * console.log(pm.scan('foo/bar/*.js'));
   * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object} Returns an object with tokens and regex source string.
   * @api public
   */


  const scan$1 = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {
      value: '',
      depth: 0,
      isGlob: false
    };

    const eos = () => index >= length;

    const peek = () => str.charCodeAt(index + 1);

    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };

    while (index < length) {
      code = advance();
      let next;

      if (code === CHAR_BACKWARD_SLASH$1) {
        backslashes = token.backslashes = true;
        code = advance();

        if (code === CHAR_LEFT_CURLY_BRACE$1) {
          braceEscaped = true;
        }

        continue;
      }

      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {
        braces++;

        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH$1) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (code === CHAR_LEFT_CURLY_BRACE$1) {
            braces++;
            continue;
          }

          if (braceEscaped !== true && code === CHAR_DOT$1 && (code = advance()) === CHAR_DOT$1) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (braceEscaped !== true && code === CHAR_COMMA$1) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (code === CHAR_RIGHT_CURLY_BRACE$1) {
            braces--;

            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_FORWARD_SLASH$1) {
        slashes.push(index);
        tokens.push(token);
        token = {
          value: '',
          depth: 0,
          isGlob: false
        };
        if (finished === true) continue;

        if (prev === CHAR_DOT$1 && index === start + 1) {
          start += 2;
          continue;
        }

        lastIndex = index + 1;
        continue;
      }

      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS$1 || code === CHAR_AT$1 || code === CHAR_ASTERISK$1 || code === CHAR_QUESTION_MARK$1 || code === CHAR_EXCLAMATION_MARK$1;

        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES$1) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;

          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH$1) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }

              if (code === CHAR_RIGHT_PARENTHESES$1) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }

            continue;
          }

          break;
        }
      }

      if (code === CHAR_ASTERISK$1) {
        if (prev === CHAR_ASTERISK$1) isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_QUESTION_MARK$1) {
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_LEFT_SQUARE_BRACKET$1) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH$1) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK$1 && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }

      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$1) {
        isGlob = token.isGlob = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES$1) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES$1) {
              finished = true;
              break;
            }
          }

          continue;
        }

        break;
      }

      if (isGlob === true) {
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }
    }

    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }

    let base = str;
    let prefix = '';
    let glob = '';

    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }

    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = '';
      glob = str;
    } else {
      base = str;
    }

    if (base && base !== '' && base !== '/' && base !== str) {
      if (isPathSeparator$1(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }

    if (opts.unescape === true) {
      if (glob) glob = utils$4.removeBackslashes(glob);

      if (base && backslashes === true) {
        base = utils$4.removeBackslashes(base);
      }
    }

    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated
    };

    if (opts.tokens === true) {
      state.maxDepth = 0;

      if (!isPathSeparator$1(code)) {
        tokens.push(token);
      }

      state.tokens = tokens;
    }

    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;

      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx];
        const value = input.slice(n, i);

        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }

          depth$1(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }

        if (idx !== 0 || value !== '') {
          parts.push(value);
        }

        prevIndex = i;
      }

      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);

        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth$1(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }

      state.slashes = slashes;
      state.parts = parts;
    }

    return state;
  };

  var scan_1$1 = scan$1;

  /**
   * Constants
   */


  const {
    MAX_LENGTH: MAX_LENGTH$1,
    POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$2,
    REGEX_NON_SPECIAL_CHARS: REGEX_NON_SPECIAL_CHARS$1,
    REGEX_SPECIAL_CHARS_BACKREF: REGEX_SPECIAL_CHARS_BACKREF$1,
    REPLACEMENTS: REPLACEMENTS$1
  } = constants$2;
  /**
   * Helpers
   */

  const expandRange$1 = (args, options) => {
    if (typeof options.expandRange === 'function') {
      return options.expandRange(...args, options);
    }

    args.sort();
    const value = `[${args.join('-')}]`;

    try {
      /* eslint-disable-next-line no-new */
      new RegExp(value);
    } catch (ex) {
      return args.map(v => utils$4.escapeRegex(v)).join('..');
    }

    return value;
  };
  /**
   * Create the message for a syntax error
   */


  const syntaxError$1 = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  /**
   * Parse the given input string.
   * @param {String} input
   * @param {Object} options
   * @return {Object}
   */


  const parse$1 = (input, options) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    input = REPLACEMENTS$1[input] || input;
    const opts = { ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
    let len = input.length;

    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }

    const bos = {
      type: 'bos',
      value: '',
      output: opts.prepend || ''
    };
    const tokens = [bos];
    const capture = opts.capture ? '' : '?:';
    const win32 = utils$4.isWindows(options); // create constants based on platform, for windows or posix

    const PLATFORM_CHARS = constants$2.globChars(win32);
    const EXTGLOB_CHARS = constants$2.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;

    const globstar = opts => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };

    const nodot = opts.dot ? '' : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;

    if (opts.capture) {
      star = `(${star})`;
    } // minimatch options support


    if (typeof opts.noext === 'boolean') {
      opts.noextglob = opts.noext;
    }

    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: '',
      output: '',
      prefix: '',
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils$4.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    /**
     * Tokenizing helpers
     */

    const eos = () => state.index === len - 1;

    const peek = state.peek = (n = 1) => input[state.index + n];

    const advance = state.advance = () => input[++state.index];

    const remaining = () => input.slice(state.index + 1);

    const consume = (value = '', num = 0) => {
      state.consumed += value;
      state.index += num;
    };

    const append = token => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };

    const negate = () => {
      let count = 1;

      while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
        advance();
        state.start++;
        count++;
      }

      if (count % 2 === 0) {
        return false;
      }

      state.negated = true;
      state.start++;
      return true;
    };

    const increment = type => {
      state[type]++;
      stack.push(type);
    };

    const decrement = type => {
      state[type]--;
      stack.pop();
    };
    /**
     * Push tokens onto the tokens array. This helper speeds up
     * tokenizing by 1) helping us avoid backtracking as much as possible,
     * and 2) helping us avoid creating extra tokens when consecutive
     * characters are plain text. This improves performance and simplifies
     * lookbehinds.
     */


    const push = tok => {
      if (prev.type === 'globstar') {
        const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');

        if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = 'star';
          prev.value = '*';
          prev.output = star;
          state.output += prev.output;
        }
      }

      if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
        extglobs[extglobs.length - 1].inner += tok.value;
      }

      if (tok.value || tok.output) append(tok);

      if (prev && prev.type === 'text' && tok.type === 'text') {
        prev.value += tok.value;
        prev.output = (prev.output || '') + tok.value;
        return;
      }

      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };

    const extglobOpen = (type, value) => {
      const token = { ...EXTGLOB_CHARS[value],
        conditions: 1,
        inner: ''
      };
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? '(' : '') + token.open;
      increment('parens');
      push({
        type,
        value,
        output: state.output ? '' : ONE_CHAR
      });
      push({
        type: 'paren',
        extglob: true,
        value: advance(),
        output
      });
      extglobs.push(token);
    };

    const extglobClose = token => {
      let output = token.close + (opts.capture ? ')' : '');

      if (token.type === 'negate') {
        let extglobStar = star;

        if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
          extglobStar = globstar(opts);
        }

        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)$))${extglobStar}`;
        }

        if (token.prev.type === 'bos') {
          state.negatedExtglob = true;
        }
      }

      push({
        type: 'paren',
        extglob: true,
        value,
        output
      });
      decrement('parens');
    };
    /**
     * Fast paths
     */


    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF$1, (m, esc, chars, first, rest, index) => {
        if (first === '\\') {
          backslashes = true;
          return m;
        }

        if (first === '?') {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : '');
          }

          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
          }

          return QMARK.repeat(chars.length);
        }

        if (first === '.') {
          return DOT_LITERAL.repeat(chars.length);
        }

        if (first === '*') {
          if (esc) {
            return esc + first + (rest ? star : '');
          }

          return star;
        }

        return esc ? m : `\\${m}`;
      });

      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, '');
        } else {
          output = output.replace(/\\+/g, m => {
            return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
          });
        }
      }

      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }

      state.output = utils$4.wrapOutput(output, state, options);
      return state;
    }
    /**
     * Tokenize input until we reach end-of-string
     */


    while (!eos()) {
      value = advance();

      if (value === '\u0000') {
        continue;
      }
      /**
       * Escaped characters
       */


      if (value === '\\') {
        const next = peek();

        if (next === '/' && opts.bash !== true) {
          continue;
        }

        if (next === '.' || next === ';') {
          continue;
        }

        if (!next) {
          value += '\\';
          push({
            type: 'text',
            value
          });
          continue;
        } // collapse slashes to reduce potential for exploits


        const match = /^\\+/.exec(remaining());
        let slashes = 0;

        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;

          if (slashes % 2 !== 0) {
            value += '\\';
          }
        }

        if (opts.unescape === true) {
          value = advance() || '';
        } else {
          value += advance() || '';
        }

        if (state.brackets === 0) {
          push({
            type: 'text',
            value
          });
          continue;
        }
      }
      /**
       * If we're inside a regex character class, continue
       * until we reach the closing bracket.
       */


      if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
        if (opts.posix !== false && value === ':') {
          const inner = prev.value.slice(1);

          if (inner.includes('[')) {
            prev.posix = true;

            if (inner.includes(':')) {
              const idx = prev.value.lastIndexOf('[');
              const pre = prev.value.slice(0, idx);
              const rest = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE$2[rest];

              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();

                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }

                continue;
              }
            }
          }
        }

        if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
          value = `\\${value}`;
        }

        if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
          value = `\\${value}`;
        }

        if (opts.posix === true && value === '!' && prev.value === '[') {
          value = '^';
        }

        prev.value += value;
        append({
          value
        });
        continue;
      }
      /**
       * If we're inside a quoted string, continue
       * until we reach the closing double quote.
       */


      if (state.quotes === 1 && value !== '"') {
        value = utils$4.escapeRegex(value);
        prev.value += value;
        append({
          value
        });
        continue;
      }
      /**
       * Double quotes
       */


      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;

        if (opts.keepQuotes === true) {
          push({
            type: 'text',
            value
          });
        }

        continue;
      }
      /**
       * Parentheses
       */


      if (value === '(') {
        increment('parens');
        push({
          type: 'paren',
          value
        });
        continue;
      }

      if (value === ')') {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError$1('opening', '('));
        }

        const extglob = extglobs[extglobs.length - 1];

        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }

        push({
          type: 'paren',
          value,
          output: state.parens ? ')' : '\\)'
        });
        decrement('parens');
        continue;
      }
      /**
       * Square brackets
       */


      if (value === '[') {
        if (opts.nobracket === true || !remaining().includes(']')) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError$1('closing', ']'));
          }

          value = `\\${value}`;
        } else {
          increment('brackets');
        }

        push({
          type: 'bracket',
          value
        });
        continue;
      }

      if (value === ']') {
        if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
          push({
            type: 'text',
            value,
            output: `\\${value}`
          });
          continue;
        }

        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError$1('opening', '['));
          }

          push({
            type: 'text',
            value,
            output: `\\${value}`
          });
          continue;
        }

        decrement('brackets');
        const prevValue = prev.value.slice(1);

        if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
          value = `/${value}`;
        }

        prev.value += value;
        append({
          value
        }); // when literal brackets are explicitly disabled
        // assume we should match with a regex character class

        if (opts.literalBrackets === false || utils$4.hasRegexChars(prevValue)) {
          continue;
        }

        const escaped = utils$4.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled
        // assume we should escape the brackets to match literal characters

        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        } // when the user specifies nothing, try to match both


        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      /**
       * Braces
       */


      if (value === '{' && opts.nobrace !== true) {
        increment('braces');
        const open = {
          type: 'brace',
          value,
          output: '(',
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }

      if (value === '}') {
        const brace = braces[braces.length - 1];

        if (opts.nobrace === true || !brace) {
          push({
            type: 'text',
            value,
            output: value
          });
          continue;
        }

        let output = ')';

        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];

          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();

            if (arr[i].type === 'brace') {
              break;
            }

            if (arr[i].type !== 'dots') {
              range.unshift(arr[i].value);
            }
          }

          output = expandRange$1(range, opts);
          state.backtrack = true;
        }

        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = '\\{';
          value = output = '\\}';
          state.output = out;

          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }

        push({
          type: 'brace',
          value,
          output
        });
        decrement('braces');
        braces.pop();
        continue;
      }
      /**
       * Pipes
       */


      if (value === '|') {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Commas
       */


      if (value === ',') {
        let output = value;
        const brace = braces[braces.length - 1];

        if (brace && stack[stack.length - 1] === 'braces') {
          brace.comma = true;
          output = '|';
        }

        push({
          type: 'comma',
          value,
          output
        });
        continue;
      }
      /**
       * Slashes
       */


      if (value === '/') {
        // if the beginning of the glob is "./", advance the start
        // to the current index, and don't add the "./" characters
        // to the state. This greatly simplifies lookbehinds when
        // checking for BOS characters like "!" and "." (not "./")
        if (prev.type === 'dot' && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = '';
          state.output = '';
          tokens.pop();
          prev = bos; // reset "prev" to the first token

          continue;
        }

        push({
          type: 'slash',
          value,
          output: SLASH_LITERAL
        });
        continue;
      }
      /**
       * Dots
       */


      if (value === '.') {
        if (state.braces > 0 && prev.type === 'dot') {
          if (prev.value === '.') prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = 'dots';
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }

        if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
          push({
            type: 'text',
            value,
            output: DOT_LITERAL
          });
          continue;
        }

        push({
          type: 'dot',
          value,
          output: DOT_LITERAL
        });
        continue;
      }
      /**
       * Question marks
       */


      if (value === '?') {
        const isGroup = prev && prev.value === '(';

        if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('qmark', value);
          continue;
        }

        if (prev && prev.type === 'paren') {
          const next = peek();
          let output = value;

          if (next === '<' && !utils$4.supportsLookbehinds()) {
            throw new Error('Node.js v10 or higher is required for regex lookbehinds');
          }

          if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }

          push({
            type: 'text',
            value,
            output
          });
          continue;
        }

        if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
          push({
            type: 'qmark',
            value,
            output: QMARK_NO_DOT
          });
          continue;
        }

        push({
          type: 'qmark',
          value,
          output: QMARK
        });
        continue;
      }
      /**
       * Exclamation
       */


      if (value === '!') {
        if (opts.noextglob !== true && peek() === '(') {
          if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
            extglobOpen('negate', value);
            continue;
          }
        }

        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      /**
       * Plus
       */


      if (value === '+') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('plus', value);
          continue;
        }

        if (prev && prev.value === '(' || opts.regex === false) {
          push({
            type: 'plus',
            value,
            output: PLUS_LITERAL
          });
          continue;
        }

        if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
          push({
            type: 'plus',
            value
          });
          continue;
        }

        push({
          type: 'plus',
          value: PLUS_LITERAL
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value === '@') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          push({
            type: 'at',
            extglob: true,
            value,
            output: ''
          });
          continue;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value !== '*') {
        if (value === '$' || value === '^') {
          value = `\\${value}`;
        }

        const match = REGEX_NON_SPECIAL_CHARS$1.exec(remaining());

        if (match) {
          value += match[0];
          state.index += match[0].length;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Stars
       */


      if (prev && (prev.type === 'globstar' || prev.star === true)) {
        prev.type = 'star';
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }

      let rest = remaining();

      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen('star', value);
        continue;
      }

      if (prev.type === 'star') {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }

        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === 'slash' || prior.type === 'bos';
        const afterStar = before && (before.type === 'star' || before.type === 'globstar');

        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
          push({
            type: 'star',
            value,
            output: ''
          });
          continue;
        }

        const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
        const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');

        if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
          push({
            type: 'star',
            value,
            output: ''
          });
          continue;
        } // strip consecutive `/**/`


        while (rest.slice(0, 3) === '/**') {
          const after = input[state.index + 4];

          if (after && after !== '/') {
            break;
          }

          rest = rest.slice(3);
          consume('/**', 3);
        }

        if (prior.type === 'bos' && eos()) {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = 'globstar';
          prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
          const end = rest[1] !== void 0 ? '|$' : '';
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = 'globstar';
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        }

        if (prior.type === 'bos' && rest[0] === '/') {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        } // remove single star from output


        state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar

        prev.type = 'globstar';
        prev.output = globstar(opts);
        prev.value += value; // reset output with globstar

        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      const token = {
        type: 'star',
        value,
        output: star
      };

      if (opts.bash === true) {
        token.output = '.*?';

        if (prev.type === 'bos' || prev.type === 'slash') {
          token.output = nodot + token.output;
        }

        push(token);
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }

      if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
        if (prev.type === 'dot') {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }

        if (peek() !== '*') {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }

      push(token);
    }

    while (state.brackets > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError$1('closing', ']'));
      state.output = utils$4.escapeLast(state.output, '[');
      decrement('brackets');
    }

    while (state.parens > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError$1('closing', ')'));
      state.output = utils$4.escapeLast(state.output, '(');
      decrement('parens');
    }

    while (state.braces > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError$1('closing', '}'));
      state.output = utils$4.escapeLast(state.output, '{');
      decrement('braces');
    }

    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
      push({
        type: 'maybe_slash',
        value: '',
        output: `${SLASH_LITERAL}?`
      });
    } // rebuild the output if we had to backtrack at any point


    if (state.backtrack === true) {
      state.output = '';

      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;

        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }

    return state;
  };
  /**
   * Fast paths for creating regular expressions for common glob patterns.
   * This can significantly speed up processing and has very little downside
   * impact when none of the fast paths match.
   */


  parse$1.fastpaths = (input, options) => {
    const opts = { ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
    const len = input.length;

    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }

    input = REPLACEMENTS$1[input] || input;
    const win32 = utils$4.isWindows(options); // create constants based on platform, for windows or posix

    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants$2.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? '' : '?:';
    const state = {
      negated: false,
      prefix: ''
    };
    let star = opts.bash === true ? '.*?' : STAR;

    if (opts.capture) {
      star = `(${star})`;
    }

    const globstar = opts => {
      if (opts.noglobstar === true) return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };

    const create = str => {
      switch (str) {
        case '*':
          return `${nodot}${ONE_CHAR}${star}`;

        case '.*':
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '*.*':
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '*/*':
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

        case '**':
          return nodot + globstar(opts);

        case '**/*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

        case '**/*.*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '**/.*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

        default:
          {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source = create(match[1]);
            if (!source) return;
            return source + DOT_LITERAL + match[2];
          }
      }
    };

    const output = utils$4.removePrefix(input, state);
    let source = create(output);

    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }

    return source;
  };

  var parse_1$1 = parse$1;

  const isObject$1 = val => val && typeof val === 'object' && !Array.isArray(val);
  /**
   * Creates a matcher function from one or more glob patterns. The
   * returned function takes a string to match as its first argument,
   * and returns true if the string is a match. The returned matcher
   * function also takes a boolean as the second argument that, when true,
   * returns an object with additional information.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch(glob[, options]);
   *
   * const isMatch = picomatch('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @name picomatch
   * @param {String|Array} `globs` One or more glob patterns.
   * @param {Object=} `options`
   * @return {Function=} Returns a matcher function.
   * @api public
   */


  const picomatch$3 = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map(input => picomatch$3(input, options, returnState));

      const arrayMatcher = str => {
        for (const isMatch of fns) {
          const state = isMatch(str);
          if (state) return state;
        }

        return false;
      };

      return arrayMatcher;
    }

    const isState = isObject$1(glob) && glob.tokens && glob.input;

    if (glob === '' || typeof glob !== 'string' && !isState) {
      throw new TypeError('Expected pattern to be a non-empty string');
    }

    const opts = options || {};
    const posix = utils$4.isWindows(options);
    const regex = isState ? picomatch$3.compileRe(glob, options) : picomatch$3.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;

    let isIgnored = () => false;

    if (opts.ignore) {
      const ignoreOpts = { ...options,
        ignore: null,
        onMatch: null,
        onResult: null
      };
      isIgnored = picomatch$3(opts.ignore, ignoreOpts, returnState);
    }

    const matcher = (input, returnObject = false) => {
      const {
        isMatch,
        match,
        output
      } = picomatch$3.test(input, regex, options, {
        glob,
        posix
      });
      const result = {
        glob,
        state,
        regex,
        posix,
        input,
        output,
        match,
        isMatch
      };

      if (typeof opts.onResult === 'function') {
        opts.onResult(result);
      }

      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (isIgnored(input)) {
        if (typeof opts.onIgnore === 'function') {
          opts.onIgnore(result);
        }

        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (typeof opts.onMatch === 'function') {
        opts.onMatch(result);
      }

      return returnObject ? result : true;
    };

    if (returnState) {
      matcher.state = state;
    }

    return matcher;
  };
  /**
   * Test `input` with the given `regex`. This is used by the main
   * `picomatch()` function to test the input string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.test(input, regex[, options]);
   *
   * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
   * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp} `regex`
   * @return {Object} Returns an object with matching info.
   * @api public
   */


  picomatch$3.test = (input, regex, options, {
    glob,
    posix
  } = {}) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected input to be a string');
    }

    if (input === '') {
      return {
        isMatch: false,
        output: ''
      };
    }

    const opts = options || {};
    const format = opts.format || (posix ? utils$4.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;

    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }

    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch$3.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }

    return {
      isMatch: Boolean(match),
      match,
      output
    };
  };
  /**
   * Match the basename of a filepath.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.matchBase(input, glob[, options]);
   * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
   * @return {Boolean}
   * @api public
   */


  picomatch$3.matchBase = (input, glob, options, posix = utils$4.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch$3.makeRe(glob, options);
    return regex.test(path__default['default'].basename(input));
  };
  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.isMatch(string, patterns[, options]);
   *
   * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String|Array} str The string to test.
   * @param {String|Array} patterns One or more glob patterns to use for matching.
   * @param {Object} [options] See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  picomatch$3.isMatch = (str, patterns, options) => picomatch$3(patterns, options)(str);
  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const result = picomatch.parse(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
   * @api public
   */


  picomatch$3.parse = (pattern, options) => {
    if (Array.isArray(pattern)) return pattern.map(p => picomatch$3.parse(p, options));
    return parse_1$1(pattern, { ...options,
      fastpaths: false
    });
  };
  /**
   * Scan a glob pattern to separate the pattern into segments.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.scan(input[, options]);
   *
   * const result = picomatch.scan('!./foo/*.js');
   * console.log(result);
   * { prefix: '!./',
   *   input: '!./foo/*.js',
   *   start: 3,
   *   base: 'foo',
   *   glob: '*.js',
   *   isBrace: false,
   *   isBracket: false,
   *   isGlob: true,
   *   isExtglob: false,
   *   isGlobstar: false,
   *   negated: true }
   * ```
   * @param {String} `input` Glob pattern to scan.
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */


  picomatch$3.scan = (input, options) => scan_1$1(input, options);
  /**
   * Create a regular expression from a parsed glob pattern.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const state = picomatch.parse('*.js');
   * // picomatch.compileRe(state[, options]);
   *
   * console.log(picomatch.compileRe(state));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `state` The object returned from the `.parse` method.
   * @param {Object} `options`
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */


  picomatch$3.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return parsed.output;
    }

    const opts = options || {};
    const prepend = opts.contains ? '' : '^';
    const append = opts.contains ? '' : '$';
    let source = `${prepend}(?:${parsed.output})${append}`;

    if (parsed && parsed.negated === true) {
      source = `^(?!${source}).*$`;
    }

    const regex = picomatch$3.toRegex(source, options);

    if (returnState === true) {
      regex.state = parsed;
    }

    return regex;
  };

  picomatch$3.makeRe = (input, options, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== 'string') {
      throw new TypeError('Expected a non-empty string');
    }

    const opts = options || {};
    let parsed = {
      negated: false,
      fastpaths: true
    };
    let prefix = '';
    let output;

    if (input.startsWith('./')) {
      input = input.slice(2);
      prefix = parsed.prefix = './';
    }

    if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
      output = parse_1$1.fastpaths(input, options);
    }

    if (output === undefined) {
      parsed = parse_1$1(input, options);
      parsed.prefix = prefix + (parsed.prefix || '');
    } else {
      parsed.output = output;
    }

    return picomatch$3.compileRe(parsed, options, returnOutput, returnState);
  };
  /**
   * Create a regular expression from the given regex source string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.toRegex(source[, options]);
   *
   * const { output } = picomatch.parse('*.js');
   * console.log(picomatch.toRegex(output));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `source` Regular expression source string.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */


  picomatch$3.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
    } catch (err) {
      if (options && options.debug === true) throw err;
      return /$^/;
    }
  };
  /**
   * Picomatch constants.
   * @return {Object}
   */


  picomatch$3.constants = constants$2;
  /**
   * Expose "picomatch"
   */

  var picomatch_1$1 = picomatch$3;

  var picomatch$2 = picomatch_1$1;

  const isEmptyString$1 = val => val === '' || val === './';
  /**
   * Returns an array of strings that match one or more glob patterns.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm(list, patterns[, options]);
   *
   * console.log(mm(['a.js', 'a.txt'], ['*.js']));
   * //=> [ 'a.js' ]
   * ```
   * @param {String|Array<string>} `list` List of strings to match.
   * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options)
   * @return {Array} Returns an array of matches
   * @summary false
   * @api public
   */


  const micromatch$1 = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;

    let onResult = state => {
      items.add(state.output);

      if (options && options.onResult) {
        options.onResult(state);
      }
    };

    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch$2(String(patterns[i]), { ...options,
        onResult
      }, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated) negatives++;

      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match) continue;

        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }

    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter(item => !omit.has(item));

    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(', ')}"`);
      }

      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
      }
    }

    return matches;
  };
  /**
   * Backwards compatibility
   */


  micromatch$1.match = micromatch$1;
  /**
   * Returns a matcher function from the given glob `pattern` and `options`.
   * The returned function takes a string to match as its only argument and returns
   * true if the string is a match.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.matcher(pattern[, options]);
   *
   * const isMatch = mm.matcher('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @param {String} `pattern` Glob pattern
   * @param {Object} `options`
   * @return {Function} Returns a matcher function.
   * @api public
   */

  micromatch$1.matcher = (pattern, options) => picomatch$2(pattern, options);
  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.isMatch(string, patterns[, options]);
   *
   * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(mm.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `[options]` See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  micromatch$1.isMatch = (str, patterns, options) => picomatch$2(patterns, options)(str);
  /**
   * Backwards compatibility
   */


  micromatch$1.any = micromatch$1.isMatch;
  /**
   * Returns a list of strings that _**do not match any**_ of the given `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.not(list, patterns[, options]);
   *
   * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
   * //=> ['b.b', 'c.c']
   * ```
   * @param {Array} `list` Array of strings to match.
   * @param {String|Array} `patterns` One or more glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of strings that **do not match** the given patterns.
   * @api public
   */

  micromatch$1.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];

    let onResult = state => {
      if (options.onResult) options.onResult(state);
      items.push(state.output);
    };

    let matches = micromatch$1(list, patterns, { ...options,
      onResult
    });

    for (let item of items) {
      if (!matches.includes(item)) {
        result.add(item);
      }
    }

    return [...result];
  };
  /**
   * Returns true if the given `string` contains the given pattern. Similar
   * to [.isMatch](#isMatch) but the pattern can match any part of the string.
   *
   * ```js
   * var mm = require('micromatch');
   * // mm.contains(string, pattern[, options]);
   *
   * console.log(mm.contains('aa/bb/cc', '*b'));
   * //=> true
   * console.log(mm.contains('aa/bb/cc', '*d'));
   * //=> false
   * ```
   * @param {String} `str` The string to match.
   * @param {String|Array} `patterns` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
   * @api public
   */


  micromatch$1.contains = (str, pattern, options) => {
    if (typeof str !== 'string') {
      throw new TypeError(`Expected a string: "${util__default['default'].inspect(str)}"`);
    }

    if (Array.isArray(pattern)) {
      return pattern.some(p => micromatch$1.contains(str, p, options));
    }

    if (typeof pattern === 'string') {
      if (isEmptyString$1(str) || isEmptyString$1(pattern)) {
        return false;
      }

      if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {
        return true;
      }
    }

    return micromatch$1.isMatch(str, pattern, { ...options,
      contains: true
    });
  };
  /**
   * Filter the keys of the given object with the given `glob` pattern
   * and `options`. Does not attempt to match nested keys. If you need this feature,
   * use [glob-object][] instead.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.matchKeys(object, patterns[, options]);
   *
   * const obj = { aa: 'a', ab: 'b', ac: 'c' };
   * console.log(mm.matchKeys(obj, '*b'));
   * //=> { ab: 'b' }
   * ```
   * @param {Object} `object` The object with keys to filter.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Object} Returns an object with only keys that match the given patterns.
   * @api public
   */


  micromatch$1.matchKeys = (obj, patterns, options) => {
    if (!utils$4.isObject(obj)) {
      throw new TypeError('Expected the first argument to be an object');
    }

    let keys = micromatch$1(Object.keys(obj), patterns, options);
    let res = {};

    for (let key of keys) res[key] = obj[key];

    return res;
  };
  /**
   * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.some(list, patterns[, options]);
   *
   * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // true
   * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
   * @api public
   */


  micromatch$1.some = (list, patterns, options) => {
    let items = [].concat(list);

    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch$2(String(pattern), options);

      if (items.some(item => isMatch(item))) {
        return true;
      }
    }

    return false;
  };
  /**
   * Returns true if every string in the given `list` matches
   * any of the given glob `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.every(list, patterns[, options]);
   *
   * console.log(mm.every('foo.js', ['foo.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // false
   * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param {String|Array} `list` The string or array of strings to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
   * @api public
   */


  micromatch$1.every = (list, patterns, options) => {
    let items = [].concat(list);

    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch$2(String(pattern), options);

      if (!items.every(item => isMatch(item))) {
        return false;
      }
    }

    return true;
  };
  /**
   * Returns true if **all** of the given `patterns` match
   * the specified string.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.all(string, patterns[, options]);
   *
   * console.log(mm.all('foo.js', ['foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
   * // false
   *
   * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
   * // true
   * ```
   * @param {String|Array} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  micromatch$1.all = (str, patterns, options) => {
    if (typeof str !== 'string') {
      throw new TypeError(`Expected a string: "${util__default['default'].inspect(str)}"`);
    }

    return [].concat(patterns).every(p => picomatch$2(p, options)(str));
  };
  /**
   * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.capture(pattern, string[, options]);
   *
   * console.log(mm.capture('test/*.js', 'test/foo.js'));
   * //=> ['foo']
   * console.log(mm.capture('test/*.js', 'foo/bar.css'));
   * //=> null
   * ```
   * @param {String} `glob` Glob pattern to use for matching.
   * @param {String} `input` String to match
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
   * @api public
   */


  micromatch$1.capture = (glob, input, options) => {
    let posix = utils$4.isWindows(options);
    let regex = picomatch$2.makeRe(String(glob), { ...options,
      capture: true
    });
    let match = regex.exec(posix ? utils$4.toPosixSlashes(input) : input);

    if (match) {
      return match.slice(1).map(v => v === void 0 ? '' : v);
    }
  };
  /**
   * Create a regular expression from the given glob `pattern`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.makeRe(pattern[, options]);
   *
   * console.log(mm.makeRe('*.js'));
   * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
   * ```
   * @param {String} `pattern` A glob pattern to convert to regex.
   * @param {Object} `options`
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */


  micromatch$1.makeRe = (...args) => picomatch$2.makeRe(...args);
  /**
   * Scan a glob pattern to separate the pattern into segments. Used
   * by the [split](#split) method.
   *
   * ```js
   * const mm = require('micromatch');
   * const state = mm.scan(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */


  micromatch$1.scan = (...args) => picomatch$2.scan(...args);
  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const mm = require('micromatch');
   * const state = mm(pattern[, options]);
   * ```
   * @param {String} `glob`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as regex source string.
   * @api public
   */


  micromatch$1.parse = (patterns, options) => {
    let res = [];

    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces_1(String(pattern), options)) {
        res.push(picomatch$2.parse(str, options));
      }
    }

    return res;
  };
  /**
   * Process the given brace `pattern`.
   *
   * ```js
   * const { braces } = require('micromatch');
   * console.log(braces('foo/{a,b,c}/bar'));
   * //=> [ 'foo/(a|b|c)/bar' ]
   *
   * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
   * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
   * ```
   * @param {String} `pattern` String with brace pattern to process.
   * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
   * @return {Array}
   * @api public
   */


  micromatch$1.braces = (pattern, options) => {
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');

    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }

    return braces_1(pattern, options);
  };
  /**
   * Expand braces
   */


  micromatch$1.braceExpand = (pattern, options) => {
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');
    return micromatch$1.braces(pattern, { ...options,
      expand: true
    });
  };
  /**
   * Expose micromatch
   */


  var micromatch_1$1 = micromatch$1;

  var pattern$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;







  const GLOBSTAR = '**';
  const ESCAPE_SYMBOL = '\\';
  const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
  const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
  const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
  const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
  const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
  /**
   * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.
   * The latter is due to the presence of the device path at the beginning of the UNC path.
   */

  const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;

  function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
  }

  exports.isStaticPattern = isStaticPattern;

  function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') {
      return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */


    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
      return true;
    }

    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
      return true;
    }

    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
      return true;
    }

    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
      return true;
    }

    return false;
  }

  exports.isDynamicPattern = isDynamicPattern;

  function hasBraceExpansion(pattern) {
    const openingBraceIndex = pattern.indexOf('{');

    if (openingBraceIndex === -1) {
      return false;
    }

    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);

    if (closingBraceIndex === -1) {
      return false;
    }

    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
  }

  function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
  }

  exports.convertToPositivePattern = convertToPositivePattern;

  function convertToNegativePattern(pattern) {
    return '!' + pattern;
  }

  exports.convertToNegativePattern = convertToNegativePattern;

  function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
  }

  exports.isNegativePattern = isNegativePattern;

  function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
  }

  exports.isPositivePattern = isPositivePattern;

  function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
  }

  exports.getNegativePatterns = getNegativePatterns;

  function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
  }

  exports.getPositivePatterns = getPositivePatterns;
  /**
   * Returns patterns that can be applied inside the current directory.
   *
   * @example
   * // ['./*', '*', 'a/*']
   * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
   */

  function getPatternsInsideCurrentDirectory(patterns) {
    return patterns.filter(pattern => !isPatternRelatedToParentDirectory(pattern));
  }

  exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
  /**
   * Returns patterns to be expanded relative to (outside) the current directory.
   *
   * @example
   * // ['../*', './../*']
   * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
   */

  function getPatternsOutsideCurrentDirectory(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
  }

  exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;

  function isPatternRelatedToParentDirectory(pattern) {
    return pattern.startsWith('..') || pattern.startsWith('./..');
  }

  exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;

  function getBaseDirectory(pattern) {
    return globParent(pattern, {
      flipBackslashes: false
    });
  }

  exports.getBaseDirectory = getBaseDirectory;

  function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
  }

  exports.hasGlobStar = hasGlobStar;

  function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
  }

  exports.endsWithSlashGlobStar = endsWithSlashGlobStar;

  function isAffectDepthOfReadingPattern(pattern) {
    const basename = path__default['default'].basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
  }

  exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;

  function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
      return collection.concat(expandBraceExpansion(pattern));
    }, []);
  }

  exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;

  function expandBraceExpansion(pattern) {
    const patterns = micromatch_1$1.braces(pattern, {
      expand: true,
      nodupes: true
    });
    /**
     * Sort the patterns by length so that the same depth patterns are processed side by side.
     * `a/{b,}/{c,}/*` – `['a///*', 'a/b//*', 'a//c/*', 'a/b/c/*']`
     */

    patterns.sort((a, b) => a.length - b.length);
    /**
     * Micromatch can return an empty string in the case of patterns like `{a,}`.
     */

    return patterns.filter(pattern => pattern !== '');
  }

  exports.expandBraceExpansion = expandBraceExpansion;

  function getPatternParts(pattern, options) {
    let {
      parts
    } = micromatch_1$1.scan(pattern, Object.assign(Object.assign({}, options), {
      parts: true
    }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */

    if (parts.length === 0) {
      parts = [pattern];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */


    if (parts[0].startsWith('/')) {
      parts[0] = parts[0].slice(1);
      parts.unshift('');
    }

    return parts;
  }

  exports.getPatternParts = getPatternParts;

  function makeRe(pattern, options) {
    return micromatch_1$1.makeRe(pattern, options);
  }

  exports.makeRe = makeRe;

  function convertPatternsToRe(patterns, options) {
    return patterns.map(pattern => makeRe(pattern, options));
  }

  exports.convertPatternsToRe = convertPatternsToRe;

  function matchAny(entry, patternsRe) {
    return patternsRe.some(patternRe => patternRe.test(entry));
  }

  exports.matchAny = matchAny;
  /**
   * This package only works with forward slashes as a path separator.
   * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.
   */

  function removeDuplicateSlashes(pattern) {
    return pattern.replace(DOUBLE_SLASH_RE, '/');
  }

  exports.removeDuplicateSlashes = removeDuplicateSlashes;
  });

  /*
   * merge2
   * https://github.com/teambition/merge2
   *
   * Copyright (c) 2014-2020 Teambition
   * Licensed under the MIT license.
   */



  const PassThrough = stream_1__default['default'].PassThrough;
  const slice = Array.prototype.slice;
  var merge2_1 = merge2;

  function merge2() {
    const streamsQueue = [];
    const args = slice.call(arguments);
    let merging = false;
    let options = args[args.length - 1];

    if (options && !Array.isArray(options) && options.pipe == null) {
      args.pop();
    } else {
      options = {};
    }

    const doEnd = options.end !== false;
    const doPipeError = options.pipeError === true;

    if (options.objectMode == null) {
      options.objectMode = true;
    }

    if (options.highWaterMark == null) {
      options.highWaterMark = 64 * 1024;
    }

    const mergedStream = PassThrough(options);

    function addStream() {
      for (let i = 0, len = arguments.length; i < len; i++) {
        streamsQueue.push(pauseStreams(arguments[i], options));
      }

      mergeStream();
      return this;
    }

    function mergeStream() {
      if (merging) {
        return;
      }

      merging = true;
      let streams = streamsQueue.shift();

      if (!streams) {
        process.nextTick(endStream);
        return;
      }

      if (!Array.isArray(streams)) {
        streams = [streams];
      }

      let pipesCount = streams.length + 1;

      function next() {
        if (--pipesCount > 0) {
          return;
        }

        merging = false;
        mergeStream();
      }

      function pipe(stream) {
        function onend() {
          stream.removeListener('merge2UnpipeEnd', onend);
          stream.removeListener('end', onend);

          if (doPipeError) {
            stream.removeListener('error', onerror);
          }

          next();
        }

        function onerror(err) {
          mergedStream.emit('error', err);
        } // skip ended stream


        if (stream._readableState.endEmitted) {
          return next();
        }

        stream.on('merge2UnpipeEnd', onend);
        stream.on('end', onend);

        if (doPipeError) {
          stream.on('error', onerror);
        }

        stream.pipe(mergedStream, {
          end: false
        }); // compatible for old stream

        stream.resume();
      }

      for (let i = 0; i < streams.length; i++) {
        pipe(streams[i]);
      }

      next();
    }

    function endStream() {
      merging = false; // emit 'queueDrain' when all streams merged.

      mergedStream.emit('queueDrain');

      if (doEnd) {
        mergedStream.end();
      }
    }

    mergedStream.setMaxListeners(0);
    mergedStream.add = addStream;
    mergedStream.on('unpipe', function (stream) {
      stream.emit('merge2UnpipeEnd');
    });

    if (args.length) {
      addStream.apply(null, args);
    }

    return mergedStream;
  } // check and pause streams for pipe.


  function pauseStreams(streams, options) {
    if (!Array.isArray(streams)) {
      // Backwards-compat with old-style streams
      if (!streams._readableState && streams.pipe) {
        streams = streams.pipe(PassThrough(options));
      }

      if (!streams._readableState || !streams.pause || !streams.pipe) {
        throw new Error('Only readable stream can be merged.');
      }

      streams.pause();
    } else {
      for (let i = 0, len = streams.length; i < len; i++) {
        streams[i] = pauseStreams(streams[i], options);
      }
    }

    return streams;
  }

  var stream$7 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.merge = void 0;



  function merge(streams) {
    const mergedStream = merge2_1(streams);
    streams.forEach(stream => {
      stream.once('error', error => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
  }

  exports.merge = merge;

  function propagateCloseEventToSources(streams) {
    streams.forEach(stream => stream.emit('close'));
  }
  });

  var string$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isEmpty = exports.isString = void 0;

  function isString(input) {
    return typeof input === 'string';
  }

  exports.isString = isString;

  function isEmpty(input) {
    return input === '';
  }

  exports.isEmpty = isEmpty;
  });

  var utils$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;



  exports.array = array$1;



  exports.errno = errno$1;



  exports.fs = fs$2;



  exports.path = path_1$1;



  exports.pattern = pattern$1;



  exports.stream = stream$7;



  exports.string = string$1;
  });

  var tasks$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;



  function generate(input, settings) {
    const patterns = processPatterns(input, settings);
    const ignore = processPatterns(settings.ignore, settings);
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
    const staticPatterns = positivePatterns.filter(pattern => utils$3.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter(pattern => utils$3.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns,
    /* dynamic */
    false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns,
    /* dynamic */
    true);
    return staticTasks.concat(dynamicTasks);
  }

  exports.generate = generate;

  function processPatterns(input, settings) {
    let patterns = input;
    /**
     * The original pattern like `{,*,**,a/*}` can lead to problems checking the depth when matching entry
     * and some problems with the micromatch package (see fast-glob issues: #365, #394).
     *
     * To solve this problem, we expand all patterns containing brace expansion. This can lead to a slight slowdown
     * in matching in the case of a large set of patterns after expansion.
     */

    if (settings.braceExpansion) {
      patterns = utils$3.pattern.expandPatternsWithBraceExpansion(patterns);
    }
    /**
     * If the `baseNameMatch` option is enabled, we must add globstar to patterns, so that they can be used
     * at any nesting level.
     *
     * We do this here, because otherwise we have to complicate the filtering logic. For example, we need to change
     * the pattern in the filter before creating a regular expression. There is no need to change the patterns
     * in the application. Only on the input.
     */


    if (settings.baseNameMatch) {
      patterns = patterns.map(pattern => pattern.includes('/') ? pattern : `**/${pattern}`);
    }
    /**
     * This method also removes duplicate slashes that may have been in the pattern or formed as a result of expansion.
     */


    return patterns.map(pattern => utils$3.pattern.removeDuplicateSlashes(pattern));
  }
  /**
   * Returns tasks grouped by basic pattern directories.
   *
   * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
   * This is necessary because directory traversal starts at the base directory and goes deeper.
   */


  function convertPatternsToTasks(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils$3.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils$3.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    /*
     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
     */

    if ('.' in insideCurrentDirectoryGroup) {
      tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
    } else {
      tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }

    return tasks;
  }

  exports.convertPatternsToTasks = convertPatternsToTasks;

  function getPositivePatterns(patterns) {
    return utils$3.pattern.getPositivePatterns(patterns);
  }

  exports.getPositivePatterns = getPositivePatterns;

  function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils$3.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils$3.pattern.convertToPositivePattern);
    return positive;
  }

  exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;

  function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
      const base = utils$3.pattern.getBaseDirectory(pattern);

      if (base in collection) {
        collection[base].push(pattern);
      } else {
        collection[base] = [pattern];
      }

      return collection;
    }, group);
  }

  exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;

  function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map(base => {
      return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
  }

  exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;

  function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
      dynamic,
      positive,
      negative,
      base,
      patterns: [].concat(positive, negative.map(utils$3.pattern.convertToNegativePattern))
    };
  }

  exports.convertPatternGroupToTask = convertPatternGroupToTask;
  });

  var async$7 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.read = void 0;

  function read(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
      if (lstatError !== null) {
        return callFailureCallback(callback, lstatError);
      }

      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return callSuccessCallback(callback, lstat);
      }

      settings.fs.stat(path, (statError, stat) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            return callFailureCallback(callback, statError);
          }

          return callSuccessCallback(callback, lstat);
        }

        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }

        callSuccessCallback(callback, stat);
      });
    });
  }

  exports.read = read;

  function callFailureCallback(callback, error) {
    callback(error);
  }

  function callSuccessCallback(callback, result) {
    callback(null, result);
  }
  });

  var sync$b = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.read = void 0;

  function read(path, settings) {
    const lstat = settings.fs.lstatSync(path);

    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
      return lstat;
    }

    try {
      const stat = settings.fs.statSync(path);

      if (settings.markSymbolicLink) {
        stat.isSymbolicLink = () => true;
      }

      return stat;
    } catch (error) {
      if (!settings.throwErrorOnBrokenSymbolicLink) {
        return lstat;
      }

      throw error;
    }
  }

  exports.read = read;
  });

  var fs_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;



  exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs__default['default'].lstat,
    stat: fs__default['default'].stat,
    lstatSync: fs__default['default'].lstatSync,
    statSync: fs__default['default'].statSync
  };

  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
      return exports.FILE_SYSTEM_ADAPTER;
    }

    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
  }

  exports.createFileSystemAdapter = createFileSystemAdapter;
  });

  class Settings$2 {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
      this.fs = fs_1$1.createFileSystemAdapter(this._options.fs);
      this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }

    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }

  }

  var _default$A = Settings$2;

  var settings$4 = /*#__PURE__*/Object.defineProperty({
  	default: _default$A
  }, '__esModule', {value: true});

  var out$4 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.statSync = exports.stat = exports.Settings = void 0;







  exports.Settings = settings$4.default;

  function stat(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
      return async$7.read(path, getSettings(), optionsOrSettingsOrCallback);
    }

    async$7.read(path, getSettings(optionsOrSettingsOrCallback), callback);
  }

  exports.stat = stat;

  function statSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync$b.read(path, settings);
  }

  exports.statSync = statSync;

  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings$4.default) {
      return settingsOrOptions;
    }

    return new settings$4.default(settingsOrOptions);
  }
  });

  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  let promise$1;
  var queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask.bind(globalThis) // reuse resolved promise, and allocate it lazily
  : cb => (promise$1 || (promise$1 = Promise.resolve())).then(cb).catch(err => setTimeout(() => {
    throw err;
  }, 0));

  /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

  var runParallel_1 = runParallel;



  function runParallel(tasks, cb) {
    let results, pending, keys;
    let isSync = true;

    if (Array.isArray(tasks)) {
      results = [];
      pending = tasks.length;
    } else {
      keys = Object.keys(tasks);
      results = {};
      pending = keys.length;
    }

    function done(err) {
      function end() {
        if (cb) cb(err, results);
        cb = null;
      }

      if (isSync) queueMicrotask_1(end);else end();
    }

    function each(i, err, result) {
      results[i] = result;

      if (--pending === 0 || err) {
        done(err);
      }
    }

    if (!pending) {
      // empty
      done(null);
    } else if (keys) {
      // object
      keys.forEach(function (key) {
        tasks[key](function (err, result) {
          each(key, err, result);
        });
      });
    } else {
      // array
      tasks.forEach(function (task, i) {
        task(function (err, result) {
          each(i, err, result);
        });
      });
    }

    isSync = false;
  }

  var constants$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
  const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
  const MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
  const MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
  const SUPPORTED_MAJOR_VERSION = 10;
  const SUPPORTED_MINOR_VERSION = 10;
  const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
  const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
  /**
   * IS `true` for Node.js 10.10 and greater.
   */

  exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  });

  var fs$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createDirentFromStats = void 0;

  class DirentFromStats {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }

  }

  function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
  }

  exports.createDirentFromStats = createDirentFromStats;
  });

  var utils$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fs = void 0;



  exports.fs = fs$1;
  });

  var common$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.joinPathSegments = void 0;

  function joinPathSegments(a, b, separator) {
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
      return a + b;
    }

    return a + separator + b;
  }

  exports.joinPathSegments = joinPathSegments;
  });

  var async$6 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;











  function read(directory, settings, callback) {
    if (!settings.stats && constants$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      return readdirWithFileTypes(directory, settings, callback);
    }

    return readdir(directory, settings, callback);
  }

  exports.read = read;

  function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, {
      withFileTypes: true
    }, (readdirError, dirents) => {
      if (readdirError !== null) {
        return callFailureCallback(callback, readdirError);
      }

      const entries = dirents.map(dirent => ({
        dirent,
        name: dirent.name,
        path: common$1.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      }));

      if (!settings.followSymbolicLinks) {
        return callSuccessCallback(callback, entries);
      }

      const tasks = entries.map(entry => makeRplTaskEntry(entry, settings));
      runParallel_1(tasks, (rplError, rplEntries) => {
        if (rplError !== null) {
          return callFailureCallback(callback, rplError);
        }

        callSuccessCallback(callback, rplEntries);
      });
    });
  }

  exports.readdirWithFileTypes = readdirWithFileTypes;

  function makeRplTaskEntry(entry, settings) {
    return done => {
      if (!entry.dirent.isSymbolicLink()) {
        return done(null, entry);
      }

      settings.fs.stat(entry.path, (statError, stats) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            return done(statError);
          }

          return done(null, entry);
        }

        entry.dirent = utils$2.fs.createDirentFromStats(entry.name, stats);
        return done(null, entry);
      });
    };
  }

  function readdir(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
      if (readdirError !== null) {
        return callFailureCallback(callback, readdirError);
      }

      const filepaths = names.map(name => common$1.joinPathSegments(directory, name, settings.pathSegmentSeparator));
      const tasks = filepaths.map(filepath => {
        return done => out$4.stat(filepath, settings.fsStatSettings, done);
      });
      runParallel_1(tasks, (rplError, results) => {
        if (rplError !== null) {
          return callFailureCallback(callback, rplError);
        }

        const entries = [];
        names.forEach((name, index) => {
          const stats = results[index];
          const entry = {
            name,
            path: filepaths[index],
            dirent: utils$2.fs.createDirentFromStats(name, stats)
          };

          if (settings.stats) {
            entry.stats = stats;
          }

          entries.push(entry);
        });
        callSuccessCallback(callback, entries);
      });
    });
  }

  exports.readdir = readdir;

  function callFailureCallback(callback, error) {
    callback(error);
  }

  function callSuccessCallback(callback, result) {
    callback(null, result);
  }
  });

  var sync$a = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;









  function read(directory, settings) {
    if (!settings.stats && constants$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      return readdirWithFileTypes(directory, settings);
    }

    return readdir(directory, settings);
  }

  exports.read = read;

  function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, {
      withFileTypes: true
    });
    return dirents.map(dirent => {
      const entry = {
        dirent,
        name: dirent.name,
        path: common$1.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      };

      if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
        try {
          const stats = settings.fs.statSync(entry.path);
          entry.dirent = utils$2.fs.createDirentFromStats(entry.name, stats);
        } catch (error) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            throw error;
          }
        }
      }

      return entry;
    });
  }

  exports.readdirWithFileTypes = readdirWithFileTypes;

  function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map(name => {
      const entryPath = common$1.joinPathSegments(directory, name, settings.pathSegmentSeparator);
      const stats = out$4.statSync(entryPath, settings.fsStatSettings);
      const entry = {
        name,
        path: entryPath,
        dirent: utils$2.fs.createDirentFromStats(name, stats)
      };

      if (settings.stats) {
        entry.stats = stats;
      }

      return entry;
    });
  }

  exports.readdir = readdir;
  });

  var fs_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;



  exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs__default['default'].lstat,
    stat: fs__default['default'].stat,
    lstatSync: fs__default['default'].lstatSync,
    statSync: fs__default['default'].statSync,
    readdir: fs__default['default'].readdir,
    readdirSync: fs__default['default'].readdirSync
  };

  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
      return exports.FILE_SYSTEM_ADAPTER;
    }

    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
  }

  exports.createFileSystemAdapter = createFileSystemAdapter;
  });

  class Settings$1 {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
      this.fs = fs_1.createFileSystemAdapter(this._options.fs);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path__default['default'].sep);
      this.stats = this._getValue(this._options.stats, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      this.fsStatSettings = new out$4.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }

    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }

  }

  var _default$z = Settings$1;

  var settings$3 = /*#__PURE__*/Object.defineProperty({
  	default: _default$z
  }, '__esModule', {value: true});

  var out$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Settings = exports.scandirSync = exports.scandir = void 0;







  exports.Settings = settings$3.default;

  function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
      return async$6.read(path, getSettings(), optionsOrSettingsOrCallback);
    }

    async$6.read(path, getSettings(optionsOrSettingsOrCallback), callback);
  }

  exports.scandir = scandir;

  function scandirSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync$a.read(path, settings);
  }

  exports.scandirSync = scandirSync;

  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings$3.default) {
      return settingsOrOptions;
    }

    return new settings$3.default(settingsOrOptions);
  }
  });

  function reusify(Constructor) {
    var head = new Constructor();
    var tail = head;

    function get() {
      var current = head;

      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor();
        tail = head;
      }

      current.next = null;
      return current;
    }

    function release(obj) {
      tail.next = obj;
      tail = obj;
    }

    return {
      get: get,
      release: release
    };
  }

  var reusify_1 = reusify;

  function fastqueue(context, worker, concurrency) {
    if (typeof context === 'function') {
      concurrency = worker;
      worker = context;
      context = null;
    }

    if (concurrency < 1) {
      throw new Error('fastqueue concurrency must be greater than 1');
    }

    var cache = reusify_1(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self = {
      push: push,
      drain: noop,
      saturated: noop,
      pause: pause,
      paused: false,
      concurrency: concurrency,
      running: running,
      resume: resume,
      idle: idle,
      length: length,
      getQueue: getQueue,
      unshift: unshift,
      empty: noop,
      kill: kill,
      killAndDrain: killAndDrain,
      error: error
    };
    return self;

    function running() {
      return _running;
    }

    function pause() {
      self.paused = true;
    }

    function length() {
      var current = queueHead;
      var counter = 0;

      while (current) {
        current = current.next;
        counter++;
      }

      return counter;
    }

    function getQueue() {
      var current = queueHead;
      var tasks = [];

      while (current) {
        tasks.push(current.value);
        current = current.next;
      }

      return tasks;
    }

    function resume() {
      if (!self.paused) return;
      self.paused = false;

      for (var i = 0; i < self.concurrency; i++) {
        _running++;
        release();
      }
    }

    function idle() {
      return _running === 0 && self.length() === 0;
    }

    function push(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      current.errorHandler = errorHandler;

      if (_running === self.concurrency || self.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }

    function unshift(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;

      if (_running === self.concurrency || self.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }

    function release(holder) {
      if (holder) {
        cache.release(holder);
      }

      var next = queueHead;

      if (next) {
        if (!self.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }

          queueHead = next.next;
          next.next = null;
          worker.call(context, next.value, next.worked);

          if (queueTail === null) {
            self.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self.drain();
      }
    }

    function kill() {
      queueHead = null;
      queueTail = null;
      self.drain = noop;
    }

    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self.drain();
      self.drain = noop;
    }

    function error(handler) {
      errorHandler = handler;
    }
  }

  function noop() {}

  function Task() {
    this.value = null;
    this.callback = noop;
    this.next = null;
    this.release = noop;
    this.context = null;
    this.errorHandler = null;
    var self = this;

    this.worked = function worked(err, result) {
      var callback = self.callback;
      var errorHandler = self.errorHandler;
      var val = self.value;
      self.value = null;
      self.callback = noop;

      if (self.errorHandler) {
        errorHandler(err, val);
      }

      callback.call(self.context, err, result);
      self.release(self);
    };
  }

  function queueAsPromised(context, worker, concurrency) {
    if (typeof context === 'function') {
      concurrency = worker;
      worker = context;
      context = null;
    }

    function asyncWrapper(arg, cb) {
      worker.call(this, arg).then(function (res) {
        cb(null, res);
      }, cb);
    }

    var queue = fastqueue(context, asyncWrapper, concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push;
    queue.unshift = unshift;
    return queue;

    function push(value) {
      return new Promise(function (resolve, reject) {
        pushCb(value, function (err, result) {
          if (err) {
            reject(err);
            return;
          }

          resolve(result);
        });
      });
    }

    function unshift(value) {
      return new Promise(function (resolve, reject) {
        unshiftCb(value, function (err, result) {
          if (err) {
            reject(err);
            return;
          }

          resolve(result);
        });
      });
    }
  }

  var queue = fastqueue;
  var promise = queueAsPromised;
  queue.promise = promise;

  var common = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;

  function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
      return true;
    }

    return !settings.errorFilter(error);
  }

  exports.isFatalError = isFatalError;

  function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
  }

  exports.isAppliedFilter = isAppliedFilter;

  function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
  }

  exports.replacePathSegmentSeparator = replacePathSegmentSeparator;

  function joinPathSegments(a, b, separator) {
    if (a === '') {
      return b;
    }
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */


    if (a.endsWith(separator)) {
      return a + b;
    }

    return a + separator + b;
  }

  exports.joinPathSegments = joinPathSegments;
  });

  class Reader$2 {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }

  }

  var _default$y = Reader$2;

  var reader$2 = /*#__PURE__*/Object.defineProperty({
  	default: _default$y
  }, '__esModule', {value: true});

  class AsyncReader extends reader$2.default {
    constructor(_root, _settings) {
      super(_root, _settings);
      this._settings = _settings;
      this._scandir = out$3.scandir;
      this._emitter = new require$$0__default['default'].EventEmitter();
      this._queue = queue(this._worker.bind(this), this._settings.concurrency);
      this._isFatalError = false;
      this._isDestroyed = false;

      this._queue.drain = () => {
        if (!this._isFatalError) {
          this._emitter.emit('end');
        }
      };
    }

    read() {
      this._isFatalError = false;
      this._isDestroyed = false;
      setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      });
      return this._emitter;
    }

    get isDestroyed() {
      return this._isDestroyed;
    }

    destroy() {
      if (this._isDestroyed) {
        throw new Error('The reader is already destroyed');
      }

      this._isDestroyed = true;

      this._queue.killAndDrain();
    }

    onEntry(callback) {
      this._emitter.on('entry', callback);
    }

    onError(callback) {
      this._emitter.once('error', callback);
    }

    onEnd(callback) {
      this._emitter.once('end', callback);
    }

    _pushToQueue(directory, base) {
      const queueItem = {
        directory,
        base
      };

      this._queue.push(queueItem, error => {
        if (error !== null) {
          this._handleError(error);
        }
      });
    }

    _worker(item, done) {
      this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
        if (error !== null) {
          return done(error, undefined);
        }

        for (const entry of entries) {
          this._handleEntry(entry, item.base);
        }

        done(null, undefined);
      });
    }

    _handleError(error) {
      if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
        return;
      }

      this._isFatalError = true;
      this._isDestroyed = true;

      this._emitter.emit('error', error);
    }

    _handleEntry(entry, base) {
      if (this._isDestroyed || this._isFatalError) {
        return;
      }

      const fullpath = entry.path;

      if (base !== undefined) {
        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
      }

      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._emitEntry(entry);
      }

      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, entry.path);
      }
    }

    _emitEntry(entry) {
      this._emitter.emit('entry', entry);
    }

  }

  var _default$x = AsyncReader;

  var async$5 = /*#__PURE__*/Object.defineProperty({
  	default: _default$x
  }, '__esModule', {value: true});

  class AsyncProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async$5.default(this._root, this._settings);
      this._storage = new Set();
    }

    read(callback) {
      this._reader.onError(error => {
        callFailureCallback(callback, error);
      });

      this._reader.onEntry(entry => {
        this._storage.add(entry);
      });

      this._reader.onEnd(() => {
        callSuccessCallback(callback, [...this._storage]);
      });

      this._reader.read();
    }

  }

  var _default$w = AsyncProvider;

  function callFailureCallback(callback, error) {
    callback(error);
  }

  function callSuccessCallback(callback, entries) {
    callback(null, entries);
  }

  var async$4 = /*#__PURE__*/Object.defineProperty({
  	default: _default$w
  }, '__esModule', {value: true});

  class StreamProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async$5.default(this._root, this._settings);
      this._stream = new stream_1__default['default'].Readable({
        objectMode: true,
        read: () => {},
        destroy: () => {
          if (!this._reader.isDestroyed) {
            this._reader.destroy();
          }
        }
      });
    }

    read() {
      this._reader.onError(error => {
        this._stream.emit('error', error);
      });

      this._reader.onEntry(entry => {
        this._stream.push(entry);
      });

      this._reader.onEnd(() => {
        this._stream.push(null);
      });

      this._reader.read();

      return this._stream;
    }

  }

  var _default$v = StreamProvider;

  var stream$6 = /*#__PURE__*/Object.defineProperty({
  	default: _default$v
  }, '__esModule', {value: true});

  class SyncReader extends reader$2.default {
    constructor() {
      super(...arguments);
      this._scandir = out$3.scandirSync;
      this._storage = new Set();
      this._queue = new Set();
    }

    read() {
      this._pushToQueue(this._root, this._settings.basePath);

      this._handleQueue();

      return [...this._storage];
    }

    _pushToQueue(directory, base) {
      this._queue.add({
        directory,
        base
      });
    }

    _handleQueue() {
      for (const item of this._queue.values()) {
        this._handleDirectory(item.directory, item.base);
      }
    }

    _handleDirectory(directory, base) {
      try {
        const entries = this._scandir(directory, this._settings.fsScandirSettings);

        for (const entry of entries) {
          this._handleEntry(entry, base);
        }
      } catch (error) {
        this._handleError(error);
      }
    }

    _handleError(error) {
      if (!common.isFatalError(this._settings, error)) {
        return;
      }

      throw error;
    }

    _handleEntry(entry, base) {
      const fullpath = entry.path;

      if (base !== undefined) {
        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
      }

      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._pushToStorage(entry);
      }

      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, entry.path);
      }
    }

    _pushToStorage(entry) {
      this._storage.add(entry);
    }

  }

  var _default$u = SyncReader;

  var sync$9 = /*#__PURE__*/Object.defineProperty({
  	default: _default$u
  }, '__esModule', {value: true});

  class SyncProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new sync$9.default(this._root, this._settings);
    }

    read() {
      return this._reader.read();
    }

  }

  var _default$t = SyncProvider;

  var sync$8 = /*#__PURE__*/Object.defineProperty({
  	default: _default$t
  }, '__esModule', {value: true});

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.basePath = this._getValue(this._options.basePath, undefined);
      this.concurrency = this._getValue(this._options.concurrency, Infinity);
      this.deepFilter = this._getValue(this._options.deepFilter, null);
      this.entryFilter = this._getValue(this._options.entryFilter, null);
      this.errorFilter = this._getValue(this._options.errorFilter, null);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path__default['default'].sep);
      this.fsScandirSettings = new out$3.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }

    _getValue(option, value) {
      return option !== null && option !== void 0 ? option : value;
    }

  }

  var _default$s = Settings;

  var settings$2 = /*#__PURE__*/Object.defineProperty({
  	default: _default$s
  }, '__esModule', {value: true});

  var out$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;









  exports.Settings = settings$2.default;

  function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
      return new async$4.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    }

    new async$4.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
  }

  exports.walk = walk;

  function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync$8.default(directory, settings);
    return provider.read();
  }

  exports.walkSync = walkSync;

  function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream$6.default(directory, settings);
    return provider.read();
  }

  exports.walkStream = walkStream;

  function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings$2.default) {
      return settingsOrOptions;
    }

    return new settings$2.default(settingsOrOptions);
  }
  });

  class Reader$1 {
    constructor(_settings) {
      this._settings = _settings;
      this._fsStatSettings = new out$4.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }

    _getFullEntryPath(filepath) {
      return path__default['default'].resolve(this._settings.cwd, filepath);
    }

    _makeEntry(stats, pattern) {
      const entry = {
        name: pattern,
        path: pattern,
        dirent: utils$3.fs.createDirentFromStats(pattern, stats)
      };

      if (this._settings.stats) {
        entry.stats = stats;
      }

      return entry;
    }

    _isFatalError(error) {
      return !utils$3.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }

  }

  var _default$r = Reader$1;

  var reader$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$r
  }, '__esModule', {value: true});

  class ReaderStream$1 extends reader$1.default {
    constructor() {
      super(...arguments);
      this._walkStream = out$2.walkStream;
      this._stat = out$4.stat;
    }

    dynamic(root, options) {
      return this._walkStream(root, options);
    }

    static(patterns, options) {
      const filepaths = patterns.map(this._getFullEntryPath, this);
      const stream = new stream_1__default['default'].PassThrough({
        objectMode: true
      });

      stream._write = (index, _enc, done) => {
        return this._getEntry(filepaths[index], patterns[index], options).then(entry => {
          if (entry !== null && options.entryFilter(entry)) {
            stream.push(entry);
          }

          if (index === filepaths.length - 1) {
            stream.end();
          }

          done();
        }).catch(done);
      };

      for (let i = 0; i < filepaths.length; i++) {
        stream.write(i);
      }

      return stream;
    }

    _getEntry(filepath, pattern, options) {
      return this._getStat(filepath).then(stats => this._makeEntry(stats, pattern)).catch(error => {
        if (options.errorFilter(error)) {
          return null;
        }

        throw error;
      });
    }

    _getStat(filepath) {
      return new Promise((resolve, reject) => {
        this._stat(filepath, this._fsStatSettings, (error, stats) => {
          return error === null ? resolve(stats) : reject(error);
        });
      });
    }

  }

  var _default$q = ReaderStream$1;

  var stream$5 = /*#__PURE__*/Object.defineProperty({
  	default: _default$q
  }, '__esModule', {value: true});

  class ReaderAsync$1 extends reader$1.default {
    constructor() {
      super(...arguments);
      this._walkAsync = out$2.walk;
      this._readerStream = new stream$5.default(this._settings);
    }

    dynamic(root, options) {
      return new Promise((resolve, reject) => {
        this._walkAsync(root, options, (error, entries) => {
          if (error === null) {
            resolve(entries);
          } else {
            reject(error);
          }
        });
      });
    }

    async static(patterns, options) {
      const entries = [];

      const stream = this._readerStream.static(patterns, options); // After #235, replace it with an asynchronous iterator.


      return new Promise((resolve, reject) => {
        stream.once('error', reject);
        stream.on('data', entry => entries.push(entry));
        stream.once('end', () => resolve(entries));
      });
    }

  }

  var _default$p = ReaderAsync$1;

  var async$3 = /*#__PURE__*/Object.defineProperty({
  	default: _default$p
  }, '__esModule', {value: true});

  class Matcher$1 {
    constructor(_patterns, _settings, _micromatchOptions) {
      this._patterns = _patterns;
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this._storage = [];

      this._fillStorage();
    }

    _fillStorage() {
      for (const pattern of this._patterns) {
        const segments = this._getPatternSegments(pattern);

        const sections = this._splitSegmentsIntoSections(segments);

        this._storage.push({
          complete: sections.length <= 1,
          pattern,
          segments,
          sections
        });
      }
    }

    _getPatternSegments(pattern) {
      const parts = utils$3.pattern.getPatternParts(pattern, this._micromatchOptions);
      return parts.map(part => {
        const dynamic = utils$3.pattern.isDynamicPattern(part, this._settings);

        if (!dynamic) {
          return {
            dynamic: false,
            pattern: part
          };
        }

        return {
          dynamic: true,
          pattern: part,
          patternRe: utils$3.pattern.makeRe(part, this._micromatchOptions)
        };
      });
    }

    _splitSegmentsIntoSections(segments) {
      return utils$3.array.splitWhen(segments, segment => segment.dynamic && utils$3.pattern.hasGlobStar(segment.pattern));
    }

  }

  var _default$o = Matcher$1;

  var matcher$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$o
  }, '__esModule', {value: true});

  class PartialMatcher$1 extends matcher$1.default {
    match(filepath) {
      const parts = filepath.split('/');
      const levels = parts.length;

      const patterns = this._storage.filter(info => !info.complete || info.segments.length > levels);

      for (const pattern of patterns) {
        const section = pattern.sections[0];
        /**
         * In this case, the pattern has a globstar and we must read all directories unconditionally,
         * but only if the level has reached the end of the first group.
         *
         * fixtures/{a,b}/**
         *  ^ true/false  ^ always true
        */

        if (!pattern.complete && levels > section.length) {
          return true;
        }

        const match = parts.every((part, index) => {
          const segment = pattern.segments[index];

          if (segment.dynamic && segment.patternRe.test(part)) {
            return true;
          }

          if (!segment.dynamic && segment.pattern === part) {
            return true;
          }

          return false;
        });

        if (match) {
          return true;
        }
      }

      return false;
    }

  }

  var _default$n = PartialMatcher$1;

  var partial$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$n
  }, '__esModule', {value: true});

  class DeepFilter$1 {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
    }

    getFilter(basePath, positive, negative) {
      const matcher = this._getMatcher(positive);

      const negativeRe = this._getNegativePatternsRe(negative);

      return entry => this._filter(basePath, entry, matcher, negativeRe);
    }

    _getMatcher(patterns) {
      return new partial$1.default(patterns, this._settings, this._micromatchOptions);
    }

    _getNegativePatternsRe(patterns) {
      const affectDepthOfReadingPatterns = patterns.filter(utils$3.pattern.isAffectDepthOfReadingPattern);
      return utils$3.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }

    _filter(basePath, entry, matcher, negativeRe) {
      if (this._isSkippedByDeep(basePath, entry.path)) {
        return false;
      }

      if (this._isSkippedSymbolicLink(entry)) {
        return false;
      }

      const filepath = utils$3.path.removeLeadingDotSegment(entry.path);

      if (this._isSkippedByPositivePatterns(filepath, matcher)) {
        return false;
      }

      return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }

    _isSkippedByDeep(basePath, entryPath) {
      /**
       * Avoid unnecessary depth calculations when it doesn't matter.
       */
      if (this._settings.deep === Infinity) {
        return false;
      }

      return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }

    _getEntryLevel(basePath, entryPath) {
      const entryPathDepth = entryPath.split('/').length;

      if (basePath === '') {
        return entryPathDepth;
      }

      const basePathDepth = basePath.split('/').length;
      return entryPathDepth - basePathDepth;
    }

    _isSkippedSymbolicLink(entry) {
      return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }

    _isSkippedByPositivePatterns(entryPath, matcher) {
      return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }

    _isSkippedByNegativePatterns(entryPath, patternsRe) {
      return !utils$3.pattern.matchAny(entryPath, patternsRe);
    }

  }

  var _default$m = DeepFilter$1;

  var deep$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$m
  }, '__esModule', {value: true});

  class EntryFilter$1 {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this.index = new Map();
    }

    getFilter(positive, negative) {
      const positiveRe = utils$3.pattern.convertPatternsToRe(positive, this._micromatchOptions);
      const negativeRe = utils$3.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), {
        dot: true
      }));
      return entry => this._filter(entry, positiveRe, negativeRe);
    }

    _filter(entry, positiveRe, negativeRe) {
      const filepath = utils$3.path.removeLeadingDotSegment(entry.path);

      if (this._settings.unique && this._isDuplicateEntry(filepath)) {
        return false;
      }

      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
        return false;
      }

      if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
        return false;
      }

      const isDirectory = entry.dirent.isDirectory();
      const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);

      if (this._settings.unique && isMatched) {
        this._createIndexRecord(filepath);
      }

      return isMatched;
    }

    _isDuplicateEntry(filepath) {
      return this.index.has(filepath);
    }

    _createIndexRecord(filepath) {
      this.index.set(filepath, undefined);
    }

    _onlyFileFilter(entry) {
      return this._settings.onlyFiles && !entry.dirent.isFile();
    }

    _onlyDirectoryFilter(entry) {
      return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }

    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
      if (!this._settings.absolute) {
        return false;
      }

      const fullpath = utils$3.path.makeAbsolute(this._settings.cwd, entryPath);
      return utils$3.pattern.matchAny(fullpath, patternsRe);
    }

    _isMatchToPatterns(filepath, patternsRe, isDirectory) {
      // Trying to match files and directories by patterns.
      const isMatched = utils$3.pattern.matchAny(filepath, patternsRe); // A pattern with a trailling slash can be used for directory matching.
      // To apply such pattern, we need to add a tralling slash to the path.

      if (!isMatched && isDirectory) {
        return utils$3.pattern.matchAny(filepath + '/', patternsRe);
      }

      return isMatched;
    }

  }

  var _default$l = EntryFilter$1;

  var entry$3 = /*#__PURE__*/Object.defineProperty({
  	default: _default$l
  }, '__esModule', {value: true});

  class ErrorFilter$1 {
    constructor(_settings) {
      this._settings = _settings;
    }

    getFilter() {
      return error => this._isNonFatalError(error);
    }

    _isNonFatalError(error) {
      return utils$3.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }

  }

  var _default$k = ErrorFilter$1;

  var error$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$k
  }, '__esModule', {value: true});

  class EntryTransformer$1 {
    constructor(_settings) {
      this._settings = _settings;
    }

    getTransformer() {
      return entry => this._transform(entry);
    }

    _transform(entry) {
      let filepath = entry.path;

      if (this._settings.absolute) {
        filepath = utils$3.path.makeAbsolute(this._settings.cwd, filepath);
        filepath = utils$3.path.unixify(filepath);
      }

      if (this._settings.markDirectories && entry.dirent.isDirectory()) {
        filepath += '/';
      }

      if (!this._settings.objectMode) {
        return filepath;
      }

      return Object.assign(Object.assign({}, entry), {
        path: filepath
      });
    }

  }

  var _default$j = EntryTransformer$1;

  var entry$2 = /*#__PURE__*/Object.defineProperty({
  	default: _default$j
  }, '__esModule', {value: true});

  class Provider$1 {
    constructor(_settings) {
      this._settings = _settings;
      this.errorFilter = new error$1.default(this._settings);
      this.entryFilter = new entry$3.default(this._settings, this._getMicromatchOptions());
      this.deepFilter = new deep$1.default(this._settings, this._getMicromatchOptions());
      this.entryTransformer = new entry$2.default(this._settings);
    }

    _getRootDirectory(task) {
      return path__default['default'].resolve(this._settings.cwd, task.base);
    }

    _getReaderOptions(task) {
      const basePath = task.base === '.' ? '' : task.base;
      return {
        basePath,
        pathSegmentSeparator: '/',
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
        entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }

    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: true,
        strictSlashes: false
      };
    }

  }

  var _default$i = Provider$1;

  var provider$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$i
  }, '__esModule', {value: true});

  class ProviderAsync$1 extends provider$1.default {
    constructor() {
      super(...arguments);
      this._reader = new async$3.default(this._settings);
    }

    async read(task) {
      const root = this._getRootDirectory(task);

      const options = this._getReaderOptions(task);

      const entries = await this.api(root, task, options);
      return entries.map(entry => options.transform(entry));
    }

    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }

      return this._reader.static(task.patterns, options);
    }

  }

  var _default$h = ProviderAsync$1;

  var async$2 = /*#__PURE__*/Object.defineProperty({
  	default: _default$h
  }, '__esModule', {value: true});

  class ProviderStream$1 extends provider$1.default {
    constructor() {
      super(...arguments);
      this._reader = new stream$5.default(this._settings);
    }

    read(task) {
      const root = this._getRootDirectory(task);

      const options = this._getReaderOptions(task);

      const source = this.api(root, task, options);
      const destination = new stream_1__default['default'].Readable({
        objectMode: true,
        read: () => {}
      });
      source.once('error', error => destination.emit('error', error)).on('data', entry => destination.emit('data', options.transform(entry))).once('end', () => destination.emit('end'));
      destination.once('close', () => source.destroy());
      return destination;
    }

    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }

      return this._reader.static(task.patterns, options);
    }

  }

  var _default$g = ProviderStream$1;

  var stream$4 = /*#__PURE__*/Object.defineProperty({
  	default: _default$g
  }, '__esModule', {value: true});

  class ReaderSync$1 extends reader$1.default {
    constructor() {
      super(...arguments);
      this._walkSync = out$2.walkSync;
      this._statSync = out$4.statSync;
    }

    dynamic(root, options) {
      return this._walkSync(root, options);
    }

    static(patterns, options) {
      const entries = [];

      for (const pattern of patterns) {
        const filepath = this._getFullEntryPath(pattern);

        const entry = this._getEntry(filepath, pattern, options);

        if (entry === null || !options.entryFilter(entry)) {
          continue;
        }

        entries.push(entry);
      }

      return entries;
    }

    _getEntry(filepath, pattern, options) {
      try {
        const stats = this._getStat(filepath);

        return this._makeEntry(stats, pattern);
      } catch (error) {
        if (options.errorFilter(error)) {
          return null;
        }

        throw error;
      }
    }

    _getStat(filepath) {
      return this._statSync(filepath, this._fsStatSettings);
    }

  }

  var _default$f = ReaderSync$1;

  var sync$7 = /*#__PURE__*/Object.defineProperty({
  	default: _default$f
  }, '__esModule', {value: true});

  class ProviderSync$1 extends provider$1.default {
    constructor() {
      super(...arguments);
      this._reader = new sync$7.default(this._settings);
    }

    read(task) {
      const root = this._getRootDirectory(task);

      const options = this._getReaderOptions(task);

      const entries = this.api(root, task, options);
      return entries.map(options.transform);
    }

    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }

      return this._reader.static(task.patterns, options);
    }

  }

  var _default$e = ProviderSync$1;

  var sync$6 = /*#__PURE__*/Object.defineProperty({
  	default: _default$e
  }, '__esModule', {value: true});

  var settings$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;




  /**
   * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
   * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
   */


  const CPU_COUNT = Math.max(os__default['default'].cpus().length, 1);
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs__default['default'].lstat,
    lstatSync: fs__default['default'].lstatSync,
    stat: fs__default['default'].stat,
    statSync: fs__default['default'].statSync,
    readdir: fs__default['default'].readdir,
    readdirSync: fs__default['default'].readdirSync
  };

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.absolute = this._getValue(this._options.absolute, false);
      this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
      this.braceExpansion = this._getValue(this._options.braceExpansion, true);
      this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
      this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
      this.cwd = this._getValue(this._options.cwd, process.cwd());
      this.deep = this._getValue(this._options.deep, Infinity);
      this.dot = this._getValue(this._options.dot, false);
      this.extglob = this._getValue(this._options.extglob, true);
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
      this.fs = this._getFileSystemMethods(this._options.fs);
      this.globstar = this._getValue(this._options.globstar, true);
      this.ignore = this._getValue(this._options.ignore, []);
      this.markDirectories = this._getValue(this._options.markDirectories, false);
      this.objectMode = this._getValue(this._options.objectMode, false);
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
      this.onlyFiles = this._getValue(this._options.onlyFiles, true);
      this.stats = this._getValue(this._options.stats, false);
      this.suppressErrors = this._getValue(this._options.suppressErrors, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
      this.unique = this._getValue(this._options.unique, true);

      if (this.onlyDirectories) {
        this.onlyFiles = false;
      }

      if (this.stats) {
        this.objectMode = true;
      }
    }

    _getValue(option, value) {
      return option === undefined ? value : option;
    }

    _getFileSystemMethods(methods = {}) {
      return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }

  }

  exports.default = Settings;
  });

  async function FastGlob$1(source, options) {
    assertPatternsInput$2(source);
    const works = getWorks$1(source, async$2.default, options);
    const result = await Promise.all(works);
    return utils$3.array.flatten(result);
  } // https://github.com/typescript-eslint/typescript-eslint/issues/60
  // eslint-disable-next-line no-redeclare


  (function (FastGlob) {
    FastGlob.glob = FastGlob;
    FastGlob.globSync = sync;
    FastGlob.globStream = stream;
    FastGlob.async = FastGlob;

    function sync(source, options) {
      assertPatternsInput$2(source);
      const works = getWorks$1(source, sync$6.default, options);
      return utils$3.array.flatten(works);
    }

    FastGlob.sync = sync;

    function stream(source, options) {
      assertPatternsInput$2(source);
      const works = getWorks$1(source, stream$4.default, options);
      /**
       * The stream returned by the provider cannot work with an asynchronous iterator.
       * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
       * This affects performance (+25%). I don't see best solution right now.
       */

      return utils$3.stream.merge(works);
    }

    FastGlob.stream = stream;

    function generateTasks(source, options) {
      assertPatternsInput$2(source);
      const patterns = [].concat(source);
      const settings = new settings$1.default(options);
      return tasks$1.generate(patterns, settings);
    }

    FastGlob.generateTasks = generateTasks;

    function isDynamicPattern(source, options) {
      assertPatternsInput$2(source);
      const settings = new settings$1.default(options);
      return utils$3.pattern.isDynamicPattern(source, settings);
    }

    FastGlob.isDynamicPattern = isDynamicPattern;

    function escapePath(source) {
      assertPatternsInput$2(source);
      return utils$3.path.escape(source);
    }

    FastGlob.escapePath = escapePath;

    function convertPathToPattern(source) {
      assertPatternsInput$2(source);
      return utils$3.path.convertPathToPattern(source);
    }

    FastGlob.convertPathToPattern = convertPathToPattern;

    (function (posix) {
      function escapePath(source) {
        assertPatternsInput$2(source);
        return utils$3.path.escapePosixPath(source);
      }

      posix.escapePath = escapePath;

      function convertPathToPattern(source) {
        assertPatternsInput$2(source);
        return utils$3.path.convertPosixPathToPattern(source);
      }

      posix.convertPathToPattern = convertPathToPattern;
    })(FastGlob.posix || (FastGlob.posix = {}));

    (function (win32) {
      function escapePath(source) {
        assertPatternsInput$2(source);
        return utils$3.path.escapeWindowsPath(source);
      }

      win32.escapePath = escapePath;

      function convertPathToPattern(source) {
        assertPatternsInput$2(source);
        return utils$3.path.convertWindowsPathToPattern(source);
      }

      win32.convertPathToPattern = convertPathToPattern;
    })(FastGlob.win32 || (FastGlob.win32 = {}));
  })(FastGlob$1 || (FastGlob$1 = {}));

  function getWorks$1(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings$1.default(options);
    const tasks = tasks$1.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
  }

  function assertPatternsInput$2(input) {
    const source = [].concat(input);
    const isValidSource = source.every(item => utils$3.string.isString(item) && !utils$3.string.isEmpty(item));

    if (!isValidSource) {
      throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
  }

  var out$1 = FastGlob$1;

  var arrayUnion = (...arguments_) => {
    return [...new Set([].concat(...arguments_))];
  };

  var array = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.splitWhen = exports.flatten = void 0;

  function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
  }

  exports.flatten = flatten;

  function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;

    for (const item of items) {
      if (predicate(item)) {
        groupIndex++;
        result[groupIndex] = [];
      } else {
        result[groupIndex].push(item);
      }
    }

    return result;
  }

  exports.splitWhen = splitWhen;
  });

  var errno = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isEnoentCodeError = void 0;

  function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
  }

  exports.isEnoentCodeError = isEnoentCodeError;
  });

  var fs = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createDirentFromStats = void 0;

  class DirentFromStats {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }

  }

  function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
  }

  exports.createDirentFromStats = createDirentFromStats;
  });

  var path_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;



  const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\

  const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
  /**
   * Designed to work only with simple paths: `dir\\file`.
   */

  function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
  }

  exports.unixify = unixify;

  function makeAbsolute(cwd, filepath) {
    return path__default['default'].resolve(cwd, filepath);
  }

  exports.makeAbsolute = makeAbsolute;

  function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
  }

  exports.escape = escape;

  function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
      const secondCharactery = entry.charAt(1);

      if (secondCharactery === '/' || secondCharactery === '\\') {
        return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
    }

    return entry;
  }

  exports.removeLeadingDotSegment = removeLeadingDotSegment;
  });

  const WIN_SLASH = '\\\\/';
  const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  /**
   * Posix glob regex
   */

  const DOT_LITERAL = '\\.';
  const PLUS_LITERAL = '\\+';
  const QMARK_LITERAL = '\\?';
  const SLASH_LITERAL = '\\/';
  const ONE_CHAR = '(?=.)';
  const QMARK = '[^/]';
  const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  const NO_DOT = `(?!${DOT_LITERAL})`;
  const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  const STAR = `${QMARK}*?`;
  const POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  /**
   * Windows glob regex
   */

  const WINDOWS_CHARS = { ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  };
  /**
   * POSIX Bracket Regex
   */

  const POSIX_REGEX_SOURCE$1 = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
  };
  var constants = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      '***': '*',
      '**/**': '**',
      '**/**/**': '**'
    },
    // Digits
    CHAR_0: 48,

    /* 0 */
    CHAR_9: 57,

    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,

    /* A */
    CHAR_LOWERCASE_A: 97,

    /* a */
    CHAR_UPPERCASE_Z: 90,

    /* Z */
    CHAR_LOWERCASE_Z: 122,

    /* z */
    CHAR_LEFT_PARENTHESES: 40,

    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,

    /* ) */
    CHAR_ASTERISK: 42,

    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,

    /* & */
    CHAR_AT: 64,

    /* @ */
    CHAR_BACKWARD_SLASH: 92,

    /* \ */
    CHAR_CARRIAGE_RETURN: 13,

    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,

    /* ^ */
    CHAR_COLON: 58,

    /* : */
    CHAR_COMMA: 44,

    /* , */
    CHAR_DOT: 46,

    /* . */
    CHAR_DOUBLE_QUOTE: 34,

    /* " */
    CHAR_EQUAL: 61,

    /* = */
    CHAR_EXCLAMATION_MARK: 33,

    /* ! */
    CHAR_FORM_FEED: 12,

    /* \f */
    CHAR_FORWARD_SLASH: 47,

    /* / */
    CHAR_GRAVE_ACCENT: 96,

    /* ` */
    CHAR_HASH: 35,

    /* # */
    CHAR_HYPHEN_MINUS: 45,

    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,

    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,

    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,

    /* [ */
    CHAR_LINE_FEED: 10,

    /* \n */
    CHAR_NO_BREAK_SPACE: 160,

    /* \u00A0 */
    CHAR_PERCENT: 37,

    /* % */
    CHAR_PLUS: 43,

    /* + */
    CHAR_QUESTION_MARK: 63,

    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,

    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,

    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,

    /* ] */
    CHAR_SEMICOLON: 59,

    /* ; */
    CHAR_SINGLE_QUOTE: 39,

    /* ' */
    CHAR_SPACE: 32,

    /*   */
    CHAR_TAB: 9,

    /* \t */
    CHAR_UNDERSCORE: 95,

    /* _ */
    CHAR_VERTICAL_LINE: 124,

    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,

    /* \uFEFF */
    SEP: path__default['default'].sep,

    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(chars) {
      return {
        '!': {
          type: 'negate',
          open: '(?:(?!(?:',
          close: `))${chars.STAR})`
        },
        '?': {
          type: 'qmark',
          open: '(?:',
          close: ')?'
        },
        '+': {
          type: 'plus',
          open: '(?:',
          close: ')+'
        },
        '*': {
          type: 'star',
          open: '(?:',
          close: ')*'
        },
        '@': {
          type: 'at',
          open: '(?:',
          close: ')'
        }
      };
    },

    /**
     * Create GLOB_CHARS
     */
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }

  };

  var utils$1 = createCommonjsModule(function (module, exports) {



  const win32 = process.platform === 'win32';

  const {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = constants;

  exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

  exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);

  exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);

  exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');

  exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

  exports.removeBackslashes = str => {
    return str.replace(REGEX_REMOVE_BACKSLASH, match => {
      return match === '\\' ? '' : match;
    });
  };

  exports.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split('.').map(Number);

    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }

    return false;
  };

  exports.isWindows = options => {
    if (options && typeof options.windows === 'boolean') {
      return options.windows;
    }

    return win32 === true || path__default['default'].sep === '\\';
  };

  exports.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };

  exports.removePrefix = (input, state = {}) => {
    let output = input;

    if (output.startsWith('./')) {
      output = output.slice(2);
      state.prefix = './';
    }

    return output;
  };

  exports.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? '' : '^';
    const append = options.contains ? '' : '$';
    let output = `${prepend}(?:${input})${append}`;

    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }

    return output;
  };
  });

  const {
    CHAR_ASTERISK,

    /* * */
    CHAR_AT,

    /* @ */
    CHAR_BACKWARD_SLASH,

    /* \ */
    CHAR_COMMA,

    /* , */
    CHAR_DOT,

    /* . */
    CHAR_EXCLAMATION_MARK,

    /* ! */
    CHAR_FORWARD_SLASH,

    /* / */
    CHAR_LEFT_CURLY_BRACE,

    /* { */
    CHAR_LEFT_PARENTHESES,

    /* ( */
    CHAR_LEFT_SQUARE_BRACKET,

    /* [ */
    CHAR_PLUS,

    /* + */
    CHAR_QUESTION_MARK,

    /* ? */
    CHAR_RIGHT_CURLY_BRACE,

    /* } */
    CHAR_RIGHT_PARENTHESES,

    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET
    /* ] */

  } = constants;

  const isPathSeparator = code => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };

  const depth = token => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  /**
   * Quickly scans a glob pattern and returns an object with a handful of
   * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
   * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
   *
   * ```js
   * const pm = require('picomatch');
   * console.log(pm.scan('foo/bar/*.js'));
   * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object} Returns an object with tokens and regex source string.
   * @api public
   */


  const scan = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {
      value: '',
      depth: 0,
      isGlob: false
    };

    const eos = () => index >= length;

    const peek = () => str.charCodeAt(index + 1);

    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };

    while (index < length) {
      code = advance();
      let next;

      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }

        continue;
      }

      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;

        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }

          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;

            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = {
          value: '',
          depth: 0,
          isGlob: false
        };
        if (finished === true) continue;

        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }

        lastIndex = index + 1;
        continue;
      }

      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;

        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;

          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }

              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }

            continue;
          }

          break;
        }
      }

      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }

      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }

          continue;
        }

        break;
      }

      if (isGlob === true) {
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }
    }

    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }

    let base = str;
    let prefix = '';
    let glob = '';

    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }

    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = '';
      glob = str;
    } else {
      base = str;
    }

    if (base && base !== '' && base !== '/' && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }

    if (opts.unescape === true) {
      if (glob) glob = utils$1.removeBackslashes(glob);

      if (base && backslashes === true) {
        base = utils$1.removeBackslashes(base);
      }
    }

    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated
    };

    if (opts.tokens === true) {
      state.maxDepth = 0;

      if (!isPathSeparator(code)) {
        tokens.push(token);
      }

      state.tokens = tokens;
    }

    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;

      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx];
        const value = input.slice(n, i);

        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }

          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }

        if (idx !== 0 || value !== '') {
          parts.push(value);
        }

        prevIndex = i;
      }

      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);

        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }

      state.slashes = slashes;
      state.parts = parts;
    }

    return state;
  };

  var scan_1 = scan;

  /**
   * Constants
   */


  const {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  /**
   * Helpers
   */

  const expandRange = (args, options) => {
    if (typeof options.expandRange === 'function') {
      return options.expandRange(...args, options);
    }

    args.sort();
    const value = `[${args.join('-')}]`;

    try {
      /* eslint-disable-next-line no-new */
      new RegExp(value);
    } catch (ex) {
      return args.map(v => utils$1.escapeRegex(v)).join('..');
    }

    return value;
  };
  /**
   * Create the message for a syntax error
   */


  const syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  /**
   * Parse the given input string.
   * @param {String} input
   * @param {Object} options
   * @return {Object}
   */


  const parse = (input, options) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    input = REPLACEMENTS[input] || input;
    const opts = { ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;

    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }

    const bos = {
      type: 'bos',
      value: '',
      output: opts.prepend || ''
    };
    const tokens = [bos];
    const capture = opts.capture ? '' : '?:';
    const win32 = utils$1.isWindows(options); // create constants based on platform, for windows or posix

    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;

    const globstar = opts => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };

    const nodot = opts.dot ? '' : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;

    if (opts.capture) {
      star = `(${star})`;
    } // minimatch options support


    if (typeof opts.noext === 'boolean') {
      opts.noextglob = opts.noext;
    }

    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: '',
      output: '',
      prefix: '',
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils$1.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    /**
     * Tokenizing helpers
     */

    const eos = () => state.index === len - 1;

    const peek = state.peek = (n = 1) => input[state.index + n];

    const advance = state.advance = () => input[++state.index];

    const remaining = () => input.slice(state.index + 1);

    const consume = (value = '', num = 0) => {
      state.consumed += value;
      state.index += num;
    };

    const append = token => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };

    const negate = () => {
      let count = 1;

      while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
        advance();
        state.start++;
        count++;
      }

      if (count % 2 === 0) {
        return false;
      }

      state.negated = true;
      state.start++;
      return true;
    };

    const increment = type => {
      state[type]++;
      stack.push(type);
    };

    const decrement = type => {
      state[type]--;
      stack.pop();
    };
    /**
     * Push tokens onto the tokens array. This helper speeds up
     * tokenizing by 1) helping us avoid backtracking as much as possible,
     * and 2) helping us avoid creating extra tokens when consecutive
     * characters are plain text. This improves performance and simplifies
     * lookbehinds.
     */


    const push = tok => {
      if (prev.type === 'globstar') {
        const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');

        if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = 'star';
          prev.value = '*';
          prev.output = star;
          state.output += prev.output;
        }
      }

      if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
        extglobs[extglobs.length - 1].inner += tok.value;
      }

      if (tok.value || tok.output) append(tok);

      if (prev && prev.type === 'text' && tok.type === 'text') {
        prev.value += tok.value;
        prev.output = (prev.output || '') + tok.value;
        return;
      }

      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };

    const extglobOpen = (type, value) => {
      const token = { ...EXTGLOB_CHARS[value],
        conditions: 1,
        inner: ''
      };
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? '(' : '') + token.open;
      increment('parens');
      push({
        type,
        value,
        output: state.output ? '' : ONE_CHAR
      });
      push({
        type: 'paren',
        extglob: true,
        value: advance(),
        output
      });
      extglobs.push(token);
    };

    const extglobClose = token => {
      let output = token.close + (opts.capture ? ')' : '');

      if (token.type === 'negate') {
        let extglobStar = star;

        if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
          extglobStar = globstar(opts);
        }

        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)$))${extglobStar}`;
        }

        if (token.prev.type === 'bos') {
          state.negatedExtglob = true;
        }
      }

      push({
        type: 'paren',
        extglob: true,
        value,
        output
      });
      decrement('parens');
    };
    /**
     * Fast paths
     */


    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
        if (first === '\\') {
          backslashes = true;
          return m;
        }

        if (first === '?') {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : '');
          }

          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
          }

          return QMARK.repeat(chars.length);
        }

        if (first === '.') {
          return DOT_LITERAL.repeat(chars.length);
        }

        if (first === '*') {
          if (esc) {
            return esc + first + (rest ? star : '');
          }

          return star;
        }

        return esc ? m : `\\${m}`;
      });

      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, '');
        } else {
          output = output.replace(/\\+/g, m => {
            return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
          });
        }
      }

      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }

      state.output = utils$1.wrapOutput(output, state, options);
      return state;
    }
    /**
     * Tokenize input until we reach end-of-string
     */


    while (!eos()) {
      value = advance();

      if (value === '\u0000') {
        continue;
      }
      /**
       * Escaped characters
       */


      if (value === '\\') {
        const next = peek();

        if (next === '/' && opts.bash !== true) {
          continue;
        }

        if (next === '.' || next === ';') {
          continue;
        }

        if (!next) {
          value += '\\';
          push({
            type: 'text',
            value
          });
          continue;
        } // collapse slashes to reduce potential for exploits


        const match = /^\\+/.exec(remaining());
        let slashes = 0;

        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;

          if (slashes % 2 !== 0) {
            value += '\\';
          }
        }

        if (opts.unescape === true) {
          value = advance() || '';
        } else {
          value += advance() || '';
        }

        if (state.brackets === 0) {
          push({
            type: 'text',
            value
          });
          continue;
        }
      }
      /**
       * If we're inside a regex character class, continue
       * until we reach the closing bracket.
       */


      if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
        if (opts.posix !== false && value === ':') {
          const inner = prev.value.slice(1);

          if (inner.includes('[')) {
            prev.posix = true;

            if (inner.includes(':')) {
              const idx = prev.value.lastIndexOf('[');
              const pre = prev.value.slice(0, idx);
              const rest = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest];

              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();

                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }

                continue;
              }
            }
          }
        }

        if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
          value = `\\${value}`;
        }

        if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
          value = `\\${value}`;
        }

        if (opts.posix === true && value === '!' && prev.value === '[') {
          value = '^';
        }

        prev.value += value;
        append({
          value
        });
        continue;
      }
      /**
       * If we're inside a quoted string, continue
       * until we reach the closing double quote.
       */


      if (state.quotes === 1 && value !== '"') {
        value = utils$1.escapeRegex(value);
        prev.value += value;
        append({
          value
        });
        continue;
      }
      /**
       * Double quotes
       */


      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;

        if (opts.keepQuotes === true) {
          push({
            type: 'text',
            value
          });
        }

        continue;
      }
      /**
       * Parentheses
       */


      if (value === '(') {
        increment('parens');
        push({
          type: 'paren',
          value
        });
        continue;
      }

      if (value === ')') {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '('));
        }

        const extglob = extglobs[extglobs.length - 1];

        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }

        push({
          type: 'paren',
          value,
          output: state.parens ? ')' : '\\)'
        });
        decrement('parens');
        continue;
      }
      /**
       * Square brackets
       */


      if (value === '[') {
        if (opts.nobracket === true || !remaining().includes(']')) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError('closing', ']'));
          }

          value = `\\${value}`;
        } else {
          increment('brackets');
        }

        push({
          type: 'bracket',
          value
        });
        continue;
      }

      if (value === ']') {
        if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
          push({
            type: 'text',
            value,
            output: `\\${value}`
          });
          continue;
        }

        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError('opening', '['));
          }

          push({
            type: 'text',
            value,
            output: `\\${value}`
          });
          continue;
        }

        decrement('brackets');
        const prevValue = prev.value.slice(1);

        if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
          value = `/${value}`;
        }

        prev.value += value;
        append({
          value
        }); // when literal brackets are explicitly disabled
        // assume we should match with a regex character class

        if (opts.literalBrackets === false || utils$1.hasRegexChars(prevValue)) {
          continue;
        }

        const escaped = utils$1.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled
        // assume we should escape the brackets to match literal characters

        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        } // when the user specifies nothing, try to match both


        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      /**
       * Braces
       */


      if (value === '{' && opts.nobrace !== true) {
        increment('braces');
        const open = {
          type: 'brace',
          value,
          output: '(',
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }

      if (value === '}') {
        const brace = braces[braces.length - 1];

        if (opts.nobrace === true || !brace) {
          push({
            type: 'text',
            value,
            output: value
          });
          continue;
        }

        let output = ')';

        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];

          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();

            if (arr[i].type === 'brace') {
              break;
            }

            if (arr[i].type !== 'dots') {
              range.unshift(arr[i].value);
            }
          }

          output = expandRange(range, opts);
          state.backtrack = true;
        }

        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = '\\{';
          value = output = '\\}';
          state.output = out;

          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }

        push({
          type: 'brace',
          value,
          output
        });
        decrement('braces');
        braces.pop();
        continue;
      }
      /**
       * Pipes
       */


      if (value === '|') {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Commas
       */


      if (value === ',') {
        let output = value;
        const brace = braces[braces.length - 1];

        if (brace && stack[stack.length - 1] === 'braces') {
          brace.comma = true;
          output = '|';
        }

        push({
          type: 'comma',
          value,
          output
        });
        continue;
      }
      /**
       * Slashes
       */


      if (value === '/') {
        // if the beginning of the glob is "./", advance the start
        // to the current index, and don't add the "./" characters
        // to the state. This greatly simplifies lookbehinds when
        // checking for BOS characters like "!" and "." (not "./")
        if (prev.type === 'dot' && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = '';
          state.output = '';
          tokens.pop();
          prev = bos; // reset "prev" to the first token

          continue;
        }

        push({
          type: 'slash',
          value,
          output: SLASH_LITERAL
        });
        continue;
      }
      /**
       * Dots
       */


      if (value === '.') {
        if (state.braces > 0 && prev.type === 'dot') {
          if (prev.value === '.') prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = 'dots';
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }

        if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
          push({
            type: 'text',
            value,
            output: DOT_LITERAL
          });
          continue;
        }

        push({
          type: 'dot',
          value,
          output: DOT_LITERAL
        });
        continue;
      }
      /**
       * Question marks
       */


      if (value === '?') {
        const isGroup = prev && prev.value === '(';

        if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('qmark', value);
          continue;
        }

        if (prev && prev.type === 'paren') {
          const next = peek();
          let output = value;

          if (next === '<' && !utils$1.supportsLookbehinds()) {
            throw new Error('Node.js v10 or higher is required for regex lookbehinds');
          }

          if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }

          push({
            type: 'text',
            value,
            output
          });
          continue;
        }

        if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
          push({
            type: 'qmark',
            value,
            output: QMARK_NO_DOT
          });
          continue;
        }

        push({
          type: 'qmark',
          value,
          output: QMARK
        });
        continue;
      }
      /**
       * Exclamation
       */


      if (value === '!') {
        if (opts.noextglob !== true && peek() === '(') {
          if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
            extglobOpen('negate', value);
            continue;
          }
        }

        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      /**
       * Plus
       */


      if (value === '+') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('plus', value);
          continue;
        }

        if (prev && prev.value === '(' || opts.regex === false) {
          push({
            type: 'plus',
            value,
            output: PLUS_LITERAL
          });
          continue;
        }

        if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
          push({
            type: 'plus',
            value
          });
          continue;
        }

        push({
          type: 'plus',
          value: PLUS_LITERAL
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value === '@') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          push({
            type: 'at',
            extglob: true,
            value,
            output: ''
          });
          continue;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value !== '*') {
        if (value === '$' || value === '^') {
          value = `\\${value}`;
        }

        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());

        if (match) {
          value += match[0];
          state.index += match[0].length;
        }

        push({
          type: 'text',
          value
        });
        continue;
      }
      /**
       * Stars
       */


      if (prev && (prev.type === 'globstar' || prev.star === true)) {
        prev.type = 'star';
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }

      let rest = remaining();

      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen('star', value);
        continue;
      }

      if (prev.type === 'star') {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }

        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === 'slash' || prior.type === 'bos';
        const afterStar = before && (before.type === 'star' || before.type === 'globstar');

        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
          push({
            type: 'star',
            value,
            output: ''
          });
          continue;
        }

        const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
        const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');

        if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
          push({
            type: 'star',
            value,
            output: ''
          });
          continue;
        } // strip consecutive `/**/`


        while (rest.slice(0, 3) === '/**') {
          const after = input[state.index + 4];

          if (after && after !== '/') {
            break;
          }

          rest = rest.slice(3);
          consume('/**', 3);
        }

        if (prior.type === 'bos' && eos()) {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = 'globstar';
          prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
          const end = rest[1] !== void 0 ? '|$' : '';
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = 'globstar';
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        }

        if (prior.type === 'bos' && rest[0] === '/') {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        } // remove single star from output


        state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar

        prev.type = 'globstar';
        prev.output = globstar(opts);
        prev.value += value; // reset output with globstar

        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      const token = {
        type: 'star',
        value,
        output: star
      };

      if (opts.bash === true) {
        token.output = '.*?';

        if (prev.type === 'bos' || prev.type === 'slash') {
          token.output = nodot + token.output;
        }

        push(token);
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }

      if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
        if (prev.type === 'dot') {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }

        if (peek() !== '*') {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }

      push(token);
    }

    while (state.brackets > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
      state.output = utils$1.escapeLast(state.output, '[');
      decrement('brackets');
    }

    while (state.parens > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
      state.output = utils$1.escapeLast(state.output, '(');
      decrement('parens');
    }

    while (state.braces > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
      state.output = utils$1.escapeLast(state.output, '{');
      decrement('braces');
    }

    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
      push({
        type: 'maybe_slash',
        value: '',
        output: `${SLASH_LITERAL}?`
      });
    } // rebuild the output if we had to backtrack at any point


    if (state.backtrack === true) {
      state.output = '';

      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;

        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }

    return state;
  };
  /**
   * Fast paths for creating regular expressions for common glob patterns.
   * This can significantly speed up processing and has very little downside
   * impact when none of the fast paths match.
   */


  parse.fastpaths = (input, options) => {
    const opts = { ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;

    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }

    input = REPLACEMENTS[input] || input;
    const win32 = utils$1.isWindows(options); // create constants based on platform, for windows or posix

    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? '' : '?:';
    const state = {
      negated: false,
      prefix: ''
    };
    let star = opts.bash === true ? '.*?' : STAR;

    if (opts.capture) {
      star = `(${star})`;
    }

    const globstar = opts => {
      if (opts.noglobstar === true) return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };

    const create = str => {
      switch (str) {
        case '*':
          return `${nodot}${ONE_CHAR}${star}`;

        case '.*':
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '*.*':
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '*/*':
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

        case '**':
          return nodot + globstar(opts);

        case '**/*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

        case '**/*.*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

        case '**/.*':
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

        default:
          {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source = create(match[1]);
            if (!source) return;
            return source + DOT_LITERAL + match[2];
          }
      }
    };

    const output = utils$1.removePrefix(input, state);
    let source = create(output);

    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }

    return source;
  };

  var parse_1 = parse;

  const isObject = val => val && typeof val === 'object' && !Array.isArray(val);
  /**
   * Creates a matcher function from one or more glob patterns. The
   * returned function takes a string to match as its first argument,
   * and returns true if the string is a match. The returned matcher
   * function also takes a boolean as the second argument that, when true,
   * returns an object with additional information.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch(glob[, options]);
   *
   * const isMatch = picomatch('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @name picomatch
   * @param {String|Array} `globs` One or more glob patterns.
   * @param {Object=} `options`
   * @return {Function=} Returns a matcher function.
   * @api public
   */


  const picomatch$1 = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map(input => picomatch$1(input, options, returnState));

      const arrayMatcher = str => {
        for (const isMatch of fns) {
          const state = isMatch(str);
          if (state) return state;
        }

        return false;
      };

      return arrayMatcher;
    }

    const isState = isObject(glob) && glob.tokens && glob.input;

    if (glob === '' || typeof glob !== 'string' && !isState) {
      throw new TypeError('Expected pattern to be a non-empty string');
    }

    const opts = options || {};
    const posix = utils$1.isWindows(options);
    const regex = isState ? picomatch$1.compileRe(glob, options) : picomatch$1.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;

    let isIgnored = () => false;

    if (opts.ignore) {
      const ignoreOpts = { ...options,
        ignore: null,
        onMatch: null,
        onResult: null
      };
      isIgnored = picomatch$1(opts.ignore, ignoreOpts, returnState);
    }

    const matcher = (input, returnObject = false) => {
      const {
        isMatch,
        match,
        output
      } = picomatch$1.test(input, regex, options, {
        glob,
        posix
      });
      const result = {
        glob,
        state,
        regex,
        posix,
        input,
        output,
        match,
        isMatch
      };

      if (typeof opts.onResult === 'function') {
        opts.onResult(result);
      }

      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (isIgnored(input)) {
        if (typeof opts.onIgnore === 'function') {
          opts.onIgnore(result);
        }

        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (typeof opts.onMatch === 'function') {
        opts.onMatch(result);
      }

      return returnObject ? result : true;
    };

    if (returnState) {
      matcher.state = state;
    }

    return matcher;
  };
  /**
   * Test `input` with the given `regex`. This is used by the main
   * `picomatch()` function to test the input string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.test(input, regex[, options]);
   *
   * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
   * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp} `regex`
   * @return {Object} Returns an object with matching info.
   * @api public
   */


  picomatch$1.test = (input, regex, options, {
    glob,
    posix
  } = {}) => {
    if (typeof input !== 'string') {
      throw new TypeError('Expected input to be a string');
    }

    if (input === '') {
      return {
        isMatch: false,
        output: ''
      };
    }

    const opts = options || {};
    const format = opts.format || (posix ? utils$1.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;

    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }

    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch$1.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }

    return {
      isMatch: Boolean(match),
      match,
      output
    };
  };
  /**
   * Match the basename of a filepath.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.matchBase(input, glob[, options]);
   * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
   * @return {Boolean}
   * @api public
   */


  picomatch$1.matchBase = (input, glob, options, posix = utils$1.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch$1.makeRe(glob, options);
    return regex.test(path__default['default'].basename(input));
  };
  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.isMatch(string, patterns[, options]);
   *
   * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String|Array} str The string to test.
   * @param {String|Array} patterns One or more glob patterns to use for matching.
   * @param {Object} [options] See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  picomatch$1.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);
  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const result = picomatch.parse(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
   * @api public
   */


  picomatch$1.parse = (pattern, options) => {
    if (Array.isArray(pattern)) return pattern.map(p => picomatch$1.parse(p, options));
    return parse_1(pattern, { ...options,
      fastpaths: false
    });
  };
  /**
   * Scan a glob pattern to separate the pattern into segments.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.scan(input[, options]);
   *
   * const result = picomatch.scan('!./foo/*.js');
   * console.log(result);
   * { prefix: '!./',
   *   input: '!./foo/*.js',
   *   start: 3,
   *   base: 'foo',
   *   glob: '*.js',
   *   isBrace: false,
   *   isBracket: false,
   *   isGlob: true,
   *   isExtglob: false,
   *   isGlobstar: false,
   *   negated: true }
   * ```
   * @param {String} `input` Glob pattern to scan.
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */


  picomatch$1.scan = (input, options) => scan_1(input, options);
  /**
   * Create a regular expression from a parsed glob pattern.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const state = picomatch.parse('*.js');
   * // picomatch.compileRe(state[, options]);
   *
   * console.log(picomatch.compileRe(state));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `state` The object returned from the `.parse` method.
   * @param {Object} `options`
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */


  picomatch$1.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return parsed.output;
    }

    const opts = options || {};
    const prepend = opts.contains ? '' : '^';
    const append = opts.contains ? '' : '$';
    let source = `${prepend}(?:${parsed.output})${append}`;

    if (parsed && parsed.negated === true) {
      source = `^(?!${source}).*$`;
    }

    const regex = picomatch$1.toRegex(source, options);

    if (returnState === true) {
      regex.state = parsed;
    }

    return regex;
  };

  picomatch$1.makeRe = (input, options, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== 'string') {
      throw new TypeError('Expected a non-empty string');
    }

    const opts = options || {};
    let parsed = {
      negated: false,
      fastpaths: true
    };
    let prefix = '';
    let output;

    if (input.startsWith('./')) {
      input = input.slice(2);
      prefix = parsed.prefix = './';
    }

    if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
      output = parse_1.fastpaths(input, options);
    }

    if (output === undefined) {
      parsed = parse_1(input, options);
      parsed.prefix = prefix + (parsed.prefix || '');
    } else {
      parsed.output = output;
    }

    return picomatch$1.compileRe(parsed, options, returnOutput, returnState);
  };
  /**
   * Create a regular expression from the given regex source string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.toRegex(source[, options]);
   *
   * const { output } = picomatch.parse('*.js');
   * console.log(picomatch.toRegex(output));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `source` Regular expression source string.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */


  picomatch$1.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
    } catch (err) {
      if (options && options.debug === true) throw err;
      return /$^/;
    }
  };
  /**
   * Picomatch constants.
   * @return {Object}
   */


  picomatch$1.constants = constants;
  /**
   * Expose "picomatch"
   */

  var picomatch_1 = picomatch$1;

  var picomatch = picomatch_1;

  const isEmptyString = val => val === '' || val === './';
  /**
   * Returns an array of strings that match one or more glob patterns.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm(list, patterns[, options]);
   *
   * console.log(mm(['a.js', 'a.txt'], ['*.js']));
   * //=> [ 'a.js' ]
   * ```
   * @param {String|Array<string>} `list` List of strings to match.
   * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options)
   * @return {Array} Returns an array of matches
   * @summary false
   * @api public
   */


  const micromatch = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;

    let onResult = state => {
      items.add(state.output);

      if (options && options.onResult) {
        options.onResult(state);
      }
    };

    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch(String(patterns[i]), { ...options,
        onResult
      }, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated) negatives++;

      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match) continue;

        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }

    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter(item => !omit.has(item));

    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(', ')}"`);
      }

      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
      }
    }

    return matches;
  };
  /**
   * Backwards compatibility
   */


  micromatch.match = micromatch;
  /**
   * Returns a matcher function from the given glob `pattern` and `options`.
   * The returned function takes a string to match as its only argument and returns
   * true if the string is a match.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.matcher(pattern[, options]);
   *
   * const isMatch = mm.matcher('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @param {String} `pattern` Glob pattern
   * @param {Object} `options`
   * @return {Function} Returns a matcher function.
   * @api public
   */

  micromatch.matcher = (pattern, options) => picomatch(pattern, options);
  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.isMatch(string, patterns[, options]);
   *
   * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(mm.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `[options]` See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  /**
   * Backwards compatibility
   */


  micromatch.any = micromatch.isMatch;
  /**
   * Returns a list of strings that _**do not match any**_ of the given `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.not(list, patterns[, options]);
   *
   * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
   * //=> ['b.b', 'c.c']
   * ```
   * @param {Array} `list` Array of strings to match.
   * @param {String|Array} `patterns` One or more glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array} Returns an array of strings that **do not match** the given patterns.
   * @api public
   */

  micromatch.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];

    let onResult = state => {
      if (options.onResult) options.onResult(state);
      items.push(state.output);
    };

    let matches = micromatch(list, patterns, { ...options,
      onResult
    });

    for (let item of items) {
      if (!matches.includes(item)) {
        result.add(item);
      }
    }

    return [...result];
  };
  /**
   * Returns true if the given `string` contains the given pattern. Similar
   * to [.isMatch](#isMatch) but the pattern can match any part of the string.
   *
   * ```js
   * var mm = require('micromatch');
   * // mm.contains(string, pattern[, options]);
   *
   * console.log(mm.contains('aa/bb/cc', '*b'));
   * //=> true
   * console.log(mm.contains('aa/bb/cc', '*d'));
   * //=> false
   * ```
   * @param {String} `str` The string to match.
   * @param {String|Array} `patterns` Glob pattern to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
   * @api public
   */


  micromatch.contains = (str, pattern, options) => {
    if (typeof str !== 'string') {
      throw new TypeError(`Expected a string: "${util__default['default'].inspect(str)}"`);
    }

    if (Array.isArray(pattern)) {
      return pattern.some(p => micromatch.contains(str, p, options));
    }

    if (typeof pattern === 'string') {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }

      if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {
        return true;
      }
    }

    return micromatch.isMatch(str, pattern, { ...options,
      contains: true
    });
  };
  /**
   * Filter the keys of the given object with the given `glob` pattern
   * and `options`. Does not attempt to match nested keys. If you need this feature,
   * use [glob-object][] instead.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.matchKeys(object, patterns[, options]);
   *
   * const obj = { aa: 'a', ab: 'b', ac: 'c' };
   * console.log(mm.matchKeys(obj, '*b'));
   * //=> { ab: 'b' }
   * ```
   * @param {Object} `object` The object with keys to filter.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Object} Returns an object with only keys that match the given patterns.
   * @api public
   */


  micromatch.matchKeys = (obj, patterns, options) => {
    if (!utils$1.isObject(obj)) {
      throw new TypeError('Expected the first argument to be an object');
    }

    let keys = micromatch(Object.keys(obj), patterns, options);
    let res = {};

    for (let key of keys) res[key] = obj[key];

    return res;
  };
  /**
   * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.some(list, patterns[, options]);
   *
   * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // true
   * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
   * @api public
   */


  micromatch.some = (list, patterns, options) => {
    let items = [].concat(list);

    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);

      if (items.some(item => isMatch(item))) {
        return true;
      }
    }

    return false;
  };
  /**
   * Returns true if every string in the given `list` matches
   * any of the given glob `patterns`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.every(list, patterns[, options]);
   *
   * console.log(mm.every('foo.js', ['foo.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
   * // true
   * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
   * // false
   * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
   * // false
   * ```
   * @param {String|Array} `list` The string or array of strings to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
   * @api public
   */


  micromatch.every = (list, patterns, options) => {
    let items = [].concat(list);

    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);

      if (!items.every(item => isMatch(item))) {
        return false;
      }
    }

    return true;
  };
  /**
   * Returns true if **all** of the given `patterns` match
   * the specified string.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.all(string, patterns[, options]);
   *
   * console.log(mm.all('foo.js', ['foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
   * // false
   *
   * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
   * // true
   *
   * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
   * // true
   * ```
   * @param {String|Array} `str` The string to test.
   * @param {String|Array} `patterns` One or more glob patterns to use for matching.
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  micromatch.all = (str, patterns, options) => {
    if (typeof str !== 'string') {
      throw new TypeError(`Expected a string: "${util__default['default'].inspect(str)}"`);
    }

    return [].concat(patterns).every(p => picomatch(p, options)(str));
  };
  /**
   * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.capture(pattern, string[, options]);
   *
   * console.log(mm.capture('test/*.js', 'test/foo.js'));
   * //=> ['foo']
   * console.log(mm.capture('test/*.js', 'foo/bar.css'));
   * //=> null
   * ```
   * @param {String} `glob` Glob pattern to use for matching.
   * @param {String} `input` String to match
   * @param {Object} `options` See available [options](#options) for changing how matches are performed
   * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
   * @api public
   */


  micromatch.capture = (glob, input, options) => {
    let posix = utils$1.isWindows(options);
    let regex = picomatch.makeRe(String(glob), { ...options,
      capture: true
    });
    let match = regex.exec(posix ? utils$1.toPosixSlashes(input) : input);

    if (match) {
      return match.slice(1).map(v => v === void 0 ? '' : v);
    }
  };
  /**
   * Create a regular expression from the given glob `pattern`.
   *
   * ```js
   * const mm = require('micromatch');
   * // mm.makeRe(pattern[, options]);
   *
   * console.log(mm.makeRe('*.js'));
   * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
   * ```
   * @param {String} `pattern` A glob pattern to convert to regex.
   * @param {Object} `options`
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */


  micromatch.makeRe = (...args) => picomatch.makeRe(...args);
  /**
   * Scan a glob pattern to separate the pattern into segments. Used
   * by the [split](#split) method.
   *
   * ```js
   * const mm = require('micromatch');
   * const state = mm.scan(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */


  micromatch.scan = (...args) => picomatch.scan(...args);
  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const mm = require('micromatch');
   * const state = mm(pattern[, options]);
   * ```
   * @param {String} `glob`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as regex source string.
   * @api public
   */


  micromatch.parse = (patterns, options) => {
    let res = [];

    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces_1(String(pattern), options)) {
        res.push(picomatch.parse(str, options));
      }
    }

    return res;
  };
  /**
   * Process the given brace `pattern`.
   *
   * ```js
   * const { braces } = require('micromatch');
   * console.log(braces('foo/{a,b,c}/bar'));
   * //=> [ 'foo/(a|b|c)/bar' ]
   *
   * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
   * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
   * ```
   * @param {String} `pattern` String with brace pattern to process.
   * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
   * @return {Array}
   * @api public
   */


  micromatch.braces = (pattern, options) => {
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');

    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }

    return braces_1(pattern, options);
  };
  /**
   * Expand braces
   */


  micromatch.braceExpand = (pattern, options) => {
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');
    return micromatch.braces(pattern, { ...options,
      expand: true
    });
  };
  /**
   * Expose micromatch
   */


  var micromatch_1 = micromatch;

  var pattern = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;







  const GLOBSTAR = '**';
  const ESCAPE_SYMBOL = '\\';
  const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
  const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
  const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
  const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
  const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;

  function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
  }

  exports.isStaticPattern = isStaticPattern;

  function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') {
      return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */


    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
      return true;
    }

    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
      return true;
    }

    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
      return true;
    }

    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
      return true;
    }

    return false;
  }

  exports.isDynamicPattern = isDynamicPattern;

  function hasBraceExpansion(pattern) {
    const openingBraceIndex = pattern.indexOf('{');

    if (openingBraceIndex === -1) {
      return false;
    }

    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);

    if (closingBraceIndex === -1) {
      return false;
    }

    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
  }

  function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
  }

  exports.convertToPositivePattern = convertToPositivePattern;

  function convertToNegativePattern(pattern) {
    return '!' + pattern;
  }

  exports.convertToNegativePattern = convertToNegativePattern;

  function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
  }

  exports.isNegativePattern = isNegativePattern;

  function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
  }

  exports.isPositivePattern = isPositivePattern;

  function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
  }

  exports.getNegativePatterns = getNegativePatterns;

  function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
  }

  exports.getPositivePatterns = getPositivePatterns;
  /**
   * Returns patterns that can be applied inside the current directory.
   *
   * @example
   * // ['./*', '*', 'a/*']
   * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
   */

  function getPatternsInsideCurrentDirectory(patterns) {
    return patterns.filter(pattern => !isPatternRelatedToParentDirectory(pattern));
  }

  exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
  /**
   * Returns patterns to be expanded relative to (outside) the current directory.
   *
   * @example
   * // ['../*', './../*']
   * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
   */

  function getPatternsOutsideCurrentDirectory(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
  }

  exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;

  function isPatternRelatedToParentDirectory(pattern) {
    return pattern.startsWith('..') || pattern.startsWith('./..');
  }

  exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;

  function getBaseDirectory(pattern) {
    return globParent(pattern, {
      flipBackslashes: false
    });
  }

  exports.getBaseDirectory = getBaseDirectory;

  function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
  }

  exports.hasGlobStar = hasGlobStar;

  function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
  }

  exports.endsWithSlashGlobStar = endsWithSlashGlobStar;

  function isAffectDepthOfReadingPattern(pattern) {
    const basename = path__default['default'].basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
  }

  exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;

  function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
      return collection.concat(expandBraceExpansion(pattern));
    }, []);
  }

  exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;

  function expandBraceExpansion(pattern) {
    return micromatch_1.braces(pattern, {
      expand: true,
      nodupes: true
    });
  }

  exports.expandBraceExpansion = expandBraceExpansion;

  function getPatternParts(pattern, options) {
    let {
      parts
    } = micromatch_1.scan(pattern, Object.assign(Object.assign({}, options), {
      parts: true
    }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */

    if (parts.length === 0) {
      parts = [pattern];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */


    if (parts[0].startsWith('/')) {
      parts[0] = parts[0].slice(1);
      parts.unshift('');
    }

    return parts;
  }

  exports.getPatternParts = getPatternParts;

  function makeRe(pattern, options) {
    return micromatch_1.makeRe(pattern, options);
  }

  exports.makeRe = makeRe;

  function convertPatternsToRe(patterns, options) {
    return patterns.map(pattern => makeRe(pattern, options));
  }

  exports.convertPatternsToRe = convertPatternsToRe;

  function matchAny(entry, patternsRe) {
    return patternsRe.some(patternRe => patternRe.test(entry));
  }

  exports.matchAny = matchAny;
  });

  var stream$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.merge = void 0;



  function merge(streams) {
    const mergedStream = merge2_1(streams);
    streams.forEach(stream => {
      stream.once('error', error => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
  }

  exports.merge = merge;

  function propagateCloseEventToSources(streams) {
    streams.forEach(stream => stream.emit('close'));
  }
  });

  var string = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isEmpty = exports.isString = void 0;

  function isString(input) {
    return typeof input === 'string';
  }

  exports.isString = isString;

  function isEmpty(input) {
    return input === '';
  }

  exports.isEmpty = isEmpty;
  });

  var utils = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;



  exports.array = array;



  exports.errno = errno;



  exports.fs = fs;



  exports.path = path_1;



  exports.pattern = pattern;



  exports.stream = stream$3;



  exports.string = string;
  });

  var tasks = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;



  function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter(pattern => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter(pattern => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns,
    /* dynamic */
    false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns,
    /* dynamic */
    true);
    return staticTasks.concat(dynamicTasks);
  }

  exports.generate = generate;
  /**
   * Returns tasks grouped by basic pattern directories.
   *
   * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
   * This is necessary because directory traversal starts at the base directory and goes deeper.
   */

  function convertPatternsToTasks(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    /*
     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
     */

    if ('.' in insideCurrentDirectoryGroup) {
      tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
    } else {
      tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }

    return tasks;
  }

  exports.convertPatternsToTasks = convertPatternsToTasks;

  function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
  }

  exports.getPositivePatterns = getPositivePatterns;

  function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
  }

  exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;

  function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
      const base = utils.pattern.getBaseDirectory(pattern);

      if (base in collection) {
        collection[base].push(pattern);
      } else {
        collection[base] = [pattern];
      }

      return collection;
    }, group);
  }

  exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;

  function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map(base => {
      return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
  }

  exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;

  function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
      dynamic,
      positive,
      negative,
      base,
      patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
  }

  exports.convertPatternGroupToTask = convertPatternGroupToTask;
  });

  var patterns = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.removeDuplicateSlashes = exports.transform = void 0;
  /**
   * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.
   * The latter is due to the presence of the device path at the beginning of the UNC path.
   * @todo rewrite to negative lookbehind with the next major release.
   */

  const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;

  function transform(patterns) {
    return patterns.map(pattern => removeDuplicateSlashes(pattern));
  }

  exports.transform = transform;
  /**
   * This package only works with forward slashes as a path separator.
   * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.
   */

  function removeDuplicateSlashes(pattern) {
    return pattern.replace(DOUBLE_SLASH_RE, '/');
  }

  exports.removeDuplicateSlashes = removeDuplicateSlashes;
  });

  class Reader {
    constructor(_settings) {
      this._settings = _settings;
      this._fsStatSettings = new out$4.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }

    _getFullEntryPath(filepath) {
      return path__default['default'].resolve(this._settings.cwd, filepath);
    }

    _makeEntry(stats, pattern) {
      const entry = {
        name: pattern,
        path: pattern,
        dirent: utils.fs.createDirentFromStats(pattern, stats)
      };

      if (this._settings.stats) {
        entry.stats = stats;
      }

      return entry;
    }

    _isFatalError(error) {
      return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }

  }

  var _default$d = Reader;

  var reader = /*#__PURE__*/Object.defineProperty({
  	default: _default$d
  }, '__esModule', {value: true});

  class ReaderStream extends reader.default {
    constructor() {
      super(...arguments);
      this._walkStream = out$2.walkStream;
      this._stat = out$4.stat;
    }

    dynamic(root, options) {
      return this._walkStream(root, options);
    }

    static(patterns, options) {
      const filepaths = patterns.map(this._getFullEntryPath, this);
      const stream = new stream_1__default['default'].PassThrough({
        objectMode: true
      });

      stream._write = (index, _enc, done) => {
        return this._getEntry(filepaths[index], patterns[index], options).then(entry => {
          if (entry !== null && options.entryFilter(entry)) {
            stream.push(entry);
          }

          if (index === filepaths.length - 1) {
            stream.end();
          }

          done();
        }).catch(done);
      };

      for (let i = 0; i < filepaths.length; i++) {
        stream.write(i);
      }

      return stream;
    }

    _getEntry(filepath, pattern, options) {
      return this._getStat(filepath).then(stats => this._makeEntry(stats, pattern)).catch(error => {
        if (options.errorFilter(error)) {
          return null;
        }

        throw error;
      });
    }

    _getStat(filepath) {
      return new Promise((resolve, reject) => {
        this._stat(filepath, this._fsStatSettings, (error, stats) => {
          return error === null ? resolve(stats) : reject(error);
        });
      });
    }

  }

  var _default$c = ReaderStream;

  var stream$2 = /*#__PURE__*/Object.defineProperty({
  	default: _default$c
  }, '__esModule', {value: true});

  class ReaderAsync extends reader.default {
    constructor() {
      super(...arguments);
      this._walkAsync = out$2.walk;
      this._readerStream = new stream$2.default(this._settings);
    }

    dynamic(root, options) {
      return new Promise((resolve, reject) => {
        this._walkAsync(root, options, (error, entries) => {
          if (error === null) {
            resolve(entries);
          } else {
            reject(error);
          }
        });
      });
    }

    async static(patterns, options) {
      const entries = [];

      const stream = this._readerStream.static(patterns, options); // After #235, replace it with an asynchronous iterator.


      return new Promise((resolve, reject) => {
        stream.once('error', reject);
        stream.on('data', entry => entries.push(entry));
        stream.once('end', () => resolve(entries));
      });
    }

  }

  var _default$b = ReaderAsync;

  var async$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$b
  }, '__esModule', {value: true});

  class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
      this._patterns = _patterns;
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this._storage = [];

      this._fillStorage();
    }

    _fillStorage() {
      /**
       * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
       * So, before expand patterns with brace expansion into separated patterns.
       */
      const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);

      for (const pattern of patterns) {
        const segments = this._getPatternSegments(pattern);

        const sections = this._splitSegmentsIntoSections(segments);

        this._storage.push({
          complete: sections.length <= 1,
          pattern,
          segments,
          sections
        });
      }
    }

    _getPatternSegments(pattern) {
      const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
      return parts.map(part => {
        const dynamic = utils.pattern.isDynamicPattern(part, this._settings);

        if (!dynamic) {
          return {
            dynamic: false,
            pattern: part
          };
        }

        return {
          dynamic: true,
          pattern: part,
          patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
        };
      });
    }

    _splitSegmentsIntoSections(segments) {
      return utils.array.splitWhen(segments, segment => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }

  }

  var _default$a = Matcher;

  var matcher = /*#__PURE__*/Object.defineProperty({
  	default: _default$a
  }, '__esModule', {value: true});

  class PartialMatcher extends matcher.default {
    match(filepath) {
      const parts = filepath.split('/');
      const levels = parts.length;

      const patterns = this._storage.filter(info => !info.complete || info.segments.length > levels);

      for (const pattern of patterns) {
        const section = pattern.sections[0];
        /**
         * In this case, the pattern has a globstar and we must read all directories unconditionally,
         * but only if the level has reached the end of the first group.
         *
         * fixtures/{a,b}/**
         *  ^ true/false  ^ always true
        */

        if (!pattern.complete && levels > section.length) {
          return true;
        }

        const match = parts.every((part, index) => {
          const segment = pattern.segments[index];

          if (segment.dynamic && segment.patternRe.test(part)) {
            return true;
          }

          if (!segment.dynamic && segment.pattern === part) {
            return true;
          }

          return false;
        });

        if (match) {
          return true;
        }
      }

      return false;
    }

  }

  var _default$9 = PartialMatcher;

  var partial = /*#__PURE__*/Object.defineProperty({
  	default: _default$9
  }, '__esModule', {value: true});

  class DeepFilter {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
    }

    getFilter(basePath, positive, negative) {
      const matcher = this._getMatcher(positive);

      const negativeRe = this._getNegativePatternsRe(negative);

      return entry => this._filter(basePath, entry, matcher, negativeRe);
    }

    _getMatcher(patterns) {
      return new partial.default(patterns, this._settings, this._micromatchOptions);
    }

    _getNegativePatternsRe(patterns) {
      const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
      return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }

    _filter(basePath, entry, matcher, negativeRe) {
      if (this._isSkippedByDeep(basePath, entry.path)) {
        return false;
      }

      if (this._isSkippedSymbolicLink(entry)) {
        return false;
      }

      const filepath = utils.path.removeLeadingDotSegment(entry.path);

      if (this._isSkippedByPositivePatterns(filepath, matcher)) {
        return false;
      }

      return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }

    _isSkippedByDeep(basePath, entryPath) {
      /**
       * Avoid unnecessary depth calculations when it doesn't matter.
       */
      if (this._settings.deep === Infinity) {
        return false;
      }

      return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }

    _getEntryLevel(basePath, entryPath) {
      const entryPathDepth = entryPath.split('/').length;

      if (basePath === '') {
        return entryPathDepth;
      }

      const basePathDepth = basePath.split('/').length;
      return entryPathDepth - basePathDepth;
    }

    _isSkippedSymbolicLink(entry) {
      return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }

    _isSkippedByPositivePatterns(entryPath, matcher) {
      return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }

    _isSkippedByNegativePatterns(entryPath, patternsRe) {
      return !utils.pattern.matchAny(entryPath, patternsRe);
    }

  }

  var _default$8 = DeepFilter;

  var deep = /*#__PURE__*/Object.defineProperty({
  	default: _default$8
  }, '__esModule', {value: true});

  class EntryFilter {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this.index = new Map();
    }

    getFilter(positive, negative) {
      const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
      const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
      return entry => this._filter(entry, positiveRe, negativeRe);
    }

    _filter(entry, positiveRe, negativeRe) {
      if (this._settings.unique && this._isDuplicateEntry(entry)) {
        return false;
      }

      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
        return false;
      }

      if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
        return false;
      }

      const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
      const isDirectory = entry.dirent.isDirectory();
      const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);

      if (this._settings.unique && isMatched) {
        this._createIndexRecord(entry);
      }

      return isMatched;
    }

    _isDuplicateEntry(entry) {
      return this.index.has(entry.path);
    }

    _createIndexRecord(entry) {
      this.index.set(entry.path, undefined);
    }

    _onlyFileFilter(entry) {
      return this._settings.onlyFiles && !entry.dirent.isFile();
    }

    _onlyDirectoryFilter(entry) {
      return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }

    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
      if (!this._settings.absolute) {
        return false;
      }

      const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
      return utils.pattern.matchAny(fullpath, patternsRe);
    }

    _isMatchToPatterns(entryPath, patternsRe, isDirectory) {
      const filepath = utils.path.removeLeadingDotSegment(entryPath); // Trying to match files and directories by patterns.

      const isMatched = utils.pattern.matchAny(filepath, patternsRe); // A pattern with a trailling slash can be used for directory matching.
      // To apply such pattern, we need to add a tralling slash to the path.

      if (!isMatched && isDirectory) {
        return utils.pattern.matchAny(filepath + '/', patternsRe);
      }

      return isMatched;
    }

  }

  var _default$7 = EntryFilter;

  var entry$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$7
  }, '__esModule', {value: true});

  class ErrorFilter {
    constructor(_settings) {
      this._settings = _settings;
    }

    getFilter() {
      return error => this._isNonFatalError(error);
    }

    _isNonFatalError(error) {
      return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }

  }

  var _default$6 = ErrorFilter;

  var error = /*#__PURE__*/Object.defineProperty({
  	default: _default$6
  }, '__esModule', {value: true});

  class EntryTransformer {
    constructor(_settings) {
      this._settings = _settings;
    }

    getTransformer() {
      return entry => this._transform(entry);
    }

    _transform(entry) {
      let filepath = entry.path;

      if (this._settings.absolute) {
        filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
        filepath = utils.path.unixify(filepath);
      }

      if (this._settings.markDirectories && entry.dirent.isDirectory()) {
        filepath += '/';
      }

      if (!this._settings.objectMode) {
        return filepath;
      }

      return Object.assign(Object.assign({}, entry), {
        path: filepath
      });
    }

  }

  var _default$5 = EntryTransformer;

  var entry = /*#__PURE__*/Object.defineProperty({
  	default: _default$5
  }, '__esModule', {value: true});

  class Provider {
    constructor(_settings) {
      this._settings = _settings;
      this.errorFilter = new error.default(this._settings);
      this.entryFilter = new entry$1.default(this._settings, this._getMicromatchOptions());
      this.deepFilter = new deep.default(this._settings, this._getMicromatchOptions());
      this.entryTransformer = new entry.default(this._settings);
    }

    _getRootDirectory(task) {
      return path__default['default'].resolve(this._settings.cwd, task.base);
    }

    _getReaderOptions(task) {
      const basePath = task.base === '.' ? '' : task.base;
      return {
        basePath,
        pathSegmentSeparator: '/',
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
        entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }

    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: true,
        strictSlashes: false
      };
    }

  }

  var _default$4 = Provider;

  var provider = /*#__PURE__*/Object.defineProperty({
  	default: _default$4
  }, '__esModule', {value: true});

  class ProviderAsync extends provider.default {
    constructor() {
      super(...arguments);
      this._reader = new async$1.default(this._settings);
    }

    async read(task) {
      const root = this._getRootDirectory(task);

      const options = this._getReaderOptions(task);

      const entries = await this.api(root, task, options);
      return entries.map(entry => options.transform(entry));
    }

    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }

      return this._reader.static(task.patterns, options);
    }

  }

  var _default$3 = ProviderAsync;

  var async = /*#__PURE__*/Object.defineProperty({
  	default: _default$3
  }, '__esModule', {value: true});

  class ProviderStream extends provider.default {
    constructor() {
      super(...arguments);
      this._reader = new stream$2.default(this._settings);
    }

    read(task) {
      const root = this._getRootDirectory(task);

      const options = this._getReaderOptions(task);

      const source = this.api(root, task, options);
      const destination = new stream_1__default['default'].Readable({
        objectMode: true,
        read: () => {}
      });
      source.once('error', error => destination.emit('error', error)).on('data', entry => destination.emit('data', options.transform(entry))).once('end', () => destination.emit('end'));
      destination.once('close', () => source.destroy());
      return destination;
    }

    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }

      return this._reader.static(task.patterns, options);
    }

  }

  var _default$2 = ProviderStream;

  var stream$1 = /*#__PURE__*/Object.defineProperty({
  	default: _default$2
  }, '__esModule', {value: true});

  class ReaderSync extends reader.default {
    constructor() {
      super(...arguments);
      this._walkSync = out$2.walkSync;
      this._statSync = out$4.statSync;
    }

    dynamic(root, options) {
      return this._walkSync(root, options);
    }

    static(patterns, options) {
      const entries = [];

      for (const pattern of patterns) {
        const filepath = this._getFullEntryPath(pattern);

        const entry = this._getEntry(filepath, pattern, options);

        if (entry === null || !options.entryFilter(entry)) {
          continue;
        }

        entries.push(entry);
      }

      return entries;
    }

    _getEntry(filepath, pattern, options) {
      try {
        const stats = this._getStat(filepath);

        return this._makeEntry(stats, pattern);
      } catch (error) {
        if (options.errorFilter(error)) {
          return null;
        }

        throw error;
      }
    }

    _getStat(filepath) {
      return this._statSync(filepath, this._fsStatSettings);
    }

  }

  var _default$1 = ReaderSync;

  var sync$5 = /*#__PURE__*/Object.defineProperty({
  	default: _default$1
  }, '__esModule', {value: true});

  class ProviderSync extends provider.default {
    constructor() {
      super(...arguments);
      this._reader = new sync$5.default(this._settings);
    }

    read(task) {
      const root = this._getRootDirectory(task);

      const options = this._getReaderOptions(task);

      const entries = this.api(root, task, options);
      return entries.map(options.transform);
    }

    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }

      return this._reader.static(task.patterns, options);
    }

  }

  var _default = ProviderSync;

  var sync$4 = /*#__PURE__*/Object.defineProperty({
  	default: _default
  }, '__esModule', {value: true});

  var settings = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;




  /**
   * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
   * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
   */


  const CPU_COUNT = Math.max(os__default['default'].cpus().length, 1);
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs__default['default'].lstat,
    lstatSync: fs__default['default'].lstatSync,
    stat: fs__default['default'].stat,
    statSync: fs__default['default'].statSync,
    readdir: fs__default['default'].readdir,
    readdirSync: fs__default['default'].readdirSync
  };

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.absolute = this._getValue(this._options.absolute, false);
      this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
      this.braceExpansion = this._getValue(this._options.braceExpansion, true);
      this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
      this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
      this.cwd = this._getValue(this._options.cwd, process.cwd());
      this.deep = this._getValue(this._options.deep, Infinity);
      this.dot = this._getValue(this._options.dot, false);
      this.extglob = this._getValue(this._options.extglob, true);
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
      this.fs = this._getFileSystemMethods(this._options.fs);
      this.globstar = this._getValue(this._options.globstar, true);
      this.ignore = this._getValue(this._options.ignore, []);
      this.markDirectories = this._getValue(this._options.markDirectories, false);
      this.objectMode = this._getValue(this._options.objectMode, false);
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
      this.onlyFiles = this._getValue(this._options.onlyFiles, true);
      this.stats = this._getValue(this._options.stats, false);
      this.suppressErrors = this._getValue(this._options.suppressErrors, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
      this.unique = this._getValue(this._options.unique, true);

      if (this.onlyDirectories) {
        this.onlyFiles = false;
      }

      if (this.stats) {
        this.objectMode = true;
      }
    }

    _getValue(option, value) {
      return option === undefined ? value : option;
    }

    _getFileSystemMethods(methods = {}) {
      return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }

  }

  exports.default = Settings;
  });

  async function FastGlob(source, options) {
    assertPatternsInput$1(source);
    const works = getWorks(source, async.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
  } // https://github.com/typescript-eslint/typescript-eslint/issues/60
  // eslint-disable-next-line no-redeclare


  (function (FastGlob) {
    function sync(source, options) {
      assertPatternsInput$1(source);
      const works = getWorks(source, sync$4.default, options);
      return utils.array.flatten(works);
    }

    FastGlob.sync = sync;

    function stream(source, options) {
      assertPatternsInput$1(source);
      const works = getWorks(source, stream$1.default, options);
      /**
       * The stream returned by the provider cannot work with an asynchronous iterator.
       * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
       * This affects performance (+25%). I don't see best solution right now.
       */

      return utils.stream.merge(works);
    }

    FastGlob.stream = stream;

    function generateTasks(source, options) {
      assertPatternsInput$1(source);
      const patterns$1 = patterns.transform([].concat(source));
      const settings$1 = new settings.default(options);
      return tasks.generate(patterns$1, settings$1);
    }

    FastGlob.generateTasks = generateTasks;

    function isDynamicPattern(source, options) {
      assertPatternsInput$1(source);
      const settings$1 = new settings.default(options);
      return utils.pattern.isDynamicPattern(source, settings$1);
    }

    FastGlob.isDynamicPattern = isDynamicPattern;

    function escapePath(source) {
      assertPatternsInput$1(source);
      return utils.path.escape(source);
    }

    FastGlob.escapePath = escapePath;
  })(FastGlob || (FastGlob = {}));

  function getWorks(source, _Provider, options) {
    const patterns$1 = patterns.transform([].concat(source));
    const settings$1 = new settings.default(options);
    const tasks$1 = tasks.generate(patterns$1, settings$1);
    const provider = new _Provider(settings$1);
    return tasks$1.map(provider.read, provider);
  }

  function assertPatternsInput$1(input) {
    const source = [].concat(input);
    const isValidSource = source.every(item => utils.string.isString(item) && !utils.string.isEmpty(item));

    if (!isValidSource) {
      throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
  }

  var out = FastGlob;

  const getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];

  const getPath = (filepath, cwd) => {
    const pth = filepath[0] === '!' ? filepath.slice(1) : filepath;
    return path__default['default'].isAbsolute(pth) ? pth : path__default['default'].join(cwd, pth);
  };

  const addExtensions = (file, extensions) => {
    if (path__default['default'].extname(file)) {
      return `**/${file}`;
    }

    return `**/${file}.${getExtensions(extensions)}`;
  };

  const getGlob = (directory, options) => {
    if (options.files && !Array.isArray(options.files)) {
      throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
    }

    if (options.extensions && !Array.isArray(options.extensions)) {
      throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
    }

    if (options.files && options.extensions) {
      return options.files.map(x => path__default['default'].posix.join(directory, addExtensions(x, options.extensions)));
    }

    if (options.files) {
      return options.files.map(x => path__default['default'].posix.join(directory, `**/${x}`));
    }

    if (options.extensions) {
      return [path__default['default'].posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
    }

    return [path__default['default'].posix.join(directory, '**')];
  };

  var dirGlob = async (input, options) => {
    options = {
      cwd: process.cwd(),
      ...options
    };

    if (typeof options.cwd !== 'string') {
      throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }

    const globs = await Promise.all([].concat(input).map(async x => {
      const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
      return isDirectory ? getGlob(x, options) : x;
    }));
    return [].concat.apply([], globs); // eslint-disable-line prefer-spread
  };

  var sync$3 = (input, options) => {
    options = {
      cwd: process.cwd(),
      ...options
    };

    if (typeof options.cwd !== 'string') {
      throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }

    const globs = [].concat(input).map(x => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
    return [].concat.apply([], globs); // eslint-disable-line prefer-spread
  };
  dirGlob.sync = sync$3;

  // A simple implementation of make-array
  function makeArray(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }

  const EMPTY = '';
  const SPACE = ' ';
  const ESCAPE = '\\';
  const REGEX_TEST_BLANK_LINE = /^\s+$/;
  const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
  const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
  const REGEX_SPLITALL_CRLF = /\r?\n/g; // /foo,
  // ./foo,
  // ../foo,
  // .
  // ..

  const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
  const SLASH = '/';
  const KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore';

  const define = (object, key, value) => Object.defineProperty(object, key, {
    value
  });

  const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;

  const RETURN_FALSE = () => false; // Sanitize the range of a regular expression
  // The cases are complicated, see test cases for details


  const sanitizeRange = range => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but
  //   fatal for JavaScript regular expression, so eliminate it.
  : EMPTY); // See fixtures #59


  const cleanRangeBackSlash = slashes => {
    const {
      length
    } = slashes;
    return slashes.slice(0, length - length % 2);
  }; // > If the pattern ends with a slash,
  // > it is removed for the purpose of the following description,
  // > but it would only find a match with a directory.
  // > In other words, foo/ will match a directory foo and paths underneath it,
  // > but will not match a regular file or a symbolic link foo
  // >  (this is consistent with the way how pathspec works in general in Git).
  // '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
  // -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
  //      you could use option `mark: true` with `glob`
  // '`foo/`' should not continue with the '`..`'


  const REPLACERS = [// > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [// (a\ ) -> (a )
  // (a  ) -> (a)
  // (a \ ) -> (a  )
  /\\?\s+$/, match => match.indexOf('\\') === 0 ? SPACE : EMPTY], // replace (\ ) with ' '
  [/\\\s/g, () => SPACE], // Escape metacharacters
  // which is written down by users but means special for regular expressions.
  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [/[\\$.|*+(){^]/g, match => `\\${match}`], [// > a question mark (?) matches a single character
  /(?!\\)\?/g, () => '[^/]'], // leading slash
  [// > A leading slash matches the beginning of the pathname.
  // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
  // A leading slash matches the beginning of the pathname
  /^\//, () => '^'], // replace special metacharacter slash after the leading slash
  [/\//g, () => '\\/'], [// > A leading "**" followed by a slash means match in all directories.
  // > For example, "**/foo" matches file or directory "foo" anywhere,
  // > the same as pattern "foo".
  // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
  // >   under directory "foo".
  // Notice that the '*'s have been replaced as '\\*'
  /^\^*\\\*\\\*\\\//, // '**/foo' <-> 'foo'
  () => '^(?:.*\\/)?'], // starting
  [// there will be no leading '/'
  //   (which has been replaced by section "leading slash")
  // If starts with '**', adding a '^' to the regular expression also works
  /^(?=[^^])/, function startingReplacer() {
    // If has a slash `/` at the beginning or middle
    return !/\/(?!$)/.test(this) // > Prior to 2.22.1
    // > If the pattern does not contain a slash /,
    // >   Git treats it as a shell glob pattern
    // Actually, if there is only a trailing slash,
    //   git also treats it as a shell glob pattern
    // After 2.22.1 (compatible but clearer)
    // > If there is a separator at the beginning or middle (or both)
    // > of the pattern, then the pattern is relative to the directory
    // > level of the particular .gitignore file itself.
    // > Otherwise the pattern may also match at any level below
    // > the .gitignore level.
    ? '(?:^|\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for
    // >   consumption by fnmatch(3)
    : '^';
  }], // two globstars
  [// Use lookahead assertions so that we could match more than one `'/**'`
  /\\\/\\\*\\\*(?=\\\/|$)/g, // Zero, one or several directories
  // should not use '*', or it will be replaced by the next replacer
  // Check if it is not the last `'/**'`
  (_, index, str) => index + 6 < str.length // case: /**/
  // > A slash followed by two consecutive asterisks then a slash matches
  // >   zero or more directories.
  // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
  // '/**/'
  ? '(?:\\/[^\\/]+)*' // case: /**
  // > A trailing `"/**"` matches everything inside.
  // #21: everything inside but it should not include the current folder
  : '\\/.+'], // intermediate wildcards
  [// Never replace escaped '*'
  // ignore rule '\*' will match the path '*'
  // 'abc.*/' -> go
  // 'abc.*'  -> skip this rule
  /(^|[^\\]+)\\\*(?=.+)/g, // '*.js' matches '.js'
  // '*.js' doesn't match 'abc'
  (_, p1) => `${p1}[^\\/]*`], [// unescape, revert step 3 except for back slash
  // For example, if a user escape a '\\*',
  // after step 3, the result will be '\\\\\\*'
  /\\\\\\(?=[$.|*+(){^])/g, () => ESCAPE], [// '\\\\' -> '\\'
  /\\\\/g, () => ESCAPE], [// > The range notation, e.g. [a-zA-Z],
  // > can be used to match one of the characters in a range.
  // `\` is escaped by step 3
  /(\\)?\[([^\]/]*?)(\\*)($|\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE // '\\[bar]' -> '\\\\[bar\\]'
  ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === ']' ? endEscape.length % 2 === 0 // A normal case, and it is a range notation
  // '[bar]'
  // '[bar\\\\]'
  ? `[${sanitizeRange(range)}${endEscape}]` // Invalid range notaton
  // '[bar\\]' -> '[bar\\\\]'
  : '[]' : '[]'], // ending
  [// 'js' will not match 'js.'
  // 'ab' will not match 'abc'
  /(?:[^*])$/, // WTF!
  // https://git-scm.com/docs/gitignore
  // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
  // which re-fixes #24, #38
  // > If there is a separator at the end of the pattern then the pattern
  // > will only match directories, otherwise the pattern can match both
  // > files and directories.
  // 'js*' will not match 'a.js'
  // 'js/' will not match 'a.js'
  // 'js' will match 'a.js' and 'a.js/'
  match => /\/$/.test(match) // foo/ will not match 'foo'
  ? `${match}$` // foo matches 'foo' and 'foo/'
  : `${match}(?=$|\\/$)`], // trailing wildcard
  [/(\^|\\\/)?\\\*$/, (_, p1) => {
    const prefix = p1 // '\^':
    // '/*' does not match EMPTY
    // '/*' does not match everything
    // '\\\/':
    // 'abc/*' does not match 'abc/'
    ? `${p1}[^/]+` // 'a*' matches 'a'
    // 'a*' matches 'aa'
    : '[^/]*';
    return `${prefix}(?=$|\\/$)`;
  }]]; // A simple cache, because an ignore rule only has only one certain meaning

  const regexCache = Object.create(null); // @param {pattern}

  const makeRegex = (pattern, ignoreCase) => {
    let source = regexCache[pattern];

    if (!source) {
      source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
      regexCache[pattern] = source;
    }

    return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);
  };

  const isString$1 = subject => typeof subject === 'string'; // > A blank line matches no files, so it can serve as a separator for readability.


  const checkPattern = pattern => pattern && isString$1(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0;

  const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF);

  class IgnoreRule {
    constructor(origin, pattern, negative, regex) {
      this.origin = origin;
      this.pattern = pattern;
      this.negative = negative;
      this.regex = regex;
    }

  }

  const createRule = (pattern, ignoreCase) => {
    const origin = pattern;
    let negative = false; // > An optional prefix "!" which negates the pattern;

    if (pattern.indexOf('!') === 0) {
      negative = true;
      pattern = pattern.substr(1);
    }

    pattern = pattern // > Put a backslash ("\") in front of the first "!" for patterns that
    // >   begin with a literal "!", for example, `"\!important!.txt"`.
    .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!') // > Put a backslash ("\") in front of the first hash for patterns that
    // >   begin with a hash.
    .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');
    const regex = makeRegex(pattern, ignoreCase);
    return new IgnoreRule(origin, pattern, negative, regex);
  };

  const throwError = (message, Ctor) => {
    throw new Ctor(message);
  };

  const checkPath = (path, originalPath, doThrow) => {
    if (!isString$1(path)) {
      return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    } // We don't know if we should ignore EMPTY, so throw


    if (!path) {
      return doThrow(`path must not be empty`, TypeError);
    } // Check if it is a relative path


    if (checkPath.isNotRelative(path)) {
      const r = '`path.relative()`d';
      return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }

    return true;
  };

  const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path);

  checkPath.isNotRelative = isNotRelative;

  checkPath.convert = p => p;

  class Ignore {
    constructor({
      ignorecase = true,
      ignoreCase = ignorecase,
      allowRelativePaths = false
    } = {}) {
      define(this, KEY_IGNORE, true);
      this._rules = [];
      this._ignoreCase = ignoreCase;
      this._allowRelativePaths = allowRelativePaths;

      this._initCache();
    }

    _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }

    _addPattern(pattern) {
      // #32
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }

      if (checkPattern(pattern)) {
        const rule = createRule(pattern, this._ignoreCase);
        this._added = true;

        this._rules.push(rule);
      }
    } // @param {Array<string> | string | Ignore} pattern


    add(pattern) {
      this._added = false;
      makeArray(isString$1(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,
      // making the behavior changed.

      if (this._added) {
        this._initCache();
      }

      return this;
    } // legacy


    addPattern(pattern) {
      return this.add(pattern);
    } //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns {TestResult} true if a file is ignored


    _testOne(path, checkUnignored) {
      let ignored = false;
      let unignored = false;

      this._rules.forEach(rule => {
        const {
          negative
        } = rule;

        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }

        const matched = rule.regex.test(path);

        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });

      return {
        ignored,
        unignored
      };
    } // @returns {TestResult}


    _test(originalPath, cache, checkUnignored, slices) {
      const path = originalPath // Supports nullable path
      && checkPath.convert(originalPath);
      checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
      return this._t(path, cache, checkUnignored, slices);
    }

    _t(path, cache, checkUnignored, slices) {
      if (path in cache) {
        return cache[path];
      }

      if (!slices) {
        // path/to/a.js
        // ['path', 'to', 'a.js']
        slices = path.split(SLASH);
      }

      slices.pop(); // If the path has no parent directory, just test it

      if (!slices.length) {
        return cache[path] = this._testOne(path, checkUnignored);
      }

      const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices); // If the path contains a parent directory, check the parent first


      return cache[path] = parent.ignored // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent : this._testOne(path, checkUnignored);
    }

    ignores(path) {
      return this._test(path, this._ignoreCache, false).ignored;
    }

    createFilter() {
      return path => !this.ignores(path);
    }

    filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    } // @returns {TestResult}


    test(path) {
      return this._test(path, this._testCache, true);
    }

  }

  const factory = options => new Ignore(options);

  const isPathValid = path => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);

  factory.isPathValid = isPathValid; // Fixes typescript

  factory.default = factory;
  var ignore = factory; // Windows
  // --------------------------------------------------------------

  /* istanbul ignore if  */

  if ( // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {
    /* eslint no-control-regex: "off" */
    const makePosix = str => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, '/');

    checkPath.convert = makePosix; // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
    // 'd:\\foo'

    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;

    checkPath.isNotRelative = path => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
  }

  var slash = path => {
    const isExtendedLengthPath = /^\\\\\?\\/.test(path);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex

    if (isExtendedLengthPath || hasNonAscii) {
      return path;
    }

    return path.replace(/\\/g, '/');
  };

  const {
    promisify: promisify$1
  } = util__default['default'];











  const DEFAULT_IGNORE = ['**/node_modules/**', '**/flow-typed/**', '**/coverage/**', '**/.git'];
  const readFileP = promisify$1(fs__default['default'].readFile);

  const mapGitIgnorePatternTo = base => ignore => {
    if (ignore.startsWith('!')) {
      return '!' + path__default['default'].posix.join(base, ignore.slice(1));
    }

    return path__default['default'].posix.join(base, ignore);
  };

  const parseGitIgnore = (content, options) => {
    const base = slash(path__default['default'].relative(options.cwd, path__default['default'].dirname(options.fileName)));
    return content.split(/\r?\n/).filter(Boolean).filter(line => !line.startsWith('#')).map(mapGitIgnorePatternTo(base));
  };

  const reduceIgnore = files => {
    const ignores = ignore();

    for (const file of files) {
      ignores.add(parseGitIgnore(file.content, {
        cwd: file.cwd,
        fileName: file.filePath
      }));
    }

    return ignores;
  };

  const ensureAbsolutePathForCwd = (cwd, p) => {
    cwd = slash(cwd);

    if (path__default['default'].isAbsolute(p)) {
      if (slash(p).startsWith(cwd)) {
        return p;
      }

      throw new Error(`Path ${p} is not in cwd ${cwd}`);
    }

    return path__default['default'].join(cwd, p);
  };

  const getIsIgnoredPredecate = (ignores, cwd) => {
    return p => ignores.ignores(slash(path__default['default'].relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
  };

  const getFile = async (file, cwd) => {
    const filePath = path__default['default'].join(cwd, file);
    const content = await readFileP(filePath, 'utf8');
    return {
      cwd,
      filePath,
      content
    };
  };

  const getFileSync = (file, cwd) => {
    const filePath = path__default['default'].join(cwd, file);
    const content = fs__default['default'].readFileSync(filePath, 'utf8');
    return {
      cwd,
      filePath,
      content
    };
  };

  const normalizeOptions = ({
    ignore = [],
    cwd = slash(process.cwd())
  } = {}) => {
    return {
      ignore,
      cwd
    };
  };

  var gitignore = async options => {
    options = normalizeOptions(options);
    const paths = await out('**/.gitignore', {
      ignore: DEFAULT_IGNORE.concat(options.ignore),
      cwd: options.cwd
    });
    const files = await Promise.all(paths.map(file => getFile(file, options.cwd)));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
  };

  var sync$2 = options => {
    options = normalizeOptions(options);
    const paths = out.sync('**/.gitignore', {
      ignore: DEFAULT_IGNORE.concat(options.ignore),
      cwd: options.cwd
    });
    const files = paths.map(file => getFileSync(file, options.cwd));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
  };
  gitignore.sync = sync$2;

  const {
    Transform
  } = stream_1__default['default'];

  class ObjectTransform extends Transform {
    constructor() {
      super({
        objectMode: true
      });
    }

  }

  class FilterStream$1 extends ObjectTransform {
    constructor(filter) {
      super();
      this._filter = filter;
    }

    _transform(data, encoding, callback) {
      if (this._filter(data)) {
        this.push(data);
      }

      callback();
    }

  }

  class UniqueStream$1 extends ObjectTransform {
    constructor() {
      super();
      this._pushed = new Set();
    }

    _transform(data, encoding, callback) {
      if (!this._pushed.has(data)) {
        this.push(data);

        this._pushed.add(data);
      }

      callback();
    }

  }

  var streamUtils = {
    FilterStream: FilterStream$1,
    UniqueStream: UniqueStream$1
  };

  const {
    FilterStream,
    UniqueStream
  } = streamUtils;

  const DEFAULT_FILTER = () => false;

  const isNegative = pattern => pattern[0] === '!';

  const assertPatternsInput = patterns => {
    if (!patterns.every(pattern => typeof pattern === 'string')) {
      throw new TypeError('Patterns must be a string or an array of strings');
    }
  };

  const checkCwdOption = (options = {}) => {
    if (!options.cwd) {
      return;
    }

    let stat;

    try {
      stat = fs__default['default'].statSync(options.cwd);
    } catch {
      return;
    }

    if (!stat.isDirectory()) {
      throw new Error('The `cwd` option must be a path to a directory');
    }
  };

  const getPathString = p => p.stats instanceof fs__default['default'].Stats ? p.path : p;

  const generateGlobTasks = (patterns, taskOptions) => {
    patterns = arrayUnion([].concat(patterns));
    assertPatternsInput(patterns);
    checkCwdOption(taskOptions);
    const globTasks = [];
    taskOptions = {
      ignore: [],
      expandDirectories: true,
      ...taskOptions
    };

    for (const [index, pattern] of patterns.entries()) {
      if (isNegative(pattern)) {
        continue;
      }

      const ignore = patterns.slice(index).filter(pattern => isNegative(pattern)).map(pattern => pattern.slice(1));
      const options = { ...taskOptions,
        ignore: taskOptions.ignore.concat(ignore)
      };
      globTasks.push({
        pattern,
        options
      });
    }

    return globTasks;
  };

  const globDirs = (task, fn) => {
    let options = {};

    if (task.options.cwd) {
      options.cwd = task.options.cwd;
    }

    if (Array.isArray(task.options.expandDirectories)) {
      options = { ...options,
        files: task.options.expandDirectories
      };
    } else if (typeof task.options.expandDirectories === 'object') {
      options = { ...options,
        ...task.options.expandDirectories
      };
    }

    return fn(task.pattern, options);
  };

  const getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];

  const getFilterSync = options => {
    return options && options.gitignore ? gitignore.sync({
      cwd: options.cwd,
      ignore: options.ignore
    }) : DEFAULT_FILTER;
  };

  const globToTask = task => glob => {
    const {
      options
    } = task;

    if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
      options.ignore = dirGlob.sync(options.ignore);
    }

    return {
      pattern: glob,
      options
    };
  };

  var globby = async (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);

    const getFilter = async () => {
      return options && options.gitignore ? gitignore({
        cwd: options.cwd,
        ignore: options.ignore
      }) : DEFAULT_FILTER;
    };

    const getTasks = async () => {
      const tasks = await Promise.all(globTasks.map(async task => {
        const globs = await getPattern(task, dirGlob);
        return Promise.all(globs.map(globToTask(task)));
      }));
      return arrayUnion(...tasks);
    };

    const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
    const paths = await Promise.all(tasks.map(task => out(task.pattern, task.options)));
    return arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));
  };

  var sync$1 = (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);
    const tasks = [];

    for (const task of globTasks) {
      const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
      tasks.push(...newTask);
    }

    const filter = getFilterSync(options);
    let matches = [];

    for (const task of tasks) {
      matches = arrayUnion(matches, out.sync(task.pattern, task.options));
    }

    return matches.filter(path_ => !filter(path_));
  };

  var stream = (patterns, options) => {
    const globTasks = generateGlobTasks(patterns, options);
    const tasks = [];

    for (const task of globTasks) {
      const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
      tasks.push(...newTask);
    }

    const filter = getFilterSync(options);
    const filterStream = new FilterStream(p => !filter(p));
    const uniqueStream = new UniqueStream();
    return merge2_1(tasks.map(task => out.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
  };

  var generateGlobTasks_1 = generateGlobTasks;

  var hasMagic = (patterns, options) => [].concat(patterns).some(pattern => out.isDynamicPattern(pattern, options));

  var gitignore_1 = gitignore;
  globby.sync = sync$1;
  globby.stream = stream;
  globby.generateGlobTasks = generateGlobTasks_1;
  globby.hasMagic = hasMagic;
  globby.gitignore = gitignore_1;

  /** @typedef {import('stylelint').PostcssResult} PostcssResult */

  /** @typedef {import('stylelint').LintResult} StylelintResult */

  /**
   * @param {PostcssResult} [postcssResult]
   * @param {import('stylelint').CssSyntaxError} [cssSyntaxError]
   * @return {StylelintResult}
   */

  var createPartialStylelintResult = function createPartialStylelintResult(postcssResult, cssSyntaxError) {
    /** @type {StylelintResult} */
    let stylelintResult;
    /** @type {string | undefined} */

    let source;

    if (postcssResult && postcssResult.root) {
      if (postcssResult.root.source) {
        source = postcssResult.root.source.input.file;

        if (!source && 'id' in postcssResult.root.source.input) {
          source = postcssResult.root.source.input.id;
        }
      }

      const deprecationMessages = postcssResult.messages.filter(message => message.stylelintType === 'deprecation');
      const deprecations = deprecationMessages.map(deprecationMessage => {
        return {
          text: deprecationMessage.text,
          reference: deprecationMessage.stylelintReference
        };
      });
      const invalidOptionMessages = postcssResult.messages.filter(message => message.stylelintType === 'invalidOption');
      const invalidOptionWarnings = invalidOptionMessages.map(invalidOptionMessage => {
        return {
          text: invalidOptionMessage.text
        };
      });
      const parseErrors = postcssResult.messages.filter(message => message.stylelintType === 'parseError'); // Remove deprecation warnings, invalid options, and parse errors from the messages

      postcssResult.messages = postcssResult.messages.filter(message => message.stylelintType !== 'deprecation' && message.stylelintType !== 'invalidOption' && message.stylelintType !== 'parseError'); // This defines the stylelint result object that formatters receive

      stylelintResult = {
        source,
        deprecations,
        invalidOptionWarnings,
        // @ts-expect-error -- TS2322: Type 'Message[]' is not assignable to type '(Warning & { stylelintType: string; })[]'.
        parseErrors,
        errored: postcssResult.stylelint.stylelintError,
        warnings: postcssResult.messages.map(message => {
          return {
            line: message.line,
            column: message.column,
            endLine: message.endLine,
            endColumn: message.endColumn,
            rule: message.rule,
            severity: message.severity,
            text: message.text
          };
        }),
        ignored: postcssResult.stylelint.ignored,
        _postcssResult: postcssResult
      };
    } else if (cssSyntaxError) {
      if (cssSyntaxError.name !== 'CssSyntaxError') {
        throw cssSyntaxError;
      }

      stylelintResult = {
        source: cssSyntaxError.file || '<input css 1>',
        deprecations: [],
        invalidOptionWarnings: [],
        parseErrors: [],
        errored: true,
        warnings: [{
          line: cssSyntaxError.line,
          column: cssSyntaxError.column,
          endLine: cssSyntaxError.endLine,
          endColumn: cssSyntaxError.endColumn,
          rule: cssSyntaxError.name,
          severity: 'error',
          text: `${cssSyntaxError.reason} (${cssSyntaxError.name})`
        }]
      };
    } else {
      throw new Error('createPartialStylelintResult must be called with either postcssResult or CssSyntaxError');
    }

    return stylelintResult;
  };

  /**
   * @param {string} separator
   * @param {string} [quote]
   * @returns {string}
   */


  var getFormatterOptionsText = function getFormatterOptionsText(separator, quote = '') {
    return Object.keys(formatters_1).map(name => `${quote}${name}${quote}`).join(separator);
  };

  class NoFilesFoundError extends Error {
    /**
     * @param {string|string[]} fileList
     */
    constructor(fileList) {
      super();

      if (typeof fileList === 'string') {
        fileList = [fileList];
      }

      const pattern = fileList.filter(i => !i.startsWith('!')).join(', ');
      this.message = `No files matching the pattern "${pattern}" were found.`;
    }

  }

  var noFilesFoundError = NoFilesFoundError;

  class AllFilesIgnoredError extends Error {
    constructor() {
      super();
      this.message = `All input files were ignored because of the ignore pattern. Either change your input, ignore pattern or use "--allow-empty-input" to allow no inputs`;
    }

  }

  var allFilesIgnoredError = AllFilesIgnoredError;

  const {
    isRegExp,
    isString
  } = validateTypes;
  /**
   * @typedef {import('stylelint').PostcssResult} PostcssResult
   * @typedef {import('stylelint').DisableOptions} DisableOptions
   * @typedef {import('stylelint').DisablePropertyName} DisablePropertyName
   * @typedef {import('stylelint').StylelintPostcssResult} StylelintPostcssResult
   */

  /**
   * Validates that the stylelint config for `result` has a valid disable field
   * named `field`, and returns the result in normalized form as well as a
   * `StylelintPostcssResult` for convenience.
   *
   * Returns `null` if no disables should be reported, and automatically reports
   * an invalid configuration. If this returns non-`null`, it guarantees that
   * `result._postcssResult` is defined as well.
   *
   * @param {PostcssResult | undefined} result
   * @param {DisablePropertyName} field
   * @return {[boolean, Required<DisableOptions>, StylelintPostcssResult] | null}
   */


  var validateDisableSettings = function validateDisableSettings(result, field) {
    // Files with `CssSyntaxError`s don't have `_postcssResult`s.
    if (!result) return null;
    const stylelintResult = result.stylelint; // Files with linting errors may not have configs associated with them.

    if (!stylelintResult.config) return null;
    const rawSettings = stylelintResult.config[field];
    /** @type {boolean} */

    let enabled;
    /** @type {DisableOptions} */

    let options;

    if (Array.isArray(rawSettings)) {
      enabled = rawSettings[0];
      options = rawSettings[1] || {};
    } else {
      enabled = rawSettings || false;
      options = {};
    }

    const validOptions = validateOptions$1(result, field, {
      actual: enabled,
      possible: [true, false]
    }, {
      actual: options,
      possible: {
        except: [isString, isRegExp]
      }
    });
    if (!validOptions) return null; // If the check is disabled with no exceptions, there's no reason to run
    // it at all.

    if (!enabled && !options.except) return null;
    return [enabled, {
      except: options.except || [],
      severity: options.severity || stylelintResult.config.defaultSeverity || 'error'
    }, stylelintResult];
  };

  /** @typedef {import('postcss').Comment} PostcssComment */

  /** @typedef {import('stylelint').DisableReportRange} DisableReportRange */

  /** @typedef {import('stylelint').DisableOptionsReport} StylelintDisableOptionsReport */

  /**
   * @param {import('stylelint').LintResult[]} results
   */


  var descriptionlessDisables = function descriptionlessDisables(results) {
    for (const result of results) {
      const settings = validateDisableSettings(result._postcssResult, 'reportDescriptionlessDisables');
      if (!settings) continue;
      const [enabled, options, stylelintResult] = settings;
      /** @type {Set<PostcssComment>} */

      const alreadyReported = new Set();

      for (const [rule, ruleRanges] of Object.entries(stylelintResult.disabledRanges)) {
        for (const range of ruleRanges) {
          if (range.description) continue;
          if (alreadyReported.has(range.comment)) continue;

          if (enabled === optionsMatches(options, 'except', rule)) {
            // An 'all' rule will get copied for each individual rule. If the
            // configuration is `[false, {except: ['specific-rule']}]`, we
            // don't want to report the copies that match except, so we record
            // the comment as already reported.
            if (!enabled && rule === 'all') alreadyReported.add(range.comment);
            continue;
          }

          alreadyReported.add(range.comment); // If the comment doesn't have a location, we can't report a useful error.
          // In practice we expect all comments to have locations, though.

          if (!range.comment.source || !range.comment.source.start) continue;
          result.warnings.push({
            text: `Disable for "${rule}" is missing a description`,
            rule: '--report-descriptionless-disables',
            line: range.comment.source.start.line,
            column: range.comment.source.start.column,
            endLine: range.comment.source.end && range.comment.source.end.line,
            endColumn: range.comment.source.end && range.comment.source.end.column,
            severity: options.severity
          });
        }
      }
    }
  };

  /**
   * @param {import('stylelint').LintResult[]} results
   */


  var invalidScopeDisables = function invalidScopeDisables(results) {
    for (const result of results) {
      const settings = validateDisableSettings(result._postcssResult, 'reportInvalidScopeDisables');
      if (!settings) continue;
      const [enabled, options, stylelintResult] = settings;
      const configRules = (stylelintResult.config || {}).rules || {};
      const usedRules = new Set(Object.keys(configRules));
      usedRules.add('all');

      for (const [rule, ruleRanges] of Object.entries(stylelintResult.disabledRanges)) {
        if (usedRules.has(rule)) continue;
        if (enabled === optionsMatches(options, 'except', rule)) continue;

        for (const range of ruleRanges) {
          if (!range.strictStart && !range.strictEnd) continue; // If the comment doesn't have a location, we can't report a useful error.
          // In practice we expect all comments to have locations, though.

          if (!range.comment.source || !range.comment.source.start) continue;
          result.warnings.push({
            text: `Rule "${rule}" isn't enabled`,
            rule: '--report-invalid-scope-disables',
            line: range.comment.source.start.line,
            column: range.comment.source.start.column,
            endLine: range.comment.source.end && range.comment.source.end.line,
            endColumn: range.comment.source.end && range.comment.source.end.column,
            severity: options.severity
          });
        }
      }
    }
  };

  /**
   * If `map` already has the given `key`, returns its value. Otherwise, calls
   * `callback`, adds the result to `map` at `key`, and then returns it.
   *
   * @template K
   * @template V
   * @param {Map<K, V>} map
   * @param {K} key
   * @param {() => V} callback
   * @returns {V}
   */

  var putIfAbsent = function putIfAbsent(map, key, callback) {
    if (map.has(key)) return (
      /** @type {V} */
      map.get(key)
    );
    const value = callback();
    map.set(key, value);
    return value;
  };

  /** @typedef {import('postcss').Comment} PostcssComment */

  /** @typedef {import('stylelint').DisabledRange} DisabledRange */

  /** @typedef {import('stylelint').DisableReportRange} DisableReportRange */

  /**
   * @param {import('stylelint').LintResult[]} results
   */


  var needlessDisables = function needlessDisables(results) {
    for (const result of results) {
      const settings = validateDisableSettings(result._postcssResult, 'reportNeedlessDisables');
      if (!settings) continue;
      const [enabled, options, stylelintResult] = settings;
      const rangeData = stylelintResult.disabledRanges;
      if (!rangeData) continue;
      const disabledWarnings = stylelintResult.disabledWarnings || []; // A map from `stylelint-disable` comments to the set of rules that
      // are usefully disabled by each comment. We track this
      // comment-by-comment rather than range-by-range because ranges that
      // disable *all* rules are duplicated for each rule they apply to in
      // practice.

      /** @type {Map<PostcssComment, Set<string>>}} */

      const usefulDisables = new Map();

      for (const warning of disabledWarnings) {
        const rule = warning.rule;
        const ruleRanges = rangeData[rule];

        if (ruleRanges) {
          for (const range of ruleRanges) {
            if (isWarningInRange(warning, range)) {
              putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);
            }
          }
        }

        for (const range of rangeData.all || []) {
          if (isWarningInRange(warning, range)) {
            putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);
          }
        }
      }

      const allRangeComments = new Set((rangeData.all || []).map(range => range.comment));

      for (const [rule, ranges] of Object.entries(rangeData)) {
        for (const range of ranges) {
          if (rule !== 'all' && allRangeComments.has(range.comment)) continue;
          if (enabled === optionsMatches(options, 'except', rule)) continue;
          const useful = usefulDisables.get(range.comment) || new Set(); // Only emit a warning if this range's comment isn't useful for this rule.
          // For the special rule "all", only emit a warning if it's not useful for
          // *any* rules, because it covers all of them.

          if (rule === 'all' ? useful.size !== 0 : useful.has(rule)) continue; // If the comment doesn't have a location, we can't report a useful error.
          // In practice we expect all comments to have locations, though.

          if (!range.comment.source || !range.comment.source.start) continue;
          result.warnings.push({
            text: `Needless disable for "${rule}"`,
            rule: '--report-needless-disables',
            line: range.comment.source.start.line,
            column: range.comment.source.start.column,
            endLine: range.comment.source.end && range.comment.source.end.line,
            endColumn: range.comment.source.end && range.comment.source.end.column,
            severity: options.severity
          });
        }
      }
    }
  };
  /**
   * @param {import('stylelint').DisabledWarning} warning
   * @param {DisabledRange} range
   * @return {boolean}
   */


  function isWarningInRange(warning, range) {
    const line = warning.line; // Need to check if range.end exist, because line number type cannot be compared to undefined

    return range.start <= line && (range.end !== undefined && range.end >= line || range.end === undefined);
  }

  /** @typedef {import('stylelint').DisableReportRange} DisabledRange */

  /** @typedef {import('stylelint').LintResult} StylelintResult */

  /** @typedef {import('stylelint').ConfigRuleSettings<any, Object>} StylelintConfigRuleSettings */

  /**
   * Returns a report describing which `results` (if any) contain disabled ranges
   * for rules that disallow disables via `reportDisables: true`.
   *
   * @param {StylelintResult[]} results
   */

  var reportDisables = function reportDisables(results) {
    for (const result of results) {
      // File with `CssSyntaxError` don't have `_postcssResult`s.
      if (!result._postcssResult) {
        continue;
      }

      const rangeData = result._postcssResult.stylelint.disabledRanges;
      if (!rangeData) continue;
      const config = result._postcssResult.stylelint.config;
      if (!config || !config.rules) continue; // If no rules actually disallow disables, don't bother looking for ranges
      // that correspond to disabled rules.

      if (!Object.values(config.rules).some(rule => reportDisablesForRule(rule))) {
        continue;
      }

      for (const [rule, ranges] of Object.entries(rangeData)) {
        for (const range of ranges) {
          if (!reportDisablesForRule(config.rules[rule] || [])) continue; // If the comment doesn't have a location, we can't report a useful error.
          // In practice we expect all comments to have locations, though.

          if (!range.comment.source || !range.comment.source.start) continue;
          result.warnings.push({
            text: `Rule "${rule}" may not be disabled`,
            rule: 'reportDisables',
            line: range.comment.source.start.line,
            column: range.comment.source.start.column,
            endLine: range.comment.source.end && range.comment.source.end.line,
            endColumn: range.comment.source.end && range.comment.source.end.column,
            severity: 'error'
          });
        }
      }
    }
  };
  /**
   * @param {StylelintConfigRuleSettings} options
   * @return {boolean}
   */


  function reportDisablesForRule(options) {
    if (!options || !options[1]) return false;
    return Boolean(options[1].reportDisables);
  }

  /** @typedef {import('stylelint').Formatter} Formatter */

  /** @typedef {import('stylelint').LintResult} StylelintResult */

  /** @typedef {import('stylelint').LinterOptions["maxWarnings"]} maxWarnings */

  /** @typedef {import('stylelint').LinterResult} LinterResult */

  /**
   * @param {StylelintResult[]} stylelintResults
   * @param {maxWarnings} maxWarnings
   * @param {Formatter} formatter
   * @param {string} cwd
   *
   * @returns {LinterResult}
   */


  var prepareReturnValue = function prepareReturnValue(stylelintResults, maxWarnings, formatter, cwd) {
    reportDisables(stylelintResults);
    needlessDisables(stylelintResults);
    invalidScopeDisables(stylelintResults);
    descriptionlessDisables(stylelintResults);
    let errored = false;

    for (const result of stylelintResults) {
      if (result.errored || result.parseErrors.length > 0 || result.warnings.some(warning => warning.severity === 'error')) {
        errored = true;
        result.errored = true;
      }
    }
    /** @type {LinterResult} */


    const returnValue = {
      cwd,
      errored,
      results: [],
      output: '',
      reportedDisables: [],
      ruleMetadata: getRuleMetadata(stylelintResults)
    };

    if (maxWarnings !== undefined) {
      const foundWarnings = stylelintResults.reduce((count, file) => count + file.warnings.length, 0);

      if (foundWarnings > maxWarnings) {
        returnValue.maxWarningsExceeded = {
          maxWarnings,
          foundWarnings
        };
      }
    }

    returnValue.output = formatter(stylelintResults, returnValue);
    returnValue.results = stylelintResults;
    return returnValue;
  };
  /**
   * @param {StylelintResult[]} lintResults
   */


  function getRuleMetadata(lintResults) {
    const [lintResult] = lintResults;
    if (lintResult === undefined) return {};
    if (lintResult._postcssResult === undefined) return {};
    return lintResult._postcssResult.stylelint.ruleMetadata;
  }

  var _a;

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.unload = exports.load = exports.onExit = exports.signals = void 0; // Note: since nyc uses this module to output coverage, any lines
  // that are in the direct sync flow of nyc's outputCoverage are
  // ignored, since we can never get coverage for them.
  // grab a reference to node's real process object right away

  const signals_js_1 = require("./signals.js");

  Object.defineProperty(exports, "signals", {
    enumerable: true,
    get: function () {
      return signals_js_1.signals;
    }
  });

  const processOk = process => !!process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';

  const kExitEmitter = Symbol.for('signal-exit emitter');
  const global$1 = globalThis;
  const ObjectDefineProperty = Object.defineProperty.bind(Object); // teeny tiny ee

  class Emitter {
    constructor() {
      _defineProperty(this, "emitted", {
        afterExit: false,
        exit: false
      });

      _defineProperty(this, "listeners", {
        afterExit: [],
        exit: []
      });

      _defineProperty(this, "count", 0);

      _defineProperty(this, "id", Math.random());

      if (global$1[kExitEmitter]) {
        return global$1[kExitEmitter];
      }

      ObjectDefineProperty(global$1, kExitEmitter, {
        value: this,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }

    on(ev, fn) {
      this.listeners[ev].push(fn);
    }

    removeListener(ev, fn) {
      const list = this.listeners[ev];
      const i = list.indexOf(fn);
      /* c8 ignore start */

      if (i === -1) {
        return;
      }
      /* c8 ignore stop */


      if (i === 0 && list.length === 1) {
        list.length = 0;
      } else {
        list.splice(i, 1);
      }
    }

    emit(ev, code, signal) {
      if (this.emitted[ev]) {
        return;
      }

      this.emitted[ev] = true;

      for (const fn of this.listeners[ev]) {
        fn(code, signal);
      }
    }

  }

  class SignalExitBase {}

  const signalExitWrap = handler => {
    return {
      onExit(cb, opts) {
        return handler.onExit(cb, opts);
      },

      load() {
        return handler.load();
      },

      unload() {
        return handler.unload();
      }

    };
  };

  class SignalExitFallback extends SignalExitBase {
    onExit() {
      return () => {};
    }

    load() {}

    unload() {}

  }

  var _hupSig = new WeakMap();

  var _emitter = new WeakMap();

  var _process = new WeakMap();

  var _originalProcessEmit = new WeakMap();

  var _originalProcessReallyExit = new WeakMap();

  var _sigListeners = new WeakMap();

  var _loaded = new WeakMap();

  var _processReallyExit = new WeakSet();

  var _processEmit = new WeakSet();

  class SignalExit extends SignalExitBase {
    // "SIGHUP" throws an `ENOSYS` error on Windows,
    // so use a supported signal instead

    /* c8 ignore start */

    /* c8 ignore stop */
    constructor(_process2) {
      super();

      _processEmit.add(this);

      _processReallyExit.add(this);

      _hupSig.set(this, {
        writable: true,
        value: process$1.platform === 'win32' ? 'SIGINT' : 'SIGHUP'
      });

      _emitter.set(this, {
        writable: true,
        value: new Emitter()
      });

      _process.set(this, {
        writable: true,
        value: void 0
      });

      _originalProcessEmit.set(this, {
        writable: true,
        value: void 0
      });

      _originalProcessReallyExit.set(this, {
        writable: true,
        value: void 0
      });

      _sigListeners.set(this, {
        writable: true,
        value: {}
      });

      _loaded.set(this, {
        writable: true,
        value: false
      });

      _classPrivateFieldSet(this, _process, _process2); // { <signal>: <listener fn>, ... }


      _classPrivateFieldSet(this, _sigListeners, {});

      for (const sig of signals_js_1.signals) {
        _classPrivateFieldGet(this, _sigListeners)[sig] = () => {
          // If there are no other listeners, an exit is coming!
          // Simplest way: remove us and then re-send the signal.
          // We know that this will kill the process, so we can
          // safely emit now.
          const listeners = _classPrivateFieldGet(this, _process).listeners(sig);

          let {
            count
          } = _classPrivateFieldGet(this, _emitter); // This is a workaround for the fact that signal-exit v3 and signal
          // exit v4 are not aware of each other, and each will attempt to let
          // the other handle it, so neither of them do. To correct this, we
          // detect if we're the only handler *except* for previous versions
          // of signal-exit.

          /* c8 ignore start */
          //@ts-ignore


          if (typeof _process2.__signal_exit_emitter__ === 'object') count++;
          /* c8 ignore stop */

          if (listeners.length === count) {
            this.unload();

            _classPrivateFieldGet(this, _emitter).emit('exit', null, sig);

            _classPrivateFieldGet(this, _emitter).emit('afterExit', null, sig);
            /* c8 ignore start */


            _process2.kill(_process2.pid, sig === 'SIGHUP' ? _classPrivateFieldGet(this, _hupSig) : sig);
            /* c8 ignore stop */

          }
        };
      }

      _classPrivateFieldSet(this, _originalProcessReallyExit, _process2.reallyExit);

      _classPrivateFieldSet(this, _originalProcessEmit, _process2.emit);
    }

    onExit(cb, opts) {
      /* c8 ignore start */
      if (!processOk(_classPrivateFieldGet(this, _process))) {
        return () => {};
      }
      /* c8 ignore stop */


      if (_classPrivateFieldGet(this, _loaded) === false) {
        this.load();
      }

      const ev = opts?.alwaysLast ? 'afterExit' : 'exit';

      _classPrivateFieldGet(this, _emitter).on(ev, cb);

      return () => {
        _classPrivateFieldGet(this, _emitter).removeListener(ev, cb);

        if (_classPrivateFieldGet(this, _emitter).listeners['exit'].length === 0 && _classPrivateFieldGet(this, _emitter).listeners['afterExit'].length === 0) {
          this.unload();
        }
      };
    }

    load() {
      if (_classPrivateFieldGet(this, _loaded)) {
        return;
      }

      _classPrivateFieldSet(this, _loaded, true); // This is the number of onSignalExit's that are in play.
      // It's important so that we can count the correct number of
      // listeners on signals, and don't wait for the other one to
      // handle it instead of us.


      _classPrivateFieldGet(this, _emitter).count += 1;

      for (const sig of signals_js_1.signals) {
        try {
          const fn = _classPrivateFieldGet(this, _sigListeners)[sig];

          if (fn) _classPrivateFieldGet(this, _process).on(sig, fn);
        } catch (_) {}
      }

      _classPrivateFieldGet(this, _process).emit = (ev, ...a) => {
        return _classPrivateMethodGet(this, _processEmit, _processEmit2).call(this, ev, ...a);
      };

      _classPrivateFieldGet(this, _process).reallyExit = code => {
        return _classPrivateMethodGet(this, _processReallyExit, _processReallyExit2).call(this, code);
      };
    }

    unload() {
      if (!_classPrivateFieldGet(this, _loaded)) {
        return;
      }

      _classPrivateFieldSet(this, _loaded, false);

      signals_js_1.signals.forEach(sig => {
        const listener = _classPrivateFieldGet(this, _sigListeners)[sig];
        /* c8 ignore start */


        if (!listener) {
          throw new Error('Listener not defined for signal: ' + sig);
        }
        /* c8 ignore stop */


        try {
          _classPrivateFieldGet(this, _process).removeListener(sig, listener);
          /* c8 ignore start */

        } catch (_) {}
        /* c8 ignore stop */

      });
      _classPrivateFieldGet(this, _process).emit = _classPrivateFieldGet(this, _originalProcessEmit);
      _classPrivateFieldGet(this, _process).reallyExit = _classPrivateFieldGet(this, _originalProcessReallyExit);
      _classPrivateFieldGet(this, _emitter).count -= 1;
    }

  }

  var _processReallyExit2 = function _processReallyExit2(code) {
    /* c8 ignore start */
    if (!processOk(_classPrivateFieldGet(this, _process))) {
      return 0;
    }

    _classPrivateFieldGet(this, _process).exitCode = code || 0;
    /* c8 ignore stop */

    _classPrivateFieldGet(this, _emitter).emit('exit', _classPrivateFieldGet(this, _process).exitCode, null);

    _classPrivateFieldGet(this, _emitter).emit('afterExit', _classPrivateFieldGet(this, _process).exitCode, null);

    return _classPrivateFieldGet(this, _originalProcessReallyExit).call(_classPrivateFieldGet(this, _process), _classPrivateFieldGet(this, _process).exitCode);
  };

  var _processEmit2 = function _processEmit2(ev, ...args) {
    const og = _classPrivateFieldGet(this, _originalProcessEmit);

    if (ev === 'exit' && processOk(_classPrivateFieldGet(this, _process))) {
      if (typeof args[0] === 'number') {
        _classPrivateFieldGet(this, _process).exitCode = args[0];
        /* c8 ignore start */
      }
      /* c8 ignore start */


      const ret = og.call(_classPrivateFieldGet(this, _process), ev, ...args);
      /* c8 ignore start */

      _classPrivateFieldGet(this, _emitter).emit('exit', _classPrivateFieldGet(this, _process).exitCode, null);

      _classPrivateFieldGet(this, _emitter).emit('afterExit', _classPrivateFieldGet(this, _process).exitCode, null);
      /* c8 ignore stop */


      return ret;
    } else {
      return og.call(_classPrivateFieldGet(this, _process), ev, ...args);
    }
  };

  const process$1 = globalThis.process; // wrap so that we call the method on the actual handler, without
  // exporting it directly.

  _a = signalExitWrap(processOk(process$1) ? new SignalExit(process$1) : new SignalExitFallback()),
  /**
   * Called when the process is exiting, whether via signal, explicit
   * exit, or running out of stuff to do.
   *
   * If the global process object is not suitable for instrumentation,
   * then this will be a no-op.
   *
   * Returns a function that may be used to unload signal-exit.
   */
  exports.onExit = _a.onExit,
  /**
   * Load the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  exports.load = _a.load,
  /**
   * Unload the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  exports.unload = _a.unload;

  var cjs = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(cjs);

  var lib$1 = writeFile;
  var sync = writeFileSync;
  var _getTmpname = getTmpname; // for testing

  var _cleanupOnExit = cleanupOnExit;





  const {
    onExit
  } = require$$0;



  const {
    promisify
  } = util__default['default'];

  const activeFiles = {}; // if we run inside of a worker_thread, `process.pid` is not unique

  /* istanbul ignore next */

  const threadId = function getId() {
    try {
      const workerThreads = require$$2__default['default']; /// if we are in main thread, this is set to `0`


      return workerThreads.threadId;
    } catch (e) {
      // worker_threads are not available, fallback to 0
      return 0;
    }
  }();

  let invocations = 0;

  function getTmpname(filename) {
    return filename + '.' + imurmurhash(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
  }

  function cleanupOnExit(tmpfile) {
    return () => {
      try {
        fs__default['default'].unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile);
      } catch {// ignore errors
      }
    };
  }

  function serializeActiveFile(absoluteName) {
    return new Promise(resolve => {
      // make a queue if it doesn't already exist
      if (!activeFiles[absoluteName]) {
        activeFiles[absoluteName] = [];
      }

      activeFiles[absoluteName].push(resolve); // add this job to the queue

      if (activeFiles[absoluteName].length === 1) {
        resolve();
      } // kick off the first one

    });
  } // https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342


  function isChownErrOk(err) {
    if (err.code === 'ENOSYS') {
      return true;
    }

    const nonroot = !process.getuid || process.getuid() !== 0;

    if (nonroot) {
      if (err.code === 'EINVAL' || err.code === 'EPERM') {
        return true;
      }
    }

    return false;
  }

  async function writeFileAsync(filename, data, options = {}) {
    if (typeof options === 'string') {
      options = {
        encoding: options
      };
    }

    let fd;
    let tmpfile;
    /* istanbul ignore next -- The closure only gets called when onExit triggers */

    const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));
    const absoluteName = path__default['default'].resolve(filename);

    try {
      await serializeActiveFile(absoluteName);
      const truename = await promisify(fs__default['default'].realpath)(filename).catch(() => filename);
      tmpfile = getTmpname(truename);

      if (!options.mode || !options.chown) {
        // Either mode or chown is not explicitly set
        // Default behavior is to copy it from original file
        const stats = await promisify(fs__default['default'].stat)(truename).catch(() => {});

        if (stats) {
          if (options.mode == null) {
            options.mode = stats.mode;
          }

          if (options.chown == null && process.getuid) {
            options.chown = {
              uid: stats.uid,
              gid: stats.gid
            };
          }
        }
      }

      fd = await promisify(fs__default['default'].open)(tmpfile, 'w', options.mode);

      if (options.tmpfileCreated) {
        await options.tmpfileCreated(tmpfile);
      }

      if (ArrayBuffer.isView(data)) {
        await promisify(fs__default['default'].write)(fd, data, 0, data.length, 0);
      } else if (data != null) {
        await promisify(fs__default['default'].write)(fd, String(data), 0, String(options.encoding || 'utf8'));
      }

      if (options.fsync !== false) {
        await promisify(fs__default['default'].fsync)(fd);
      }

      await promisify(fs__default['default'].close)(fd);
      fd = null;

      if (options.chown) {
        await promisify(fs__default['default'].chown)(tmpfile, options.chown.uid, options.chown.gid).catch(err => {
          if (!isChownErrOk(err)) {
            throw err;
          }
        });
      }

      if (options.mode) {
        await promisify(fs__default['default'].chmod)(tmpfile, options.mode).catch(err => {
          if (!isChownErrOk(err)) {
            throw err;
          }
        });
      }

      await promisify(fs__default['default'].rename)(tmpfile, truename);
    } finally {
      if (fd) {
        await promisify(fs__default['default'].close)(fd).catch(
        /* istanbul ignore next */
        () => {});
      }

      removeOnExitHandler();
      await promisify(fs__default['default'].unlink)(tmpfile).catch(() => {});
      activeFiles[absoluteName].shift(); // remove the element added by serializeSameFile

      if (activeFiles[absoluteName].length > 0) {
        activeFiles[absoluteName][0](); // start next job if one is pending
      } else {
        delete activeFiles[absoluteName];
      }
    }
  }

  async function writeFile(filename, data, options, callback) {
    if (options instanceof Function) {
      callback = options;
      options = {};
    }

    const promise = writeFileAsync(filename, data, options);

    if (callback) {
      try {
        const result = await promise;
        return callback(result);
      } catch (err) {
        return callback(err);
      }
    }

    return promise;
  }

  function writeFileSync(filename, data, options) {
    if (typeof options === 'string') {
      options = {
        encoding: options
      };
    } else if (!options) {
      options = {};
    }

    try {
      filename = fs__default['default'].realpathSync(filename);
    } catch (ex) {// it's ok, it'll happen on a not yet existing file
    }

    const tmpfile = getTmpname(filename);

    if (!options.mode || !options.chown) {
      // Either mode or chown is not explicitly set
      // Default behavior is to copy it from original file
      try {
        const stats = fs__default['default'].statSync(filename);
        options = Object.assign({}, options);

        if (!options.mode) {
          options.mode = stats.mode;
        }

        if (!options.chown && process.getuid) {
          options.chown = {
            uid: stats.uid,
            gid: stats.gid
          };
        }
      } catch (ex) {// ignore stat errors
      }
    }

    let fd;
    const cleanup = cleanupOnExit(tmpfile);
    const removeOnExitHandler = onExit(cleanup);
    let threw = true;

    try {
      fd = fs__default['default'].openSync(tmpfile, 'w', options.mode || 0o666);

      if (options.tmpfileCreated) {
        options.tmpfileCreated(tmpfile);
      }

      if (ArrayBuffer.isView(data)) {
        fs__default['default'].writeSync(fd, data, 0, data.length, 0);
      } else if (data != null) {
        fs__default['default'].writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));
      }

      if (options.fsync !== false) {
        fs__default['default'].fsyncSync(fd);
      }

      fs__default['default'].closeSync(fd);
      fd = null;

      if (options.chown) {
        try {
          fs__default['default'].chownSync(tmpfile, options.chown.uid, options.chown.gid);
        } catch (err) {
          if (!isChownErrOk(err)) {
            throw err;
          }
        }
      }

      if (options.mode) {
        try {
          fs__default['default'].chmodSync(tmpfile, options.mode);
        } catch (err) {
          if (!isChownErrOk(err)) {
            throw err;
          }
        }
      }

      fs__default['default'].renameSync(tmpfile, filename);
      threw = false;
    } finally {
      if (fd) {
        try {
          fs__default['default'].closeSync(fd);
        } catch (ex) {// ignore close errors at this stage, error may have closed fd already.
        }
      }

      removeOnExitHandler();

      if (threw) {
        cleanup();
      }
    }
  }
  lib$1.sync = sync;
  lib$1._getTmpname = _getTmpname;
  lib$1._cleanupOnExit = _cleanupOnExit;

  const debug = src$1('stylelint:standalone');































  const {
    assert
  } = validateTypes;



  const ALWAYS_IGNORED_GLOBS = ['**/node_modules/**'];


  /** @typedef {import('stylelint').Formatter} Formatter */

  /** @typedef {import('stylelint').FormatterType} FormatterType */

  /**
   * @type {import('stylelint')['lint']}
   */


  async function standalone({
    allowEmptyInput,
    cache,
    cacheLocation,
    cacheStrategy,
    code,
    codeFilename,
    config,
    configBasedir,
    configFile,
    customSyntax,
    cwd = process.cwd(),
    disableDefaultIgnores,
    files,
    fix,
    formatter,
    globbyOptions,
    ignoreDisables,
    ignorePath,
    ignorePattern,
    maxWarnings,
    quiet,
    quietDeprecationWarnings = false,
    reportDescriptionlessDisables,
    reportInvalidScopeDisables,
    reportNeedlessDisables
  }) {
    const startTime = Date.now();
    const isValidCode = typeof code === 'string';

    if (!files && !isValidCode || files && (code || isValidCode)) {
      return Promise.reject(new Error('You must pass stylelint a `files` glob or a `code` string, though not both'));
    } // The ignorer will be used to filter file paths after the glob is checked,
    // before any files are actually read

    /** @type {import('ignore').Ignore} */


    let ignorer;

    try {
      ignorer = getFileIgnorer({
        cwd,
        ignorePath,
        ignorePattern
      });
    } catch (error) {
      return Promise.reject(error);
    }
    /** @type {Formatter} */


    let formatterFunction;

    try {
      formatterFunction = getFormatterFunction(formatter);
    } catch (error) {
      return Promise.reject(error);
    }

    const stylelint = createStylelint({
      cacheLocation,
      cacheStrategy,
      config,
      configFile,
      configBasedir,
      cwd,
      ignoreDisables,
      ignorePath,
      reportNeedlessDisables,
      reportInvalidScopeDisables,
      reportDescriptionlessDisables,
      customSyntax,
      fix,
      quiet,
      quietDeprecationWarnings
    });

    if (!files) {
      const absoluteCodeFilename = codeFilename !== undefined && !path__default['default'].isAbsolute(codeFilename) ? path__default['default'].join(cwd, codeFilename) : codeFilename; // if file is ignored, return nothing

      if (absoluteCodeFilename && !filterFilePaths(ignorer, [path__default['default'].relative(cwd, absoluteCodeFilename)]).length) {
        return prepareReturnValue([], maxWarnings, formatterFunction, cwd);
      }

      let stylelintResult;

      try {
        const postcssResult = await lintSource(stylelint, {
          code,
          codeFilename: absoluteCodeFilename
        });
        stylelintResult = createPartialStylelintResult(postcssResult);
      } catch (error) {
        stylelintResult = handleError(error);
      }

      const postcssResult = stylelintResult._postcssResult;
      const returnValue = prepareReturnValue([stylelintResult], maxWarnings, formatterFunction, cwd);
      const autofix = fix ?? config?.fix ?? false;

      if (autofix && postcssResult && !postcssResult.stylelint.ignored) {
        returnValue.output = !postcssResult.stylelint.disableWritingFix && postcssResult.opts ? // If we're fixing, the output should be the fixed code
        postcssResult.root.toString(postcssResult.opts.syntax) : // If the writing of the fix is disabled, the input code is returned as-is
        code;
      }

      return returnValue;
    }

    let fileList = [files].flat().map(entry => {
      const globCWD = globbyOptions && globbyOptions.cwd || cwd;
      const absolutePath = !path__default['default'].isAbsolute(entry) ? path__default['default'].join(globCWD, entry) : path__default['default'].normalize(entry);

      if (fs__default['default'].existsSync(absolutePath)) {
        // This path points to a file. Return an escaped path to avoid globbing
        return out$1.escapePath(normalizePath(entry));
      }

      return entry;
    });

    if (!disableDefaultIgnores) {
      fileList = fileList.concat(ALWAYS_IGNORED_GLOBS.map(glob => `!${glob}`));
    } // do not cache if config is explicitly overridden by option


    const useCache = cache ?? config?.cache ?? false;

    if (!useCache) {
      stylelint._fileCache.destroy();
    }

    const effectiveGlobbyOptions = {
      cwd,
      ...(globbyOptions || {}),
      absolute: true
    };
    const globCWD = effectiveGlobbyOptions.cwd;
    let filePaths = await globby(fileList, effectiveGlobbyOptions); // Record the length of filePaths before ignore operation
    // Prevent prompting "No files matching the pattern 'xx' were found." when .stylelintignore ignore all input files

    const filePathsLengthBeforeIgnore = filePaths.length; // The ignorer filter needs to check paths relative to cwd

    filePaths = filterFilePaths(ignorer, filePaths.map(p => path__default['default'].relative(globCWD, p)));
    let stylelintResults;

    if (filePaths.length) {
      let absoluteFilePaths = filePaths.map(filePath => {
        const absoluteFilepath = !path__default['default'].isAbsolute(filePath) ? path__default['default'].join(globCWD, filePath) : path__default['default'].normalize(filePath);
        return absoluteFilepath;
      });
      const getStylelintResults = absoluteFilePaths.map(async absoluteFilepath => {
        debug(`Processing ${absoluteFilepath}`);

        try {
          const postcssResult = await lintSource(stylelint, {
            filePath: absoluteFilepath,
            cache: useCache
          });

          if ((postcssResult.stylelint.stylelintError || postcssResult.stylelint.stylelintWarning) && useCache) {
            debug(`${absoluteFilepath} contains linting errors and will not be cached.`);

            stylelint._fileCache.removeEntry(absoluteFilepath);
          }
          /**
           * If we're fixing, save the file with changed code
           */


          if (postcssResult.root && postcssResult.opts && !postcssResult.stylelint.ignored && fix && !postcssResult.stylelint.disableWritingFix) {
            const fixedCss = postcssResult.root.toString(postcssResult.opts.syntax);

            if (postcssResult.root && postcssResult.root.source && postcssResult.root.source.input.css !== fixedCss) {
              await lib$1(absoluteFilepath, fixedCss);
            }
          }

          return createPartialStylelintResult(postcssResult);
        } catch (error) {
          // On any error, we should not cache the lint result
          stylelint._fileCache.removeEntry(absoluteFilepath);

          return handleError(error);
        }
      });
      stylelintResults = await Promise.all(getStylelintResults);
    } else if (allowEmptyInput ?? config?.allowEmptyInput ?? (await canAllowEmptyInput(stylelint))) {
      stylelintResults = await Promise.all([]);
    } else if (filePathsLengthBeforeIgnore) {
      // All input files ignored
      stylelintResults = await Promise.reject(new allFilesIgnoredError());
    } else {
      stylelintResults = await Promise.reject(new noFilesFoundError(fileList));
    }

    if (useCache) {
      stylelint._fileCache.reconcile();
    }

    const result = prepareReturnValue(stylelintResults, maxWarnings, formatterFunction, cwd);
    debug(`Linting complete in ${Date.now() - startTime}ms`);
    return result;
  }
  /**
   * @param {FormatterType | Formatter | undefined} selected
   * @returns {Formatter}
   */


  function getFormatterFunction(selected) {
    if (typeof selected === 'string') {
      const formatterFunction = formatters_1[selected];

      if (formatterFunction === undefined) {
        const formattersText = getFormatterOptionsText(', ', '"');
        throw new Error(`You must use a valid formatter option: ${formattersText} or a function`);
      }

      return formatterFunction;
    }

    if (typeof selected === 'function') {
      return selected;
    }

    assert(formatters_1.json);
    return formatters_1.json;
  }
  /**
   * @typedef {import('stylelint').CssSyntaxError} CssSyntaxError
   *
   * @param {unknown} error
   * @return {import('stylelint').LintResult}
   */


  function handleError(error) {
    if (error instanceof Error && error.name === 'CssSyntaxError') {
      return createPartialStylelintResult(undefined,
      /** @type {CssSyntaxError} */
      error);
    }

    throw error;
  }
  /**
   * @param {import('stylelint').InternalApi} stylelint
   * @returns {Promise<boolean>}
   */


  async function canAllowEmptyInput(stylelint) {
    const config = await getConfigForFile(stylelint);
    return Boolean(config?.config?.allowEmptyInput);
  }

  var standalone_1 = standalone;

  const {
    longhandSubPropertiesOfShorthandProperties
  } = properties$4;




  /** @type {import('stylelint')} */


  const stylelint = Object.assign(postcssPlugin, {
    lint: standalone_1,
    rules: rules_1,
    formatters: formatters_1,
    createPlugin: createPlugin$1,
    resolveConfig,
    _createLinter: createStylelint,
    utils: {
      report: report$1,
      ruleMessages: ruleMessages$1,
      validateOptions: validateOptions$1,
      checkAgainstRule
    },
    reference: {
      longhandSubPropertiesOfShorthandProperties
    }
  });
  var lib = stylelint;

  const {
    createPlugin,
    utils: {
      report,
      ruleMessages,
      validateOptions
    }
  } = lib;
  const ruleName = 'foo-org/selector-no-foo';
  const messages = ruleMessages(ruleName, {
    rejected: selector => `Unexpected "foo" within selector "${selector}"`
  });
  const meta = {
    url: 'https://github.com/foo-org/stylelint-selector-no-foo/blob/main/README.md'
  };
  /** @type {import('stylelint').Rule} */
  // $FlowFixMe[missing-local-annot]

  const ruleFunction = primary => (root, result) => {
    const validOptions = validateOptions(result, ruleName, {
      actual: primary,
      possible: [true]
    });
    if (!validOptions) return;
    root.walkRules(ruleNode => {
      const {
        selector
      } = ruleNode;
      if (!selector.includes('foo')) return;
      report({
        result,
        ruleName,
        message: messages.rejected(selector),
        node: ruleNode,
        word: selector
      });
    });
  };

  ruleFunction.ruleName = ruleName;
  ruleFunction.messages = messages;
  ruleFunction.meta = meta; // $FlowFixMe[signature-verification-failure]

  var test = createPlugin(ruleName, ruleFunction);

  /* eslint-disable import/no-import-module-exports */
  module.exports = {
    rules: {
      'test': test
    }
  };
  /* eslint-enable import/no-import-module-exports */

})));
